#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 
#+AUTHOR: Caio Rodrigues 

* STL - Standard Library Reference Card 
** C++ Standard Library Reference

*C++ Standards* ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html][Source]])

 - *C++ is standardized as ISO/IEC 14882.* Currently, there are two
   versions:

   - _C++98 (ISO/IEC 14882:1998)_ 1st standard version of C++.
   - _C++03 (ISO/IEC 14882:2003)_ minor "bug-fix" to C++98 with no change
     to the language. Commonly refer to as C++98/C++03 or First C++
     standard.
 - _C++11 (ISO/IEC 14882:2011)_ 2nd standard version of C++.


*C++ Libraries* 

 + STL (Standard Template Library) Containers, Iterators and Function objects.
   + Sequence
     + vector  -> <vector>
     + list    -> <list>
     + dequee  -> <deque>
     + array   -> <array>

   + Associative Sequence
     + set
     + map (Hashmap or hash table).
     + multiset
     + multimap
     + ~unordered_set~
     + ~unordered_map~

 + C++ Libraries ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
   + <ios>, <iostream>, <istream>, <ostream>, <fstream>, <sstream>
   + <iomanip> 
   + <string>  - C++ Strings.
   + <regex>
   + <random>
   + <limits>
   + <stdexcept>, <exception>
   + <complex>, <tuple>, <valarray>
   + <locale>
   + <typeinfo>
   + <chrono>

   + Other: <codecvt>, <new>, <ratio>, <system_error>, <type_traits>

 + Useful non-standard C++ Libraries 
   + Boost C++ libaries
   + QT toolkit / GUI - Toolkit

 + C Compatibility
   + Standard ANSI C libaries ported to C++ are prefixed with "c"
     without ".h". For instance, "#include <math.h>" form C becomes
     "#include <cmath>" in C++.

   + C Libraries. ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
     + <cmath> - (math.h) - Standard mathematical functions such as
       sin, cos, sqrt and so on.
     + <cctypes> - (ctypes.h) - Checking character types (isalpha,
       isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl,
       isgraph, isprint, ispunct, isxdigit) and character conversion
       (toupper, tolower).
     + <climits>, <cfloat>: Size and limit of integer types (INT_MAX,
       INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX
       for long, LLONG_XXX for long long, CHAR_XXX for char) and
       floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP,
       DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double).

     + <ctime>: time, difftime, clock, gmttime, localtime, and etc.
     + <cstdio>: C's IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)
     + <cassert>, <cerrno>, <csignal>: Diagnostics and error
     + <clocale>: localizaton
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
** STL Sequential Container Methods - Cheat Sheet  
*** Use Cases 

Use Cases: 
 + _vector_
   + Operations where the vector size is known in advance and it is
     necessary constant access time for random access to any
     element. Example of use case: linear algebra and numerical
     algorithms. Insertion of elements at end or at the front is
     efficient, however it less efficient than the deque container and
     whenever a new element is added. Vectors are not ideal for
     operations where the number of elements is not known because its
     elements are stored in C-array allocated in the heap, as result,
     all elements are reallocated whenever a new element is added or
     removed.
   + Use cases:
     + General sequential container
     + Linear algebra and numerical algorithms 
     + C++ replacement for C-arrays 
     + C-arrays interoperability
 + _deque_
   + Operations with requires fast random access time and fast
     insertion or deletion of elements at both ends. Unlike vectors,
     deque is not stored internally as a C-array and unlike vectors,
     whenever an element is inserted, any reallocation happens which
     means that deques are more efficient than vectors when the size
     of container is not known in advance.
   + Use Case:
     + General sequential container
     + Fast random access
     + Number of elements aren't known in advance.
*** Member Functions / Methods reference table 

| Method of Container<T> | Return type | Description                                              | vector | deque | list | array |
|------------------------+-------------+----------------------------------------------------------+--------+-------+------+-------|
| *Element Access*         |             |                                                          |        |       |      |       |
| operator[](int n)      | T&          | return nth-element, doesn't throw exception.             | yes    | yes   | no   | yes   |
| at(int n)              | T&          | return nth-element, but throws exception.                | yes    | yes   | no   | yes   |
| front()                | T&          | return first element                                     | yes    | yes   | yes  | yes   |
| back()                 | T&          | return last element                                      | yes    | yes   | yes  | yes   |
| data()                 | T*          | Return pointer to first element of container.            | yes    | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Capacity*               |             |                                                          |        |       |      |       |
| size()                 | size_t      | Return number of container elements.                     | yes    | yes   | yes  | yes   |
| max_size()             | size_t      | Return maximum container size.                           | yes    | yes   | yes  | yes   |
| empty()                | bool        | Return true if container is empty                        | yes    | yes   | yes  | yes   |
| reserve(size_t n)      | void        | Reserve a minimum storage for vectors.                   | yes    | no    | no   | no    |
| resize(size_t n)       | void        | Resize container to n elements.                          | yes    | yes   | yes  | no    |
|                        |             |                                                          |        |       |      |       |
| *Modifiers*              |             |                                                          |        |       |      |       |
| ~push_back(T t)~         | void        | Add element at the end of container                      | yes    | yes   | yes  | no    |
| ~push_front(T t)~        | void        | Add element at the beggining of container.               | yes    | yes   | yes  | no    |
| ~pop_back()~             | void        | Delete element at the end of container.                  | yes    | yes   | yes  | no    |
| ~pop_front()~            | void        | Delete element at beginning of container.                | yes    | yes   | yes  | no    |
| emplace_back           | void        | Construct and insert element at the end without copying. | yes    | yes   | yes  | no    |
| clear()                | void        | Remove all elements.                                     | yes    | yes   | yes  | no    |
| fill(T t)              | void        | Fill all elements                                        | no     | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Iterator*               |             |                                                          |        |       |      |       |
| begin()                | iterator    | Return iterator to beggining                             |        |       |      |       |
| end()                  | iterator    | Return iterator to end                                   |        |       |      |       |
| rbegin()               | iterator    | Return reverse iterator to beggining                     |        |       |      |       |
| rend()                 | iterator    | Return reverse iterator to end                           |        |       |      |       |
| cbegin()               | iterator    | Return const iterator to beginning                       |        |       |      |       |
| cend()                 | iterator    | Return const iterator to end                             |        |       |      |       |
| crebegin()             | iterator    | Return const iterator to beginning                       |        |       |      |       |
| crend()                | iterator    | Return const iterator to end                             |        |       |      |       |
    
*** Constructors 

Vector constructors: 

#+BEGIN_SRC cpp 
  // Empty vector 
  >> std::vector<double> xs1
  (std::vector<double> &) {}

  // Intialize vector with a given size
  >> std::vector<double> xs2(5, 3.0)
  (std::vector<double> &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }

  // Constructor with uniform initialization 
  >> std::vector<double> xs4 {1.0, -2.0, 1.0, 10 }
  (std::vector<double> &) { 1.0000000, -2.0000000, 1.0000000, 10.000000 }

  // =========== Constructors with C++11 auto keyword =============//

  >> auto xs1 = vector<double>()
  (std::vector<double, std::allocator<double> > &) {}
  >> 
  >> auto xs2 = vector<double>(5, 3.0)
  (std::vector<double, std::allocator<double> > &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }
  >> 
  >> auto xs3 = vector<double>{1, -2, 1, 1}
  (std::vector<double, std::allocator<double> > &) { 1.0000000, -2.0000000, 1.0000000, 1.0000000 }
  >> 
#+END_SRC

Deque constructors: 

#+BEGIN_SRC cpp 
  >> std::deque<int> ds1
  (std::deque<int> &) {}
  >> 
  >> std::deque<int> ds2(5, 2)
  (std::deque<int> &) { 2, 2, 2, 2, 2 }
  >> 
  >> std::deque<int> ds3 {2, -10, 20, 100, 20}
  (std::deque<int> &) { 2, -10, 20, 100, 20 }
  >> 
  // ======== Constructors with auto type inference ========== //
  >> auto ds1 = std::deque<int>()
  (std::deque<int, std::allocator<int> > &) {}
  >> 
  >> auto ds2 = std::deque<int>(5, 2)
  (std::deque<int, std::allocator<int> > &) { 2, 2, 2, 2, 2 }
  >> 
  >> auto ds3 = std::deque<int>{2, -10, 20, 100, 20}
  (std::deque<int, std::allocator<int> > &) { 2, -10, 20, 100, 20 }
  >> 
#+END_SRC

References: 
 + [[http://www.cplusplus.com/reference/vector/vector/][vector - C++ Reference]]  
 + [[http://www.cplusplus.com/reference/stl/][Containers - C++ Reference]] 
 + [[https://embeddedartistry.com/blog/2017/9/11/choosing-the-right-stl-container-sequential-containers][Choosing the Right Container: Sequential Containers â€” Embedded Artistry]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/containers_sequential.html][STL Sequential Container Member Function Summary]] 
	 
*** Tips and tricks 
**** Pass containers by reference or const reference

If the intent of the operation is not modify the container, it is
preferrable to pass it by const reference in order to avoid copying
overhead. 

For instance, the function: 

#+BEGIN_SRC cpp 
  double computeNorm(std::vector<double> xs)
  {
   // The vector xs is copied here, if it has 1GB of memory.
   // It will use 2GB instead of 1GB!
    ... ... 
  }
#+END_SRC

Should be written as: 

#+BEGIN_SRC cpp 
  double computeNorm(const std::vector<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::list<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::deque<double>& xs)
  {
    ... ... 
  }
#+END_SRC
**** Use the member function emplace_back to avoid uncessary copies.

Example: 

 - file: stl-emplace.cpp

#+BEGIN_SRC cpp :export both :results code
  #include <iostream>
  #include <ostream>
  #include <iomanip>
  #include <string>
  #include <vector>
  #include <deque>

  struct Product{
          std::string  name;	
          int          quantity;
          double       price;
          Product(){
                  std::cerr << " [TRACE] - Empty constructor invoked\n";
          }
          Product(const std::string& name, int quantity, double price):
                  name(name),
                  quantity(quantity),
                  price(price){
                  std::cerr << " [TRACE] - Product created as " << *this << "\n" ;
          }
          // The compiler generate an copy constructor automatically,
          // but this one was written to instrument C++ value semantics
          // and check when copies happen.
          Product(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy constructor invoked -> copied = " << *this << "\n";
          }
          // Copy assignment-operator
          void operator=(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy assignment operator invoked = " << *this << "\n";		
          }
          // Make class printable 
          friend std::ostream& operator<< (std::ostream& os, const Product& p)
          {
                  int size1 = 10;
                  int size2 = 2;
                  return os << " Product{ "
                                    << std::setw(1) << " name = "       << p.name
                                    << std::setw(10) << "; quantity  = "  << std::setw(size2) << p.quantity
                                    << std::setw(size1) << "; price = "      << std::setw(size2) << p.price
                                    << " }";
          }
  };


  int main(){
          auto inventory = std::deque<Product>();

          // Using push_back
          std::cerr << "====== Experiment .push_back() ======\n";
          std::cerr << " [INFO] - Adding orange with .push_back\n";
          inventory.push_back(Product("Orange - 1kg", 10, 3.50));
          std::cerr << " [INFO] - Adding rice with .push_back \n";
          inventory.push_back({"Rice bag", 20, 0.80});

          // Using emlace_back
          std::cerr << "====== Experiment .emplace_back() ======\n";	
          std::cerr << " [INFO] - Adding baccon with .emplace_back \n";
          inventory.emplace_back("Fresh tasty bacon", 50, 30.25);
          std::cerr << " [INFO] - Adding soft drink with .emplace_back \n";
          inventory.emplace_back("Soft drink", 100, 2.50);

          std::cerr << " ====== Inventory =======\n";
          // Print inventory
          int nth = 0;
          for(const auto& p: inventory){
                  std::cout << "product " << nth << " = " << p << "\n";
                  nth++;
          }	
          return 0;
  }

#+END_SRC

Running:

 - It can be seen in the program output that ~.emplace_back~ doen't
   invoke the copy constructor, so it has less overhead than
   ~.emplace_back~ which copies the passed element.

#+BEGIN_SRC txt
  $ clang++ stl-emplace.cpp -o stl-emplace.bin -g -std=c++11 -Wall -Wextra && ./stl-emplace.bin

  ====== Experiment .push_back() ======
   [INFO] - Adding orange with .push_back
   [TRACE] - Product created as  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [INFO] - Adding rice with .push_back 
   [TRACE] - Product created as  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  ====== Experiment .emplace_back() ======
   [INFO] - Adding baccon with .emplace_back 
   [TRACE] - Product created as  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
   [INFO] - Adding soft drink with .emplace_back 
   [TRACE] - Product created as  Product{  name = Soft drink; quantity  = 100; price = 2.5 }
   ====== Inventory =======
  product 0 =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
  product 1 =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  product 2 =  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
  product 3 =  Product{  name = Soft drink; quantity  = 100; price = 2.5 }

#+END_SRC
** Methods of C++ STL Vetor<T>


| Vector Class Member               | Description                                                                  |
|-----------------------------------+------------------------------------------------------------------------------|
| *Constructors*                      |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>(int size)               | Create a vector of size n                                                    |
| vector<a>(int size, a init)       | Create a vector of size n with all elements set to _init_                      |
| vector<a>(a [])                   | Intialize vector with an C-Array.                                            |
|                                   |                                                                              |
| *Methods*                           |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>[i]                      | Get the element i of a vector. i ranges from 0 to size - 1                   |
| int  vector<a>::size()            | Get vector size                                                              |
| a    vector<a>::at(i)             | Get the nth element of a vector and checks if the index is within the bounds |
| bool vector<a>::empty()           | Returns true if vector is empty and false, otherwise.                        |
| void vector<a>::resize(int N)     | Resize vector to N elements.                                                 |
| void vector<a>::clear()           | Remove all elements and sets the vector size to 0.                           |
| ~void vector<a>::push_back(elem a)~ | Insert element at the end of v.                                              |
| a    vector<a>::begin()           | Returns first element.                                                       |
| a    vector<a>::end()             | Returns last element                                                         |
| ~void vector<a>::pop_back()~        | Remove last element of vector.                                               |
|                                   |                                                                              |
|                                   |                                                                              |

** Associative Container - Map methods 

Documentation: 
 + [[http://www.cplusplus.com/reference/map/map/][map - C++ Reference]]

| Method of map<K, V>          | Return type          |                                                                              |
|------------------------------+----------------------+------------------------------------------------------------------------------|
| *Capacity*                     |                      |                                                                              |
| empty()                      | bool                 | Return true if container empty                                               |
| size()                       | size_t               | Return number of elements                                                    |
| max_size()                   | sizet_t              | Return maximum number of elements                                            |
|                              |                      |                                                                              |
| *Element Access*               |                      |                                                                              |
| operator[](K k)              | V&                   | Return value associated to key k. It doesn't throw exception.                |
| at(K k)                      | V&                   | Return value associated to key k. Note: it can throw exception.              |
| find(const K& k)             | iterator             | Search for an element and returns map::end if it doesn't find the given key. |
| count(const K& k)            | size_t               | Count number of elements with a given key.                                   |
|                              |                      |                                                                              |
| *Modifiers*                    |                      |                                                                              |
| clear()                      | void                 | Remove all elements.                                                         |
| insert(std::pair<K, V> pair) | void                 | Insert a new key-value pair.                                                 |
| emplace(Args&&& ... args)    | pair<iterator, bool> |                                                                              |
|                              |                      |                                                                              |
|                              |                      |                                                                              |

Map example: 

 - File: *map-container.cpp*

#+BEGIN_SRC cpp 
  #include<iostream>
  #include<string>
  #include<map>
  #include <iomanip>

  struct Point3D{
          double x;
          double y;
          double z;
          Point3D(): x(0), y(0), z(0){}
          Point3D(double x, double y, double z): x(x), y(y), z(z){}
          /* Copy constructor 
       ,* -> Implement redundant copy constructor for logging purposes and 
       ,* detect when copy happens. 
       ,*/
          Point3D(const Point3D& p){		
                  std::cerr << " I was copied" << std::endl;
                  this->x = p.x;
                  this->y = p.y;
                  this->z = p.z;
          }
          ~Point3D() = default;
  };

  std::ostream& operator<< (std::ostream& os, const Point3D& p){
          os << std::setprecision(3) << std::fixed;
          return os << "Point3D{"
                            << "x = "  << p.x
                            << ",y = " << p.y
                            << ", z = "<< p.z
                            << "}";
  }

  int main(){	
          auto locations = std::map<std::string, Point3D>();
          locations["point1"] = Point3D(2.0, 3.0, 5.0);
          locations["pointX"] = Point3D(12.0, 5.0, -5.0);
          locations["pointM"] =  {121.0, 4.0, -15.0};
          locations["Origin"] = {}; // Point32{} or Point3D()
	
          // Invokes copy constructor
          std::cerr << "  <== Before inserting" << "\n";
          locations.insert(std::pair<std::string, Point3D>("PointO1", Point3D(0.0, 0.0, 0.0)));
          std::cerr << "  <== After inserting" << "\n";
	
          // operator[] doesn't throw exception 
          std::cout << "point1 = " << locations["point1"] << "\n";
          std::cout << "pointX = " << locations.at("pointX") << "\n";
          std::cout << "pointM = " << locations.at("pointM") << "\n";

          // Safer and uses exception 
          try {
                  std::cout << "pointY = " << locations.at("pointY") << "\n";
          } catch(const std::out_of_range& ex){
                  std::cout << "Error - not found element pointY. MSG = " << ex.what() << "\n";
          }

          if(auto it = locations.find("pointX"); it != locations.end())
                  std::cout << " [INFO]= => Location pointX found =  " << it->second << "\n";

          if(locations.find("pointMAS") == locations.end())
                  std::cout << " [ERROR] ==> Location pointMAS  not found" << "\n";
	
          std::cout << "Key-Value pairs " << "\n";
          std::cout << "-------------------------" << "\n";
          for (const auto& x: locations)
                  std::cout << x.first << " : " << x.second << "\n";
          std::cout << '\n';

          return 0;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ map-container.cpp -o map-container.bin -std=c++1z -Wall -Wextra  && ./map-container.bin

    <== Before inserting
   I was copied
   I was copied
    <== After inserting
  point1 = Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointX = Point3D{x = 12.000,y = 5.000, z = -5.000}
  pointM = Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointY = Error - not found element pointY. MSG = map::at
   [INFO]= => Location pointX found =  Point3D{x = 12.000,y = 5.000, z = -5.000}
   [ERROR] ==> Location pointMAS  not found
  Key-Value pairs 
  -------------------------
  Origin : Point3D{x = 0.000,y = 0.000, z = 0.000}
  PointO1 : Point3D{x = 0.000,y = 0.000, z = 0.000}
  point1 : Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointM : Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointX : Point3D{x = 12.000,y = 5.000, z = -5.000}

#+END_SRC
