#+HTML_MATHJAX: align:left font:Neo-Euler scale:100  path:"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"

#+INCLUDE: theme/style.org
#+TITLE: Computer Graphics
#+DESCRIPTION: cpp/c++ interoperability ffi shim qt5 widgets gui library wrapper julia dlang
#+STARTUP: content


* Computer Graphics
** Computer Graphics Applications 

  *Motivation* 

Outline of common computer graphics applications and a motivation for
the study of this field.

   + 2D and 3D Games

   + Virtual Reality 

   + Cartography

   + Charts and plotting 

   + Scientific Visualization

   + Data visualization

   + Medical Images 

   + Physical simulation

   + Implementation of CAD (Computer Aided Design) systems

   + Animation. See Pixar company that created many movies using computer graphics.
 
 
  *Videos - Related to Computer Graphics* 

   + [[https://www.youtube.com/watch?v=pQcC2CqReSA][Tutorial 9 - Coordinate Systems in OpenGL]] [BEST]

   + [[https://www.youtube.com/watch?v=vQ60rFwh2ig][The True Power of the Matrix (Transformations in Graphics) - Computerphile]]

   + [[https://www.youtube.com/watch?v=KdyvizaygyY][A universe of Triangles - Computerphile]]

   + [[https://www.youtube.com/watch?v=U93RImC-by4][VOX - Why video games are made of tiny triangles]]

   + [[https://www.youtube.com/watch?v=TPCpXXBHFSA][VOX - Why gamers use WASD to move]]

** GPU Accelerated Computer Graphics APIs

 *Native Graphics APIs* (exposed as C-subroutines)

  + [[https://www.opengl.org//][OpenGL]] (Khronos Group) - Main OpenGL specification
    + => Open standard, cross-platform and vendor-independent API for
      rendering 2D or 3D computer graphics with GPU (Graphics
      Processing Unit) acceleration. OpenGL can be used for
      implementing computer graphics, games, scientific vizualization,
      virtual reality and CADs - Computer Aided Design
      software. OpenGL API specificiation is maintained as an
      open-standard by the Krhonos Group industry consortium.

    + => OpenGL has two modes, _immediate mode_ (a.k.a fixed-function
      pipeline, legacy-OpenGL) which is being depreacted, and _retained_
      _mode_ (modern OpenGL) that delivers more performance and is based
      on buffer-objects and shaders.

    + => OpenGL Official Specification: [[https://www.khronos.org/registry/OpenGL/index_gl.php][Khronos OpenGL® Registry]]

  + _OpenGL ES_  (Khronos Group)
    + => OpenGL for embedded systems, mobile devices and touch screen
      devices and so on. This API (Application Programming Interface)
      is widely used by many mobile games.

    + => Similar to OpenGL specfication, but supports only the
      _retained-mode_. OpenGL ES does not support _immediate-mode_. As a
      result, calls to legacy OpenGL subroutines such as glBegin(),
      glEnd(), glRotate(), glTranslate(), ..., are not supported.

  + [[https://www.khronos.org/vulkan/][Vulkan]]_(Khronos Group)
    + => Graphics API with GPU acceleration that provides more
      low-level GPU control and less overhead than OpenGL. This API is
      designed for taking more advantag of multi-core CPU
      architectures and performing tasks in parallel.

  + [[https://en.wikipedia.org/wiki/DirectX][DirectX]] / Direct3D (Microsoft inc.) - Windows-only
    + => Microsoft's graphics API for accessing the GPU hardware. It
      is only available on operating systems based Windows-NT kernel
      and Windows-CE kernel (embedded version of Windows-NT).

  + [[https://developer.apple.com/metal/][Metal]] (Apple inc.)
    + => Apple-only API for rendering 2D or 3D computer graphics with
      GPU acceleration. This API is available only on iOS and MacOSX
      operating systems. On iOS and MacOSX, Apple is deprecating and
      phasing out OpenGL in favor of its own  API.

 *Web Computer Graphics APIs* (exposed as Javascript/ECMAScript subroutines)

  + [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL][WebGL]] (Khronos Group)  / Html5 API
    + => Based on OpenGL ES and implemented by major web
      browsers. Unlike OpenGL or OpenGL ES, which are exposed via C
      subroutines, WebGL is exposed to calling codes via JavaScript
      (ECMAScript) and Html5 canvas.

    + => Note: This API does not support OpenGL immediate-mode or
      legacy OpenGL. WebGL only supports _retained-mode_.

  + [[https://en.wikipedia.org/wiki/WebGPU][WebGPU]] (W3C Consortium) - Upcoming Html5 standard.
    + => Upcoming graphics API for web browser, based on Vulkan,
      Metal and DirectX which intends to deliver more low level GPU
      control and higher performance. Unlike WebGL, this API is not a
      direct port of any native graphics API such as Vulkan, Metal and
      DirectX.
    + [[https://gpuweb.github.io/gpuweb/][WebGPU - Editor’s Draft]]
    + [[https://github.com/gpuweb/gpuweb/wiki/Implementation-Status][Implementation Status · gpuweb/gpuweb Wiki · GitHub]]
    + [[https://github.com/gpuweb/gpuweb][GitHub - gpuweb/gpuweb: Where the GPU for the Web work happens!]]
    + [[https://kvark.github.io/web/gpu/native/2020/05/03/point-of-webgpu-native.html][Point of WebGPU on native]]
    + [[https://hacks.mozilla.org/2020/04/experimental-webgpu-in-firefox/][A Taste of WebGPU in Firefox - Mozilla Hacks - the Web developer blog]]


 *Further Reading*

General:

  + [[https://vulkan.gpuinfo.org/listdevices.php][Devices - Vulkan Hardware Database by Sascha Willems]]

  + [[https://github.com/KhronosGroup/MoltenVK][GitHub - KhronosGroup/MoltenVK]]
    + "MoltenVK is a Vulkan Portability implementation. It layers a
      subset of the high-performance, industry-standard Vulkan
      graphics and compute API over Apple's Metal graphics framework,
      enabling Vulkan applications to run on iOS and macOS."

  + [[https://www.pcgamer.com/doom-benchmarks-return-vulkan-vs-opengl/][Doom benchmarks return: Vulkan vs. OpenGL | PC Gamer]]

  + [[https://linuxhint.com/vulkan-for-linux-users/][Vulkan for Linux Users – Linux Hint]]

  + [[https://stackoverflow.com/questions/56766983/what-can-vulkan-do-specifically-that-opengl-4-6-cannot][What can Vulkan do specifically that OpenGL 4.6+ cannot? - Stack]]

  + [[https://softwareengineering.stackexchange.com/questions/380832/opengl-and-global-state][design - OpenGL and global state - Software Engineering Stack Exchange]]

Image Resolution DPI, PPI and so on:

  + [[https://en.wikipedia.org/wiki/Resolution_independence][Resolution Independence]]

  + [[https://en.wikipedia.org/wiki/Pixel_density][Pixel Density]]

  + [[https://en.wikipedia.org/wiki/Vector_graphics][Vector Graphics]]

  + [[https://en.wikipedia.org/wiki/Scalable_Vector_Graphics][SVG - Scalable Vector Graphics]]

  + [[https://en.wikipedia.org/wiki/Comparison_of_graphics_file_formats][Comparison of Graphic File Formats]]

  + [[https://en.wikipedia.org/wiki/Retina_display][Retina Display - Apple]]

  + [[https://www.atiz.com/resources/DPI-PPI-Megapixels-and-Resolution.pdf][Making sense of DPI, PPI, Megapixels and Resolution - Atiz Innovation]]

  + [[https://cft.vanderbilt.edu/wp-content/uploads/sites/59/Image_resolutions.pdf][What Resolution Should Your Images Be?]]

  + [[https://pixelcalculator.com/en][Pixelscalculator - Convert DPI / PPI to Pixels and cmm, cm, inches]]

  + [[https://www.omnicalculator.com/other/pixels-per-inch][PPI - Calculator (Pixels Per Inch)]]

** OpenGL Documentation

 *OpenGL:*

   * [[http://docs.gl/][docs.gl]] [BEST]
     + Allows searching and quickly browsing the OpenGL
       documentation.

   * https://www.opengl.org/

   * [[https://docs.microsoft.com/en-us/windows/win32/opengl/opengl][Microsoft Windows OpenGL Implementation - WGL]]

   * [[https://www.khronos.org/registry/OpenGL/index_gl.php][Khronos OpenGL® Registry]]
     * OpenGL Official Specification.

   * [[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)][Core Language (GLSL) - OpenGL Wiki]] / Khronos Group
     * Official Documentation of OpenGL shading language.

   * [[https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)][Data Type (GLSL) - OpenGL Wiki]] / Khronos Group
     * Data types of GLSL - OpenGL Shading Language.

   * [[https://thebookofshaders.com/][The Book of Shaders]] - (Patricio Gonzalez and Jen Love)

   * [[https://arm-software.github.io/opengl-es-sdk-for-android/index.html][OpenGL ES SDK for Android Documentation]] (ARM Company)

   * [[https://www.khronos.org/opengl/wiki/Common_Mistakes][Common Mistakes]] (Khronos Group) =>> Useful for debugging.

   * [[https://web.archive.org/web/20190629031543/http://antongerdelan.net/teaching/3dprog1/maths_cheat_sheet.pdf][3D Maths Cheat Sheet]] - Reference Card for computer graphics
     linear algebra. (homogeneous coordinates, rotation matrices,
     translation matrices and etc.)

 *WebGL:*

   * [[https://www.khronos.org/webgl/][WebGL Overview - The Khronos Group Inc]]
     * "WebGL is a cross-platform, royalty-free web standard for a
       low-level 3D graphics API based on OpenGL ES, exposed to
       ECMAScript via the HTML5 Canvas element. Developers familiar
       with OpenGL ES 2.0 will recognize WebGL as a Shader-based API
       using GLSL, with constructs that are semantically similar to
       those of the underlying OpenGL ES API. It stays very close to
       the OpenGL ES specification, with some concessions made for
       what developers expect out of memory-managed languages such as
       JavaScript. WebGL 1.0 exposes the OpenGL ES 2.0 feature set;
       WebGL 2.0 exposes the OpenGL ES 3.0 API."

   * [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial][WebGL tutorial - Web APIs | MDN]]

   * [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL][Getting started with WebGL - Web APIs | MDN]] - WebGL Documentation.

   * [[https://webglfundamentals.org/][WebGL Fundamentals]]
** Terminology related to OpenGL and  Computer Graphics

  + *SIGGRAPH* - international Association for Computing Machinery's
    Special Interest Group on Computer Graphics and Interactive
    Technique.

  + API - Application Programming Interface

  + SGI - Silicon Graphics International - Company which developed
    first version of OpenGL. It was known for this SGI workstations.

  + _OpenGL_ - Open Graphics Library

  + [[https://www.khronos.org/opengl/wiki/OpenGL_Context][OpenGL Context]]

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler

  + ARB - Architecture Review Board

  + OpenGL _Immediate Mode_ (Fixed-Function Pipeline, Legacy OpenGL)
    + Also known as: Legacy OpenGL, Fixed-Function Pipeline
    + Drawing is mostly performed without storing data on GPU and by
      using subroutines calls to glScale(), glRotate(), glPush(), glPop(),
      glTranslate(), glBegin(), glEnd() and so on.
    + Immediate-mode is not supported by OpenGL ES or WebGL.
    + See: [[https://www.khronos.org/opengl/wiki/Fixed_Function_Pipeline][Fixed Function Pipeline - OpenGL Wiki]]

  + OpenGL _retained mode_ (Programmable Pipeline, Modern OpenGL)
    + Also known as: Modern OpenGL, Programmable Pipeline
    + New and modern OpenGL API => Drawing is performed by storing
      data on the GPU via VBO (Vertex Buffer Objects) and by using
      _shaders_, programs that runs on GPU, for performing geometric
      vertex transformations, color and texturing computations.
    + More peformant than _immediate-mode_ as the data is not sent to
      the GPU every frame.

  + _GPU_ - Graphics Processing Unit

  + _iGPU_ - Integrated GPU - The GPU is in the same processor chip
    silicon die. Most mobile GPUs are integrated. Most desktop
    computers also have dedicated GPUs built in the same chip as the
    CPU cores. This type of GPU is enough for most common tasks such
    as lightweight games, 2D games and watching youtube videos, but
    they are not suitable for heavy AAA (triple-A) games.

  + _dGPU_ - Dedicated GPU - GPU available as a separated card and
    connected to the motherboard via PCI connection. They are suitable
    for triple-A games and GPGPU (General Purpose GPU Computing). The
    biggest manufacturers of those GPUs are _Nvidia_ and _AMD_ (Advanced
    Micro Devices). 

  + _eGPU_ - External GPU - GPU external to the motherboard and often
    connected via _thunderbolt_ cable. External GPUs can be used on
    laptop machines, that often lack enough space for installing a
    dedicated GPU. Disadvantage: only newer motherboards have support
    for thunderbolt cables.

  + _GPGPU_ - General Purpose Computing on GPU
    + APIs: OpenCL, Cuda, and so on.
    + Parallel non-graphics computations on GPU. GPGPU APIs take
      advantage of GPU parallel computing features for high
      performance computing.

  + AAA - Triple-A games.

  + [[https://www.khronos.org/opengl/wiki/Direct_State_Access][DSA]] - Direct State Access

  + _Vertex_ - 2D or 3D coordinates representing a point in the space.

  + _DOF_ - Degrees Of Freedom

  + _2D_ - 2 dimensions (plane) / 2 coordinates (X, Y)

  + _3D_ - 3 dimensions (space) / 3 coordinates (X, Y, Z)

  + _Homogenous Coordinate_ - Coordinate system using an extra dimension
    for encoding translation coordinate transformation in the same way
    as rotation matrices transformations.
    + 2D homogeneous coordinates: (X, Y, W = 1)
    + 3D homogeneous coordinates: (X, Y, Z, W = 1)

  + _NDC_ - Normalized Device Coordinate
    + Default coordinates used by OpenGL (-1.0 to 1.0) for each
      axis. Any vertex that falls out of this range will not be visible
      on the screen.

  + _MCS_ - Model Coordinate System

  + _CTM_ - Current Transform Matrix

  + [[https://www.khronos.org/opengl/wiki/Buffer_Object][Buffer Object]]

  + _VBO_ - Vertex Buffer Object

  + _VAO_ - Vertex Array Object

  + _FBO_ - Framebuffer Object

  + _IBO_ - Index Buffer Object

  + _UBO_ - Uniform Buffer Object

  + _FPS_ - Frame Per Seconds

  + _Shader_ - Program that runs on the GPU and performs vertex
    computations such as coordinate transformations (matrix
    multiplications), colors and texture computations.

  + _GLSL_ - OpenGL shading programming language - for performing
    computer graphics calculations on the GPU hardware.

  + _HLSL_ (High-Level Shader Language) - Microsft's DirectX shading language.

  + _COP_ - Center Of Projection

  + _CAD_ - Computer Aided Design

  + _CAM_ - Computer Aided Manufacturing

  + _CSG_ - Constructive Solid Geometry

  + Computer Graphics Data Structures
    + [[https://en.wikipedia.org/wiki/Polygon_mesh][Mesh]]
    + Nurb 
    + Voxel
    + Quad tree
    + Octo tree
    + [[https://en.wikipedia.org/wiki/Digital_elevation_model][DEM - Digital Elevation Model]]

  + Common Mesh File Formats (Standardized file formats for mesh storage)
    + [[https://en.wikipedia.org/wiki/Wavefront_.obj_file][.obj File]] - ASCII text file format for mesh storage.
    + [[http://paulbourke.net/dataformats/ply/][.ply File]] - Polygon File Format
    + [[https://en.wikipedia.org/wiki/VRML][.vrml File]] - VRM XML file format created by the W3C consortium.
    + [[https://en.wikipedia.org/wiki/Blender_(software)#File_format][.blend File]] - Blender File format

  + Article Related to Meshes
    + [[https://en.wikipedia.org/wiki/Types_of_mesh][Types of Meshes]] 
    + [[https://en.wikipedia.org/wiki/List_of_common_3D_test_models][Common 3D test models]]
    + [[https://en.wikipedia.org/wiki/Mesh_generation][Mesh Generation]]
    + [[https://en.wikipedia.org/wiki/Polygon_mesh][Polygon Mesh]]
    + [[https://en.wikipedia.org/wiki/Triangulation_(geometry)][Triangulation (Geometry)]]
    + [[https://en.wikipedia.org/wiki/Wire-frame_model][Wire-frame model]]
    + [[https://en.wikipedia.org/wiki/Point_cloud][Point Cloud]]
    + [[http://wiki.gis.com/wiki/index.php/Polygon_mesh][Polygon mesh (GIS)]]

  + _Resolution_
    + PPI - Pixels Per Inch
    + DPI - Dots Per Inch

  + _Display Types_
    + CRT - Cathode Ray Tube
    + LCD - Liquid Crtystal Display
    + PDP - Plasma Display Panel
    + OLED

** OpenGL companion libraries
*** OpenGL Companion Libraries

 _OpenGL Loaders:_ [ESSENTIAL]

  + Libraries that abstracts OpenGL function pointers loading in a
    platform-independent way.

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler [MOST USED]
    + "The OpenGL Extension Wrangler Library (GLEW) is a
      cross-platform open-source C/C++ extension loading library. GLEW
      provides efficient run-time mechanisms for determining which
      OpenGL extensions are supported on the target platform. OpenGL
      core and extension functionality is exposed in a single header
      file. GLEW has been tested on a variety of operating systems,
      including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris."

  + [[https://glad.dav1d.de/][GLAD]] - [MOST-USED] Multi-Language GL/GLES/EGL/GLX/WGL
    Loader-Generator based on the official specs.

  + [[https://github.com/cginternals/glbinding][GitHub - cginternals/glbinding]]
    + "A C++ binding for the OpenGL API, generated using the gl.xml
      specification."

  + [[https://github.com/anholt/libepoxy][GitHub - anholt/libepoxy]]
    + "Epoxy is a library for handling OpenGL function pointer
      management for you."

  + [[https://github.com/imakris/glatter][GitHub - imakris/glatter]]
    + "An OpenGL loading library, with support for GL, GLES, EGL, GLX and WGL"

  + [[https://galogen.gpfault.net/][Galogen OpenGL Loader Generator]]
    + "Galogen is an OpenGL loader generator. Given an API version and
      a list of extensions, Galogen will produce corresponding headers
      and code that load the exact OpenGL entry points you need. The
      produced code can then be used directly by your C or C++
      application, without having to link against any additional
      libraries."

  + [[https://github.com/SFML/SFML-glLoadGen][GitHub - SFML/SFML-glLoadGen]]
    + Customized glLoadGen for SFML


  _Window System Abstraction_ 

Libraries for window systems, event handling and OpenGL context abstraction: [ESSENTIAL]

  + Abstract platform-specific window system and event handling.

  + [[https://www.glfw.org/][GLFW]] [BEST] [MOST-USED]
    * C library that provides graphics windows for OpenGL, Vulkan,
      OpenGL ES and deals with event handling.

  + [[https://www.libsdl.org/][SDL]] (Simple Direct Media Layer) [BEST] [MOST-USED]
    * Cross-platform C library that provides windows and event
      handling for many computer graphics APIs such as OpenGL, Vulkan
      and DirectX. SLD also has facilities for dealing with audio,
      joystick, CD-ROM, network and threads.

  + [[https://www.sfml-dev.org/][SFML]] (Simple and Fast Multimedia Library) [MOST-USED]
    + "SFML provides a simple interface to the various components of
      your PC, to ease the development of games and multimedia
      applications. It is composed of five modules: system, window,
      graphics, audio and network." 

  + [[http://freeglut.sourceforge.net/][GLUT]] (FreeGlut) - OpenGL Utility Toolkit
    * Deals with window creation, OpenGL initialization, event
      handling and  so on.
    * Docs: https://www.glfw.org/documentation.html


  _Graphics Math Libraries_ 

OpenGL Math and Computer Graphics Math: [ESSENTIAL]


  + [[https://glm.g-truc.net/0.9.5/api/index.html][GLM]] (OpenGL Mathematics Library) [MOST-USED]
    + Source code: https://github.com/g-truc/glm
    + Header-only C++ library that provides classes for computer
      graphics mathematics such as: 2D, 3D and homogeneous coordinate
      vector; 2D, 3D and homogeneous coordinate transformation
      matrices; quaternions and subroutines for computing camera,
      perspective or orthogonal transformation matrices.

  + [[https://github.com/Kazade/kazmath][GitHub - Kazade/kazmath]] - A C math library targeted at games
    + "Kazmath is a simple 3D maths library written in C. It was
      initially coded for use in my book, Beginning OpenGL Game
      Programming - Second edition, but rapidly gained a life of its
      own. Kazmath is now used by many different projects, and
      apparently is used in 25% of the worlds mobile games (yeah, I
      don't believe it either - but it's used in Cocos2d-x)."

  + [[https://github.com/recp/cglm][GitHub - recp/cglm]] -  Highly Optimized Graphics Math (glm) for C

  + See: [[https://github.com/chunkyguy/Math-Library-Test][GitHub - chunkyguy/Math-Library-Test]] - A comparison of the
    various major math libraries for speed and ease of use.


  _Asset/Object Loaders - Mesh Importing Libraries_ [ESSENTIAL]

Object loader / Asset import libraries: 

  * [[http://www.assimp.org/][Assimp - The Open-Asset-Import Library]] [MOST-USED]
    + "The Open Asset Import Library (short name: Assimp) is a
      portable Open-Source library to import various well-known 3D
      model formats in a uniform manner. The most recent version also
      knows how to export 3d files and is therefore suitable as a
      general-purpose 3D model converter. See the feature-list."
    + Note: Allows importing blender-generated models/assets in OpenGL.
    + Repository: https://github.com/assimp/assimp
    + See: https://www.khronos.org/opengl/wiki/Tools/Open_Asset_Import

  * [[https://github.com/Bly7/OBJ-Loader][OBJ-Loader]]
    + "OBJ Loader is a simple, header only, .obj model file loader
      that will take in a path to a file, load it into the Loader
      class object, then allow you to get the data from each mesh
      loaded. This will load each mesh within the model with the
      corresponding data such as vertices, indices, and material. Plus
      a large array of vertices, indices and materials which you can
      do whatever you want with."

  * [[https://github.com/tinyobjloader/tinyobjloader][tinyobjloader/tinyobjloader]]
    * "Tiny but powerful single file wavefront obj loader written in
      C++03. No dependency except for C++ STL. It can parse over 10M
      polygons with moderate memory and time. tinyobjloader is good
      for embedding .obj loader to your (global illumination) renderer
      ;-)."

  * [[https://github.com/codelibs/libdxfrw][codelibs/libdxfrw]]
    * "C++ library to read and write DXF/DWG (Autocad file format)
      files. - libdxfrw is a free C++ library to read and write DXF
      files in both formats, ascii and binary form. Also can read DWG
      files from R14 to the last V2015. It is licensed under the terms
      of the GNU General Public License version 2 (or at you option
      any later version)."


  _Text and Font Rendering_

  + [[https://www.freetype.org/][The FreeType Project]]
    * Brief: "It is written in C, designed to be small, efficient,
      highly customizable, and portable while capable of producing
      high-quality output (glyph images) of most vector and bitmap
      font formats."

  + [[http://oglft.sourceforge.net/][OGLFT: OpenGL-FreeType Library]]
    * Brief: "This C++ library supplies an interface between the fonts
      on your system and an OpenGL or Mesa application. It uses the
      excellent FreeType library to read font faces from their files
      and renders text strings as OpenGL primitives."

  + [[https://github.com/vallentin/glText][GitHub - vallentin/glText]] - [HEADER-ONLY-LIBRARY]
    * Brief: "glText is a simple cross-platform single header text
      rendering library for OpenGL. glText requires no additional
      files (such as fonts or textures) for drawing text, everything
      comes pre-packed in the header."

  + [[https://github.com/MartinPerry/OpenGL-Font-Rendering][GitHub - MartinPerry/OpenGL-Font-Rendering]]
    + Brief: "Rendering UNICODE fonts with OpenGL This library is
      still work-in-progress. This is a working beta version."

  + [[http://nuclear.mutantstargoat.com/sw/libdrawtext/][libdrawtext - OpenGL text rendering library]]
    + Brief: "Libdrawtext uses freetype2 for glyph rasterization. If
      you would rather avoid having freetype2 as a dependency, you can
      optionally compile libdrawtext without it, and use pre-rendered
      glyphmaps. Glyphmaps can be generated by the included
      font2glyphmap tool, or by calling dtx_save_glyphmap."

  + [[https://github.com/codetiger/Font23D][GitHub - codetiger/Font23D]] - Convert any text to a 3d mesh using any font style
    + Brief: "Font23D is a C++ library for creating a 3d mesh of any
      Text in the given True type font."


 _C++ Wrappers_

  + [[https://oglplus.org/][OGplus]] - Self described as C++ Wrapper for modern OpengL.
    + Brief: "OGLplus is a header-only library which implements a thin
      object-oriented facade over the OpenGL® (version 3 and higher)
      C-language API. It provides wrappers which automate resource and
      object management and make the use of OpenGL in C++ safer and
      easier."
    + Repository: https://github.com/matus-chochlik/oglplu2

  + [[https://github.com/Tomius/oglwrap][Oglwrap]]
    + Brief: "Oglwrap is a lightweight, cross-platform,
      object-oriented, header-only C++ wrapper for modern (2.1+)
      OpenGL, that focuses on preventing most of the trivial OpenGL
      errors, and giving as much debug information about the other
      errors, as possible."

  + [[https://globjects.org/][Globjects]] - globjects is a cross-platform C++ wrapper for OpenGL
    API objects
    + Brief: "globjects provides object-oriented interfaces to the
      OpenGL API (3.0 and higher). It reduces the amount of OpenGL
      code required for rendering and facilitates coherent OpenGL use
      by means of an additional abstraction layer to glbinding and
      GLM. Common rendering tasks and processes are automated and
      missing features of specific OpenGL drivers are partially
      simulated or even emulated at run-time."

  _Form-based Graphical User Interface_  

   + [[https://github.com/ocornut/imgui][Dear imgui]]
     + Brief: "Dear ImGui is a bloat-free graphical user interface
       library for C++. It outputs optimized vertex buffers that you
       can render anytime in your 3D-pipeline enabled application. It
       is fast, portable, renderer agnostic and self-contained (no
       external dependencies)."
     + See: [[https://blog.conan.io/2019/06/26/An-introduction-to-the-Dear-ImGui-library.html][An introduction to Dear Imgui Library]]

  _Non-categorized / Miscellaneous_


  + [[http://glsdk.sourceforge.net/docs/html/index.html][GLSDK - Unofficial OpenGL Software Development Kit]]
    + Brief: "The Unofficial OpenGL Software Development Kit is a
      collection of libraries and utilities that will help you get
      started working with OpenGL. It provides a unified,
      cross-platform build system to make compiling the disparate
      libraries easier. Many of the components of the SDK are C++
      libraries. Each component of the SDK specifies the terms under
      which they are distributed. All licenses used by components are
      approximately like the MIT license in permissivity. The parts of
      the SDK responsible for maintaining the build, as well as all
      examples, are distributed under the MIT License."q
*** WebGL Companion Libraries

WebGL Companion Libraries: (OpenGL on the WEB)

  + [[https://glmatrix.net/][glMatrix]] - GLM math library ported to Javascript. Computer
    graphics math library, similar to OpenGL GLM math library.

  + [[https://math.gl/docs][Math.GL]] - "math.gl is JavaScript math library focused on
    geospatial and 3D use cases, designed as a composable, modular
    toolbox. math.gl provides a core module with classic vector and
    matrix classes, and a suite of optional modules implementing
    various aspects of geospatial and 3D math. While the math.gl is
    highly optimized for use with the WebGL and WebGPU APIs, math.gl
    itself has no WebGL dependencies."

  + [[https://humbletim.github.io/glm-js/][GLM-JS]] - "glm-js is an experimental JavaScript implementation of
    the OpenGL Mathematics (GLM) C++ Library."

  + [[https://threejs.org/][Three.JS]] - High level wrapper library around WebGL, that provides
    many high level features that includes: camera objects; scene graphs;
    geometry; perspective; forward kinematics, inverse kinematics;
    graphics math library containing, matrices, vectors, quaternions;
    image loaders; animation and more.
*** See also

  + [[https://www.khronos.org/opengl/wiki/OpenGL_Loading_Library][OpenGL Loading Library - OpenGL Wiki]] / Khronos Group
    + Brief: "An OpenGL Loading Library is a library that loads
      pointers to OpenGL functions at runtime, core as well as
      extensions. This is required to access functions from OpenGL
      versions above 1.1 on most platforms. Extension loading
      libraries also abstracts away the difference between the loading
      mechanisms on different platforms."

  + [[https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions][Load OpenGL Functions - OpenGL Wiki]]  / Khronos Group
    + Brief: "Loading OpenGL Functions is an important task for
      initializing OpenGL after creating an OpenGL context. You are
      strongly advised to use an OpenGL Loading Library instead of a
      manual process. However, if you want to know how it works
      manually, read on."

  + [[https://www.khronos.org/opengl/wiki/Image_Libraries][Image Libraries - OpenGL Wiki]]  / Khronos Group

  + [[https://stackoverflow.com/questions/27873784/when-do-i-need-to-use-an-opengl-function-loader][When do I need to use an OpenGL function loader? - Stack Overflow]]

  + [[https://keyj.emphy.de/glext/][KeyJ's Blog : Blog Archive » Modern OpenGL with lcc-win32, the hard way]]

  + [[https://apoorvaj.io/loading-opengl-without-glew/][Loading OpenGL without GLEW]]

  + [[https://www.libsdl.org/release/SDL-1.2.15/docs/html/guidevideoopengl.html][Using OpenGL With SDL]] - LibSDL

  + [[https://www.khronos.org/opengl/wiki/Tutorial1:_Creating_a_Cross_Platform_OpenGL_3.2_Context_in_SDL_(C_/_SDL)][Tutorial1: Creating a Cross Platform OpenGL 3.2 Context in SDL (C / SDL) - OpenGL Wiki]]

** Legacy/Obsolete OpenGL Subroutines

The following OpenGL subroutines are from the OpenGL _immediate mode_
(fixed-function pipeline), which are obsolete and should be avoided as
they incur on a significant overhead and they lack portability since
they are not be available on OpenGL ES.

Note: The best way to check wether a OpenGL subroutine is obsolete is
by searching for its name at http://docs.gl/. Subroutines without ES2,
ES3 or GL4 hyperlinks are obsolete. For instance, by searching for
'glLight' at this web site, there are no ES2, ES3 or GL4 hyperlinks,
which indicates that this subroutine is outdated.


Obsolete Subroutines:

  + Vertex:
    + => Modern OpenGL replacement: VBO (Vertex Buffer Object) and VAO
      (Vertex Array Object) and shader program.
    + glVertex2f()  => 2D coordinate of current vertex
    + glVertex3f()  => 3D Coordinate of current vertex
    + glNormal3f()  => Sets the surface normal vector for the current vertex.
    + glColor3f()   => Sets the color for the current vertex.
    + glColor4ub()  => Sets the color for the current vertex using RGB
      in byte format from 0 to 255.

  + Begin/End:
    + glEnd()
    + glBegin()

  + Colors
    + glColor()   => Modern OpenGL replacement: Fragement shader
    + glMaterial()
    + glVertexPointer()

  + Coordinate Transformation
    + Modern OpenGL Replacement: shader model matrix _uniform variable_
      which is set by the calling code. Since the matrix math (linear
      algebra) functionality is no longer provided by OpenGL, a third
      party math library is necessary.
    + glLoadIdentity()  => Modern OpenGL replacement: glm::mat4(1.0);
    + glRotate()        => Modern OpenGL replacement: glm::rotate();
    + glTranslate()     => Modern OpenGL replacement: glm::translate();
    + glScale()         => Modern OpenGL replacement: glm::scale();
    + glRotate3f()
    + glMatrixMode()
    + glFrustum()       => Modern OpenGL replacement: glm::frustum();
    + gluLookAt()       => Modern OpenGL replacement: glm::lookAt();
    + gluPerspective()  => Modern OpenGL replacement: glm::perspective();
    + glMatrixMode()
    + glViewPort()
    + glOrtho()
    + glMultMatrix()

  + Camera affine transforms:
    + gluLookAt() => Replacement: glm::lookAt()

  + Save Context
    + glPop()
    + glPush()

  + Matrix Stack [DEPRECATED!]
    + Modern OpenGL replacement: OpenGL since 3.0, no longer provides
      a matrix stack. Now the calling code that has to keep track of
      transformation state.
    + glPushMatrix()
    + glPopMatrix()

  + Light and illumination:
    + Modern OpenGL Replacement: Light and illumination model are
      computed on fragment shader or vertex shader.
    + glLight()
    + glLightModel()
    + glMaterial()
    + glNormal3f()

  + Miscellaneous / Non Categorized
    + glEnableClientState()
    + glColorPointer()
    + glVertexPointer(*)
    + glLight*...
    + glMaterial*...
    + glDrawPixels()
    + glPixelZoom()
    + glRasterPos2i()


See:

  + [[https://stackoverflow.com/questions/13647108/matrix-stacks-in-opengl-deprecated][Matrix stacks in OpenGL deprecated?]]

  + [[https://stackoverflow.com/questions/3755998/what-is-the-point-of-the-matrix-stack-in-opengl][What is the point of the matrix stack in OpenGL?]]

  + [[http://edeleastar.github.io/opengl-programming/topic05/pdf/3.MatrixStacks.pdf][OpenGL Matrix Stacks {PDF}]]

** Linux-Specific

  *Install OpenGL development dependencies*

Install OpenGL development dependencies on Ubuntu or Debian-like
distributions:

#+BEGIN_SRC sh
   $ sudo apt-get install -y libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev  libgl1-mesa-dev libxrandr-dev
   $ sudo apt-get install -y libxinerama-dev libxcursor-dev libxi-dev
#+END_SRC

 *Information about OpenGL and graphics card*

Vendor:

#+BEGIN_SRC sh
   $ >> glxinfo | grep -E "vendor"
  server glx vendor string: SGI
  client glx vendor string: Mesa Project and SGI
  OpenGL vendor string: Intel
#+END_SRC

Rendering:

#+BEGIN_SRC sh
   $ >> glxinfo | grep -E "rendering"
  direct rendering: Yes
#+END_SRC

Version:

#+BEGIN_SRC sh
   $ >> glxinfo | grep -E "version"
  server glx version string: 1.4
  client glx version string: 1.4
  GLX version: 1.4
      Max core profile version: 4.6
      Max compat profile version: 4.6
      Max GLES1 profile version: 1.1
      Max GLES[23] profile version: 3.2
  OpenGL core profile version string: 4.6 (Core Profile) Mesa 20.3.2
  OpenGL core profile shading language version string: 4.60
  OpenGL version string: 4.6 (Compatibility Profile) Mesa 20.3.2
  OpenGL shading language version string: 4.60
  OpenGL ES profile version string: OpenGL ES 3.2 Mesa 20.3.2
  OpenGL ES profile shading language version string: OpenGL ES GLSL ES 3.20
      GL_EXT_shader_implicit_conversions, GL_EXT_shader_integer_mix,
#+END_SRC

Display:

#+BEGIN_SRC sh
   $ >> glxinfo | grep -E "display"
  name of display: :1
  display: :1  screen: 0
#+END_SRC

** Computer Graphics Math
*** Overview

Computer graphics math is based on vector algebra, linear algebra and
affine transforms. Those concepts are not exclusive to OpenGL, they
are essential and universal to all computer graphics APIS -
Application Programming Interfaces, including OpenGL, DirectX, Metal,
Vulkan, WebGL and html5 canvas.
*** Vector Algebra

Given 2 3D vectors $\vec{A} = [ x_A, y_A, z_A ]$ and $\vec{B} = [ x_B, y_B, z_B ]$
, the following properties can be defined:

 *Vector Sum*

\begin{equation}
  \vec{C} = \vec{A} + \vec{B}
          = (x_A + x_B) \hat{i} + (y_A + y_B) \hat{j} + (z_A + z_B) \hat{k}
\end{equation}

 *Vector Difference / Subtraction*

\begin{equation}
  \vec{C} = \vec{B} - \vec{A}
          = (x_B - x_A) \hat{i} + (y_B - y_A) \hat{j} + (z_B - z_A) \hat{k}
\end{equation}

 *Vector Norm*

The _norm_ or _magnitude_ of A, $|| \vec{A} ||$ is given by:

\begin{equation}
   || \vec{A} || = \sqrt{ x_A^2 + y_A^2 + z_A^2 }
\end{equation}


\begin{equation}
   || \vec{A} ||^2 = \vec{A} \cdot \vec{A}
\end{equation}

 *Normalized Vector / Unit Vector*

A _normalized vector_, is a vector with the same direction than a given
vector, but with norm equal to one. A normalized vector of A can be
computed as:

\begin{equation}
    \text{normalized}( \vec{A} )
       = \frac{ \vec{A} }{ || A || }
       = \frac{1}{ \sqrt{ x_A^2 + y_A^2 + z_A^2 } } . \vec{A}
\end{equation}

\begin{equation}
   \text{ normalized }( \vec{A} )
   = \frac{1}{ \sqrt{ x_A^2 + y_A^2 + z_A^2 } } . ( x_A \cdot \hat{i} + y_A \cdot \hat{j} + z_A \cdot \hat{k} )
\end{equation}

Where:
  + $\hat{i}$, $\hat{j}$, $\hat{k}$ are the unit vectors of axis X, Y
    and Z respectively.

\begin{equation}
    || \text{normalized}( \vec{A} ) || = 1
\end{equation}


 *Distance between two position (point) vectors*

Given two vectors A and B which represent the position relative to the
coordinate system origin or point. (0, 0, 0). The distance between A
and B, or the length of the vector difference between A and B is
determined by the following relation.

\begin{eqnarray*}
   \text{distance}( \vec{A}, \vec{B}) &=& || \vec{A}  - \vec{B} || = || \vec{B}  - \vec{A} || \\
   \text{distance}( \vec{A}, \vec{B}) &=& \sqrt{ (x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2 }
\end{eqnarray*}

 *Dot Product (a.k.a - Scalar Product)*

The vector _dot product_ is:

\begin{equation}
  \text{dot}( \vec{A}, \vec{B} )
    = \vec{A} \cdot \vec{B}
    = x_A \cdot x_B + y_A \cdot y_B + z_A \cdot z_B
\end{equation}

  + Where:
    + $|| \vec{A} ||$ is the norm of vector A
    + $|| \vec{B} ||$ is the norm of vector B

  + The vectors $\vec{A}$ and $\vec{B}$ are _orthogonal_, the angle
    between them is 90 degrees, when the dot product is zero.


The dot product has the property:

\begin{equation}
  \text{dot}( \vec{A}, \vec{B} )
    = \vec{A} \cdot \vec{B}
    = || \vec{A} || \cdot || \vec{B} || \cdot \cos \theta
\end{equation}

And also:

\begin{equation}
   \cos \theta =  \frac{ \vec{A} \cdot \vec{B}  }{ || \vec{A} || \cdot || \vec{B} ||  }
\end{equation}

Where:
   + $\theta$ is the angle between vectors A and B.


If the vectors $\vec{A}$ and $\vec{B}$ are expressed as column
matrices, the product can be computed as a matrix multiplication.

  + In the following equations. $A^T$ is the transpose of matrix A.

\begin{equation}
  A = \begin{bmatrix} x_A \\ y_A \\ z_A  \end{bmatrix}
\end{equation}

\begin{equation}
  B = \begin{bmatrix} x_B \\ y_B \\ z_B  \end{bmatrix}
\end{equation}


\begin{equation}
  dot(\vec{A}, \vec{B})
     = \vec{A} \cdot \vec{B}
     = A^T \cdot B
     =
        \begin{bmatrix} x_A & y_A & z_A  \end{bmatrix}
        \cdot
        \begin{bmatrix} x_B \\ y_B \\ z_B  \end{bmatrix}
\end{equation}


  *Cross Product* *(a.k.a - Vector product)*

The cross product between two vectors $\vec{A}$ and $\vec{B}$ results
in a vector which is perpendicular (orthogonal) to both A and B.

\begin{equation}
   \text{cross}( \vec{A}, \vec{B} )

        = \vec{A} \times \vec{B}

        = \begin{bmatrix}
             y_A \cdot z_B - z_A \cdot y_B   \\
             z_A \cdot x_B - x_A \cdot z_B   \\
             x_A \cdot y_B - y_A \cdot x_B   \\
          \end{bmatrix}

       = [A]_{\times} \cdot B
\end{equation}


Where $[A]_{\times}$ is the _cross product matrix_.

\begin{equation}
  [A]_{\times} =
     \begin{bmatrix}
          0   & -z_A  &  y_A  \\
          z_A &  0    & -x_A  \\
         -y_A &  x_A  &  0    \\
     \end{bmatrix}
\end{equation}

The cross product have the following properties:

\begin{equation}
  || \vec{A} \times \vec{B} || = || \vec{A} || \cdot || \vec{B} || \cdot \sin \theta
\end{equation}

\begin{equation}
  \vec{A} \times \vec{B} = || \vec{A} || \cdot || \vec{B} || \cdot \sin \theta \cdot \hat{n}
\end{equation}


\begin{equation}
   \vec{A} \times \vec{B} = - \vec{B} \times \vec{A}
\end{equation}


  + Where:
    + $\vec{n}$ is unit vector with the same direction as the cross
      product vector.
    + $\theta$ is the angle between the two underlying vectors.


  *Vector Triple Product*

\begin{equation}
   ( \vec{u} \times \vec{v} ) \times \vec{w}
         = ( \vec{v} \cdot \vec{w} ) \vec{u} + ( \vec{u} \cdot \vec{w}) \vec{v}
         = \text{dot}( \vec{v}, \vec{w} ) \vec{u} + \text{dot}( \vec{u}, \vec{w}) \vec{v}
\end{equation}


  *Relation between vectors*

 _Orthogonal (perpendicular) vectors:_

Two vectors $\vec{A}$ and $\vec{B}$ are orthogonal, the angle between
them is 90 degrees or PI/2 radians, if their dot product is zero.

\begin{equation}
   \vec{A} \cdot \vec{B} = 0
\end{equation}


 _Parallel vectors_

Two vectors $\vec{A}$ and $\vec{B}$ are parallel, the angle between
them are zero or 180 degrees, if their cross product is zero.

\begin{equation}
   \vec{A} \times \vec{B} = 0
\end{equation}


  _Same direction_

Let the unit vector that points in the same direction of a vector
$\vec{A}$ be $[\vec{A}]_u$, where $[ \cdot ]_u$ is a operator that
determines the unit vector of a vector.

\begin{equation}
   [\vec{A}]_u = \frac{1}{|| \vec{A} || } \vec{A}
               = \frac{1}{|| \vec{A} || } (x_A \cdot \hat{i} + y_A \cdot \hat{j} + z_A \cdot \hat{k} )
\end{equation}

A pair of vector $\vec{A}$ and $\vec{B}$ have the same direction if
both have the same unit vector or:

\begin{equation}
   [ \vec{A} ]_u = [ \vec{B} ]_u
\end{equation}

Two vectors have the same direction if their cross product is zero and
their dot product (scalar product) is zero as expressed in the
following statements.

\begin{eqnarray*}
   \vec{A} \cdot  \vec{B} > 0 \\
   \vec{A} \times \vec{B} = 0
\end{eqnarray*}

  _Angle between two vectors_

The angle between two 3D vectors can be determined by using their dot
product and cross product.

\begin{equation}
  \theta = \text{atan2}( || \vec{A} \times \vec{B} ||, \vec{A} \cdot \vec{B}  )
         = \text{atan2} \left( \text{norm}(  \text{cross}( \vec{A}, \vec{B})) , \text{dot}(\vec{A}, \vec{B})  \right)
\end{equation}
*** Affine Transforms

Affine transforms, which are represented by matrices, are a particular
class of linear transforms which preserves ratios between distances,
colinearity and parallelism. Affine transforms has many applications
that includes, computer graphics, computer vision, image processing,
CAD (Computer Aided Design) and robotics.

Outline of properties preserved by affine transforms:

  + Ratios between distances.

  + Colinearity
    + => Points in the same line, remains in the same line, after the
      transform was applied.

  + Parallelism
    + => Lines that are parallels, remains parallel.


Types of geometric linear transforms:

  * Affine Transforms
    + => Preserves ratios, colinearity and parallelism. Some affine
      transforms are: _identity_, _translation_, _rotation_ and _scaling_.

  * Projection Transforms
    + => They not preserve parallelism. However, they preserve
      colinearity. Affine transforms are a particular case of
      projection transforms.
    + => Some projection transforms are:
      + Orthogonal view transform
      + Projection view transform

  * Rigid body transforms
    + => Are a particular case of affine transforms. The set of rigid
      body transforms comprises: _identity_, _translation_ and
      _rotation_. This set of transforms does not include shear and scaling.
    + => Use cases: Computer graphics, Newtonian mechanics, robotics,
      aerospace and many other cases.


Some affine transforms are:

  + Identity (Identity matrix) => Represents no transform, all points
    or vertices remain the same.

  + Translation

  + Scaling

  + Reflection

  + Rotation

  + Shear


   *General form of 2D affine transforms*

2D affine transforms, including translation, rotation and scaling can
be represented by matrices with the following format, that transforms
homogeneous coordinates from one coordinate system to
another. _Homogeneous coordinates_, are 2D or 3D coordinates with an
extra pseudo-coordinate, often designated by 'w', for representing
translations affine transforms in the same way as rotations and
scaling.


\begin{equation}
  A =
   \begin{bmatrix}
     a_{11}   & a_{12}   &  a_{13} \\
     a_{21}   & a_{22}   &  a_{23} \\
     0        & 0        &  1 \\
   \end{bmatrix}
\end{equation}

This affine transform performs the coordinate transformation from the
coordinate frame C2 (which axis are x, y), which could an object
local-space coordinate, to coordinate frame C1 (which axis are x', y')
which could be a world-coordinate system. The matrix transforms
homogenous coordinates, which are coordinates with an extra parameter
w = 1 for allowing translation transformation to be expressed in the
same way as rotation transformations.


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ w' = 1
      \end{bmatrix}
  =
    \begin{bmatrix}
      a_{11}   & a_{12}   &  a_{13} \\
      a_{21}   & a_{22}   &  a_{23} \\
      0        & 0        &  1      \\
   \end{bmatrix}

     \cdot

     \begin{bmatrix}
       x \\ y \\ w = 1
     \end{bmatrix}

    =

    \begin{bmatrix}
        a_{11} \cdot x + a_{12}  \cdot y + a_{13}  \\
        a_{21} \cdot x + a_{22}  \cdot y + a_{23}  \\
        1
    \end{bmatrix}
\end{equation}

The multiplication between two affine transforms also results in a
affine transform. Consider two affine transforms $A = a_{ij}$ 
and $B = b_{ij}$. The product between these two affine transforms is
also an affine transform. 

\begin{equation} 
   C = A \cdot B = 

   \begin{bmatrix}
     a_{11}   & a_{12}   &  a_{13} \\
     a_{21}   & a_{22}   &  a_{23} \\
     0        & 0        &  1 \\
   \end{bmatrix}

   \begin{bmatrix}
     b_{11}   & b_{12}   &  b_{13} \\
     b_{21}   & b_{22}   &  b_{23} \\
     0        & 0        &  1 \\
   \end{bmatrix}

  = 

   \begin{bmatrix}
       c_{11} & c_{12} & c_{13}  \\ 
       c_{21} & c_{22} & c_{23}  \\
         0    &  0     &  1 
   \end{bmatrix}
\end{equation}

Where: 

  + $c_{11} = a_{11} \cdot b_{11} + a_{12} \cdot b_{21}$
  + $c_{12} = a_{11} \cdot b_{12} + a_{12} \cdot b_{22}$
  + $c_{21} = a_{21} \cdot b_{11} + a_{22} \cdot b_{21}$
  + $c_{22} = a_{21} \cdot b_{12} + a_{22} \cdot b_{22}$
  + $c_{13} = a_{11} \cdot b_{13} + a_{12} \cdot b_{23} + a_{13}$
  + $c_{23} = a_{21} \cdot b_{13} + a_{22} \cdot b_{23} + a_{23}$


  *3D Affine Transforms*

3D affine transforms can be represented by matrices with the following
format.

\begin{equation}
  A =
   \begin{bmatrix}
     a_{11}   & a_{12}   &  a_{13} & a_{14}  \\
     a_{21}   & a_{22}   &  a_{23} & a_{24}  \\
     a_{31}   & a_{32}   &  a_{33} & a_{34}  \\
     0        & 0        &  0      & 1       \\
   \end{bmatrix}
\end{equation}

An affine transformation maps the coordinate system (X, Y, Z), which
could be an object local coordinate system, to the coordinate system
(X', Y', Z'), which could be a world coordinate system. In a similar
manner to 2D homogeneous coordinates, an extra pseudo-coordinate w = 1
is added for expressing translations transformations as matrix
multiplications, in the same way as rotations.


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =
    \begin{bmatrix}
      a_{11}   & a_{12}   &  a_{13} & a_{14} \\
      a_{21}   & a_{22}   &  a_{23} & a_{24} \\
      a_{31}   & a_{32}   &  a_{33} & a_{34} \\
      0        & 0        &  0      &   1    \\
   \end{bmatrix}

     \cdot

     \begin{bmatrix}
       x \\ y \\ z \\ w = 1
     \end{bmatrix}

\end{equation}


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ 1
      \end{bmatrix}
    =

    \begin{bmatrix}
        a_{11} \cdot x + a_{12}  \cdot y + a_{13} \cdot z + a_{14}  \\
        a_{21} \cdot x + a_{22}  \cdot y + a_{23} \cdot z + a_{24}  \\
        a_{31} \cdot x + a_{32}  \cdot y + a_{33} \cdot z + a_{34}  \\
        1
    \end{bmatrix}
\end{equation}

Consider two affine transforms $A = a_{ij}$ and $B = b_{ij}$. The
product between those two transform is also an affine transform. 

\begin{equation} 
  C = A \cdot B 
   = 
    \left[\begin{matrix}a_{11} & a_{12} & a_{13} & a_{14}\\a_{21} & a_{22} & a_{23} 
         & a_{24}\\a_{31} & a_{32} & a_{33} & a_{34}\\0 & 0 & 0 & 1\end{matrix}\right]

    \left[\begin{matrix}b_{11} & b_{12} & b_{13} & b_{14}\\b_{21} & b_{22} & b_{23} 
         & b_{24}\\b_{31} & b_{32} & b_{33} & b_{34}\\0 & 0 & 0 & 1\end{matrix}\right]
\end{equation}


\begin{equation} 
   C = 
    \left[\begin{matrix}c_{11} & c_{12} & c_{13} & c_{14}\\c_{21} & c_{22} & c_{24} 
         & c_{23}\\c_{31} & c_{32} & c_{33} & c_{34}\\0 & 0 & 0 & 1\end{matrix}\right]
\end{equation}


  *Further Reading*

General:

  + [[http://graphics.cs.cmu.edu/nsp/course/15-462/Spring04/slides/04-transform.pdf][CMU - Transformations]]

  + [[http://www.cs.cornell.edu/courses/cs4620/2013fa/lectures/04transforms2d.pdf][Cornell CS4620 - 2D Geometric Transformations]]

  + [[https://web.iitd.ac.in/~hegde/cad/lecture/L6_3dtrans.pdf][AML170 CAD - 3D Transformations - Lecture 6]]

  + [[https://mycourses.aalto.fi/pluginfile.php/352115/mod_resource/content/1/01_transform.pdf][CS_CS3100 (Introduction to) Computer Graphics]]

Coordinate Systems:

  + [[https://en.m.wikipedia.org/wiki/Coordinate_system][Coordinate system - Wikipedia]]
    + Brief: "n geometry, a coordinate system is a system that uses
      one or more numbers, or coordinates, to uniquely determine the
      position of the points or other geometric elements on a manifold
      such as Euclidean space."

  + [[https://en.m.wikipedia.org/wiki/Homogeneous_coordinates][Homogeneous coordinates - Wikipedia]]
    + Brief: "Homogeneous coordinates have a range of applications,
      including computer graphics and 3D computer vision, where they
      allow affine transformations and, in general, projective
      transformations to be easily represented by a matrix."

Rotation Matrix and right-hand-rule:

  + [[https://en.m.wikipedia.org/wiki/Right-hand_rule][Right-hand rule - Wikipedia]]
    + Brief: "In mathematics and physics, the right-hand rule is a
      common mnemonic for understanding orientation of axes in
      three-dimensional space."

  + [[https://en.m.wikipedia.org/wiki/Rotation_matrix][Rotation matrix - Wikipedia]]
    + Brief: "In linear algebra, a rotation matrix is a transformation
      matrix that is used to perform a rotation in Euclidean space."

  + [[https://en.m.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions][Rotation formalisms in three dimensions - Wikipedia]]
    + Brief: "In geometry, various formalisms exist to express a
      rotation in three dimensions as a mathematical
      transformation. In physics, this concept is applied to classical
      mechanics where rotational (or angular) kinematics is the
      science of quantitative description of a purely rotational
      motion."

  + [[https://en.m.wikipedia.org/wiki/Axes_conventions][Axes conventions - Wikipedia]]
    + Brief: "In ballistics and flight dynamics, axes conventions are
      standardized ways of establishing the location and orientation
      of coordinate axes for use as a frame of reference."

  + [[https://en.m.wikipedia.org/wiki/Euler_angles][Euler angles - Wikipedia]]
    + Brief: "The Euler angles are three angles introduced by Leonhard
      Euler to describe the orientation of a rigid body with respect
      to a fixed coordinate system."

  + [[https://en.m.wikipedia.org/wiki/Aircraft_principal_axes][Yaw, Pitch, Roll angles - Aircraft principal axes - Wikipedia]]
    + Brief: Rotation angles convention for aircrafts.

  + [[https://en.m.wikipedia.org/wiki/Celestial_coordinate_system][Celestial coordinate system - Wikipedia]]
    + Brief: "In astronomy, a celestial coordinate system (or
      celestial reference system) is a system for specifying positions
      of satellites, planets, stars, galaxies, and other celestial
      objects relative to physical reference points available to a
      situated observer (e.g. the true horizon and north cardinal
      direction to an observer situated on the Earth's surface)"

  + [[https://en.m.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles][Conversion between quaternions and Euler angles - Wikipedia]]
    + Brief: "Spatial rotations in three dimensions can be
      parametrized using both Euler angles and unit quaternions. This
      article explains how to convert between the two
      representations. Actually this simple use of "quaternions" was
      first presented by Euler some seventy years earlier than
      Hamilton to solve the problem of magic squares."

Affine Tranform Matrices in SVG, Html5 Canvas and WebGL:

  + [[https://blog.carbonfive.com/taming-2d-transforms/][Taming 2D Transforms in Html5 Canvas]]

  + [[https://www.w3resource.com/html5-canvas/html5-canvas-matrix-transforms.php][Html5 Canvas: Matrix Transforms]]

  + [[https://www.html5rocks.com/en/tutorials/webgl/webgl_transforms/][Html5 Rocks - WebGL Transforms]] (WebGL - OpenGL for the web)

  + [[https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform][MDN - SVG Transform matrices (Mozilla)]]

  + [[https://www.w3.org/TR/SVGTiny12/coords.html][W3C - 7 Coordinate Systems, Transformations and Units]] (SVG)

  + [[https://thesoftwaresimpleton.com/blog/2018/09/25/affine-matrix][SVG Transformations with affine matrices]] (Paul Cowan)

  + [[https://bl.ocks.org/helderdarocha/8b28505082bf1c81977d7dec797686c7][Examples using matrix transforms in SVG]]

Affine Transform Matrices in DirectX (Direct3D):

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/transforms][MSDN - Transforms (Direct3D 9)]]

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/world-transform][MSDN - World Transform]]

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/view-transform][MSDN - View Transform]]

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/projection-transform][MSDN - Projection Transform]]

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/viewports-and-clipping][MSDN - Viewport and Clipping]]

  + [[https://docs.microsoft.com/en-us/windows/win32/direct3d9/d3dxmatrixaffinetransformation][D3DXMatrixAffineTransformation function (D3dx9math.h)]]


Affine Transform Matrices in Java AWT:

  + [[https://docs.oracle.com/javase/7/docs/api/java/awt/geom/AffineTransform.html][Oracle - Class AffineTransform]]

  + [[https://www.developer.com/net/vb/article.php/626051/Java-2D-Graphics-Simple-Affine-Transforms.htm][Java 2D Graphics, Simple Affine Transforms]]

Affine Transform Matrices in non-categorized APIs

 + [[https://brlcad.org/OLD/reports/tr-313/chapt3.html][BRL Cad - Object Motion and Matrix Manipulation]]

 + [[https://docs.geotools.org/latest/userguide/tutorial/affinetransform.html][Affine Transformation Tutorial - GeoTools OSGeo]]

 + [[https://wiki.freecadweb.org/Macro_MatrixTransform][FreeCAD - Macro MatrixTransform]]

 + [[https://cadbooster.com/complete-overview-of-matrix-transformations-in-the-solidworks-api/][A complete overview of matrix transformations in the SOLIDWORKS API]]
   (SolidWorks CAD for mechanical engineering)

*** 2D Canonical Affine Transforms


Identity matrix

  + Causes no coordinate transformation. The result coordinate system
    and vertices remain at the same position. The identity matrix is
    also a reasonable initial default value for the model matrix, view
    matrix and projection matrix. 

\begin{equation}
  I =
   \begin{bmatrix}
     1   & 0   &  0 \\
     0   & 1   &  0 \\
     0   & 0   &  1 \\
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ 1
      \end{bmatrix}
  =

     I
     \cdot

   \begin{bmatrix}
       x \\ y \\ w = 1
   \end{bmatrix}
  =

   \begin{bmatrix}
     1   & 0   &  0 \\
     0   & 1   &  0 \\
     0   & 0   &  1 \\
   \end{bmatrix}


   \begin{bmatrix}
       x \\ y \\ 1 
   \end{bmatrix}

  = 
   \begin{bmatrix}
       x  \\ y  \\ 1
   \end{bmatrix}
\end{equation}


Translation:

  + Translate the coordinate system from one position into another and
    translate vertices. 

\begin{equation}
  T =
   \begin{bmatrix}
     1   & 0   &  \Delta_x \\
     0   & 1   &  \Delta_y \\
     0   & 0   &  1        \\
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ 1
      \end{bmatrix}
  =

   \begin{bmatrix}
     1   & 0   &  \Delta_x \\
     0   & 1   &  \Delta_y \\
     0   & 0   &  1        \\
   \end{bmatrix}

     \cdot

   \begin{bmatrix}
       x \\ y \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       x + \Delta_x \\ y + \Delta_y \\ 1
   \end{bmatrix}
\end{equation}


Scaling:

  + Increases or decreases object size. This transformation allows
    resizing an object without sending the vertices multiple times to
    the GPU in the case of a GPU accelerated graphics API.
  + Where: $s_x$ is the scale for X axis and $s_y$ is the scale for
    the y axis.

\begin{equation}
  S =
   \begin{bmatrix}
     s_x   & 0     &  0 \\
     0     & s_y   &  0 \\
     0     & 0     &  1 \\
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ 1
      \end{bmatrix}
  =

   \begin{bmatrix}
     s_x   & 0     &  0 \\
     0     & s_y   &  0 \\
     0     & 0     &  1 \\
   \end{bmatrix}
     \cdot

   \begin{bmatrix}
       x \\ y \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       s_x \cdot x \\ s_y \cdot y \\ 1
   \end{bmatrix}
\end{equation}


Shear:

\begin{equation}
  H =
   \begin{bmatrix}
     1     & h_x  &  0 \\
     h_y   & 1    &  0 \\
     0     & 0    &  1 \\
   \end{bmatrix}
\end{equation}


Rotation around Z axis:

  + Where $\theta$ is the angle of counterclockwise rotation around Z
    axis. A negative angle results in a rotation in the opposite
    direction. 

\begin{equation}
  R  =
   \begin{bmatrix}
     \cos \theta     & -\sin \theta  &  0 \\
     \sin \theta     &  \cos \theta  &  0 \\
     0               &  0            &  1 \\
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix} x' \\ y' \\ 1  \end{bmatrix}

    =
      \begin{bmatrix}
        \cos \theta     & -\sin \theta  &  0 \\
        \sin \theta     &  \cos \theta  &  0 \\
        0               &  0            &  1 \\
      \end{bmatrix}

     \begin{bmatrix} x \\ y \\ 1  \end{bmatrix}
    =
     \begin{bmatrix}
          x \cos \theta - y \sin \theta  \\
          x \sin \theta + y \cos \theta \\
          1
     \end{bmatrix}
\end{equation}
*** 2D Window to Viewport transform

The window-to-viewport affine transform maps coordinates from a
world-space window to a viewport (physical display coordinates). The
world-space window defines what region of the world-space will be
viewed. It is specified using the world-space coordinates $x_{wmin}$,
$x_{wmax}$, $y_{wmin}$ and $y_{wmax}$. The viewport is a rectangle
within the graphics display window to where the world-window
coordinates will be mapped to. The viewport window is defined by the
coordinates: $x_{vmin}$, $x_{vmax}$, $y_{vmin}$, $y_{vmax}$ - given in
screen device-coordinates with origin at the graphics display bottom
left corner.

Note: In OpenGL this transform can be obtained using the subroutines
glViewport() and glm::ortho().

 *Applications*

  + Draw in a limited area of screen. (Note: it is often possible to
    define multiple viewport windows.)

  + Draw using user-defined coordinates and make the drawing
    independent of the screen size.

  + Draw multiple views of the world-space.

  + Draw charts (a.k.a curve plotting).

  + Draw multiple charts on the same screen.

 *Parts:*

  * _World-Window_ (a.k.a clipping window) => Defines _what_ the user wants to
    see from the world-space. Define by: $x_{wmin}$, $x_{wmax}$,
    $y_{wmin}$ and $y_{wmax}$.
    + $x_{wmin}$ - Minimum X axis coordinate from window-space that can be viewed.
    + $x_{wmax}$ - Maximum X axis coordinate from window-space that can be viewed.
    + $y_{wmin}$ - Minimum y axis coordinate from window-space that can be viewed.
    + $y_{wmax}$ - Maximum y axis coordinate from window-space that can be viewed.

  * _Viewport_ => Defines _where_ the user wants to see the _world-window_
    within the graphics display window (a.k.a canvas).
    + $x_{vmin}$  => $0 \leq x_{vmin} \leq w$
    + $x_{vmax}$  => $0 \leq x_{vmin} \leq w$
    + $y_{vmin}$  => $0 \leq y_{vmin} \leq h$
    + $y_{vmax}$  => $0 \leq y_{vmax} \leq h$

  * Default values of viewport:
    + $x_{vmin} = 0$
    + $x_{vmax} = w$
    + $y_{vmin} = 0$
    + $y_{vmax} = h$

Where:
  + h - graphics display screen height, often in pixels.
  + w - graphics display screen width, often in pixelss

#+CAPTION: World-to-viewport transform
[[file:images/world-window-to-viewport.png][file:images/world-window-to-viewport.png]]

The window-to-viewport transform matrix can be computed as:

\begin{equation}
   T_{ W \rightarrow V} =
       \begin{bmatrix}
           s_x  &  0    & t_x \\
           0    &  s_y  & t_y \\
           0    &  0    & 1   \\
       \end{bmatrix}
\end{equation}

Where:

\begin{eqnarray*}
   s_x &=& \frac{\Delta x_{v} }{ \Delta x_{w} }
       = \frac{ x_{vmax} - x_{vmin} }{x_{wmax} - x_{wmin}}  \\

   s_y &=& \frac{\Delta y_{v} }{ \Delta y_{w} }
           = \frac{ y_{vmax} - y_{vmin} }{y_{wmax} - y_{wmin}}  \\
   t_x &=& x_{vmin} - s_x \cdot x_{wmin}                      \\
   t_y &=& y_{vmin} - s_y \cdot y_{wmin}                      \\
\end{eqnarray*}

Coordinates from world-space can be mapped to the screen-device space
by applying the affine transform $T_{ W \rightarrow V}$ to the
world-space coordinates, designated by $x_w$, $y_w$.

\begin{equation}
     \begin{bmatrix} x_v \\ y_v \\ 1 \end{bmatrix}
  =
    T_{ W \rightarrow V} \cdot
    \begin{bmatrix} x_w \\ y_w \\ 1 \end{bmatrix}
\end{equation}

\begin{equation}
     \begin{bmatrix} x_v \\ y_v \\ 1 \end{bmatrix}
  =
    \begin{bmatrix}
       s_x \cdot x_w + t_x \\
       s_y \cdot y_w + t_y \\
       1
    \end{bmatrix}
  =
    \begin{bmatrix}
       s_x (x_w - x_{wmin}) + x_{vmin} \\
       s_y (x_y - y_{wmin}) + y_{vmin} \\
       1
    \end{bmatrix}
\end{equation}

Finally, the coordinates $x_v$ and $y_v$ can be determined in a more
human-friendly way with the following expression:

\begin{eqnarray*}
   x_v &=&  s_x (x_w - x_{wmin}) + x_{vmin} \\
   y_v &=&  s_y (y_w - y_{wmin}) + y_{vmin} \\
\end{eqnarray*}

 *Image distortion*

The world-space propotions will only be preserved when the following
predicate holds. For instance, a square in the world-space will look
like a rectangle if the rations $s_x$ and $s_y$ are not equal.

\begin{equation}
   s_x = s_y
\end{equation}

In orther words,

\begin{equation}
   \frac{ x_{vmax} - x_{vmin} }{x_{wmax} - x_{wmin}} = \frac{ y_{vmax} - y_{vmin} }{y_{wmax} - y_{wmin}}
\end{equation}

 *Upper-left coordinate system*

If the graphics API has a default upper-left coordinate system, where
the origin is at the upper-left corner of the display window and Y
axis is pointing downwards. The viewport matrix transform becomes:

\begin{equation}
   T_{ W \rightarrow VU} =
       \begin{bmatrix}
           s_x  &  0     & t_x      \\
           0    &  -s_y  & h - t_y  \\
           0    &  0     &  1       \\
       \end{bmatrix}
\end{equation}

Then, the $x_v$, $y_v$ coordinates can be computed as: 


\begin{eqnarray*}
   x_v &=&  +s_x (x_w - x_{wmin}) + x_{vmin}       \\
   y_v &=&  -s_y (y_w - y_{wmin}) + (h - y_{vmin}) \\
\end{eqnarray*}

 *References and further reading:*

  + [[https://www.khronos.org/opengl/wiki/Vertex_Post-Processing#Viewport_transform][Khronos Group - Viewport transform]]
    + "The viewport transform defines the transformation of vertex
      positions from NDC space to window space. These are the
      coordinates that are rasterized to the output image. The
      viewport is defined by a number of viewport parameters. These
      parameters are set by these functions: _glViewport_; _glDepthRange_;
      _glDepthRangef_."

  + [[http://mcasjcet.weebly.com/uploads/4/4/7/9/4479347/computer_graphics_second_module_second.pdf][MCA - 301 - Computer Graphics]]

  + [[https://eaymanelshenawy.files.wordpress.com/2016/02/gc-lecture-005-viewingand-clipping.pdf][Computer Graphics Viewing Objective]]

  + [[https://www.sfu.ca/sasdoc/sashtml/iml/chap12/sect7.htm][Windows and viewports]]

  + [[https://web.cse.ohio-state.edu/~shen.94/581/Site/Slides_files/2dDrawing.pdf][Drawing and coordinate system]]

*** 3D Canonical Affine Transforms

 _Translation:_

  + Where: $T^{-1}$ is the inverse transform.

\begin{equation}
  T =
   \begin{bmatrix}
     1   & 0   &  0 &  \Delta_x \\
     0   & 1   &  0 &  \Delta_y \\
     0   & 0   &  1 &  \Delta_z \\
     0   & 0   &  0 &   1      \\
   \end{bmatrix}
\end{equation}


\begin{equation}
  T^{-1} =
   \begin{bmatrix}
     1   & 0   &  0 &  -\Delta_x \\
     0   & 1   &  0 &  -\Delta_y \\
     0   & 0   &  1 &  -\Delta_z \\
     0   & 0   &  0 &   1        \\
   \end{bmatrix}
\end{equation}

Translation transform applied to an homogeneous vector (x, y, z, w = 1):


\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =

   \begin{bmatrix}
     1   & 0   & 0 &  \Delta_x \\
     0   & 1   & 0 &  \Delta_y \\
     0   & 0   & 1 &  \Delta_z \\
     0   & 0   & 0 &    1      \\
   \end{bmatrix}

     \cdot

   \begin{bmatrix}
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       x + \Delta_x \\ y + \Delta_y \\ z + \Delta_z \\ 1
   \end{bmatrix}
\end{equation}


 _Scaling:_

  + Where: $s_x$,  $s_y$, $s_z$ are the scale factors for axis x, y, z
    and  $S^{-1}$ is the inverse transform (inverse matrix).

\begin{equation}
  S =
   \begin{bmatrix}
     s_x   & 0     &  0   &  0 \\
     0     & s_y   &  0   &  0 \\
     0     & 0     &  s_z &  0 \\
     0     & 0     &  0   &  1  \\
   \end{bmatrix}
\end{equation}


\begin{equation}
  S^{-1} =
   \begin{bmatrix}
     1 / s_x   & 0     &  0       &  0 \\
     0     & 1 / s_y   &  0       &  0 \\
     0     &    0      &  1 / s_z &  0 \\
     0     &    0      &  0       &  1 \\
   \end{bmatrix}
\end{equation}



\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =

   S \cdot

   \begin{bmatrix}
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       s_x \cdot x \\ s_y \cdot y \\ s_z \cdot z \\ 1
   \end{bmatrix}
\end{equation}


 _Rotation around x axis_

 + $R_x^{-1} = R_x^T$ => The inverse is equal to the transpose.

\begin{equation}
    R_x(\alpha) =
      \begin{bmatrix}
        1   & 0            &  0              & 0  \\
        0   & \cos{\alpha} & -\sin{\alpha}   & 0  \\
        0   & \sin{\alpha} &  \cos{\alpha}   & 0  \\
        0   & 0            &  0              & 1  \\
      \end{bmatrix}
\end{equation}


Transform $R_x$ applied to a homogeneous vector (X, Y, Z, w = 1).

\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =

   R_x(\alpha) \cdot

   \begin{bmatrix}
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       x                                            \\
       y \cdot \cos{\alpha} - z \cdot \sin{\alpha}  \\
       y \cdot \sin{\alpha} + z \cdot \cos{\alpha}  \\
       1                                            \\
   \end{bmatrix}
\end{equation}



 _Rotation around y axis_

  + $R_y^{-1} = R_y^T$

\begin{equation}
 R_y(\beta) =
   \begin{bmatrix}
     \cos{\beta}    & 0   & \sin{\beta} & 0 \\
     0              & 1   & 0           & 0 \\
    -\sin{\beta}    & 0   & \cos{\beta} & 0 \\
    0               & 0   & 0           & 1
   \end{bmatrix}
\end{equation}


Transform $R_y$ applied to a homogeneous vector:

\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =

   R_y(\beta) \cdot

   \begin{bmatrix}
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       x \cdot \cos{\beta} + z \cdot \sin{\beta} \\
       y                             \\
     - x \cdot \sin{\beta} + z \cdot \cos{\beta} \\
   \end{bmatrix}
\end{equation}

 _Rotation around z axis_

  + $R_z^{-1} = R_z^T$

\begin{equation}
 R_z(\theta) =
   \begin{bmatrix}
      \cos{\theta}  & -\sin{\theta} &  0 & 0 \\
      \sin{\theta}  &  \cos{\theta} &  0 & 0 \\
     0              & 0             &  1 & 0 \\
     0              & 0             &  0 & 1 \\
   \end{bmatrix}
\end{equation}


Transform $R_z$ applied to a homogeneous vector:

\begin{equation}
     \begin{bmatrix}
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  =

   R_z(\theta) \cdot

   \begin{bmatrix}
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  =
   \begin{bmatrix}
       x \cdot \cos{\theta} - y \cdot \sin{\theta}   \\
       x \cdot \sin{\theta} + y \cdot \cos{\theta}   \\
       z                                             \\
       1
   \end{bmatrix}
\end{equation}



 _Rotation around arbirtary axis_

  + Formula 1 : The axis is defined by unit vector $\hat{n}$
    + References:  [[http://www.chrobotics.com/library/understanding-quaternions][(Chrobotics)]], [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Ben-Ari - Weizmann)]] - derived from
      quaternion equations.

\begin{equation}
   T_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)
          &  0                            \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2
          &  2 ( c \cdot d -  a \cdot b )
          &  0                            \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2
          &  0                            \\

             0 & 0 & 0 & 1 \\
         \end{bmatrix}
\end{equation}

Where:
  + $\hat{n}$ is a unit vector that designates the direction, thus: $\hat{n} = 1$
  + $\hat{n} = [x_n \quad y_n \quad z_n]^T$
    + $x_n$, $y_n$, $z_n$ are the components of vector $\hat{n}$.
  + $a = \cos( \theta / 2)$
  + $b = x_n \cdot \sin (\theta / 2)$
  + $c = y_n \cdot \sin (\theta / 2)$
  + $d = z_n \cdot \sin (\theta / 2)$


 _Rotation around arbirtary axis_
   + Reference:  [[https://cseweb.ucsd.edu/classes/wi18/cse169-a/slides/CSE169_03.pdf][(Steve Rotenberg - Computer Animation)]]


\begin{equation}
  T_n = \begin{bmatrix}
             x_n^2 + C \cdot (1 - x_n^2)
          &  x_n \cdot y_n \cdot (1 - C) - z_n \cdot S
          &  x_n \cdot z_n \cdot (1 - C)  + y_n \cdot S
          &  0
          \\

             x_n \cdot y_n \cdot (1 - C) + z_n \cdot S
          &  y_n^2 + C \cdot (1 - y_n^2)
          &  y_n \cdot z_n \cdot (1 - C) - x_n \cdot S
          &  0
          \\
               x_n \cdot z_n \cdot (1 - C) - y_n \cdot S
           &   y_n \cdot z_n \cdot (1 - C) +  x_n \cdot S
           &  z_n^2 + C \cdot (1 - z_n^2)
           &  0
           \\

           0 & 0 & 0 & 1

        \end{bmatrix}
\end{equation}

Where:
  + $\theta$ is the rotation angle around the unit vector $\hat{n}$
  + $C = \sin \theta$
  + $S = \cos \theta$
  + $\hat{n}$ is a unit vector that designates the direction, thus: $\hat{n} = 1$
  + $\hat{n} = [x_n \quad y_n \quad z_n]^T$
    + $x_n$, $y_n$, $z_n$ are the components of vector $\hat{n}$.


Testing formula in [[https://www.sympy.org/en/index.html][Sympy]] - Python CAS (Computer Algebra System):

#+BEGIN_SRC python
  import sympy

  # t represents the angle theta
  x, y, z, t = symbols('x y z t')
  C, S = symbols("C S")

  row1 = [ x**2 + C * (1 - x**2), x * y * (1 - C) - z * S, x * z * (1 - C)  + y * S ]
  row2 = [ x * y * (1 - C) + z * S, y**2 + C * (1 - y**2), y * z * (1 - C) - x * S ]
  row3 = [ x * z * (1 - C) - y * S,  y * z * (1 - C) +  x * S, z**2 + C * (1 - z**2) ]

  m = Matrix([row1, row2, row3])

  # C = cos(t)
  # S = sin(t)

  In [7]: m
  Out[7]:
  ⎡   ⎛     2⎞    2                                          ⎤
  ⎢ C⋅⎝1 - x ⎠ + x     -S⋅z + x⋅y⋅(1 - C)  S⋅y + x⋅z⋅(1 - C) ⎥
  ⎢                                                          ⎥
  ⎢                       ⎛     2⎞    2                      ⎥
  ⎢S⋅z + x⋅y⋅(1 - C)    C⋅⎝1 - y ⎠ + y     -S⋅x + y⋅z⋅(1 - C)⎥
  ⎢                                                          ⎥
  ⎢                                           ⎛     2⎞    2  ⎥
  ⎣-S⋅y + x⋅z⋅(1 - C)  S⋅x + y⋅z⋅(1 - C)    C⋅⎝1 - z ⎠ + z   ⎦

  # --- Determine rotation matrix around Z axis (Particular case) ------#
  #

  In [8]: m.subs({x: 0, y: 0, z: 1})
  Out[8]:
  ⎡C  -S  0⎤
  ⎢        ⎥
  ⎢S  C   0⎥
  ⎢        ⎥
  ⎣0  0   1⎦

  In [11]: rotZ = m.subs({x: 0, y: 0, z: 1, C: cos(t), S: sin(t) })

  In [12]: rotZ
  Out[12]:
  ⎡cos(t)  -sin(t)  0⎤
  ⎢                  ⎥
  ⎢sin(t)  cos(t)   0⎥
  ⎢                  ⎥
  ⎣  0        0     1⎦


  #---- Determine rotation matrix around X axis (Particular case) ------#
  #
  In [14]: rotX = m.subs({x: 1, y: 0, z: 0, C: cos(t), S: sin(t) })

  In [15]: rotX
  Out[15]:
  ⎡1    0        0   ⎤
  ⎢                  ⎥
  ⎢0  cos(t)  -sin(t)⎥
  ⎢                  ⎥
  ⎣0  sin(t)  cos(t) ⎦

  #---- Determine rotation matrix around Y axis (Particular case) ------#
  #
  In [16]: rotY = m.subs({x: 0, y: 1, z: 0, C: cos(t), S: sin(t) })

  In [17]: rotY
  Out[17]:
  ⎡cos(t)   0  sin(t)⎤
  ⎢                  ⎥
  ⎢   0     1    0   ⎥
  ⎢                  ⎥
  ⎣-sin(t)  0  cos(t)⎦

#+END_SRC

*** Camera View Transform

The camera view transform matrix transforms world-space coordinates to
camera-space coordinates. On old OpenGL versions, this matrix was
can be constructed through the OpenGL routine _gluLookAt_ or the GLM
(OpenGL Mathematics) library routine glm::lookAt.

The GLM function glm::lookAt() has the following type signature.

#+BEGIN_SRC cpp
   glm::mat4 glm::lookAt(
                   // Eye vector - camera position in world-space coordinates
                   glm::vec3 const& eye

                   // At vector - point to where camera is looking at
                   // in world-space coordinates.
                 , glm::vec3 const& at

                   // Up vector - camera's orientation. Often set to vertical axis
                   // or Y axis up = (x = 0, y = 1, z = 0) by default.
                 , glm::vec3 const& up
                 );

     // --------- Usage ------------------------//

     ... ... ... ... ...

   glm::mat4 camera_View_transform = glm::lookAt(  eye_camera_current_position
                                                 , point_to_where_camera_is_looking_at
                                                 , up_vector
                                                 );

     // Get shader ID of shader's view transform uniform variable.
     const GLint u_view_transform = glGetUniformLocation(prog, "u_view_transform");

     // Set View tranform shader uniform variable
     glUniformMatrix4fv(u_view_transform, 1, GL_FALSE, glm::value_ptr(camera_View_transform) );
#+END_SRC


This function has the following algorithm:

\begin{equation}
    T_{\text{view}} =
          \begin{bmatrix}
              X_x & X_y & X_z & -\vec{X} \cdot \vec{\text{eye}}  \\
              Y_x & Y_y & Y_z & -\vec{Y} \cdot \vec{\text{eye}}  \\
              Z_x & Z_y & Z_z & -\vec{Z} \cdot \vec{\text{eye}}  \\
              0   & 0   & 0   &  1
          \end{bmatrix}

     =
          \begin{bmatrix}
              X_x & X_y & X_z & - \text{dot}(\vec{X}, \vec{\text{eye}})  \\
              Y_x & Y_y & Y_z & - \text{dot}(\vec{Y}, \vec{\text{eye}})  \\
              Z_x & Z_y & Z_z & - \text{dot}(\vec{Z}, \vec{\text{eye}})  \\
              0   & 0   & 0   &  1
          \end{bmatrix}
\end{equation}

And the unit vectors, X, Y and Z are computed in the following manner:

\begin{eqnarray*}
    \vec{Z} &=&  \frac{ \vec{eye} - \vec{at} }{\left\| \vec{eye} - \vec{at}  \right\| }
              = \frac{ -\vec{\text{forward}}  }{\left\| \vec{\text{forward}}  \right\| }  \\

    \vec{X} &=&  \frac{ \vec{up} \times \vec{Z} }{\left\| \vec{up} \times \vec{Z}  \right\| }  \\

    \vec{Y} &=&  \frac{ \vec{Z} \times \vec{X} }{\left\| \vec{Z} \times \vec{Z}  \right\| }  \\
\end{eqnarray*}

The vector $\vec{Z}$ is the opposite direction, represented by a unit
vector, to where the camera is looking at. If this vector were an
input, and was directly set by the calling code, rotating that camera
viewing direction  would require just rotating this vector.

Where:
  + $\vec{forward} = \vec{at} - \vec{eye}$ => Direction to where the camera is looking at (a.k.a pointing at).
  + INPUTS:
    + $\vec{eye}$ (Eye vector) => Camera's position in world-space coordinates.
    + $\vec{at}$  (At vector) => Point in world-space coordinate where the camera is lookin at.
    + $\vec{up}$  (Up vector) => Camera orientation, often set by default to Y axis.
  + Intermediate Outputs:
    + $\vec{X} = [X_x \quad X_y \quad X_z]$
    + $\vec{Y} = [Y_x \quad Y_y \quad Y_z]$
    + $\vec{Z} = [Z_x \quad Z_y \quad Z_z]$
  + Notation Used:
    + $\left\| \vec{vector}  \right\|$ - means the vector norm
    + $\vec{A} \times \vec{B}$ - means vector cross product
    + $\vec{A} \cdot \vec{B}$ - means vector dot product.


The previous matrix turns world-space into camera-space coordinates in
the following mode:

\begin{equation}
   \begin{bmatrix}
       x_{\text{camera}} \\ y_{\text{camera}} \\ z_{\text{camera}} \\ 1
   \end{bmatrix}

   =  T_{\text{projection}} \cdot

   \begin{bmatrix}
       x_{\text{world}} \\ y_{\text{world}} \\ z_{\text{world}} \\ 1
   \end{bmatrix}
\end{equation}

Where:

  + The right-side (4 x 1) column vector (input) is the world-space coordinate.

  + The left-side (4 x 1) column vector (ouput) is the camera-space
    coordinate.

 *Pointing camera to specific direction*

The function lookAt() points the camera view to a specific point in
the space _at_ vector in world-space coordinates. The following function
could be defined for pointing the camera at specific direction (vector
or normalized vector) instead of a point-vector.

#+BEGIN_SRC cpp
   glm::mat4
   lookAt_direction(glm::vec3 const& eye, glm::vec3 const& forward, glm::vec3 const& up  )
   {
       glm::vec3 at = eye + forward;
       return lookAt(eye, at, up);
   }
#+END_SRC

Where:

  + _eye_ - (point-verctor) Camera position in world-space coordinates
  + _forward_ - (vector) Direction to where camera is looking at.
  + _up_ (vector) Camera's orientation


 *Algorithm Validation*

Testing GLM (OpenGL Mathematic Library) in CERN's root REPL:

#+BEGIN_SRC cpp
   // -------------- Case  1 --------------------- //
   //
   auto eye = glm::vec3(3.0, 10.0, 20.0);
   auto at  = glm::vec3(50.0, 25.0, 10.0);
   auto up  = glm::vec3(0.0, 1.0, 0.0);

   root [108] auto view_matrix = glm::lookAt(eye, at, up);
   root [109]
   root [109] show_matrix("view = ", view_matrix)

    [MATRIX] view =  =
      0.208  -0.000   0.978 -20.186
     -0.291   0.955   0.062  -9.912
     -0.934  -0.298   0.199   1.808
      0.000   0.000   0.000   1.000
   root [110]

   // ------------ Case 2 --------------------------//
   auto eye = glm::vec3(50.0, -10.0, 0.0);
   auto up = glm::vec3(0.0, 1.0, 0.0);
   auto at = glm::vec3(25.0, 5.615, -200.0);
   auto view_matrix = glm::lookAt(eye, at, up);

   root [114]
   root [114] show_matrix("view = ", view_matrix)

    [MATRIX] view =  =
      0.992   0.000  -0.124 -49.614
      0.010   0.997   0.077   9.491
      0.124  -0.077   0.989  -6.956
      0.000   0.000   0.000   1.000

#+END_SRC

Implement glm::lookAt() algorithm in Julia programming language:

#+BEGIN_SRC julia
  # Return vector v normalized =>> Returns column vector
  normalize(v) = begin
     x, y, z = v
     mag = sqrt(x * x + y * y + z * z)
     [ (x / mag) (y / mag) (z / mag)]'
  end

  # Vector cross product =>> Returns column vector
  function cross(va, vb)
     x, y, z = va
     T = [ 0 -z y ; z 0 -x; -y x 0]
     return T * vb
  end

  # Vector Dot product via vector column X transpose multiplication
  dot(va, vb) = va' * vb

  # Note: The inputs must be column vectors
  function lookAt(eye, at, up)
     # The vector Z is the direction to where the camera is looking at.
     Z = normalize( eye - at      )
     X = normalize( cross(up, Z)  )
     Y = normalize( cross(Z, X )  )
     t = [ dot(eye, X)  dot(eye, Y)  dot(eye, Z) ]

     # Define identity matrix
     matrix = [ 1.0 0.0 0.0 0.0 ; 0.0 1.0 0.0 0.0 ; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]

     # Assign vector X to matrix's first row
     matrix[1, 1:3] = X
     # Assign vector Y to matrix's second row
     matrix[2, 1:3] = Y
     # Assign vector Z to matrix's third row
     matrix[3, 1:3] = Z
     # Assign forth (last) column to vector t
     matrix[1:3, 4] = -t
     return matrix
  end
#+END_SRC

Test implementation:

#+BEGIN_SRC julia
   #  --------- Test Case 1 --------------------------#
   # =================================================#
   eye = [3.0 10.0 20.0  ]'
   at  = [50.0 25.0 10.0 ]'
   up  = [0.0   1.0 0.00 ]' # Y axis

   julia> eye
   3×1 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
     3.0
    10.0
    20.0

   # Camera's view transform matrix
   julia> Tview = lookAt(eye, at, up)
   4×4 Array{Float64,2}:
    -0.208108  0.0       -0.978106   20.1864
    -0.291457  0.954572   0.062012   -9.91159
     0.933672  0.297981  -0.198654  -52.1466
     0.0       0.0        0.0         1.0

   # Camera's view transform matrix rounded with 3 decimal digits
   julia> map(x -> round(x, digits=3), Tview)
   4×4 Array{Float64,2}:
     0.208   0.0    0.978  -20.186
    -0.291   0.955  0.062   -9.912
    -0.934  -0.298  0.199    1.808
     0.0     0.0    0.0      1.0

   #  --------- Test Case 2 --------------------------#
   # =================================================#
   eye = [50.0 -10.0 0.0 ]'
   up  = [0.0 1.0 0.0 ]'
   at  = [25.0 5.615 -200.0]'

   Tview = lookAt(eye, at, up)

   julia> map(x -> round(x, digits=3), Tview)
   4×4 Array{Float64,2}:
    0.992   0.0    -0.124  -49.614
    0.01    0.997   0.077    9.491
    0.124  -0.077   0.989   -6.956
    0.0     0.0     0.0      1.0

#+END_SRC


 *References*

  + [[http://ivl.calit2.net/wiki/images/2/2c/03_CoordinateSystemsS15.pdf][CSE 167: Introduction to Computer Graphics]] - Lecture 3 - Coordinate Systems.

  + [[https://www.cs.utexas.edu/~fussell/courses/cs354/lectures/lecture11.pdf][Viewing and Modelling - CS354]]
*** Camera Projection Transform

The camera's projection transform matrix turns camera-space
coordinates into clip-space coordinates, which are normalized NDC
(Normalized-Device Coordinates). Any coordinate in the clip-space
coordinate out of the range (-1.0 to 1.0) in the three axis X, Y and Z
will not be shown at the screen, they will be clipped. It is worth
noting that some projection matrices are not affine transforms.


 *Ortographic Projection Transform* - [[https://cseweb.ucsd.edu/classes/wi18/cse167-a/lec4.pdf][(CSE167 - page 25)]] ; [[https://docs.microsoft.com/en-us/windows/win32/opengl/glortho][(Microsoft- WGL)]]

The orthographic perspective transformation preserves parallel lines
and provides no sense of depth. This type of projection is suitable
for charts, engineering drawing, engineering blueprints, CADs
(Computer Aided Design) views and so on.

  + Computed with subroutines:
    + _glm::ortho_ (xmin, xmax, ymin, ymax, zNear, zFar)  => GLM math library
    + _glm::ortho_ (left, right, bottom, top, near, far)
    + glOrtho(left, right, bottom, top, near, far) => Legacy OpenGL


\begin{equation}
   T_{\text{ortho}} =
          \begin{bmatrix}
                  \frac{ 2 }{ x_{max} - x_{min} }
               &  0
               & 0
               & -\frac{ x_{max} + x_{min} }{ x_{max} - x_{min} }
               \\

                  0
               &  \frac{ 2 }{ y_{max} - y_{min} }
               &  0
               &  -\frac{ y_{max} + y_{min} }{ y_{max} - y_{min} }
               \\

                  0
               &  0
               &  - \frac{ 2 }{ z_{far} - z_{near} }
               &  - \frac{ z_{far} + z_{near} }{ z_{far} - z_{near} }
               \\

              0 & 0 & 0 & 1
          \end{bmatrix}
\end{equation}

Where:
  + $x_{min}$ (left)
  + $x_{max}$ (right)
  + $y_{min}$ (bottom)
  + $y_{max}$ (top)
  + $z_{near}$  (near) => Distance from the camera coordinate system to the nearest clipping plane.
  + $z_{far}$  (far)   => Distance from the camera coordinate system to the farthest clipping plane.

Observations:
  + The axis Z points the opposite direction to where the camera is looking at.
  + Any coordinate outside the range ($x_{min}$, $x_{max}$), ($y_{min}$, $y_{max}$) and ($z_{far}$, $z_{near}$) will not be visible.
  + Those parameters are in the camera's coordinate system.


If a camera looking at the negative direction of Z axi is positioned
at (x = 0, y = 0, z = 0) in world-coordinate origin. The ortographic
projection for OpenGL's canonical view volume is the identity matrix.

  + $x_{min} = -1$, $x_{min} = +1$
  + $y_{min} = -1$, $z_{min} = +1$
  + $z_{near} = +1$
  + $z_{far} =  -1$

\begin{equation}
   T_{\text{ortho}} =  \text{ortho}(-1, +1, -1, +1, +1, -1)
        \\  =
          \begin{bmatrix}
                  \frac{ 2 }{ (+1) - (-1) }
               &  0
               & 0
               & -\frac{ (+1) + (-1) }{ (+1) - (-1) }
               \\

                  0
               &  \frac{ 2 }{ (+1) - (-1) }
               &  0
               &  -\frac{ (+1) +  (-1) }{ (+1) - (-1) }
               \\

                  0
               &  0
               &  - \frac{ 2 }{ -(-1) + (+1) }
               &  - \frac{ (-1) + (+1) }{ (-1) - (+1) }
               \\

              0 & 0 & 0 & 1
          \end{bmatrix}

    \\ =   \begin{bmatrix}
            1 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 0 & 0 & 1
         \end{bmatrix}
\end{equation}



  *Ortographic Projection for 2D drawing*

The ortographic projection can be used 2D drawing by setting the
coordinate Z of any vertex to zero, $z_{near} = -1$ and $z_{far} = +1$.
Then, the ortographic projection becomes:


\begin{equation}
   T_{\text{ortho2D}} =
          \begin{bmatrix}
                  \frac{ 2 }{ x_{max} - x_{min} }
               &  0
               & 0
               & -\frac{ x_{max} + x_{min} }{ x_{max} - x_{min} }
               \\

                  0
               &  \frac{ 2 }{ y_{max} - y_{min} }
               &  0
               &  -\frac{ y_{max} + y_{min} }{ y_{max} - y_{min} }
               \\

                  0  &  0  &  1 &  0    \\
                  0 & 0 & 0 & 1
          \end{bmatrix}
\end{equation}

If the transform is applied to any vertex with z = 0, the following
outcome is achieved.

\begin{equation}
   \begin{bmatrix} x' \\ y' \\ z' \\ 1 \end{bmatrix}

  =

  T_{ortho2D}

   \begin{bmatrix} x \\ y \\ z = 0 \\ w = 1 \end{bmatrix}

  =

   \begin{bmatrix}
        \frac{ 2 }{ x_{max} - x_{min} } \cdot x  -  \frac{ x_{max} + x_{min} }{ x_{max} - x_{min} }  \\
        \frac{ 2 }{ y_{max} - y_{min} } \cdot y  -  \frac{ y_{max} + y_{min} }{ y_{min} - y_{min} }  \\
         0  \\
         1  \\
   \end{bmatrix}
\end{equation}



 *Perspective projection matrix* (with FOV - Field-of-View)

  + This matrix is generated by the following subroutines:
    + _glm::perspective_ (FOV, aspect_ratio, zNear, zFar) => GLM library
    + _glPerspective_ (FOV, aspect_ratio, zNear, zFar)  => Old OpenGL.

\begin{equation}
   T_{\text{perspective}} =  \begin{bmatrix}
                 a_{11}&  0     &  0     &  0      \\
                  0    & a_{22} &  0     &  0      \\
                  0    &  0     & a_{33} &  a_{34} \\
                  0    &  0     & -1     &  0      \\
             \end{bmatrix}
\end{equation}

The matrix elements are:

\begin{eqnarray*}
   a_{11} &=& 1 / ( k \cdot \tan( \theta / 2 ) )                           \\
   a_{22} &=& 1 / \tan( \theta / 2 )                                              \\
   a_{33} &=& \frac{ \text{zN} + \text{zF} }{ \text{zN} - \text{zF} }             \\
   a_{43} &=& \frac{ 2 \cdot \text{zN} \cdot \text{zF} }{ \text{zN} - \text{zF} } \\
\end{eqnarray*}


Where:
  + k - is the window aspect ration, the ratio between the window
    width and its height. So:
    + $k = \text{width} / \text{height}$
  + $\theta$ - is the FOV (Field-Of-View angle)
  + $zN$ (zNear) - Distance to near plane.
  + $zF$ (zFar) - Distance to far plane.
  + Only camera-space coordinates within the range $zN$ to $zF$ will
    be displayed on the screen. Anything out of this range will be
    clipped.

This matrix transform coordinates in the following manner:

\begin{equation}
   \begin{bmatrix}
       x_{\text{clip}} \\ y_{\text{clip}} \\ z_{\text{clip}} \\ 1
   \end{bmatrix}

   =  T_{\text{projection}} \cdot

   \begin{bmatrix}
       x_{\text{camera}} \\ y_{\text{camera}} \\ z_{\text{camera}} \\ 1
   \end{bmatrix}
\end{equation}

Where:

  + The right-side (4 x 1) column vector (input) is the camera-space coordinate.

  + The left-side (4 x 1) column vector (ouput) is the clip-space
    coordinate. Any clip-space (NDC coordinates) coordinate out of the
    range -1.0 to 1.0 on each axis will not be displayed on the
    screen.



 *Perspective Projection Matrix* (defined from View frustum) - [[https://cseweb.ucsd.edu/classes/wi18/cse167-a/lec4.pdf][(CSE167)]],

The perspective projection matrix provides a sense of depth, objects
that are far from the camera will look like smaller and objects near
the camera will look like smaller. Note: parallel lines are not
preserved by this transform and also this transform is not affine.


  + This matrix can be computed by using subroutines:
    + _glm::frustum_ (Xmin, Xmax, Ymin, Ymax, Zmin, Zmax)
    + _glm::frustum_ (left, right, bottom, top, near, far)


\begin{equation}
   T_{\text{perspective}} =
          \begin{bmatrix}
                  \frac{ 2 \cdot z_{near} }{ x_{max} - x_{min} }
               &  0
               & \frac{ x_{max} + x_{min} }{ x_{max} - x_{min} }
               & 0
               \\

                  0
               &  \frac{ 2 \cdot z_{near} }{ y_{max} - y_{min} }
               &  \frac{ y_{max} + y_{min} }{ y_{max} - y_{min} }
               &  0
               \\

                  0
               &  0
               &  - \frac{ z_{far} + z_{near} }{ z_{far} - z_{near} }
               &  - \frac{ z_{far} \cdot z_{near} }{ z_{far} - z_{near} }
               \\

              0 & 0 & -1 & 0
          \end{bmatrix}
\end{equation}

Aspect ratio and field of view (FOV) angle:

\begin{eqnarray*}
   \text{aspect ratio} &=& \frac{x_{max} - x_{min}}{ y_{min} - y_{max} }  \\
   \tan( \text{FOV} / 2) &=& \frac{ y_{max} }{ z_{min} }
\end{eqnarray*}

Where:

  + $x_{min}$ => (left)   - Minimum X coordinate
    + Coordinate for the _left_ clipping plane.

  + $x_{max}$ => (right)  - Maximum X coordinate
    + Coordinate for the _right_ clipping plane.

  + $y_{min}$ => (bottom) - Minimum Y coordinate
    + Coordinate for the _bottom_ clipping plane.

  + $y_{max}$ => (top)    - Maximum Y coordinate
    + Coordinate for the _top_ clipping plane.

  + $z_{near}$  => (near)
    + Minimum Z coordinate - distance to the _near_ depth clipping
      plane. The $z_{near}$ value should never be zero, in this case,
      the $z_{near}$ value should as close as possible to zero.

  + $z_{far}$  => (far)
    + Maximum Z coordinate  - distance to the _far_ depth clippling plane.

Notes:
  + The camera is looking at the opposite direction of Z axis.
  + Any point in camera-space coordinate outside of the previous range
    will not be visible on the screen.
  + The parameters $z_{far}$ and $z_{near}$ must be positive.


 *Perspective and orthogonal transform matrix formula validation - in Julia Language*

Running GLM math library in CERN's Root RPL:

#+BEGIN_SRC cpp
   root [0] .I .

   #include <glm/glm.hpp>
   #include <glm/gtc/matrix_transform.hpp>
   #include <glm/gtc/type_ptr.hpp>
   #include <glm/gtx/string_cast.hpp>
   #include <glm/gtx/io.hpp>

   std::cout << std::setprecision(5);

   // Note: GLM matrices are stored in Column-major order
   void show_matrix(const char* label, glm::mat4 const& m){
       std::cout << "\n [MATRIX] " << label << " = " << '\n';
       std::cout << std::fixed << std::setprecision(5);
       for(size_t i = 0; i < 4; i++)
       {
           for(size_t j = 0; j < 4; j++)
           {
               std::cout << std::setw(10) << m[j][i];
           }
           std::cout << '\n';
       }
   }


   float xmin, xmax, ymin, ymax, zmin, zmax;

   // --------- Test Case 1 --------------------------//
   //
   root [58] xmin = 4.0, xmax = 10.0, ymin = 0.1, ymax = 25.0, zmin = 8.0, zmax = 20.0;

   root [59] glm::mat4 T = glm::frustum(xmin, xmax, ymin, ymax, zmin, zmax);

   root [60] std::cout << " T = " << T << '\n'
    T =
   [[    2.667,    0.000,    2.333,    0.000]
    [    0.000,    0.643,    1.008,    0.000]
    [    0.000,    0.000,   -2.333,  -26.667]
    [    0.000,    0.000,   -1.000,    0.000]]


   // ------- Test Case 2 ------------------------------//

   root [93] xmin = -20.0, xmax = 50.0, ymin = -10.0, ymax = 25.0, zmin = 0.1, zmax = 100.0;
   root [94]
   root [94] glm::mat4 T = glm::frustum(xmin, xmax, ymin, ymax, zmin, zmax)
   (glm::mat4 &) @0x7f73c3d5d490
   root [95]
   root [95] show_matrix("T", T)

    [MATRIX] T =
      0.00286   0.00000   0.42857   0.00000
      0.00000   0.00571   0.42857   0.00000
      0.00000   0.00000  -1.00200  -0.20020
      0.00000   0.00000  -1.00000   0.00000
   root [96]


   // ------- Test Case 3 - Ortographics Matrix  -----------//

   root [96] xmin = -20.0, xmax = 50.0, ymin = -10.0, ymax = 25.0, zmin = 0.1, zmax = 100.0;
   root [97]
   root [97] glm::mat4 T = glm::ortho(xmin, xmax, ymin, ymax, zmin, zmax)
   (glm::mat4 &) @0x7f73c3d5d4d0
   root [98]
   root [98] show_matrix("T", T)

    [MATRIX] T =
      0.02857   0.00000   0.00000  -0.42857
      0.00000   0.05714   0.00000  -0.42857
      0.00000   0.00000  -0.02002  -1.00200
      0.00000   0.00000   0.00000   1.00000

#+END_SRC

Test in Julia programming language:

#+BEGIN_SRC julia
   function frustum(xmin, xmax, ymin, ymax, zmin, zmax)
        a11 = 2 * zmin / (xmax - xmin)
        a22 = 2 * zmin / (ymax - ymin)
        a13 = (xmax + xmin) / (xmax - xmin)
        a23 = (ymax + ymin) / (ymax - ymin)
        a33 = -(zmax + zmin) / (zmax - zmin)
        a34 = -2 * zmax * zmin / (zmax - zmin)
        T = [ a11 0 a13 0 ; 0 a22 a23 0; 0 0 a33 a34; 0 0 -1 0]
        return T
    end

    function ortho(xmin, xmax, ymin, ymax, zmin, zmax)
          a11 = 2 / (xmax - xmin)
          a22 = 2 / (ymax - ymin)
          a33 = -2 / (zmax - zmin)
          a14 = -(xmax + xmin ) / (xmax - xmin)
          a24 = -(ymin + ymax) / (ymax - ymin)
          a34 = -(zmax + zmin) / (zmax - zmin)
          T = [ a11 0 0 a14; 0 a22 0 a24 ; 0 0 a33 a34; 0 0 0 1]
          return T
    end


   ## --------- Test Case 1 --------------------------##

   julia> xmin = 4.0; xmax = 10.0; ymin = 0.1; ymax = 25.0; zmin = 8.0; zmax = 20.0;

   julia> frustum(xmin, xmax, ymin, ymax, zmin, zmax)
   4×4 Array{Float64,2}:
    2.66667  0.0       2.33333    0.0
    0.0      0.64257   1.00803    0.0
    0.0      0.0      -2.33333  -26.6667
    0.0      0.0      -1.0        0.0

   ## --------- Test Case 2 --------------------------##

  julia> xmin = -20.0; xmax = 50.0; ymin = -10.0; ymax = 25.0; zmin = 0.1; zmax = 100.0;

  julia> frustum(xmin, xmax, ymin, ymax, zmin, zmax)
  4×4 Array{Float64,2}:
   0.00285714  0.0          0.428571   0.0
   0.0         0.00571429   0.428571   0.0
   0.0         0.0         -1.002     -0.2002
   0.0         0.0         -1.0        0.0

  ## -------- Test Case 3 - Ortographic Projection ---##

  julia> xmin = -20.0; xmax = 50.0; ymin = -10.0; ymax = 25.0; zmin = 0.1; zmax = 100.0;

  julia> ortho(xmin, xmax, ymin, ymax, zmin, zmax)
  4×4 Array{Float64,2}:
   0.0285714  0.0         0.0      -0.428571
   0.0        0.0571429   0.0      -0.428571
   0.0        0.0        -0.02002  -1.002
   0.0        0.0         0.0       1.0

#+END_SRC


  *References*

  + *GlFrustum - Khronos Group* (Documentation of function glFrustum())
    + https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml

  + *Projection and viewing - Computer Graphics - CSE167 - Lecture 4* [BEST]
    + https://cseweb.ucsd.edu/classes/wi18/cse167-a/lec4.pdf
    + glFrustum() - perspective transform formula located at page 20.

  + *View Frustum Clipping* - University of Texas - CS354 [BEST]
    + https://www.cs.utexas.edu/~fussell/courses/cs354-fall2015/lectures/lecture9.pdf
    + glFrustum() - formula located at page

  + *glOrtho - Khronos Grouo* (Documentation of function glOrtho())
    + https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml

  + *Ortographic Projection*
    + https://en.wikipedia.org/wiki/Orthographic_projection

  + *Computergrafik - Matthias Zwicker Universität Bern - Herbst 2016*
    + https://www.cs.umd.edu/~zwicker/courses/computergraphics/03_Projection.pdf

  + *Matrix4x4.Ortho - Unity 3D engine*
    + https://docs.unity3d.com/ScriptReference/Matrix4x4.Ortho.html

  + *Microsoft WGL Docs* - glFrustum() [BEST]
    * https://docs.microsoft.com/en-us/windows/win32/opengl/glfrustum

  + *Microsoft WGL Docs* - glOrtho() [BEST]
    * https://docs.microsoft.com/en-us/windows/win32/opengl/glortho

  + *CSE - 420 Computer Graphics* - California State University [BEST]
    * http://cse.csusb.edu/tongyu/courses/cs420/notes/viewing2.php

*** Concatenating Affine Transforms

  *Concatenating / Combinating of affine transforms*

Multiple affine transforms can be combined or concatenated as a single
affine transform, just by multiplying matrices. Considering the
following sequence of 3D affine transforms, such as:

   1. scale(3, 3, 3) - scale by 3 on all axis.
   2. translate(x = 25, y = 10, z = 20) - translate to point (25, 30, 2)
   3. rotX(30) - rotate 30 degrees around X axis
   4. rotZ(54) - rotate by 54 degrees around Z axis.

Let V = [ x y z 1 ]' to be (4 x 1 - 4 rows and 1 column) a column
vector containing the current vertice homogeneous coordinates.

Those transforms can be combined in the following way:

  + Node: the symbol (·) means multiplication.

#+BEGIN_SRC js
    // Where:
    //  =>  scale(3, 3, 3) is the scaling affine transform matrix.
    //  =>  Va is the vertex coordinate after applying the scale transform.
    //
    Va = scale(3, 3, 3) · V

    // Where:
    // => translate(25, 10, 20) is the translation affine transfom matrix.
    // => Vb is the result, vertex coodinate after the transform was applied.
    Vb = translate(25, 10, 20)  · Va

    Vc = rotX(30) · Vb
    Vd = rotZ(54) · Vc

    // V' (V - prime) - overall transformation result (end result)
    V' = Vd
#+END_SRC

By performing algebraics substitution, the overall transform result
becomes:

#+BEGIN_SRC text
   STEP 1:
    Vb = translate(25, 10, 20) · Va
    Vb = translate(25, 10, 20) · ( scale(3, 3, 3) · V )

   STEP 2:
     Vc = rotX(30) · Vb
     Vc = rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) )

   STEP 3:
     Vd = rotZ(54) · vc
     Vd = rotZ(54) · ( rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) ) )

   STEP 4:  - End result
     V' = Vd
     V' = rotZ(54) · ( rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) ) )
#+END_SRC

The final vertex position can be stated as:

#+BEGIN_SRC text
     V' = rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3) · V

  OR:

     V' =  [ rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3) ] · V
#+END_SRC

All the sequence of transformations can be combined as a single
transform, designated by T, which is the multiplication between all
transforms in reverse order that they were applied. The last transform
is multiplied first and first transform is multiplied last. In the
same that matrix multiplication is not commutative, the operation
result depends on the order that of matrices, transform combinations
are not commutative, they also depends on the order that transforms
were applied.

#+BEGIN_SRC text
  V' = T · V

  Where:
     T =  rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3)
#+END_SRC

Multiple transforms can be combined as:

#+BEGIN_SRC text
    Tranform_combined = Transform_N · Transform_N-1 · ... · Transform_2 · Transform_1
#+END_SRC


  *Combining 2D canonical transforms in Sympy - Python CAS*

Sympy - Python CAS (Computer Algebra System) can be used for debugging
and testing affine transforms in a symbolic way.

Define 2D canonical affine transforms:

#+BEGIN_SRC python
   from sympy import *

   x,  y  = symbols("x y")
   dx, dy = symbols("dx dy")
   sx, sy = symbols("sx sy")
   t      = symbols("t")  # t represents the rotation angle theta (θ)


   # Column vector representing - generic Vertex (aka point) in homogeneous coordinate
   #
   v = Matrix([x, y, 1])

   >>> pprint(v)
   ⎡x⎤
   ⎢ ⎥
   ⎢y⎥
   ⎢ ⎥
   ⎣1⎦

   # Translation of (dx, dy) coordinate transform
   >>> Translate = Matrix([[1, 0, dx], [0, 1, dy], [0, 0, 1]])

   >>> pprint(Translate)
   ⎡1  0  dx⎤
   ⎢        ⎥
   ⎢0  1  dy⎥
   ⎢        ⎥
   ⎣0  0  1 ⎦


   # Scale affine transform
   >>> Scale = Matrix([[sx, 0, 0], [0, sy, 0], [0, 0, 1]])

   >>> pprint(Scale)
   ⎡sx  0   0⎤
   ⎢         ⎥
   ⎢0   sy  0⎥
   ⎢         ⎥
   ⎣0   0   1⎦


   # Rotation around Z axis
   >>> RotZ  = Matrix([[ cos(t), -sin(t), 0], [ sin(t), cos(t), 0], [0, 0, 1]])

   >>> pprint( RotZ )
   ⎡cos(t)  -sin(t)  0⎤
   ⎢                  ⎥
   ⎢sin(t)  cos(t)   0⎥
   ⎢                  ⎥
   ⎣  0        0     1⎦

#+END_SRC

Apply single transforms to vertex *v*.

#+BEGIN_SRC python
  # Apply translation affine transform to vertex V
  #-------------------------------------------
  >>> pprint( Translate * v )
  ⎡dx + x⎤
  ⎢      ⎥
  ⎢dy + y⎥
  ⎢      ⎥
  ⎣  1   ⎦

  # Apply scale to vertex v
  #-------------------------------------------

  >>> Scale * v
  Matrix([
  [sx*x],
  [sy*y],
  [   1]])

  >>> pprint( Scale * v )
  ⎡sx⋅x⎤
  ⎢    ⎥
  ⎢sy⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦

  >>> pprint( (Scale * v).subs({sx: 10, sy: 10}) )
  ⎡10⋅x⎤
  ⎢    ⎥
  ⎢10⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦


  >>> pprint( (Scale * v).subs({sx: 10, sy: 20}) )
  ⎡10⋅x⎤
  ⎢    ⎥
  ⎢20⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦


  # Apply rotation to vertex v
  #------------------------------

  >>> v_rot = RotZ * v

  >>> pprint( v_rot )
  ⎡x⋅cos(t) - y⋅sin(t)⎤
  ⎢                   ⎥
  ⎢x⋅sin(t) + y⋅cos(t)⎥
  ⎢                   ⎥
  ⎣         1         ⎦

  >>> pprint( v_rot.subs(t, 0) )
  ⎡x⎤
  ⎢ ⎥
  ⎢y⎥
  ⎢ ⎥
  ⎣1⎦

  # Rotate by 90 degrees (pi / 2 radians)
  >>> pprint( v_rot.subs(t, pi / 2) )
  ⎡-y⎤
  ⎢  ⎥
  ⎢x ⎥
  ⎢  ⎥
  ⎣1 ⎦

  # Rotate by 60 degreees (pi / 3)
  >>> pprint( v_rot.subs(t, pi / 3) )
  ⎡x   √3⋅y⎤
  ⎢─ - ────⎥
  ⎢2    2  ⎥
  ⎢        ⎥
  ⎢√3⋅x   y⎥
  ⎢──── + ─⎥
  ⎢ 2     2⎥
  ⎢        ⎥
  ⎣   1    ⎦
#+END_SRC

Combine 2 tranforms in multiple orders and check the outcome.

#+BEGIN_SRC python
  # Combine transforms: 1st - translation; 2nd - scale.
  #--------------------------------------------------

    >>> T = Scale * Translate

    >>> pprint(T)
    ⎡sx  0   dx⋅sx⎤
    ⎢             ⎥
    ⎢0   sy  dy⋅sy⎥
    ⎢             ⎥
    ⎣0   0     1  ⎦


    # Apply to vertex
    >>> pprint( T * v )
    ⎡dx⋅sx + sx⋅x⎤
    ⎢            ⎥
    ⎢dy⋅sy + sy⋅y⎥
    ⎢            ⎥
    ⎣     1      ⎦


  # Combine transforms: 1st - scale; 2nd - translation.
  #--------------------------------------------------

     >>> T = Translate * Scale

     >>> pprint( T )
     ⎡sx  0   dx⎤
     ⎢          ⎥
     ⎢0   sy  dy⎥
     ⎢          ⎥
     ⎣0   0   1 ⎦

     # Apply to vertex
     >>> pprint(T * v)
     ⎡dx + sx⋅x⎤
     ⎢         ⎥
     ⎢dy + sy⋅y⎥
     ⎢         ⎥
     ⎣    1    ⎦


  # Combine transforms: 1st - rotation; 2nd - translation.
  #--------------------------------------------------

     >>> T = Translate * RotZ

     >>> pprint( T )
     ⎡cos(t)  -sin(t)  dx⎤
     ⎢                   ⎥
     ⎢sin(t)  cos(t)   dy⎥
     ⎢                   ⎥
     ⎣  0        0     1 ⎦


     # Apply to vertex
     >>> pprint( T * v )
     ⎡dx + x⋅cos(t) - y⋅sin(t)⎤
     ⎢                        ⎥
     ⎢dy + x⋅sin(t) + y⋅cos(t)⎥
     ⎢                        ⎥
     ⎣           1            ⎦

  # Combine transforms: 1st - translation ; 2nd - rotation
  #------------------------------------------------------

     >>> T = RotZ * Translate

     >>> pprint( T )
     ⎡cos(t)  -sin(t)  dx⋅cos(t) - dy⋅sin(t)⎤
     ⎢                                      ⎥
     ⎢sin(t)  cos(t)   dx⋅sin(t) + dy⋅cos(t)⎥
     ⎢                                      ⎥
     ⎣  0        0               1          ⎦


     # Apply to vertex
     >>> pprint( T * v )
     ⎡dx⋅cos(t) - dy⋅sin(t) + x⋅cos(t) - y⋅sin(t)⎤
     ⎢                                           ⎥
     ⎢dx⋅sin(t) + dy⋅cos(t) + x⋅sin(t) + y⋅cos(t)⎥
     ⎢                                           ⎥
     ⎣                     1                     ⎦


#+END_SRC

Combine transforms in the following order: 1st - rotation; 2nd -
scaling; 3rd - translation:

#+BEGIN_SRC python
   >>> T = Translate * Scale * RotZ

   >>> pprint( T )
   ⎡sx⋅cos(t)  -sx⋅sin(t)  dx⎤
   ⎢                         ⎥
   ⎢sy⋅sin(t)  sy⋅cos(t)   dy⎥
   ⎢                         ⎥
   ⎣    0          0       1 ⎦

   >>> pprint( T * v )
   ⎡dx + sx⋅x⋅cos(t) - sx⋅y⋅sin(t)⎤
   ⎢                              ⎥
   ⎢dy + sy⋅x⋅sin(t) + sy⋅y⋅cos(t)⎥
   ⎢                              ⎥
   ⎣              1               ⎦
#+END_SRC
*** 3D Scene Transforms  

In a 3D scene, the following typical transformations happens to the
vertex coordinates of some object to be rendered. The model matrix
transform, $T_m$, converts the object vertex coordinates from the
local-space (a.k.a object-space) to world-space, then the view-matrix,
$T_v$, converts vertex world-space coordinates to the camera-space,
finally the projection matrix transform, $T_p$, turns the camera-space
coordinates into clip-space coordinates (NDC - Normalized Device
Coordinates) within the range -1.0 to 1.0 on each axis. Any NDC
coordinate out of the range -1.0 to 1.0 will not be visible on the
canvas, graphics window screen. 


#+BEGIN_SRC tex                                                       Eye
                +---------+              +---------+ Space      +---------------+  Clip-Space
    Local       |         |  World       |         |  Camera    |               |  (NDC - Coordinates)
   Space        |   Model |  Space       |  View   |  Space     |  Projection   | 
      +------->>+  Matrix +------>>----->+ Matrix  +---------->>+   Matrix      +------->>>
    V           |         |   Vw         |         |   Vc       |               |  Vndc
                | Tm      |              |  Tv     |            |    Tp         |
                +---------+              +---------+            +---------------+


      Tm - (4x4) Model matrix transform 
      Tv - (4x4) View matrix transform 
      Tp - (4x4) Projection matrix transform. 

      V    - Vertex coordinate in local space 
      Vw   - Vertex coordinate in world-space
      Vc   - Vertex coordinate in camera-space coordinate (a.k.a eye-space)
      Vndc - Vertex coordinate in clip-space coordinate (NDC)
#+END_SRC


  + Transform from local-space coordinates to world-space coordinates
    + Where:
      + $T_m$ - is the _model-matrix_, often comprised of rotation,
        scaling and translation concatened canonical transforms. 
      + v - Vertex coordinate in local-space.
        + $v = \begin{bmatrix} x & y & z & 1 \end{bmatrix}^T$ 
      + $v_w$ - Vertex coordinate in world-space
        + $v_w = \begin{bmatrix} x_w & y_w & z_w & 1 \end{bmatrix}^T$

\begin{equation} 
   v_w = T_m \cdot v
\end{equation}


  + Transform from world-space coordinates to camera-space coordinates
    (a.k.a eye space).
    + $T_v$ - is the _view matrix_, computed using the eye vector,
      camera position; up vector - camera orientation; at
      point-vector, point which the camera is looking at.

\begin{equation}
  v_c = T_v \cdot v_w 
\end{equation}

  + Transform from camera-space to clip-space coordinates.
    + Where:
      + $T_p$ - is the _projection matrix_ which can be either the
        _perspective_ projection matrix or _ortographic_ projection
        matrix.
      + $v_{\text{ndc}}$ - is the vertex NDC coordinate. 

\begin{equation}
  v_{\text{ndc}} = T_p \cdot v_c 
\end{equation}

  + Overall scene transform from local-space to clip-space
    coordinates. 

\begin{equation}
  v_{\text{ndc}} = \left( T_p \cdot T_v \cdot T_m \right) v
\end{equation}


 + MVP transform - The overall transform is often designated as
   Model-View-Projection transform ( $T_{mvp}$ ).

\begin{eqnarray*}
   v_{\text{ndc}} &=&  T_{mvp} \cdot v \\
   T_{mvp}        &=&  T_p \cdot T_v \cdot T_m 
\end{eqnarray*}

\begin{equation}
     T_{\text{ModelViewProjection}} =T_{\text{Projection}} \cdot T_{\text{View}} \cdot T_{\text{Model}}
\end{equation}
  
 + The _Model-View transform_ is the product between the model and view
    transforms.

\begin{eqnarray*}
   T_{mv}                    &=& T_v \cdot T_m  \\
   T_{\text{ModelView}} &=& T_{\text{View}} \cdot T_{\text{Model}}
\end{eqnarray*}


  + _Normal transform matrix_ ( $T_{normal}$ ) is computed as the
    transpose of model-view matrix inverse. This matrix transform
    vertex _normal_ vector in the local-space coordinates to
    camera-space coordinates. This transform matrix is used for
    illumination calculations, such as Phong illumination model.
    + Where:
      + n - is the normal vector in local-space coordinates.
        + $n = \begin{bmatrix} x_n & y_n & z_n & 0 \end{bmatrix}^T$
      + $n_c$ is the normal vector in camera-space (eye-space) coordinates. 

\begin{equation}
   T_{normal} = \left[ T_{\text{ModelView}}^{-1}  \right]^T = \left[ ( T_{\text{View}} \cdot T_{\text{Model}}  )^{-1}  \right]^T
\end{equation} 

\begin{equation}
   n_c = T_{normal} \cdot n 
\end{equation} 

  *References* 

    + Chapter 8 - OpenGL – A 3D Graphics API 8.1 - Pipeline architecture
      + <https://people.cs.clemson.edu/~dhouse/courses/817/notes/OpenGL-pipeline.pdf>

    + CS315 Lab 3: 3D Transformations
      + <https://www.cs.uregina.ca/Links/class-info/315/WebGL2/Lab3/>

    + Appendix F - Homogeneous Coordinates and Transformation Matrices
      / OpenGL Programming Guide
      + <https://www.glprogramming.com/red/appendixf.html>

    + GLSL Programming/Vertex Transformations - Wikibooks
      + <https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations>

    + OpenGL Normal Vector Transformation - Song ho Ahn
      + <http://www.songho.ca/opengl/gl_normaltransform.html>

    + The normal matrix - Light House 3D
      + <https://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/>

    + Normal Vector Transform
      + <https://www.cs.upc.edu/~robert/teaching/idi/normalsOpenGL.pdf>
*** 2D Scene Transforms  

A 2D scene can be generated as particular case of a 3D scene by
setting the vertex  Z coordinate to always zero, replacing the view
transform matrix with identity matrix and setting the projection matrix
as the ortographic projection matrix. This approach only works if the
graphics API default coordinate system is the same as the OpenGL one,
where the Y and X axis are on the screen and the Z axis positive
direction goes from the screen towards the viewer (computer user).

\begin{equation}
  v_{\text{ndc}} = \left( T_p \cdot T_v \cdot T_m \right) v
\end{equation}

By following the previous approach for a 2D scene, the vertex
transformation becomes: 

\begin{equation}
  v_{\text{ndc}} = \left( T_{\text{ortographic}} \cdot T_{\text{model}} \right)  
                     \begin{bmatrix} x \\ y \\ 0 \\ 1 \end{bmatrix}
\end{equation}

The model matrix is a combination of translation affine transforms
with z set as zero, scaling affine transforms with Z set as zero and
rotations around Z axis. 

Some matrices that can be used for building the model matrix are: 

  + 2D translation 

\begin{equation}
   T_{\text{translation-2D}} = 
   \begin{bmatrix}
     1   & 0   &  0 &  \Delta_x \\
     0   & 1   &  0 &  \Delta_y \\
     0   & 0   &  1 &   0       \\
     0   & 0   &  0 &   1       \\
   \end{bmatrix}
\end{equation}

  + 2D scaling 

\begin{equation}
  T_{\text{scaling-2D}} =
   \begin{bmatrix}
     s_x   & 0     &  0   &  0 \\
     0     & s_y   &  0   &  0 \\
     0     & 0     &  0   &  0 \\
     0     & 0     &  0   &  1  \\
   \end{bmatrix}
\end{equation}

  + 2D rotation (rotation around Z axis)

\begin{equation}
   T_{\text{rotation-2D}} =
     \begin{bmatrix}
        \cos{\theta}  & -\sin{\theta} &  0 & 0 \\
        \sin{\theta}  &  \cos{\theta} &  0 & 0 \\
       0              & 0             &  1 & 0 \\
       0              & 0             &  0 & 1 \\
     \end{bmatrix}
\end{equation}

*** Quaternions

Quaternions are a generalization of complex numbers, that was proposed
and formulated by the irish mathematician and physicist William Rowan
[[https://en.wikipedia.org/wiki/William_Rowan_Hamilton][Hamilton]], in 1843. This mathematical construct provides a convenient
notation for expressing rotation and has a broad range of
applications, including computer graphics, computer vision, robotics,
orbital mechanics, aerospace and flight dynamics.

A quaternion *q* is defined as:

  + Where:
    + w, x, y, z are real numbers.
    + w => is the quaternion's real (scalar) component.
    + [x, y, z] => is the quaternion's vector componet
    + i, j, k are unit vectors (basis elements) that satisfies a set
      of properties.

\begin{equation}
   q = w + x \cdot i + y \cdot j + z \cdot k
\end{equation}

The quaternion *q* can be represented as:

   + Where:
     + $\vec{v} = [x, y, z]$ is the quaternion vector component.

\begin{align*}
    q &= [w, x, y, z]  \quad & \text{Tuple representation}         \\
    q &= (u, \vec{v})  \quad & \text{Scalar/vector representation} \\
\end{align*}


The quaternion unit vectors or basis elements satifies the following
properties:

\begin{equation}
   i^1 = j^2 = k^2 = i \cdot j \cdot k = -1
\end{equation}

And also:

\begin{align*}
    i \cdot j = k  & \quad & j \cdot i =  k  \\
    j \cdot k = i  & \quad & k \cdot j = -i  \\
    k \cdot i = j  & \quad & i \cdot k = -j  \\
\end{align*}


 *Types of Quaternion*

 + Real quaternion

Real quaternion, is a quaterion which all elements of vector
components are zero.

\begin{equation}
   q = w + 0 \cdot i + 0 \cdot j + 0 \cdot k
\end{equation}

 + Pure quaternion

A pure quaternion, has the real part equal to zero. It can represent a
vector in the space.

\begin{equation}
  q = 0 + x \cdot i + y \cdot j + z \cdot k
\end{equation}

 + Unit quaternion

A quaternion which the norm or magnitude is equal to one.

\begin{equation}
  || q || = 1
\end{equation}

 + Identity quaternion

An identity quaternion when multiplied by another quaternion results
in no rotation.

\begin{equation}
   q_i = 1 + 0 \cdot i + 0 \cdot j + 0 \cdot k
\end{equation}

In similar way to identity matrices, the following is valid:

\begin{equation}
  q_i \cdot q_a = q_a \cdot q_i = q_a
\end{equation}

 *Quaternion Conjugate*

The conjugate of a quaternion, $q^*$, is defined as:

\begin{equation}
  q^{*} = w - \vec{v}
        = w - (x \cdot i + y \cdot j + z \cdot k)
        = w + (-x) i + (-y) j + (-z) k
\end{equation}

 *Inverse Quaternion* $q^{-1}$

\begin{equation}
  q^{-1} = \frac{q^{*}}{ || q ||^2 }
\end{equation}

The inverse quaternion satifies the following equality:

\begin{equation}
  q^{-1} \cdot q = q \cdot q^{-1} = 1
\end{equation}

 *Quaternion Norm*

The norm (magnitude) of a quaternion is given by:

\begin{equation}
   || q ||^2 = q \cdot q^{*} =  w^2 + x^2 + y^2 + z^2
\end{equation}

 *Unit quaternion*

An unit quaternion $q_u$ has norm equal to one.

\begin{equation}
   || q_u || = 1
\end{equation}

An unit quaternion is equal to its conjugate:

\begin{equation}
   q^* = q^{-1}
\end{equation}

 *Quaternion Dot Product*

A quaternion dot product is similar to vector dot product. The
quaternion dot product between two quaternions q1 and q2 is defined as
the sum of the product between the quaternions components.

\begin{equation}
   \text{dotquat}(q_1, q_2) = q_1 \cdot q_2 = w_1 \cdot w_2 + x_1 \cdot x_2 + y_1 \cdot y_2 + z_1 \cdot z_2
\end{equation}

 *Angle between two quaternion*

The angle between two quaternions q1 and q2 is defined as:

\begin{equation}
    \cos \theta = \frac{ q_1 \cdot q_2 }{ || q_1 || \cdot || q_2 ||  }
                = \frac{ \text{dotquat}(q_1, q_2) }{ \text{norm}( q_1) \cdot \text{norm}(q_2)  }
                = \frac{  w_1 \cdot w_2 + x_1 \cdot x_2 + y_1 \cdot y_2 + z_1 \cdot z_2  }{  || q_1 || \cdot || q_2 ||  }
\end{equation}

 *Quaternion Sum*

The sum of two quaternions q1 and q2 is:

\begin{equation}
   q_1 + q_2 = (w_1 + w_2) + (x_1 + x_2) i + (y_1 + y_2)j + (z_1 + z_2) k
\end{equation}

 *Quaternion Product* (a.k.a Hamilton Product)

The product *p* of two quaternons q1 and q2 can be computed as:

  + Where:
    + p is the quaternion product between q1 and q2
    + $\vec{v_1} \cdot \vec{v_2}$ is the scalar product between $\vec{v_1}$ and $\vec{v_2}$.
    + $\vec{v1} \times \vec{v_2}$ is the cross product between  $\vec{v_1}$ and $\vec{v_2}$.
    + $p_v$ is the vector component of p
    + $p_w$ is the scalar/real component of p.

\begin{align*}
  p &= q_1 \cdot q_2 = ( w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2} \quad ; \quad
                       w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} )  \\

    &= ( w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2} )  +
                      ( w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} )
\end{align*}

The components of vector p are:

\begin{align*}
    p_w &= w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2}                             \\
    p_v &= w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} \\
\end{align*}

The quaternion product is non commuative, as a result, the following
holds:

\begin{equation}
      q_1 \cdot q_2 \neq q_2 \cdot q_2
\end{equation}

The quaternion product satifies the following properties:

\begin{align*}
    || q_1 \cdot q_2 ||  &= ||q_1|| \cdot || q_2 ||   \\
     (q_1 \cdot q_2)^* &= q_2^* \cdot q_1^*
\end{align*}

  *Quaternion product between pure quaternions*

The product between two pure quaternions yields the dot product and
cross simultaneously, the dot product as the real part of the
operation result and cross product as the vector part of the result.

\begin{equation}
    p \cdot q = - (p \cdot q) + (p \times q)
\end{equation}

Where:
  + Note: A pure quaternion, is the same as space vector, the real
    part is zero, w = 0.
  + $p = 0 + x_p \cdot i + y_p \cdot j + z_p \cdot k$
  + $q = 0 + x_q \cdot i + y_q \cdot j + z_q \cdot k$
  + $p \cdot q$ is the dot product between the vector parts of p and q.
  + $p \times q$ is the cross product (vector product) between p and q.


  *Quaternion division* ([[http://www.math.umd.edu/~immortal/MATH431/lecturenotes/ch_quaternions.pdf][MATH432]] - page 11)

The division between two quaternions q1 and q2 is defined as:

\begin{equation}
   \frac{q_1}{q_2} = \frac{q_1 \cdot q_2^* }{ || q_2 ||^2 } = \frac{1}{ || q_2 ||^2 } ( q_1 \cdot q_2^* )
\end{equation}

  *Quaternion product using matrices representation*

The product of two quaternions q1 and q2 can be computed
in a more convenient and faster way by using matrices and column
vectors multiplication, instead of dot product and cross product.

Let $[q]_v$ be the vector column representation of a quaternion:

\begin{equation}
  [q]_v = \begin{bmatrix} w \\ x \\ y \\ z  \end{bmatrix}
\end{equation}

Let $[q]_m$ be the following matrix representation of a quaternion:

\begin{equation}
  [q]_m = \begin{bmatrix}
               w  & -x & -y & -z  \\
               x  &  w & -z &  y  \\
               y  &  z &  w & -x  \\
               z  & -y &  x &  w  \\
          \end{bmatrix}
\end{equation}

The quaternion product between q1 and q2, designated by $[q_r]_v$, can
be expressed as a matrix-column vector multiplication, which is best
suitable for a computer implementation.

\begin{equation}
  [q_r]_v = q_1 \cdot q_2 = [q_1]_m \cdot [q_2]_v
          =
          \begin{bmatrix}
               w_1  & -x_1 & -y_1 & -z_1  \\
               x_1  &  w_1 & -z_1 &  y_1  \\
               y_1  &  z_1 &  w_1 & -x_1  \\
               z_1  & -y_1 &  x_1 &  w_1  \\
          \end{bmatrix}

          \begin{bmatrix}
              w_2 \\ x_2 \\ y_2 \\ z_2 \\
          \end{bmatrix}
\end{equation}

By performing the previous matrix multiplication, the quaternion
product becomes:

\begin{equation}
     [q_r]_v = q_1 \cdot q_2 =
       \begin{bmatrix}
            w_1 \cdot w_2 - x_1 \cdot x_2 - y_1 \cdot y_2 - z_1 \cdot z_2  \\
            w_1 \cdot x_2 + w_2 \cdot x_1 + y_1 \cdot z_2 - y_2 \cdot z_1  \\
            w_1 \cdot y_2 + w_2 \cdot y_1 - x_1 \cdot z_2 + x_2 \cdot z_1  \\
            w_1 \cdot z_2 + w_2 \cdot z_1 + x_1 \cdot y_2 - x_2 \cdot y_1  \\
       \end{bmatrix}
\end{equation}


  *Rotation Quaternion*

A rotation around an axis $\hat{n}$ (unit vector) by angle $\theta$
can be encoded by quaternion $q_r$:

\begin{equation}
   q_r = \cos \frac{\theta}{2}  + \sin \frac{\theta}{2} \cdot \hat{n}
       = \cos \frac{\theta}{2}  + \sin \frac{\theta}{2} ( x_n \cdot i + y_n \cdot j + z_n \cdot k  )
\end{equation}

 + Where:
   + $\hat{n}$ is a unit vector.
   + $\hat{n} = x_n \cdot i + y_n \cdot j + z_n \cdot k$
   + $|| \hat{n} || = 1$

The norm of quaternion $q_r = 1$, thus the following holds:

\begin{equation}
  || q_r || = 1
\end{equation}

The coordinate transformation from a vector in reference frame A to a
reference frame B, obtained by the rotation of coordinate frame A
around a unit vector $\hat{n}$ can be computed as:

\begin{equation}
   q_B = q_r \cdot q_A \cdot q_r^{-1}
       = q_r \cdot q_A \cdot q_r^{*}
\end{equation}

Where:
  + $q_A$ is the coordinate of a vector in the reference frame A (aka
    coordinate system, aka coordinate frame).
  + $q_B$ is the coordinate of a the same vector in the reference frame B.
  + $q_A = 0 + x_A \cdot i + y_A \cdot j + z_A \cdot k$
  + $q_B = 0 + x_B \cdot i + y_B \cdot j + z_B \cdot k$


The previous rotation coordinate transformation can be determined in a
more efficient way by applying the following algorithm. [[https://fgiesen.wordpress.com/2019/02/09/rotating-a-single-vector-using-a-quaternion/][(The-Ryg-Blog)]]


\begin{eqnarray*}
   v_t &=& 2 ( v_r \times v_a)                    \\
   q_B &=&  v_A + w_r \cdot v_t + v_r \times v_t
\end{eqnarray*}

Where:
  + $[ Q ]_w$ - real part of a quaternion Q
  + $[ Q ]_v$ - vector part of a quaterion Q
  + $w_r = \cos ( \theta / 2)$ - real part of rotation quaternion $q_r$
  + $v_r = \hat{n} \cdot \sin( \theta / 2 )$ - vector part of rotation quaternion $q_r$
  + $v_B$ - vector part of quaternion $q_B$
  + $v_A$ - Vector part of quaternion $q_A$
  + $v_r \times v_a$ - Cross product between those two vectors.


  *Determining rotation and axis from a normalized quaternion*

Supposing that the components (w, x, y, z) of normalized quaternion *q*
are known. The represented rotation angle, $\theta$ and rotation axis
(a.k.a orientation) vector, $\hat{n} = [x_n \quad y_n \quad z_n]$, can
be determined in the following way.

Rotation quaternion (known: x, y, z, w)

\begin{eqnarray*}
  q  &=& w + x \cdot i + y \cdot j + z \cdot k  \\
     &=& \cos \frac{\theta}{2} + \sin \frac{\theta}{2}  \hat{n} \\
     &=& \cos \frac{\theta}{2} + \sin \frac{\theta}{2} (x_n \cdot i + y_n \cdot j + z_n \cdot k) \\
\end{eqnarray*}

Rotation angle $\theta$

\begin{equation}
  \theta  = 2 \text{atan2}( || \vec{v} ||, w  ) = 2 \text{atan2}( \sqrt{x^2 + y^2 + z^2} , w  )
\end{equation}

Rotation axis: $\hat{n} = x_n \cdot i + y_n \cdot j + z_n \cdot k$

\begin{eqnarray*}
   x_n &=& x / \sqrt{1 - w^2} \\
   y_n &=& y / \sqrt{1 - w^2} \\
   z_n &=& z / \sqrt{1 - w^2} \\
\end{eqnarray*}

Where:

  + [[https://en.wikipedia.org/wiki/Atan2][Atan2]](Y, X) is the 2-argument tangent function which determines
    the angle quadrant.

  + $q = w + x \cdot i + y \cdot j + z \cdot k$ - is a unitary
    quaternion, which components x, y and z are assumed to be
    known. The quaternion *q* is presumed to be normalized.

  + $\theta$ is the rotation angle. Assumed to be unknown.

  + $\hat{n}$ - is the rotation axis vector. Also assumed to be
    unknown, which components are $x_n$, $y_n$ and $z_n$.
    * $\hat{n} = 0 + x_n \cdot i + y_n + \cdot j + z_n \cdot k$



  *Quaternion to rotation matrix conversion*

The rotation matrix that transforms coordinates from reference frame A
to reference frame B can be computed as:  [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Moti Ben-Ari - Wizmann)]], [[http://barbic.usc.edu/cs520-s12/quaternions/quaternions-cs520.pdf][(Jernej Barbic)]]

\begin{equation}
   R_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)  \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2
          &  2 ( c \cdot d -  a \cdot b ) \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2     \\

         \end{bmatrix}
\end{equation}

Where:
  + a, b, c, d are the components of the unit quaternion $q_r$
  + $a = \cos( \theta / 2)$
  + $b = x_n \cdot \sin (\theta / 2)$
  + $c = y_n \cdot \sin (\theta / 2)$
  + $d = z_n \cdot \sin (\theta / 2)$

The matrix $R_n$ can also be simplified to: [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Moti Ben-Ari - Wizmann)]]

\begin{equation}
   R_n = 2 \begin{bmatrix}
              a^2 + b^2 - 1/2  &
              b \cdot c - a \cdot d  &
              a \cdot c + b \cdot d  \\

              a \cdot d + b \cdot c  &
              a^2  + c^2 - 1/2 &
              c \cdot d - a \cdot b  \\

              b \cdot d - a \cdot c &
              a \cdot b + c \cdot d &
              a^2 + d^2 - 1/2 \\

          \end{bmatrix}
\end{equation}

Coordinates from frame A can be turned into coordinates from frame B
by performing the following  matrix multiplication.

\begin{equation}
    \begin{bmatrix} x_B \\ y_B \\ z_B \end{bmatrix}
    = R_n  \begin{bmatrix} x_A \\ y_A \\ z_A \end{bmatrix}
\end{equation}


From the previous matrix $R_n$ it is possible to determine the
yaw-pitch-roll (Z-X-Y) Euler's angles. [[http://www.chrobotics.com/library/understanding-quaternions][(chrobotics)]]

\begin{eqnarray*}
    \phi   &=&  \arctan\left( \frac{ 2 a \cdot b + 2 c \cdot d } { a^2 - b^2 - c^2 + d^2 } \right )  \\
    \theta &=& -\arcsin\left( 2 b \cdot d - 2 a \cdot c  \right )                                    \\
    \psi   &=&  \arctan\left( \frac{ 2 a \cdot d + 2 b \cdot c}{ a^2 + b^2 - c^2 - d^2 } \right )    \\
\end{eqnarray*}

Where:
  + $\phi$   - is the yaw angle
  + $\theta$ - is the pitch angle
  + $\psi$   -is the roll angle


  *Quaternion to homogeneous coordinate rotation matrix*

The matrix $R_n$ can be converted to a homogenous coordinate form,
$T_n$, which is more convenient, since homogenous coordinate allows
expressing translations in a similar fashion to rotation
transformations, just as vector-matrix multiplication.


\begin{equation}
   T_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)
          &  0                            \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2
          &  2 ( c \cdot d -  a \cdot b )
          &  0                            \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2
          &  0                            \\

             0 & 0 & 0 & 1 \\
         \end{bmatrix}
\end{equation}


\begin{equation}
   T_n = 2 \begin{bmatrix}
              a^2 + b^2 - 1/2  &
              b \cdot c - a \cdot d  &
              a \cdot c + b \cdot d  &
              0                      \\

              a \cdot d + b \cdot c  &
              a^2  + c^2 - 1/2       &
              c \cdot d - a \cdot b  &
              0                     \\

              b \cdot d - a \cdot c &
              a \cdot b + c \cdot d &
              a^2 + d^2 - 1/2       &
              0                     \\

              0 & 0 & 0 & 1 \\

          \end{bmatrix}
\end{equation}

Homogeneous coordinates from frame A can be turned into coordinates of
frame B by using the following expression:

\begin{equation}
    \begin{bmatrix} x_B \\ y_B \\ z_B \\ 1 \end{bmatrix}
    = T_n  \begin{bmatrix} x_A \\ y_A \\ z_A \\ 1 \end{bmatrix}
\end{equation}


  *Table with Useful Normalized Quaternions (Rotation Quaternions)* - [[http://wiki.ogre3d.org/Quaternion+and+Rotation+Primer][(Ogre3D Game Engine)]]

|--------------+---------------+---------------+---------------+---+----------------------------------------------|
| w            |             x |             y |             z |   | Description                                  |
|--------------+---------------+---------------+---------------+---+----------------------------------------------|
| 1            |             0 |             0 |             0 |   | Identity quaternion, represents no rotation. |
| 0            |             1 |             0 |             0 |   | 180°  (π radians) rotation around X axis     |
| 0            |             0 |             1 |             0 |   | 180° rotation around Y axis                  |
| 0            |             0 |             0 |             1 |   | 180° rotation around Z axis.                 |
|              |               |               |               |   |                                              |
| $\sqrt{1/2}$ |  $\sqrt{1/2}$ |             0 |             0 |   | 90° rotation around X axis.                  |
| $\sqrt{1/2}$ |             0 |  $\sqrt{1/2}$ |             0 |   | 90° rotation around Y axis.                  |
| $\sqrt{1/2}$ |             0 |             0 |  $\sqrt{1/2}$ |   | 90° rotation around Z axis.                  |
|              |               |               |               |   |                                              |
| $\sqrt{1/2}$ | $-\sqrt{1/2}$ |             0 |             0 |   | -90° rotation around X axis.                 |
| $\sqrt{1/2}$ |             0 | $-\sqrt{1/2}$ |             0 |   | -90° rotation around Y axis.                 |
| $\sqrt{1/2}$ |             0 |             0 | $-\sqrt{1/2}$ |   | -90° rotation around Z axis.                 |
|              |               |               |               |   |                                              |
|--------------+---------------+---------------+---------------+---+----------------------------------------------|

Note:
  + $\sqrt{1/2} = \sqrt{0.5} \approx 0.70710$
  + $\pi = pi = \approx 3.14159265$


  *Further Reading*


Quaternions:

   + [[https://en.wikipedia.org/wiki/Quaternion][Quaternions]] - Wikipedia

   + [[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation][Quaternions and spatial rotation]]

   + [[https://en.wikipedia.org/wiki/History_of_quaternions][History of Quaternions]]

   + [[https://arxiv.org/pdf/2009.00425.pdf][An algorithm for dividing quaternions]] [PAPER]

   + [[http://www.chrobotics.com/library/understanding-quaternions][Understanding Quaternions]]  - ChRobotics

   + [[http://www.chrobotics.com/library/understanding-euler-angles][Understanding Euler Angles]] - ChRobotics

   + [[https://www.energid.com/resources/orientation-calculator][Quaternion Calculator]] - Energid / Actin Advanced Control For Robotics
     + Note: Online calculator for Quaternions.

   + [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][A Tutorial on Euler Angles and Quaternions]] - Weizmann Institute of Science

   + [[http://www.math.umd.edu/~immortal/MATH431/lecturenotes/ch_quaternions.pdf][Chapter 5 - Quaternions]]

   + [[http://wiki.ogre3d.org/Quaternion+and+Rotation+Primer][Quaternion Rotation Primer / Ogre3D Game Engine]]

   + https://web.cs.ucdavis.edu/~amenta/3dphoto/quaternion.pdf

   + [[http://www2.cs.uregina.ca/~anima/408/Notes/Quaternions/Quaternions.htm][Quaternion - in computer animation]]

   + [[http://web.archive.org/web/20130116192343/https://www.crytek.com/download/izfrey_siggraph2011.pdf][Spherical Skinning withDual-Quaternions and QTangents]] - Spherical Skinning withDual-Quaternions and QTangentsIvo Zoltan FreyCrytek R&D


Dual Quaternion:

   + Dual quaternions are a combination of quaternions and dual
     numbers. Unlike ordinary quaternions, which can only express
     rotation, dual quaternions can express both rotation and
     translation in a more concise and efficient way than
     transformation matrices. Some applications of this mathematical
     construct are: computer graphics; robotics; aerospace engineering
     and more.

   + [[https://en.m.wikipedia.org/wiki/Dual_quaternion][Dual Quaternions]]

   + [[https://doc.magnum.graphics/magnum/transformations.html][Feature guide » 2D and 3D transformations]] - Magnum Engine


Quaternion Computer Implementations:

   * [[http://docs.ros.org/en/kinetic/api/tf/html/c++/classtf_1_1Quaternion.html][t::Quaternion - ROS Framework]] (C++)

   * [[https://doc.qt.io/qt-5/qquaternion.html][Qt5 C++ Framework - QQuaternion class]] (C++)

   * [[https://doc.qt.io/qt-5/qtdatavisualization-rotations-example.html][Qt5 - Rotation Example]]

   * [[https://ivlab.github.io/MinGfx/classmingfx_1_1_quaternion.html][MinGfx C++ - OpenGL Wrapper]] (C++)

   * [[https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FQuat/index.html][FQuat]] - Unreal Game Engine (C++)
     + Brief: "Floating point quaternion that can represent a rotation
       about an axis in 3-D space."

   * [[https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FTransform/index.html][FTransform]] - Unreal Game Engine (C++)
     + Brief: "Transform composed of Scale, Rotation (as a
       quaternion), and Translation."
     + Note: It has three member variables: Rotation (class FQaut),
       Scale3D (FVector) and Translation (FVector).

   * [[https://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FRotator/index.html][FRotator]]  - Unreal Gamer Engine (C++)
     + Brief: "Implements a container for rotation information. All rotation
       values are stored in degrees."

   * [[https://docs.unity3d.com/ScriptReference/Quaternion.html][Unity3D - Quaternion]] (C#, CSharp - Unity Game Engine)
     * Brief: "Quaternions are used to represent rotations. They are
       compact, don't suffer from gimbal lock and can easily be
       interpolated. Unity internally uses Quaternions to represent
       all rotations. They are based on complex numbers and are not
       easy to understand intuitively. You almost never access or
       modify individual Quaternion components (x,y,z,w); most often
       you would just take existing rotations (e.g. from the
       Transform) and use them to construct new rotations (e.g. to
       smoothly interpolate between two rotations). The Quaternion
       functions that you use 99% of the time are:
       Quaternion.LookRotation, Quaternion.Angle, Quaternion.Euler,
       Quaternion.Slerp, Quaternion.FromToRotation, and
       Quaternion.identity. (The other functions are only for exotic
       uses.)"

   * [[https://doc.magnum.graphics/magnum/classMagnum_1_1Math_1_1Quaternion.html][Magnum Graphics Library - Quaternion]] (C++)

   * [[https://docs.microsoft.com/en-us/dotnet/api/system.numerics.quaternion?view=net-5.0][Quaternion Struct]] - Dotnet (C#)

   * [[https://octave.sourceforge.io/quaternion/overview.html][Octave - Quaternion Library]] (OCtave Language, akin to Matlab)

   * [[https://docs.blender.org/api/2.33/Mathutils-module.html][Blender - MathUtils module]]

*** Quaternions - Combining Scale and Position

Quaternions (non-dual quaternions) can only encode and represent
rotations around some orientation, which is not enough to specify
position and scaling. As a result, quaternions rotation matrices need
to be concatenated with translation and scaling transform matrices for
computing an object's model transform matrix, which is often passed to
a shader program via uniform variables.

Assuming that a rendered object has a transform member variable of
type RendererTransform containing a a quaternion, for representing
rotation; a scale vector and a position vector. The method
get_transform() compute the rendered object transform matrix, which is
the concatenation of rotation (quaternion), scaling and translation
transforms. The model transform determined by get_transform() method
can be passed to a shader uniform variable.

Note: Dual-quaternions, which are a combination of _dual-numbers_ and
ordinary quaternions, can express both rotation and translation.


 + Class RendererTransform:


#+BEGIN_SRC cpp
   struct RenderTransform
   {
         // Rotation quaternion
         // Set to identity quaternion by default.
         // Members. The quaternion has the fields (w, x, y, z)
         quaternion rotation {1.0, 0.0, 0.0};

         // Scale vector containing scales (sx, sy, sz) of axis (X, Y, Z)
         vec3 scale(1.0, 1.0, 1.0);

         // Contains object's position
         vec3 position(tx, ty, tz);

         // ??? Get overall (end result) transform matrix that
         // will be passed to shader uniform variable.
         mat4 get_transform() const { ????? }

         void translate(float dx, float dy, float dz)
         {
             this->position.x += dx;
             this->position.y += dy;
             this->position.z += dz;
         }

         void set_position(float x, float y, float z)
         {
             this->position.x = x;
             this->position.y = y;
             this->position.z = z;
         }

         void set_scale(float sx float sy, float sz)
         {
            this->scale.x = sx;
            this->scale.y = sy;
            this->scale.z = sz;
         }
   };
#+END_SRC

The transforms are often applied in the following sequence, first
scaling, then rotation and finally translation.

\begin{equation}
   T = T_t \cdot  T_r \cdot T_s
\end{equation}

Where:
  + T is the total transform matrix, which is the product between
    intermediate transforms and later can be passed to a shader
    uniform variable.
  + $T_s$ - is the scale transform, determined from the scale vector.
  + $T_t$ - is the translation transform, computed from the position vector.
  + $T_r$ - is the quaternion rotation transform.


Intermediate transforms:

 + Translation affine transform form position vector.

\begin{equation}
  T_t =
   \begin{bmatrix}
     1   & 0   &  0 &  t_x \\
     0   & 1   &  0 &  t_y \\
     0   & 0   &  1 &  t_z \\
     0   & 0   &  0 &   1  \\
   \end{bmatrix}
\end{equation}

 + Scaling affine transform from scale vector.

\begin{equation}
  T_s =
   \begin{bmatrix}
     s_x   & 0     &  0   &  0 \\
     0     & s_y   &  0   &  0 \\
     0     & 0     &  s_z &  0 \\
     0     & 0     &  0   &  1  \\
   \end{bmatrix}
\end{equation}

 + Rotation affine transform obtainted from rotation quaternion.
   + Note: most linear algebrar or computer graphics math libraries
     provide subroutines (aka functions) or class methods for
     converting quaternions to 4x4 rotation matrices. Those libraries
     also provide subroutines for determining a quaternion's yaw,
     pitch and roll angles and constructing the quaternion from yaw,
     pitch and roll angles.

\begin{equation}
  T_r =
   \begin{bmatrix}
     a_{11}   & a_{12}   &  a_{13} & 0  \\
     a_{21}   & a_{22}   &  a_{23} & 0  \\
     a_{32}   & a_{32}   &  a_{33} & 0  \\
     0        & 0        &  0      & 1  \\
   \end{bmatrix}
\end{equation}

The end transform T is determined by concatenating all intermediate
transforms:

\begin{equation}
     T = T_t \cdot  T_r \cdot T_s
\end{equation}


\begin{equation}
     T =
  \begin{bmatrix}
     1   & 0   &  0 &  t_x \\
     0   & 1   &  0 &  t_y \\
     0   & 0   &  1 &  t_z \\
     0   & 0   &  0 &   1  \\
   \end{bmatrix}

   \begin{bmatrix}
     a_{11}   & a_{12}   &  a_{13} & 0  \\
     a_{21}   & a_{22}   &  a_{23} & 0  \\
     a_{31}   & a_{32}   &  a_{33} & 0  \\
     0        & 0        &  0      & 1  \\
   \end{bmatrix}

   \begin{bmatrix}
     s_x   & 0     &  0   &  0 \\
     0     & s_y   &  0   &  0 \\
     0     & 0     &  s_z &  0 \\
     0     & 0     &  0   &  1  \\
   \end{bmatrix}
\end{equation}

Finally, the model transform becomes:

\begin{equation}

  T =
   \begin{bmatrix}
     s_x \cdot a_{11} & s_y \cdot a_{12}  & s_z \cdot a_{13}  &  t_x \\
     s_x \cdot a_{21} & s_y \cdot a_{22}  & s_z \cdot a_{23}  &  t_y \\
     s_x \cdot a_{31} & s_y \cdot a_{32}  & s_z \cdot a_{33}  &  t_z \\
      0               &   0               &   0               &   1  \\
   \end{bmatrix}

\end{equation}

Then, the algorithm for determing the object model matrix, designated
by the transform T, could be written as the following pseudo-code:

#+BEGIN_SRC cpp
   mat4 RenderTransform::get_transform() const
   {
       // Convert quaternion to a 4x4 rotation matrix (affine transform)
       mat4 model_transform = quaternion_to_rotation_transform( this->quaternion );

       // Multiply all elements of first column by X axis scale
       model_transform.comlumn[0] = scale.x * model_transform.column[0];
       // Multiply all elemnts of second column by Y axis scale
       model_transform.comlumn[1] = scale.y * model_transform.column[1];
       // Multiply all elemnts of third column by Z axis scale
       model_transform.comlumn[2] = scale.z * model_transform.column[2];

       // Set all elements of forth column as the 4x1  column vector
       // column4 = [position.x position.y position.z 1.0 ]
       model_transform.column[4] = vec4( position.x, position.y, position.z, 1.0f );

       return model_transform;
   }
#+END_SRC

To rotate the rendered object, it is only necessary to multiply the
quaternion variable, called 'rotation' by another quaternion. So, a
C++-like pseudo-code for setting or adding a new rotation could be
written as:

#+BEGIN_SRC cpp
   RenderTransform object_transform;

   // Set a new rotation - overriding the old one.
   void RenderTransform::set_rotation(float angle_radians, vec3 axis_direction)
   {
       // Normalize axis
       vec3 axis = axis_direction.normalize();
       // Make explicit assumption the assumption that the quaternion is normalized.
       assert( norm(axis) ~= 1.0  );
       this->object_transform.quaternion = make_quaternion_from_AngleAxis(angle, axis);
   }

   // Add a new rotation, rotate the previous quaternion.
   void RenderTransform::rotate(float angle_radians, vec3 axis_direction)
   {
       vec3 axis = axis_direction.normalize();
       assert( norm(axis) ~= 1.0  );
       quaternon q = make_quaternion_from_AngleAxis(angle, axis);
       this->object_transform.quaternion = this->object_transform.quaternion * q;
   }


   // Set a new Yaw-Pitch-Roll Euler's angles rotation.
   void RenderTransform::set_rotation_YRP(float yaw, float pitch, float roll)
   {
       vec3 axis = axis_direction.normalize();
       assert( norm(axis) ~= 1.0  );
       quaternon q = make_quaternion_from_YAW_PITCH_ROLL(yaw, pitch, roll);
       assert( norm(q) ~= 1.0 );
       this->object_transform.quaternion = q;
   }
#+END_SRC

 *See also:*

  + [[https://tech.metail.com/performance-quaternions-gpu/][Performance of quaternions in the GPU]] - Metail Tech

  + [[https://stackoverflow.com/questions/8594102/matrix-multiply-with-position-quaternion-and-scale-components][c++ - Matrix multiply with position, quaternion and scale components - Stack Overflow]]

  + [[https://www.gamasutra.com/view/feature/131686/rotating_objects_using_quaternions.php][Rotating Objects Using Quaternions]] - Noick Bobic / Gamasutra

*** Quaternion in Julia Language

It is worth prototyping quaternion math in a numerically-oriented programming
language such as [[https://en.wikipedia.org/wiki/Julia_(programming_language)][Julia Language]] is helpful for understanding and
validating the inner works of quaternion computations. This
implementation of quaternion math represents quaternion as an array of
four elements and uses a matrix representation for implemeting
quaternion multiplication.

#+BEGIN_SRC julia
   # Struct for storing quaternion
   # q = w + x·i + y·j + z·k
   struct quatp
      arr::Array{Float64,1}
   end

   function quat(x, y, z, w)
     return quatp([x ; y; z; w])
   end

   # Turns a quaternion into 4x4 matrix representation
   function quat_to_mat4x4(q::quatp)
       w, x, y, z  = q.arr
       mat = [  w -x -y -z
              ; x  w -z  y
              ; y  z  w -x
              ; z -y x w ]
       return mat
    end

   function Base.getproperty(q::quatp, sym::Symbol)
       if sym == :arr
           return getfield(q, :arr)
       elseif sym == :w
           return getfield(q, :arr)[1]
       elseif sym == :x
           return getfield(q, :arr)[2]
       elseif sym == :y
           return getfield(q, :arr)[3]
       elseif sym == :z
           return getfield(q, :arr)[4]
       elseif sym == :v
           # Return only the quaternion (vector part)
           return getfield(q, :arr)[2:end]
       end
   end

   # Norm - quaternion magnitude, akin to vector norm
   function norm(q::quatp)
      w, x, y, z = q.arr
      return sqrt(w * w + x * x + y * y + z * z)
   end

   # Conjugate of a quaternion
   function conj(q::quatp)
     return quat(q.w, -q.x, -q.y, -q.z)
   end

   # Inverse of quaternion q^-1
   function Base.:inv(q::quatp)
      w, x, y, z = q.arr
      norm_square =  w * w +  x * x + y * y + z * z
      return  quat(w, -x, -y, -z) / norm_square
   end

   # Quaternion sum
   Base.:+(q1::quatp, q2::quatp) = quat(q1.w + q2.w, q1.x + q2.x, q1.y + q2.y, q1.z + q2.z)
   Base.:-(q1::quatp, q2::quatp) = quat(q1.w - q2.w, q1.x - q2.x, q1.y - q2.y, q1.z - q2.z)

   Base.:+(q::quatp,   w::Float64) = quat(w + q.w, q.x, q.y, q.z)
   Base.:+(w::Float64, q::quatp  ) = quat(w + q.w, q.x, q.y, q.z)
   Base.:-(q::quatp,   w::Float64) = quat(q.w - w, q.x, q.y, q.z)

   # Mutliplication => scalar X quaternion
   Base.:*(a::Float64, q::quatp) = quat( a * q.w, a * q.x, a * q.y, a * q.z)
   Base.:*(q::quatp, a::Float64) = quat( a * q.w, a * q.x, a * q.y, a * q.z)

   Base.:/(q::quatp, a::Float64) = quat( q.w / a, q.x / a, q.y / a, q.z / a)

   # Quaternion multiplication / product
   Base.:*(q1::quatp, q2::quatp) = begin
        A = quat_to_mat4x4(q1)
        return quatp( A * q2.arr )
   end

   # Unit quaternions i, j, k
   const i = quat(0.0, 1.0, 0.0, 0.0)
   const j = quat(0.0, 0.0, 1.0, 0.0)
   const k = quat(0.0, 0.0, 0.0, 1.0)


   # Obtain a rotation quaternion that represents a rotation
   # by some angle around some direction (normalized vector 'vec')
   # => The angle is given in degrees.
   function rot_quat(angle::Float64, vec)
      # Normalize vector vec and store the result in v
      xv, yv, zv = vec
      x, y, z = vec / sqrt( xv * xv + yv * yv + zv * zv )
      S = cosd(angle / 2)
      C = sind(angle / 2)
      return quat(C, S * x, S * y, S * z)
   end

   ## Vector cross product VA x VB of two column vectors (3 x 1)
   function cross(va, vb)
        x, y, z = va
        T = [ 0 -z y ; z 0 -x; -y x 0]
        T * vb
    end

   ## Apply a rotation quaternion to a vector (column vector 3 x 1)
   ##  =>> Vector 3 rows and 1 column
   ## Algorithm from:
   #     =>> https://fgiesen.wordpress.com/2019/02/09/rotating-a-single-vector-using-a-quaternion/
   function apply_rot(qr::quatp, va)
      wr = qr.w # Scalar/real part of rotation quaternion
      vr = qr.v # Vector part of rotation quaternion
      vt = 2 * cross(vr, va)
      vb = va + wr * vt + cross(vr, vt)
      return vb
   end

   # Obtain a rotation matrix - that represents rotation
   # around an arbitrary axis (vector)
   # Note: The angle is should be in degrees.
   #
   function make_rotmat(angle::Float64, vec)
      # Normalize vector vec and store components in x, y, z
      x, y, z = vec
      x, y, z = vec / sqrt( x * x + y * y + z * z )
      # sin and cos caching
      C = cosd(angle / 2)
      S = sind(angle / 2)
      # Parameters a, b, c, d => Components of the rotation
      # quaternion
      a = C
      b = x * S
      c = y * S
      d = z * S
      # rotation matrix
      mat = [
           ( a^2 + b^2 - c^2 - d^2 )  ( 2 * (b * c - a * d )  ) ( 2 * (b * d + a * c)   )  0
        ;  ( 2 * (b * c + a * d)   )  ( a^2 - b^2 + c^2 - d^2 ) ( 2 * (c * d - a * b)   )  0
        ;  ( 2 * (b * d - a * c)   )  ( 2 * (c * d + a * b)   ) ( a^2 - b^2 - c^2 + d^2 )  0
        ;  0                          0                         0                          1
      ]
      return mat
   end
#+END_SRC

Quaternion components:

#+BEGIN_SRC julia
  # Construct a quaternion

  julia> q = quat(10.5, -25.1, 4.5, 5.6)
  quatp([10.5, -25.1, 4.5, 5.6])

  julia> q.w # Real part
  10.5

  julia> q.x # Imaginary part - i axis component
  -25.1

  julia> q.y # Imaginary part - j axis component
  4.5

  julia> q.z # Imaginary part - k axis component (Z axis)
  5.6

  julia> q.arr # Internal array data representation
  4-element Array{Float64,1}:
    10.5
   -25.1
     4.5
     5.6

  julia> q.v # Vector component (i, j, k) components only
  3-element Array{Float64,1}:
   -25.1
     4.5
     5.6
#+END_SRC

Quaternion conjugate and inverse:

#+BEGIN_SRC julia
   julia> q = quat(1.0, 2.0, 3.0, 4.0)
   quatp([1.0, 2.0, 3.0, 4.0])

   julia> inv(q)
   quatp([0.03333333333333333, -0.06666666666666667, -0.1, -0.13333333333333333])

   # Expected (-1.0)
   julia> q * inv(q)
   quatp([1.0, 0.0, 0.0, 0.0])

   # Expected (-1.0)
   julia> inv(q) * q
   quatp([1.0, -5.551115123125783e-17, -6.938893903907228e-18, 5.551115123125783e-17])
#+END_SRC

Normalize a quaternion:

#+BEGIN_SRC julia
  # Expected normalized to be: (w = 0.18257, x = 0.36515, y = 0.54772, z = 0.7303)
  # Test case from: Matlab Robotics Toolbox - https://www.mathworks.com/help/robotics/ref/quaternion.normalize.html

   julia> q = quat(1.0, 2.0, 3.0, 4.0)
   quatp([1.0, 2.0, 3.0, 4.0])

   julia> qn = normalize(q)
   quatp([0.18257418583505536, 0.3651483716701107, 0.5477225575051661, 0.7302967433402214])

   julia> norm(qn)
   0.9999999999999999

#+END_SRC

Test case 1 - for quaternion multiplication:

  + Test quaternion laws:
  + Expected: i * i = j * j = k * k = -1
  + Expected: i * j = k
  + Expected: j * k = i
  + Expected: k * i = j
  + Expected: j * i = -k

#+BEGIN_SRC julia
   # ---- Show components i, j, k --------#

   julia> i
   quatp([0.0, 1.0, 0.0, 0.0])

   julia> j
   quatp([0.0, 0.0, 1.0, 0.0])

   julia> k
   quatp([0.0, 0.0, 0.0, 1.0])

   # ----- Check multiplication of i, j, k by themselves -----------#
   #

   julia> i * i # Expected -1 or (-1) + 0·i + 0·j + 0·k
   quatp([-1.0, 0.0, 0.0, 0.0])

   julia> j * j # Expected -1
   quatp([-1.0, 0.0, 0.0, 0.0])

   julia> k * k # Expected -1
   quatp([-1.0, 0.0, 0.0, 0.0])

   #------- Check multiplication i * j, j * k, k * i and j * i
   #
   julia> i * j # Expected k
   quatp([0.0, 0.0, 0.0, 1.0])

   julia> j * i # Expected -k
   quatp([0.0, 0.0, 0.0, -1.0])

   julia> k * i # Expected j
   quatp([0.0, 0.0, 1.0, 0.0])

   julia> i * k # Expected -j
   quatp([0.0, 0.0, -1.0, 0.0])

#+END_SRC

Test case 2 - for quaternion multiplication:

  + From:  [[https://www.mathworks.com/help/aerotbx/ug/quatmultiply.html][Matlab Aerospace Toolbox]]
  + q1 = [ 1.0 0.0 1.0 0.00 ]
  + q2 = [ 1.0 0.5 0.5 0.75 ]
  + Expected result =>> q1 * q2 = [ 0.5 1.25 1.5 0.25 ]

#+BEGIN_SRC julia
  # -------- Test A ------------------------#
  julia> q1 = quat(1.0, 0.0, 1.0, 0.0)
  quatp([1.0, 0.0, 1.0, 0.0])

  julia> q2 = quat(1.0, 0.5, 0.5, 0.75)
  quatp([1.0, 0.5, 0.5, 0.75])

  # ------- Test B ---------------------#

  julia> q1 = 1.0 + 0.0i + 1.0j + 0.0k
  quatp([1.0, 0.0, 1.0, 0.0])

  julia> q2 = 1.0 + 0.5i + 0.5j + 0.75k
  quatp([1.0, 0.5, 0.5, 0.75])

  julia> q1 * q2
  quatp([0.5, 1.25, 1.5, 0.25])
#+END_SRC

Test case 3 - for quaternion multiplication:

  + From: [[https://www.maplesoft.com/applications/view.aspx?SID=4886&view=html][Maplesoft - Quaternion]]
  + q1 = ( -6) +  (-8)i +  (-5)j +     7k
  + q2 = (-14) + (-12)i + (-19)j + (-17)k
  + Expected: q1 * q2 = 12 +   402i + (-36)j +   96k
  + Expected: q2 * q1 = 12 + (-34)i +   404j + (-88)k
  + Expected: q2 + q1 = (-20) + (-20)i + (-24)j + (-10)k

#+BEGIN_SRC julia
  julia> q1 = -6.0 + -8.0i + -5.0j + 7.0k
  quatp([-6.0, -8.0, -5.0, 7.0])

  julia> q2 = -14.0 + -12.0i + -19.0j + -17.0k
  quatp([-14.0, -12.0, -19.0, -17.0])

  julia> q1 * q2
  quatp([12.0, 402.0, -36.0, 96.0])

  julia> q2 * q1
  quatp([12.0, -34.0, 404.0, -88.0])

  julia> q1 + q2
  quatp([-20.0, -20.0, -24.0, -10.0])

  julia> q2 + q1
  quatp([-20.0, -20.0, -24.0, -10.0])


#+END_SRC

 *Test algorithm - make_rotmat* that computes rotation matrices around
 an arbitrary axis:

Define functions for computing rotation matrices:

#+BEGIN_SRC julia
   # Rotation around X axis
   function rot_x(angle::Float64)
      C = cosd(angle)
      S = sind(angle)
      return [  1   0   0  0
              ; 0   C  -S  0
              ; 0   S   C  0
              ; 0   0   0  1
             ]
   end

   # Rotation around X axis
   function rot_y(angle::Float64)
      c = cosd(angle)
      s = sind(angle)
      return [  c   0   s  0
              ; 0   1   0  0
              ;-s   0   c  0
              ; 0   0   0  1
             ]
   end

   # Returns homogeneous rotation matrix around Z axis
   # => The angle must be in degrees, not radians
   function rot_z(angle::Float64)
      c = cosd(angle)
      s = sind(angle)
      return [  c  -s  0  0
              ; s   c  0  0
              ; 0   0  1  0
              ; 0   0  0  1
             ]
   end
#+END_SRC

Test rotation matrices:

#+BEGIN_SRC julia
   const axis_x = [1.0 0.0 0.0]';
   const axis_y = [0.0 1.0 0.0]';
   const axis_z = [0.0 0.0 1.0]';

   # -------- Rotation around Z axis ---------- #
   #

   julia> rot_z(90.0)
   4×4 Array{Float64,2}:
    0.0  -1.0  0.0  0.0
    1.0   0.0  0.0  0.0
    0.0   0.0  1.0  0.0
    0.0   0.0  0.0  1.0

   julia> make_rotmat(90.0, axis_z)
   4×4 Array{Float64,2}:
    0.0  -1.0  0.0  0.0
    1.0   0.0  0.0  0.0
    0.0   0.0  1.0  0.0
    0.0   0.0  0.0  1.0


   julia> rot_z(45.0)
   4×4 Array{Float64,2}:
    0.707107  -0.707107  0.0  0.0
    0.707107   0.707107  0.0  0.0
    0.0        0.0       1.0  0.0
    0.0        0.0       0.0  1.0

   julia> make_rotmat(45.0, axis_z)
   ]4×4 Array{Float64,2}:
    0.707107  -0.707107  0.0  0.0
    0.707107   0.707107  0.0  0.0
    0.0        0.0       1.0  0.0
    0.0        0.0       0.0  1.0

   julia> rot_z(125.0)
   4×4 Array{Float64,2}:
    -0.573576  -0.819152  0.0  0.0
     0.819152  -0.573576  0.0  0.0
     0.0        0.0       1.0  0.0
     0.0        0.0       0.0  1.0

   julia> make_rotmat(125.0, axis_z)
   4×4 Array{Float64,2}:
    -0.573576  -0.819152  0.0  0.0
     0.819152  -0.573576  0.0  0.0
     0.0        0.0       1.0  0.0
     0.0        0.0       0.0  1.0


   # ----- Rotation around X axis ------------#
   #
   julia> rot_x(0.0)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  1.0  -0.0  0.0
    0.0  0.0   1.0  0.0
    0.0  0.0   0.0  1.0

   julia> make_rotmat(0.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0  0.0  0.0
    0.0  1.0  0.0  0.0
    0.0  0.0  1.0  0.0
    0.0  0.0  0.0  1.0


   julia> rot_x(45.0)
   4×4 Array{Float64,2}:
    1.0  0.0        0.0       0.0
    0.0  0.707107  -0.707107  0.0
    0.0  0.707107   0.707107  0.0
    0.0  0.0        0.0       1.0

   julia> make_rotmat(45.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0        0.0       0.0
    0.0  0.707107  -0.707107  0.0
    0.0  0.707107   0.707107  0.0
    0.0  0.0        0.0       1.0


   julia> rot_x(90.0)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  0.0  -1.0  0.0
    0.0  1.0   0.0  0.0
    0.0  0.0   0.0  1.0

   julia> make_rotmat(90.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  0.0  -1.0  0.0
    0.0  1.0   0.0  0.0
    0.0  0.0   0.0  1.0

#+END_SRC

Test rotation quaternions:

#+BEGIN_SRC julia
  # Rotation around X axis
  function rot_xx(angle::Float64)
     C = cosd(angle)
     S = sind(angle)
     return [ 1  0  0  ; 0   C  -S   ; 0   S   C     ]
  end

  julia> va = [6.0 10.5 2.56]'
  3×1 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
    6.0
   10.5
    2.56

  angle = 60.0 # 60 degrees

  julia> vb_rotmat = rot_xx(angle) * va
  3×1 Array{Float64,2}:
    6.0
    3.032974966311837
   10.373266739736605

  # Rotation quaternion that represents rotation of 60 degrees around X axis.
  julia> qr = rot_quat(60.0, [1.0 0.0 0.0]')
  quatp([0.8660254037844386, 0.5, 0.0, 0.0])

  # Apply transform to vector va
  julia> vb_qr = apply_rot(qr, va)
  3×1 Array{Float64,2}:
    6.0
    3.032974966311837
   10.373266739736607

#+END_SRC

** Default Coordinate Systems

In order to proper use a graphics application programming interface,
one must know the default coordinate system and conventions defined by
the graphics API. This convention includes: the coordinate system
origin, which may be on the upper left corner of drawing window or
lower left corner of drawing window; the default direction of axis and
whether the coordinate system is RHS (Right-Handed System) or LHS
(Left-Handed System).

  *OpenGL Default Coordinate System*

OpenGL API uses a default coordinate system with the origin place at
the screen center, X axis as the horizontal axis, Y axis as the
vertical axis and Z axis going from the screen center towards the
user. This default coordinate system NDC is normalized, each dimension
X, Y and Z has the range from -1.0 to +1.0. Any vertex with any
dimension out of this range is not displayed on the screen.

In this coordinate system, the coordinate of points: point A at the OpenGL
window top right corner is (x = 1, y = 1); the coordinate of point B
is (x = 1,y= -1); the coordinate of the point C is (x = -1, y = -1).

#+CAPTION: OpenGL default coordinate system (NDC - Normalized Device Coordinate)
[[file:images/default-coordinate-system1.png][file:images/default-coordinate-system1.png]]


  *OpenGL Coordinate System X Math-textbook Coordinate System*

OpenGL default coordinate system should not be confused with the
coordinate system commonly found in math and physics textbooks, where
Z axis is the vertical axis, Y axis is the horizontal axis and the X
axis is going from the screen twoards the screen observer (out of
screen). The advantage of OpenGL coordinate system over the coordinate
system used by textbooks is that 2D drawing requires just ignoring the
Z axis, setting any Z coordinate to zero. If one does not like the
OpenGL default coordinate system, it is possible to obtain the math
textbook coordinate system just by applying affine rotation transform
the OpenGL default coordinate system.

#+CAPTION: OpenGL coordinate system versus math or physics coordinate system.
[[file:images/default-coordinate-system2.png][file:images/default-coordinate-system2.png]]


The transform matrix that maps coordinates from the math and physics
style coordinate system (M) to the OpenGL coordinate (C) can be obtained by: 


\begin{equation}
   T_{M -> C} = \text{Rot}_x(-90) \cdot \text{Rot}_z(-90)  
\end{equation}

\begin{equation}
   T_{M -> C} = 
           \begin{bmatrix}
               1 &  0  & 0 & 0  \\
               0 &  0  & 1 & 0  \\ 
               0 & -1  & 0 & 0  \\
               0 &  0  & 0 & 1 
           \end{bmatrix}

           \begin{bmatrix}
               0 &  1  & 0 & 0  \\
              -1 &  0  & 0 & 0  \\ 
               0 &  0  & 1 & 0  \\
               0 &  0  & 0 & 1 
           \end{bmatrix}
\end{equation}


\begin{equation}
   T_{M -> C} = \begin{bmatrix}
                    0 & 1 & 0 & 0  \\
                    0 & 0 & 1 & 0  \\ 
                    1 & 0 & 0 & 0  \\
                    0 & 0 & 0 & 1 
                \end{bmatrix}
\end{equation}

Where: 

  + $Rot_x$ - Is the X axis rotation matrix.
  + $Rot_z$ - Is the Z axis rotation matrix.
  + $T_{M -> C}$ - Is the affine matrix transform that maps
    coordinates from math-and-physics coordinate system to OpenGL
    coordinate system. 
  + M - designates the coordinate system similar to the
    math-and-physics textbooks as in the right side of the previous
    picture.
  + C - designates the openGL coordinate system.

Coordinates from math textbook style coordinate systems can be mapped
to OpenGL by using the previous affine transform matrix.

\begin{equation} 
   \begin{bmatrix} x_c \\ y_c \\ z_c \\ 1 \end{bmatrix}

     =   T_{M -> C} 
        \begin{bmatrix} x_m \\ y_m \\ z_m \\ 1 \end{bmatrix}
\end{equation}

With the previous equation it is possible to verify that the Y axis,
vector (0, 1, 0) from the M coordinate system corresponds to the axis
X (1, 0, 0) in the openGL (C) coordinate system. 

\begin{equation} 
     \begin{bmatrix} 1 \\ 0 \\ 0 \\ 1 \end{bmatrix}
      = 
         \begin{bmatrix}
             0 & 1 & 0 & 0  \\
             0 & 0 & 1 & 0  \\ 
             1 & 0 & 0 & 0  \\
             0 & 0 & 0 & 1 
         \end{bmatrix}    
        \begin{bmatrix} 0 \\ 1 \\ 0 \\ 1 \end{bmatrix}
\end{equation}

The same procedure can be applied to X axis in (M) coordinate system,
which is mapped to Z axis in OpenGL coordinate system and to Z axis
from (M)  coordinate system which is mapped to Y axis in OpenGL
coordinate system. 

   *Coordinate System positions from other computer graphics APIS*

The following diagram shows the possible default coordinate systems
positions from many computer graphics APIS:

#+CAPTION: Default coordinate systems positions
[[file:images/default-coordinate-system3.png][file:images/default-coordinate-system3.png]]

  + (C) => Center of display screen
    + Default position of OpenGL NDC coordinate system (clip-space).

  + (B) => Lower-left corner of display screen
    + Default position of OpenGL screen coordinate system

  + (U) => Upper-left corner of display screen
    + => The Y axis is inverted, it is positive in the downward
      direction instead of upward direction.
    + Default position of most 2D graphics APIs including: Html5
      canvas; SVG; Java AWT 2D.


Transform matrix, $T_{B \rightarrow U}$, that maps coordinates from
lower-left corner (B) coordinate system to upper-left-corner
coordinate system.

\begin{equation}
   T_{B \rightarrow U} =
           \begin{bmatrix}
               1 &  0 & 0  \\
               0 & -1 & h  \\
               0 &  0 & 1
           \end{bmatrix}
\end{equation}

Transform matrix, $T_{C \rightarrow U}$, that maps coordinates from
(C) window-center coordinate system to upper-left corner (U)
coordinate system. This transform is useful for drawing with origin on
screen center when using gaphics APIs which the default coordinate
system is located at the upper-left corner.

\begin{equation}
   T_{C \rightarrow U} =
           \begin{bmatrix}
               1 &  0 & w/2  \\
               0 & -1 & h/2  \\
               0 &  0 & 1
           \end{bmatrix}
\end{equation}

\begin{equation}
   V_U = T_{C \rightarrow U} \cdot V_C
\end{equation}

\begin{equation}
   \begin{bmatrix} x_u \\ y_u \\ 1 \end{bmatrix}
   =
   T_{C \rightarrow U}
   \begin{bmatrix} x_c \\ y_c \\ 1 \end{bmatrix}

   =
   \begin{bmatrix}
        x_c + w/2  \\
       -y_c + h/2  \\
        1
   \end{bmatrix}
\end{equation}

Transform matrix, $T_{B \rightarrow C}$, that maps coordinates from
lower-left corner (B) to screen-center origin, OpenGL normalized
coordinate system (C).

\begin{equation}
   T_{B \rightarrow C} =
           \begin{bmatrix}
               2/w &  0  & -1  \\
               0   & 2/h & -1  \\
               0   &  0  &  1
           \end{bmatrix}
\end{equation}

The matrix transform, $T_{C \rightarrow B}$, that maps from coordinate
system C to coordinate system B can be computed as the inverse of
$T_{B \rightarrow C}$.

\begin{equation}
   T_{C \rightarrow B} = T_{B \rightarrow C}^{-1}
   =
           \begin{bmatrix}
               w/2 &  0  & w/2  \\
               0   &  h/2 & h/2  \\
               0   &  0  &  1
           \end{bmatrix}
\end{equation}

** Drawing Primitives

OpenGL can draw only points, lines, triangles and quads as
primitives. Complex models, solids, surfaces and curves can be drawn
combining those primitives.

Drawing is perfomed by using the _glDrawArrays()_ subroutine, that draws
using the vertices from the current bound VBO - Vertex Buffer Object
or VAO - Vertex Array Object.

Primitives:

  + _GL_POINTS_ => Draw a point for each vertex.

  + _GL_LINES_ => Unconnected lines - useful for drawing grids and
    coordinate axis. Each two vertices are considered the beginning
    and the end of the current line. For instance, if there are 6
    vertices, V0, V1, V2, V3, V4, V5. The primitive GL_LINES, will
    result in the following lines: Line(V0, V1) - line  from V0 to V1;
    Line(V2, V3); Line(V4, V5).

  + _GL_LINE_STRIP_  => Draw connected lines for each pair of
    consecutive vertices. For each, if there is a set of 4 vertices,
    named V0, V1, V2, V3. This primitive will draw the following
    lines: Line(V0, V1) - line from V0 to V1; Line(V1, V2) and
    Line(V2, V3). q

  + _GL_LINE_LOOP_ => Similar, to GL_LINE_STRIP primitive, although this
    primitive draws a line between the first and the last vertex. This
    primitive is suitable for drawing poligons.

  + _GL_TRIANGLES_ => Draws a triangle for each three vertices. This
    primitive is useful for drawing surfaces and solids. Any complex
    OpenGL surface can be approximated using triangles. This primitive
    draws a triangle for each three vertices. If there is a set of
    vertices V0, V1, V2, V3, V4 and V5, the primitive will draw the
    following triangles Triangle(V0, V1, V2) and Triangle(V3, V4,
    V5).

  + _GL_TRIANGLE_FAN_

  + _GL_TRIANGLE_STRIP_


#+BEGIN_SRC cpp
   glBindVertexArray(my_vao);

   // Draw points lines - using the vertices coordinates from VAO 'my_vao'.
   // (current bounded VAO)
   glDrawArrays(GL_POINTS, 0, n_vertices);


   // Draw unconnected lines - using the vertices coordinates from VAO 'my_vao'.
   glDrawArrays(GL_LINES, 0, n_vertices);

   // Draw connected lines - using the vertices coordinates from VAO 'my_vao'.
   // (current bounded VAO)
   glDrawArrays(GL_LINE_STRIP, 0, n_vertices);
#+END_SRC

** Library GLM - OpenGL Mathematics
*** Overview

The library GLM (OpenGL math library) contains many classes and
subroutines for computer graphics computations, such as: homogeneous
coordinates; quaternios; 1D, 2D, 3D and homogeneous coordinates
vectors; vector-matrix operations and so on. Aside those facilities,
the library also provides the subroutines _glm::lookAt()_, for computing
view matrix transform, that turns world coordinates into camera
coordinates; _glm::perspective()_ - for computing the projection matrix,
that turns camera coordinates into clip-space coordinates (NDC
coordinates with range -1.0 to 1.0) and also _glm::ortho_ for computing
the orthogonal perspective matrix. The GLM library is designed with
syntax based on GLSL (OpenGL shading language).

Web Site:

  + [[https://glm.g-truc.net/0.9.9/index.html][OpenGL Mathematics]]

Repository:

  + https://github.com/g-truc/glm

Other Documentations:

 + https://openframeworks.cc/documentation/glm/


  *Type signature of most relevant GLM functions:*

#+BEGIN_SRC cpp

   // Converts an input angle in degrees to radians.
   //
   //  angle_radians = angle_degrees * (PI / 180.0 )
   //
   float glm::radians(foat  degrees);

   // ------ Basic Matrix Transformation =>> Useful for model matrix ---------------//
   glm::mat4 glm::rotate   ( glm::mat4 const & m, float angle, glm::vec3 const & axis );
   glm::mat4 glm::scale    ( glm::mat4 const & m, glm::vec3 const & factors           );
   glm::mat4 glm::translate( glm::mat4 const & m, glm::vec3 const & translation       );


   // ---- Camera View matrix and Camera's matrix -------------//
   glm::mat4 glm::lookAt( glm::vec3 const & eye, glm::vec3 const & look, glm::vec3 const & up );
   glm::mat4 glm::ortho( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::ortho( float left, float right, float bottom, float top );
   glm::mat4 glm::frustum( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::perspective( float fovy, float aspect, float near, float far);
#+END_SRC

 *Subroutines for vector computations*

  * glm::normalize()
    + => Normalize a vector.

  * glm::dot(vec1, vec2)
    + => Vector dot product.

  * glm::length(vec)
    + => Vector norm, aka magnitude.

  * glm::distance(vec1, vec2)
    + => Distance between two vectors thatrepresents position.

  * glm::cross(vec1, vec2)
    + => Returns the cross product between two vectors.

 *Subroutine for Camera Implementation*

Camera's View Matrix:

  * glm::mat4 _glm::lookAt_ (eye, look, up );
    + Brief: Return *View matrix transform* - which transforms world coordinates to camera's space coordinates.
    + eye  => Vector containing the camera's current position in world coordinates.
    + look => Vector (Position) to where camera is looking at.
    + up   => Camera orientation. Suitable fault value Y axis or (x =  0, y = 1, z = 0).

Camera's Projection Matrix:

  * glm::mat4 _glm::perspective_ ( fovy, float aspect, near, far);
    + Returns projection matrix that transforms camera-space
      coordinates to clip-space coordinates (NDC - Normalized Device
      Coordinates within range -1.0 to 1.0). Anything out of the _near_,
      _far_ range is not visible.
    + fovy => Field view angle in radians.
    + near => Distance to near plane.
    + far  => Distance to far plane.

  * glm::mat4 _glm::ortho_ ( left, right, bottom, top );
    + Returns a projection matrix for ortographic projection. This
      type projection is most suitable for 2D drawing; CAD - Computer
      Aided Design; Technical drawing view and on.


 *GLM functions - transform matrix multiplication order*

Consider the subroutine, glm::translate() - which translate a
coordinate system.

#+BEGIN_SRC
   glm::mat4 SOURCE_MATRIX = something();
   glm::mat4 OUTPUT_MATRIX =  glm::translate( SOURCE_MATRIX, glm::vec3(DX, DY, DZ));
#+END_SRC

GLM computes the OUTPUT_MATRIX by performing the matrix multiplication
in the following way. The same logic is applicable to the subroutines:
glm::rotate, glm::scale and so on.

#+BEGIN_SRC cpp
    OUTPUT_MATRIX = SOURCE_MATRIX * Translate_Transform(DX, DY, DZ)

                                    | 1  0  0  DX |
    OUTPUT_MATRIX = SOURCE_MATRIX * | 0  1  0  DY |
                                    | 0  0  1  DZ |
                                    | 0  0  0  1  |
#+END_SRC

Consider the following sequence of operations:

#+BEGIN_SRC cpp
    const glm::vec4 axis_Z = glm::vec3(0, 0, 1);

   // Reset model matrix to identity matrix
    glm::mat4 model(1.0);

    // Move to (X, Y) position
    // model = model * T_translate(_x, y, 0.0)
    // model = identity * T_translate(_x, y, 0.0) = T_translate(_x, y, 0.0)
    model = glm::translate( model, glm::vec3(_x, _y, 0.0)  );

    // Scale object (increase or decrease object size)
    // model = model * T_scale
    // model = T_translate * T_scale
    model =  glm::scale( model, glm::vec3(_scale, _scale, _scale) );

    // Rotate from a given angle around Z axis at current object X, Y  postion
    // model = model * T_rotation
    // model =  (T_translate * T_scale) * T_rot
    model = glm::rotate( model, glm::radians(_angle),  axis_Z);
#+END_SRC

The final value of the model matrix, is product between the following
affine transforms:

#+BEGIN_SRC text
   model  =  Identity * T_translate * T_scale * T_rotation
   model  =  T_translate * T_scale * T_rotation
#+END_SRC

*** Testing in CERN's Root REPL

  *Download Library Source*

#+BEGIN_SRC sh
   $ mkdir -p /tmp/temp && cd /temp

   # Download source code archive
   $ >> curl -o glm.zip -L https://github.com/g-truc/glm/archive/master.zip

   # Extract code
   $ >> unzip  glm.zip

   # Enter the in the extracted directory
   $ >> cd glm-master/

   # List directory content
   $ >> ls
   cmake/  CMakeLists.txt  copying.txt  doc/  glm/  manual.md  readme.md  test/  util/
#+END_SRC

 *Load the library in CERN's ROOT repl*

#+BEGIN_SRC cpp
    $ >> ~/Applications/root/bin/root
   ERROR in cling::CIFactory::createCI(): cannot extract standard library include paths!
   Invoking:
     LC_ALL=C ccache  -O2 -DNDEBUG -xc++ -E -v /dev/null 2>&1 | sed -n -e '/^.include/,${' -e '/^ \/.*++/p' -e '}'
   Results was:
   With exit code 0
      ------------------------------------------------------------------
     | Welcome to ROOT 6.22/02                        https://root.cern |
     | (c) 1995-2020, The ROOT Team; conception: R. Brun, F. Rademakers |
     | Built for linuxx8664gcc on Aug 17 2020, 12:46:52                 |
     | From tags/v6-22-02@v6-22-02                                      |
     | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |
      ------------------------------------------------------------------

   root [0]

   root [0] .I .

   root [0] .I .
   root [1] #include <glm/glm.hpp>
   root [2] #include <glm/gtc/matrix_transform.hpp>
   root [3] #include <glm/gtc/type_ptr.hpp>
   root [4] #include <glm/gtx/string_cast.hpp>

   // Note: GLM matrices are stored in Column-major order
   void show_matrix(const char* label, glm::mat4 const& m){
       std::cout << "\n [MATRIX] " << label << " = " << '\n';
       std::cout << std::fixed << std::setprecision(3);
       for(size_t i = 0; i < 4; i++)
       {
           for(size_t j = 0; j < 4; j++)
           {
               std::cout << std::setw(8) << m[j][i];
           }
           std::cout << '\n';
       }
   }
#+END_SRC


Construct a matrix from column vectors:

\begin{equation}
   \text{colum}_0 = \begin{bmatrix}  25   \\ 40 \\   7 \\ 0    \end{bmatrix} \quad
   \text{colum}_1 = \begin{bmatrix}   8   \\ 9  \\  10 \\ 0    \end{bmatrix} \quad
   \text{colum}_2 = \begin{bmatrix}  -5   \\ 6  \\   9 \\ 0    \end{bmatrix} \quad
   \text{colum}_3 = \begin{bmatrix} 100   \\ 50 \\  20 \\ 1    \end{bmatrix}
\end{equation}


\begin{equation}
   M = \begin{bmatrix} \text{colum}_0  &\text{colum}_1 & \text{colum}_2 & \text{colum}_3 \end{bmatrix}
\end{equation}

\begin{equation}
   M = \begin{bmatrix}
            25  &  8  & -5  &  100 \\
            40  &  9  &  6  &   50 \\
             7  & 10  &  9  &   20 \\
             0  &  0  &  0  &    1 \\
       \end{bmatrix}
\end{equation}


#+BEGIN_SRC cpp
   auto col0 = glm::vec4(25, 40, 7, 0)
   auto col1 = glm::vec4(8, 9, 10, 0)
   auto col2 = glm::vec4(-5, 6, 9, 0)
   auto col3 = glm::vec4(100, 50, 20, 1)

   root [9] auto M = glm::mat4(col0, col1, col2, col3)

   root [24] show_matrix("M", M)

    [MATRIX] M =
     25.000   8.000  -5.000 100.000
     40.000   9.000   6.000  50.000
      7.000  10.000   9.000  20.000
      0.000   0.000   0.000   1.000
#+END_SRC

This matrix could also be constructed in the following mode:

#+BEGIN_SRC cpp
    auto MM = glm::mat4(25, 40, 7, 0  ,8, 9, 10, 0  ,-5, 6, 9, 0 ,100, 50, 20, 1)

   root [27] show_matrix("MM", MM)

    [MATRIX] MM =
     25.000   8.000  -5.000 100.000
     40.000   9.000   6.000  50.000
      7.000  10.000   9.000  20.000
      0.000   0.000   0.000   1.000

   // Note: It shows the matrix columns, not the matix rows.
   root [39] glm::to_string(M)
   (std::string) "mat4x4((25.000000, 40.000000, 7.000000, 0.000000), (8.000000, 9.000000, 10.000000, 0.000000), (-5.000000, 6.000000, 9.000000, 0.000000), (100.000000, 50.000000, 20.000000, 1.000000))"
   root [40]

#+END_SRC

Extract columns from matrix MM:

#+BEGIN_SRC cpp
   #include <glm/gtc/matrix_access.hpp>

   auto col0 = glm::column(MM, 0)
   auto col1 = glm::column(MM, 1)
   auto col2 = glm::column(MM, 2)
   auto col3 = glm::column(MM, 3)

   root [58] glm::to_string(col0)
   (std::string) "vec4(25.000000, 40.000000, 7.000000, 0.000000)"

   root [60] glm::to_string(col1)
   (std::string) "vec4(8.000000, 9.000000, 10.000000, 0.000000)"

   root [62] glm::to_string(col2)
   (std::string) "vec4(-5.000000, 6.000000, 9.000000, 0.000000)"

   root [64] glm::to_string(col3)
   (std::string) "vec4(100.000000, 50.000000, 20.000000, 1.000000)"

   // Get elements from column 0 (col0)
   root [65] col0[0]
   (float) 25.0000f

   root [66] col0[1]
   (float) 40.0000f

   root [67] col0[2]
   (float) 7.00000f

   root [68] col0[3]
   (float) 0.00000f
#+END_SRC

Extract rows from matrix MM:

#+BEGIN_SRC cpp
   auto row0 = glm::row(MM, 0)
   auto row1 = glm::row(MM, 1)
   auto row2 = glm::row(MM, 2)
   auto row3 = glm::row(MM, 3)

   root [73] glm::to_string(row0)
   (std::string) "vec4(25.000000, 8.000000, -5.000000, 100.000000)"

   root [74] glm::to_string(row1)
   (std::string) "vec4(40.000000, 9.000000, 6.000000, 50.000000)"

   root [75] glm::to_string(row2)
   (std::string) "vec4(7.000000, 10.000000, 9.000000, 20.000000)"

   root [76] glm::to_string(row3)
   (std::string) "vec4(0.000000, 0.000000, 0.000000, 1.000000)"
#+END_SRC

Modify matrix columns:

#+BEGIN_SRC cpp
   root [77] show_matrix("MM", MM)

    [MATRIX] MM =
     25.000   8.000  -5.000 100.000
     40.000   9.000   6.000  50.000
      7.000  10.000   9.000  20.000
      0.000   0.000   0.000   1.000

   root [80] MM[0] = glm::vec4(-90.f, 50.0f, 32.5f, 26.0f)


   root [81] show_matrix("MM", MM)

    [MATRIX] MM =
    -90.000   8.000  -5.000 100.000
     50.000   9.000   6.000  50.000
     32.500  10.000   9.000  20.000
     26.000   0.000   0.000   1.000
#+END_SRC


Obtain transpose matrix:

#+BEGIN_SRC cpp
   root [82] auto tmat = glm::transpose(MM)
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f7b71f0c20c


   root [83] show_matrix("tmat", tmat)

    [MATRIX] tmat =
    -90.000  50.000  32.500  26.000
      8.000   9.000  10.000   0.000
     -5.000   6.000   9.000   0.000
    100.000  50.000  20.000   1.000

  // ----- Access first column elements (column 0) ----//
  //  =>> The matrix is column-major order (Fortran-like data layout),
  //      not C or C++ data-layout, which is row-major order
  //
  // Tmat[j column-number][i row-number]

  // ----- Column 0 elements ----------//

  root [84] tmat[0][0]
  (float) -90.0000f

  root [85] tmat[1][0]
  (float) 50.0000f

  root [86] tmat[0][0]
  (float) -90.0000f

  root [87] tmat[0][1]
  (float) 8.00000f

  root [88] tmat[0][2]
  (float) -5.00000f

  root [89] tmat[0][3]
  (float) 100.000f
#+END_SRC

Get pointer to first element:

#+BEGIN_SRC cpp
   root [90] float* ptr = glm::value_ptr(tmat)
   (float *) 0x7f7b71f0c20c

   root [91] ptr[0]
   (float) -90.0000f

   root [92] ptr[1]
   (float) 8.00000f

   root [93] ptr[15]
   (float) 1.00000f

   root [94] ptr[10]
   (float) 9.00000f

   root [95] *(ptr + 1)
   (float) 8.00000f

   root [96] *(ptr + 10)
   (float) 9.00000f

   root [97] *(ptr + 15)
   (float) 1.00000f
#+END_SRC

Null 4x4 matrix:

#+BEGIN_SRC cpp
   root [53] auto zero_4x4 = glm::mat4()
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c20e0

   root [54] show_matrix("zero_4x4", zero_4x4)

    [MATRIX] zero_4x4 =
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
#+END_SRC

Identity matrix:

#+BEGIN_SRC cpp
  root [55] auto id_4x4 = glm::mat4(1.0)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2120
  root [56]
  root [56] show_matrix("id_4x4", id_4x4)

   [MATRIX] id_4x4 =
     1.000   0.000   0.000   0.000
     0.000   1.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
#+END_SRC

Matrix translation coordinate transform:

#+BEGIN_SRC cpp
  root [58] auto t1 = glm::translate(id_4x4, glm::vec3(2.0, 10.0, 30.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2160

  root [59] show_matrix("t1", t1)

   [MATRIX] t1 =
     1.000   0.000   0.000   2.000
     0.000   1.000   0.000  10.000
     0.000   0.000   1.000  30.000
     0.000   0.000   0.000   1.000


  root [62] auto t2 = glm::translate(t1, glm::vec3(-10, 100.0, 200.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c21a0

  root [63] show_matrix("t2", t2)

   [MATRIX] t2 =
     1.000   0.000   0.000  -8.000
     0.000   1.000   0.000 110.000
     0.000   0.000   1.000 230.000
     0.000   0.000   0.000   1.000
#+END_SRC

Rotation around Z axis of 90 degrees:

  + glm::mat4 glm::rotate(glm::mat4 const& matrix, float angle_radians, glm::vec3 const& axis)
  + Rotate around a given axis. The angle is given in radians.

#+BEGIN_SRC cpp
  root [65] const auto axis_z = glm::vec3(0.0f, 0.0f, 1.0f);
  root [66] const auto axis_y = glm::vec3(0.0f, 1.0f, 0.0f);
  root [67] const auto axis_x = glm::vec3(1.0f, 0.0f, 0.0f);


  /*          | cos(t)  -sin(t)   0   0  |
   *          | sin(t)   cos(t)   0   0  |
   *  Rz(t) = |  0        0       1   0  |
   *          |  0        0       0   1  |
   *
   *
   *  t_rotZ = Rz(90) x id_4x4 = Rz(90)
   */
  root [71] auto t_rotZ = glm::rotate(id_4x4, glm::radians(90.0f), axis_z)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2204

  root [72] show_matrix("t_rotZ", t_rotZ)

   [MATRIX] t_rotZ =
    -0.000  -1.000   0.000   0.000
     1.000  -0.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
  root [73]

   root [96] glm::to_string(t_rotZ)
   (std::string) "mat4x4((-0.000000, 1.000000, 0.000000, 0.000000), ... "
   root [97]
#+END_SRC

Scaling transformation:

#+BEGIN_SRC cpp
   root [75] auto s1 = glm::scale(id_4x4, glm::vec3(2.0, 2.0, 2.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2244

   root [76] show_matrix("s1", s1)

    [MATRIX] s1 =
      2.000   0.000   0.000   0.000
      0.000   2.000   0.000   0.000
      0.000   0.000   2.000   0.000
      0.000   0.000   0.000   1.000

   root [78] s1 = glm::scale(s1, glm::vec3(5.0, 5.0, 5.0))
   (glm::mat &) @0x7f904e6c2244

   root [79] show_matrix("s1", s1)

    [MATRIX] s1 =
     10.000   0.000   0.000   0.000
      0.000  10.000   0.000   0.000
      0.000   0.000  10.000   0.000
      0.000   0.000   0.000   1.000
   root [80]

   // Apply transform to vector:

   root [82] auto res = s1 * glm::vec4(2.0, 5.0, 10.0, 1.0)
   (glm::vec<4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2284

   root [91] glm::to_string(res)
   (std::string) "vec4(20.000000, 50.000000, 100.000000, 1.000000)"

   root [92] res[0]
   (float) 20.0000f

   root [93] res[1]
   (float) 50.0000f

   root [94] res[2]
   (float) 100.000f

   root [95] res[3]
   (float) 1.00000f
#+END_SRC

Scaling transformation:

#+BEGIN_SRC cpp
   root [97] auto s = glm::scale(id_4x4, glm::vec3(4.0, 5.0, 6.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c22a4

   root [98] show_matrix("s", s)

    [MATRIX] s =
      4.000   0.000   0.000   0.000
      0.000   5.000   0.000   0.000
      0.000   0.000   6.000   0.000
      0.000   0.000   0.000   1.000
   root [99]
   root [99] s = glm::translate(s, glm::vec3(4, -5, 9))
   (glm::mat &) @0x7f904e6c22a4


   root [100] show_matrix("s", s)

    [MATRIX] s =
      4.000   0.000   0.000  16.000
      0.000   5.000   0.000 -25.000
      0.000   0.000   6.000  54.000
      0.000   0.000   0.000   1.000
   root [101]


   root [105] s = glm::scale(s, glm::vec3(5.0, 2.0, 3.0))
   (glm::mat &) @0x7f904e6c22a4


   root [106] show_matrix("s", s)

    [MATRIX] s =
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000
#+END_SRC

Inverse matrix:

#+BEGIN_SRC cpp
   root [111] show_matrix("s", s)

    [MATRIX] s =
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000

   root [112] inv_s = glm::inverse(s)
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2324

   root [113] show_matrix("inv_s", inv_s)

    [MATRIX] inv_s =
      0.040  -0.000   0.000  -0.800
     -0.000   0.250  -0.000   2.500
      0.000  -0.000   0.111  -3.000
     -0.000   0.000  -0.000   1.000
   root [114]
   root [114]

#+END_SRC


  *GLM Quaternions*

Create an identity quaternion, which represents no rotation.

#+BEGIN_SRC cpp
   root [26] auto q = glm::quat(1.0, 0.0, 0.0, 0.0)
   (glm::qua<float, glm::qualifier::packed_highp> &) @0x7fc8b47e6020

   root [27] q.x
   (float) 0.00000f
   root [28]
   root [28] q.y
   (float) 0.00000f
   root [29]
   root [29] q.z
   (float) 0.00000f
   root [30]
   root [30] q.w
   (float) 1.00000f
   root [31]
   root [31]
#+END_SRC

Create a quaternion that represents a rotation of 90 degrees around Z
axis:

#+BEGIN_SRC cpp
   root [39] auto qrot_z = glm::angleAxis(glm::radians(90.0f), glm::vec3{0.0f, 0.0f, 1.0f} )
   (glm::qua<float, glm::qualifier::packed_highp> &) @0x7fc8b47e6050

   root [40] glm::to_string(qrot_z)
   (std::string) "quat(0.707107, {0.000000, 0.000000, 0.707107})"

   root [42] qrot_z.w
   (float) 0.707107f

   root [43] qrot_z.x
   (float) 0.00000f

   root [44] qrot_z.y
   (float) 0.00000f

   root [45] qrot_z.z
   (float) 0.707107f
#+END_SRC

Get quaternion angle:

#+BEGIN_SRC cpp

  // Angle in radians.
  root [61] glm::angle(qrot_z)
  (float) 1.57080f

  // Angle in degrees
  root [62] glm::angle(qrot_z) * 180.0 / M_PI
  (double) 90.000003
#+END_SRC

Get quaternion rotation axis vector:

#+BEGIN_SRC cpp
   root [63] auto axis = glm::axis(qrot_z)
   (glm::vec<3, float, glm::qualifier::packed_highp> &) @0x7fc8b47e6150

   root [64] glm::to_string(axis)
   (std::string) "vec3(0.000000, 0.000000, 1.000000)"
#+END_SRC

Determine quaternion conjugate:

#+BEGIN_SRC cpp
   // Conjugate
   root [68] auto res = glm::conjugate(qrot_z)
   (glm::qua<float, glm::qualifier::packed_highp> &) @0x7fc8b47e616c

   root [69] glm::to_string(res)
   (std::string) "quat(0.707107, {-0.000000, -0.000000, -0.707107})"

   root [71] glm::to_string( qrot_z * res )
   (std::string) "quat(1.000000, {0.000000, 0.000000, 0.000000})"
#+END_SRC

Determine quaternion inverse:

#+BEGIN_SRC cpp
  root [72] glm::to_string( glm::inverse(qrot_z) )
  (std::string) "quat(0.707107, {-0.000000, -0.000000, -0.707107})"
#+END_SRC

Computer quaternion norm (aka magnitude):

#+BEGIN_SRC cpp
  root [74] glm::length(qrot_z)
  (float) 1.00000f
#+END_SRC


Turn the previous quaternion in to a rotation matrix:

#+BEGIN_SRC cpp
   root [47] auto TrotZ1 = glm::mat4_cast(qrot_z)

   root [48] show_matrix("TrotZ1", TrotZ1)

    [MATRIX] TrotZ1 =
      0.000  -1.000   0.000   0.000
      1.000   0.000   0.000   0.000
      0.000   0.000   1.000   0.000
      0.000   0.000   0.000   1.000

   // ------------ Confirm result ------------//
   //

   root [51] auto TrotZ2 = glm::rotate(glm::mat4(1.0), glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0))

   root [52] show_matrix("TrotZ2", TrotZ2)

    [MATRIX] TrotZ2 =
     -0.000  -1.000   0.000   0.000
      1.000  -0.000   0.000   0.000
      0.000   0.000   1.000   0.000
      0.000   0.000   0.000   1.000

#+END_SRC

Rotate a vector with the quaternion _qrot_z_:

#+BEGIN_SRC cpp
   root [57] auto v = glm::vec3{1.0f, 0.0f, 0.0f}
   (glm::vec<3, float, glm::qualifier::packed_highp> &) @0x7fc8b47e6138

   // Rotating a vector just requires multiplication.
   root [59] auto rotated_v = qrot_z * v
   (glm::vec<3, float, glm::qualifier::packed_highp> &) @0x7fc8b47e6144

   root [60] glm::to_string(rotated_v)
   (std::string) "vec3(0.000000, 1.000000, 0.000000)"


   // Rotate the same vector with a rotation matrix.
   root [79] glm::to_string( TrotZ2 * glm::vec4(1.0, 0.0, 0.0, 0.0) )
   (std::string) "vec4(-0.000000, 1.000000, 0.000000, 0.000000)"
#+END_SRC

New rotation around Y axis about 60 degrees.

#+BEGIN_SRC cpp
   root [80] auto q = qrot_z
   (glm::qua<float, glm::qualifier::packed_highp> &) @0x7fc8b47e617c

   // ---------- Before rotation ------------
   //
   root [81] glm::to_string( q )
   (std::string) "quat(0.707107, {0.000000, 0.000000, 0.707107})"

   // -------- After rotation ----------------//
   //
   root [84] q = q * glm::angleAxis(glm::radians(60.0f), glm::vec3{0.0, 0.1, 0.0})
   (glm::qua<float, (qualifier)0U> &) @0x7fc8b47e617c

   root [85] glm::to_string( q )
   (std::string) "quat(0.612372, {-0.035355, 0.035355, 0.612372})"

   // --------- Get Rotation Matrix -----------//

   root [86] auto m = glm::mat4_cast(q)

   root [88] show_matrix("m", m)

    [MATRIX] m =
      0.248  -0.752   0.000   0.000
      0.747   0.248   0.087   0.000
     -0.087   0.000   0.995   0.000
      0.000   0.000   0.000   1.000

   // -------- Get total rotation angle and axis ---------//
   //

   // Get new rotation axis
   root [89] auto axis = glm::axis(q)
   (glm::vec<3, float, glm::qualifier::packed_highp> &) @0x7fc8b47e61cc

   root [90] glm::to_string( axis )
   (std::string) "vec3(-0.044721, 0.044721, 0.774597)"

   // Get rotation angle around new axis in radians
   root [91] glm::angle(q)
   (float) 1.82348f

   // Get rotation angle around new axis in degrees
   root [92] glm::angle(q) * 180.0 / M_PI
   (double) 104.47752


   //--------- Get Yaw, Pitch and Roll angles --------------------//
   //
   root [94] glm::yaw(q) * 180.0 / M_PI
   (double) 4.9681836

   root [95] glm::pitch(q) * 180.0 / M_PI
   (double) 0.0000000

   root [96] glm::roll(q) * 180.0 / M_PI
   (double) 90.000003

#+END_SRC

** [DRAFT] Debugging Computer Graphics Code

Outline of techniques for debugging computer graphics code:

  + Use _right-hand rule_ for finding rotation direction around some
    rotation axis.

  + Use _right-hand rule_ for finding X, Y and Z axis directions.

  + Print/display transform matrices.

  + Use assertions for validating code assumptions during runtime and
    abort the process execution if the assertion predicate does not
    hold.

  + Use print statements for tracing the code execution flow.

  + Draw X, Y, Z axis lines for visual debugging.

  + Check shader compilation error message and error code.

  + Check OpenGL error codes for every OpenGL subroutine calls.

  + Simulate and prototype linear algebra parts in a
    numerically-oriented or scientific programming language such
    Matlab, Octave or Julia.

  + Use a _debugger_, such as Windows Debugger, GDB, LLDB - LVM
    Debugger, in the case of runtime crash due to failed assertions,
    std::abort() calls, uncaught exceptions, Unix signals or
    segmentation faults.

 *Assertions*

The subroutine glGetUniformLocation() returns -1 as error code when it
fails to find a shader's uniform variable location named
'u_projection'.

#+BEGIN_SRC cpp
    // Get shader uniform variable location for projection matrix
    // See shader code: "uniform mat4 projection;"
    const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
    assert( u_proj >= 0 && "Failed to find u_projection uniform variable" );
#+END_SRC

Assertions should be used for non-recoverable errors, checking
pre-conditions, post-conditons and invariant. Since assertions are
eliminated on non-debug builds, this assertion should be replaced by a
proper error checking. However, in this case, assertion are useful
for a prototyping code and during development time as a scaffolding
for a future error handling.


 *Checking OpenGL error code*

#+BEGIN_SRC cpp
  #define GL_CHECK(funcall)\
      do { \
          (funcall); \
          GLint error = glGetError();  \
          if(error == GL_NO_ERROR){ break; } \
          std::fprintf(stderr, " [OPENGL ERROR] Error code = %d ; line = %d ; call = '%s'  \n" \
                        , error, __LINE__, #funcall ); \
          abort(); \
      } while(0)

 // -------- Usage ---------------//

    GL_CHECK( glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model) ) );
    GL_CHECK( glBindVertexArray(vao) );
    GL_CHECK( glDrawArrays(draw_type, 0, n_vertices) );

#+END_SRC

** 2D Graphics - using VBO

The following code draws a square and a triangle using the OpenGL
retained mode API. Before the rendering takes place, data must be
upload to the VBO (Vertex Buffer Object), allocated on the GPU-side,
via _glBufferData()_ call that sends the data to the previous bound VBO
through _glBindBuffer()_ call. Then, on the rendering loop and on every
frame, the buffer data layout must described with
_glVertexAttribPointer()_ before drawing via call to _glDrawArrays()_
subroutine, which draw vertices from the current bound buffer.

Subroutines that modifies global state may cause unintended behavior,
so it is a good practice to unset the affected global state when the
current global state is no longer needed. For instance, if the current
VBO no longer needs to be bound, this global state can be disabled by
calling /glBindBuffer(GL_ARRAY_BUFFER, 0)/.


OpenGL subroutines used:

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml][glGenBuffers()]] => Instantiate a buffer object.

#+BEGIN_SRC cpp
  void glGenBuffers(GLsizei n, GLuint* buffers);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml][glBindBuffer()]] => Bind some buffer object, a.k.a enable, only one
   buffer can be bound at a time. (The VBO is a global state).

#+BEGIN_SRC cpp
  void glBindBuffer(GLenum target,nt buffer);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml][glBufferData()]]  =>> Send data to current bound buffer object that
   was bound via glBindBuffer() call.

#+BEGIN_SRC cpp
  void glBufferData( GLenum      target,
                     GLsizeiptr  size,
                     const void* data,
                     GLenum      usage
                     );
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml][glEnableVertexAttribArray()]]

#+BEGIN_SRC cpp
  void glEnableVertexAttribArray(GLuint index);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml][glVertexAttribPointer()]]
   + Describes the data layout of current bound buffer.

#+BEGIN_SRC cpp
     void glVertexAttribPointer( GLuint      index,
                                 GLint       size,
                                 GLenum      type,
                                 GLboolean   normalized,
                                 GLsizei     stride,
                                 const void* pointer);
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml][glDrawArrays()]] => Render OpenGL primitives from current bound
    buffer object's data. Those primitives are: lines, triangles or
    quads and so on.

#+BEGIN_SRC cpp
  void glDrawArrays(GLenum mode, GLint first, GLsizei count);
#+END_SRC


  *Screenshot*

[[file:images/opengl-draw2d-raw.png][file:images/opengl-draw2d-raw.png]]

  *Source Code*

  + This CMakeLists.txt building script saves the user from manually
    downloading, building, installing and configuring OpenGL Glew and
    GLFW companion libraries. This file automatically downloads the
    GLFW library, that provides window system abstraction and OpenGL
    context; and a pre-compiled GLEW library (Windows only) that
    provides platform-agnostic OpenGL function pointer loading.

  + The CMakeLists.txt (version 2) contains a macro for defining
    OpenGL applications without the boilerplate needed for linking
    against OpenGL companion libraries and statically linking against
    MINGW runtimme libraries. 

File: _CMakeLists.txt_ (Version 1)

#+BEGIN_SRC cmake 
   make_minimum_required(VERSION 3.5)
   project(OpenGL_Draw2D_VBO)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download pre-compiled GLEW when building under Windows NT OS (x64)
   IF(WIN32)
      FetchContent_Declare(
         glew-release 
         URL     https://megalink.dl.sourceforge.net/project/glew/glew/2.1.0/glew-2.1.0-win32.zip
         # https://github.com/nigels-com/glew/archive/glew-2.2.0.zip
      )
      FetchContent_MakeAvailable(glew-release)
      include_directories( ${glew-release_SOURCE_DIR}/include  ${glm_SOURCE_DIR} )        
      link_directories(  ${glew-release_SOURCE_DIR}/lib/Release/x64 )

      set( GLEW_LIB_PATH1 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32.lib )
      set( GLEW_LIB_PATH2 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32s.lib )
   ENDIF()

      # ======= T A R G E T S ============================#
      #                                                   #


          add_executable( draw2d-raw  draw2d-raw.cpp )
   target_link_libraries( draw2d-raw  glfw
                                      OpenGL::GL
                                      ${GLEW_LIB_PATH1} ${GLEW_LIB_PATH2}  )

   # For MINGW (GCC Ported to Windows)				 
   IF(MINGW)
      # Statically link against MINGW dependencies
      # for making easier to deploy on other machines. 
      target_link_options( draw2d-raw PRIVATE                                 
                               -static-libgcc
                               -static-libstdc++

                               -Wl,-Bstatic,--whole-archive -lwinpthread
                                 -Wl,--no-whole-archive				     
                               )
   ENDIF()       


   # Copy GLEW DLL shared library to same directory as the executable.				 
   IF(WIN32)				 
      add_custom_command(TARGET draw2d-raw POST_BUILD 
                     COMMAND ${CMAKE_COMMAND} -E copy_if_different
                     "${glew-release_SOURCE_DIR}/bin/Release/x64/glew32.dll"              
                     $<TARGET_FILE_DIR:draw2d-raw>)
   ENDIF()	   

#+END_SRC

File: _CMakeLists.txt_ (Version 2)

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.5)
   project(OpenGL_Draw2D_VBO)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download pre-compiled GLEW when building under Windows NT OS (x64)
   IF(WIN32)
      FetchContent_Declare(
         glew-release 
         URL     https://megalink.dl.sourceforge.net/project/glew/glew/2.1.0/glew-2.1.0-win32.zip
         # https://github.com/nigels-com/glew/archive/glew-2.2.0.zip
      )
      FetchContent_MakeAvailable(glew-release)
      include_directories( ${glew-release_SOURCE_DIR}/include  ${glm_SOURCE_DIR} )        
      link_directories(  ${glew-release_SOURCE_DIR}/lib/Release/x64 )

      set( GLEW_LIB_PATH1 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32.lib )
      set( GLEW_LIB_PATH2 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32s.lib )
   ENDIF()


   MACRO(ADD_OPENGL_APP target sources)
      add_executable( ${target} ${sources} )
      message([TRACE] " Add OpenGL executable = ${target} ")

      target_link_libraries( ${target} glfw
                                       OpenGL::GL
                                       ${GLEW_LIB_PATH1}
                                       ${GLEW_LIB_PATH2} )

       IF(MINGW)
           # Statically link against MINGW dependencies
           # for making easier to deploy on other machines. 
           target_link_options( ${target} PRIVATE                                 
                                    -static-libgcc
                                    -static-libstdc++
                                    -Wl,-Bstatic,--whole-archive -lwinpthread
                                      -Wl,--no-whole-archive				     
                                    )
        ENDIF()       


        # Copy GLEW DLL shared library to same directory as the executable.		 
        IF(WIN32)				 
           add_custom_command(TARGET ${target} POST_BUILD 
                          COMMAND ${CMAKE_COMMAND} -E copy_if_different
                          "${glew-release_SOURCE_DIR}/bin/Release/x64/glew32.dll"              
                          $<TARGET_FILE_DIR:${target}>)
        ENDIF()	   				   
   ENDMACRO()     

        # ======= T A R G E T S ============================#
        #                                                   #

   ADD_OPENGL_APP( draw2-raw draw2d-raw.cpp )
#+END_SRC

File: _draw2d-raw.cpp_

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions


  #if defined(_WIN32)
     #include <windows.h>
     #include <GL/glew.h>
  #endif

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  #include <GL/glu.h>
  // #include <GL/glut.h>


  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      // Initialize GLFW 
      if (!glfwInit()){ return -1; }

    
      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "2D Drawing raw VBO buffers", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);

      // --- GLEW should always be initialized after an OpenGL context.
      #if _WIN32
      glewExperimental = GL_TRUE;
      if (glewInit() != GLEW_OK) {
          std::cerr << "GLEW::Error : failed to initialize GLEW"<< std::endl;
      }
      std::fprintf(stderr, " [TRACE] Glew Initialized Ok. \n");
      #endif
    

      Vertex2D triangle_points[3] = {
          Vertex2D{-0.25,   -0.25}
        , Vertex2D{ 0.00,   0.25}
        , Vertex2D{ 0.25,  -0.25}
      };

      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      // ================== Triangle Buffer ====================//
      //

      GLuint vbo_triangle_ = 0;

      // Create an OpenGL VBO buffer
      // =>> void glGenBuffers (GLsizei n, GLuint *buffers);
      glGenBuffers(  1                // Number of buffers that will be instantiated
                   , &vbo_triangle_   // Address of first element or address of array
                                      // that results will be written to.
                   );
      assert( vbo_triangle_ != 0 );

      // Set this buffer as the current buffer - Only one buffer can be bound at a time.
      // =>> void glBindBuffer (GLenum target, GLuint buffer)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);

      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, sizeof(triangle_points), triangle_points, GL_STATIC_DRAW);

      // Unbind current buffer in order to avoid unintended behaviors
      // as the subroutine glBindBuffer() modifies has a global state.
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      // ================ Square / Vertex Buffer Object 2 ==================//
      //

      GLuint vbo_square_ = 0;
      // Instiate buffer - gets a handle or token for
      // a buffer allocated on GPU-side.
      glGenBuffers(1, &vbo_square_);
      // Check for error
      assert( vbo_square_ != 0);
      // Bind Current buffer (Affects global state)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
      // Upload data to the GPU
      glBufferData(GL_ARRAY_BUFFER, sizeof(square_points), square_points, GL_STATIC_DRAW);
      // Unbind buffer
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      GLint shader_attr = 0;

      //  ======= R E N D E R  - L O O P ============//
      //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // ------------ Draw triangle --------------//
              //
              glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);
              glEnableVertexAttribArray(shader_attr);

              // Describe buffer data layout (binary layout)
              // =>> glVertexAttribPointer ( GLuint index, GLint size, GLenum type
              //                           , GLboolean normalized, GLsizei stride, const void *pointer);
              //
              glVertexAttribPointer(shader_attr // GLint  index         => Shader attribute location, 0 for now
                                  , 2           // GLint  size          => 2 components (X, Y) of type GLfloat
                                  , GL_FLOAT    // GLemum type          => Type of each component
                                  , GL_FALSE    // GLboolean normalized
                                  , 0           // GLsizei stride
                                  , nullptr     // const void* pointer
                                  );
              // Draw arrays using the content of buffer
              // Plot 1 triangle (each triangle has 3 vertices)
              glDrawArrays(GL_TRIANGLES, 0, 3);

              // Disable global state
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(0);

              //------------ Draw Square -------------------------//
              //

              #if 1
              glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
              glEnableVertexAttribArray(shader_attr);
              glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);
              // Plot 4 vertices
              glDrawArrays(GL_LINE_LOOP, 0, 4);

              // Disable global state
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(shader_attr);
              #endif

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      glfwTerminate();
      return 0;
  }

#+END_SRC

  *Building on Linux* 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build_linux -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build_linux --target 
 
  # Run 
  $ _build_linux/draw2d-raw 
#+END_SRC

 *Building with dockercross tool (cross compilation for Windows)*

 + See: Cross compiling toolchains in Docker images
   + =>> https://github.com/dockcross/dockcross 

#+BEGIN_SRC sh 
  $ docker run -it --rm -v $PWD:/cwd -w /cwd --entrypoint=bash dockcross/windows-static-x64

  $ cmake -H. -B_build_cross -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build_cross --target

#+END_SRC

List build directory:

#+BEGIN_SRC sh 
  $ ls _build_cross
  CMakeCache.txt CMakeFiles  Makefile  _deps  cmake_install.cmake  draw2d-raw.exe  glew32.dll
#+END_SRC

Run executable with *wine* on Linux: 

#+BEGIN_SRC sh 
  $ wine _build_cross/draw2d-raw.exe 
#+END_SRC

 *Building on Windows with MINGW (GCC ported to Windows)* 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build_mingw -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build_mingw --target
#+END_SRC

Run executable: 

#+BEGIN_SRC sh 
  # On Window
  $ _build_mingw\draw2d-raw.exe 

  # on Linux via wine 
  $ wine _build_mingw\draw2d-raw.exe  
#+END_SRC
** 2D Graphics - using VAO

A VAO (Vertex Array Object) is an object that stores all the
information necessary to render a VBO (Vertex Buffer Object). For
instance, a VAO allows rendering the data, by performing the following
set of operations only once: 1 - binding the VAO; 2 - binding the
buffer via glBindBuffer() call; 3 - enabling the vertex attribute via
glEnableVertexAttribArray(); 4 - setting the data layout by calling
glVertexAttribPointer() subroutine. Without a VAO, all those
subroutines would need to be called on every frame rendering.

Algorithm for VAO usage:

 + Setup

#+BEGIN_SRC cpp
   // Shader attribute location
   GLint shader_attr = 1;

   // -------------- Setup VAO --------------------//
   //
   GLuint vao;
   glGenVertexArrays(1, &vao); // Instantiate VAO

   GLuint vbo;
   glGenBuffers(1, &vbo);
   // Bind VBO (Recorded by VAO)
   glBindBuffer(GL_ARRAY_BUFFER, vbo);

   // Upload data to GPU
   glBufferData(GL_ARRAY_BUFFER, buffer_size, buffer, GL_STATIC_DRAW);

   glEnableVertexAttribArray(shader_attr);

   // Set buffer data layout (Recorded by VAO)
   glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

   // ------- Disable Global state ---------//

   // Unbind VAO
   glBindVertexArray(0);
   // Unbind VBO
   glBindBuffer(GL_ARRAY_BUFFER, vbo);
   // Disable current shader attribute
   glDisableVertexAttribArray(shader_attr);
#+END_SRC

 + Rendering loop

#+BEGIN_SRC cpp
         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...

    //  ======= R E N D E R  - L O O P ============//
    //                                             //
    while ( !glfwWindowShouldClose(window) )
    {
        glClear(GL_COLOR_BUFFER_BIT);
         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...

         glBindVertexArray(vao);
         glDrawArrays(GL_LINE_LOOP, 0, NUMBER_OF_VERTICES);

         glBindVertexArray(vao1);
         glDrawArrays(GL_LINE_TRIANGLES, 0, NUMBER_OF_VERTICES_1);

         glBindVertexArray(vao2);
         glDrawArrays(GL_LINES, 0, NUMBER_OF_VERTICES_2);

         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...

        /* Swap front and back buffers */
        glfwSwapBuffers(window);
        /* Poll for and process events */
        glfwPollEvents();
    }
#+END_SRC


 *Further Reading*

  + [[https://www.khronos.org/opengl/wiki/Tutorial2:_VAOs,_VBOs,_Vertex_and_Fragment_Shaders_(C_/_SDL)][Tutorial2: VAOs, VBOs, Vertex and Fragment Shaders (C / SDL) - OpenGL Wiki]]

  + [[https://android-developers.googleblog.com/2015/10/game-performance-vertex-array-objects.html][Android Developers Blog: Game Performance: Vertex Array Objects]]

  + [[https://android-developers.googleblog.com/2015/03/today-we-want-to-share-some-best.html][Android Developers Blog: Game Performance: Layout Qualifiers]]

  + [[https://stackoverflow.com/questions/28270954/process-of-setting-up-a-vao-in-opengl][c++ - Process of setting up a VAO in OpenGL - Stack Overflow]]

  + [[https://stackoverflow.com/questions/8923174/opengl-vao-best-practices][OpenGL VAO best practices - Stack Overflow]]

  + [[https://computergraphics.stackexchange.com/questions/5895/what-is-an-opengl-vao-in-a-nutshell][vertex buffer object - What is an OpenGL VAO in a nutshell?]]  -
    Computer Graphics Stack Exchange

  + [[https://gamedev.stackexchange.com/questions/92832/in-opengl-whats-quicker-lots-of-smaller-vaos-or-one-large-one-updated-each-fr][performance - In OpenGL what's quicker]] - , lots of smaller VAOs,
    or one large one updated each frame? - Game Development Stack
    Exchange.

  + [[https://stackoverflow.com/questions/18485381/opengl-how-many-vaos][OpenGL How Many VAOs - Stack Overflow]]


  *Screenshot*

#+CAPTION: 2D OpenGL draw using VAO - Vertex Array Object
[[file:images/opengl-draw2-vao.png][file:images/opengl-draw2-vao.png]]

  *Sample Code*

File: CMakeLists.txt

#+BEGIN_SRC cmake
    cmake_minimum_required(VERSION 3.5)
    project(draw2d)

    set(CMAKE_CXX_STANDARD 17)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    set(CMAKE_VERBOSE_MAKEFILE ON)

    #================ GLFW Settings  ===============#

    find_package(OpenGL REQUIRED)

    include(FetchContent)

    # Set GLFW Options before FectchContent_MakeAvailable
    set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

    # Donwload GLFW library
    FetchContent_Declare(
      glfwlib
      URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
    )
    FetchContent_MakeAvailable(glfwlib)

           add_executable( draw2d-vao  draw2d-vao.cpp )
    target_link_libraries( draw2d-vao  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d-vao.cpp_

#+BEGIN_SRC cpp
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>


  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  // Upload buffer from main memory to GPU VBO
  // =>> Parameters VAO, VBO are allocated by the caller.
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer
                    , GLint   shader_attr // Shader attribute location
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate
                    );

  void* map_buffer( GLuint* pVao         // Pointer to VAO - allocated by calling code.
                  , GLuint* pVbo         // Pointer to VBO - allocated by calling code.
                  , GLsizei data_size    // Total size in bytes that is allocated to buffer
                  , GLint   shader_attr  // Shadder attribute location id (0 - zero) is there is no shader.
                  , GLint   size         // Number of component of each vertex
                  , GLenum  type         // Type of each vertex element
                  );


  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "2D Drawing using VAO", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);

      // Shader attribute location (default 0)
      GLint shader_attr = 0;


      // ================ Square / Vertex Buffer Object 2 ==================//
      //

      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      GLuint vao_square = 0;
      GLuint vbo_square = 0;

      // Upload square_points buffer data to GPU
      send_buffer( &vao_square, &vbo_square, sizeof(square_points)
                  , square_points, shader_attr, 2, GL_FLOAT );

      assert( vao_square != 0 );
      assert( vbo_square != 0 );

      std::fprintf( stderr, " [TRACE] vao_square = %d, vbo_square = %d \n"
                   , vao_square, vbo_square);


      // ============== Circle / Vertex Buffer Object 3 ==================//
      //
      GLuint vao_circle = 0;
      GLuint vbo_circle = 0;

      // Number of vertices to used to render the circle.
      constexpr size_t N_CIRCLE = 100;
      constexpr float  PI       = 3.1415927;
      const     float  radius   = 0.75;

      // C-style cast should not be used here
      Vertex2D* pCursor = (Vertex2D*) map_buffer( &vao_circle, &vbo_circle, N_CIRCLE * sizeof(Vertex2D)
                                                , shader_attr, 2, GL_FLOAT );

      float angle = 0.0;
      const float step = 2 * PI / N_CIRCLE;

      for(size_t n = 0; n < N_CIRCLE; n++)
      {
          pCursor[n].x = radius * cosf( angle );
          pCursor[n].y = radius * sinf( angle );
          angle = angle + step;
      }


      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              //------------ Draw Square -------------------------//
              //
               glBindVertexArray(vao_square);
              // Plot 4 vertices
              glDrawArrays(GL_LINE_LOOP, 0, 4);
              // Unbind vao (restore global state to default value)
              glBindVertexArray(0);

              //------------ Draw Circle -------------------------//
              //
              glBindVertexArray(vao_circle);
              glDrawArrays(GL_LINE_LOOP, 0, N_CIRCLE);
              glBindVertexArray(0);

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      // ---------- Dispose Buffer Objects ---------//
      glDeleteBuffers(1, &vbo_square);
      glDeleteBuffers(1, &vbo_circle);

      glfwTerminate();
      return 0;
  }

  // ---------- I M P L E M E N T A T I O N S ------------------//
  //                                                            //

  // Upload buffer from main memory to GPU VBO
  // =>> Parameters VAO, VBO are allocated by the caller.
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer
                    , GLint   shader_attr // Shader attribute location id
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate
                    )
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      glGenVertexArrays(1, &vao);
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);

      glEnableVertexAttribArray(shader_attr);

      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

      // ------ Disable Global state set by this function -----//
      //
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(shader_attr);

  }

  void* map_buffer( GLuint* pVao         // Pointer to VAO - allocated by calling code.
                  , GLuint* pVbo         // Pointer to VBO - allocated by calling code.
                  , GLsizei data_size    // Total size in bytes that is allocated to buffer
                  , GLint   shader_attr  // Shadder attribute location id (0 - zero) is there is no shader.
                  , GLint   size         // Number of component of each vertex
                  , GLenum  type         // Type of each vertex element
                  )
  {
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      glGenVertexArrays(1, &vao);
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      /** See: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml
       ,*  Khronos Group: "glMapBuffer and glMapNamedBuffer map the entire data store of
       ,*  a specified buffer object into the client's address space. The data can then be directly
       ,*  read and/or written relative to the returned pointer,
       ,*  depending on the specified access policy."
       ,*/
      glBufferData(GL_ARRAY_BUFFER, data_size, nullptr, GL_STATIC_DRAW);
      void* pbuffer = glMapBuffer( GL_ARRAY_BUFFER, GL_WRITE_ONLY );

      glEnableVertexAttribArray(shader_attr);
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

      // ------ Disable Global state set by this function -----//
      //
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(shader_attr);

      // ------- Return --------------------------------------//
      return pbuffer;
  }
#+END_SRC
** 2D Graphics - using shaders

OpenGL retained mode (programmable pipeline) uses shaders, which are
programs that uses GLSL (OpenGL shading language) programming
language, runs on the GPU (Graphics Processing Unit). A vertex shader
performs vertex coordinate transformations on all vertices and colors
received from VBO - Vertex Buffer Objects. The fragment shader runs
after the vertex shader and deals with vertice texture and color
computations.

A vertex shader has the following features:

 + Data types:
   + float => Float IEEE754 32 bits floating point scalar.
   + vec2 => Vector of 2 coordinates
   + vec3 => Vector of 3 coordinates
   + vec4 => Vector of 4 coordinates
   + mat2 => 2x2 matrix
   + mat4 => 4x4 homogeneous coordinate matrix
   + mat3 => 3x3 matrix

 + _uniform variables_ => Shader variables declared with _uniform_ storage
   qualifier. They allow passing data, such as transformation
   matrices, vectors or scalar values, from the C++-side to the shader
   program. Uniform variables can be used for passing the model matrix,
   camera matrix and projection matrix to the shader.
   * Declaration example: 'uniform mat4 u_model;'

 + _attribute variables_ => Used for passing vertices or color
   coordinates from VBOs (Vertex Buffer Objects). Those variables are
   only accessible in the shader.
   * Declaration example: 'layout ( location = 2)  in vec2 position;'

 + _Output_ => Shader programs uses pre-defined global variables for
   output, for instance, _gl_Position_, which sets the current vertex
   position in clip-space (NDC - Normalized Device Coordinates).



 *Documentation*

  + [[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)][Core Language (GLSL) - OpenGL Wiki]] / Khronos Group.
    + Syntax of GLSL (OpenGL shading language)

  + [[https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)][Data Type (GLSL) - OpenGL Wiki]] / Khronos Group

  + [[https://en.wikipedia.org/wiki/OpenGL_Shading_Language][OpenGL Shading Language - Wikipedia]]

  + [[https://www.khronos.org/opengl/wiki/Shader][Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Vertex_Shader][Vertex Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Fragment_Shader][Fragment Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Uniform_(GLSL)][Uniform (GLSL) - OpenGL Wiki]] / Khronos Group
    + Discusses shader uniform variables.

  + [[https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)][Layout Qualifier (GLSL) - OpenGL Wiki]] / Khronos Group
    + Shader attribute index (attribute location)

  + [[https://www.khronos.org/opengl/wiki/Geometry_Shader][Geometry Shader - OpenGL Wiki]] / Khronos Group.

  + [[https://www.khronos.org/opengl/wiki/Shader_Compilation][Shader Compilation - OpenGL Wiki]] / Khronos Group.

  + [[https://www.khronos.org/opengl/wiki/Vertex_Rendering][Vertex Rendering - OpenGL Wiki]]

  + [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Data][Data in WebGL - Web APIs | MDN]] / Mozilla
    + Explanation of shader's attribute variables and shader's uniform
      variables.

  *Source Code*

Summary:

 + This sample application, draws many 4 triangles from a 2 VBO
   (Vertex Buffer Object) and a single VAO (Vertex Array Object). The
   application uses a vertex shader for performing coordinate
   transformation for every triangle and drawing them at different
   position with different rotation angles around Z axis. The triangle
   'triangleD' follows the mouse position while the triangle
   'triangleB' rotates acoording to the mouse position.

 + The vertex shader has two attributes variables ('position' and
   'color') and two uniform variables u_model, that contains the model
   matrix from every rendered object, and u_projection, which contains
   the projection matrix.

Screenshot:

[[file:images/opengl-draw2d-shader.png][file:images/opengl-draw2d-shader.png]]


_Vertex Shader_ - Source Code (Extraced from _draw2d-shader.cpp_)

#+BEGIN_SRC cpp
    #version 330 core

    // Supplied by GPU - attribute location (id = 2)
    // contains a (X, Y) vertex
    layout ( location = 2)  in vec2 position;
    layout ( location = 1 ) in vec3 color;     // Contains (Red, Green, Blue) components

    // Output to fragment shader
    out vec3 out_color;

    // Model matrix => projection coordinates from the local space (model space)
    // to view space .
    // Transform 4x4 matrix - supplied by the C++ side.
    uniform mat4 u_model;

    // Projection matrix => projections camera-space coordinates
    // to clip-space coordinates. (-1.0 to 1.0) range.
    uniform mat4 u_projection;

    void main()
    {
        // gl_Position => Global output variable that holds the
        // the current vertex position. It is a vector of
        // components (X, Y, Z = 0, W = ignored)
        gl_Position = u_projection * u_model * vec4(position, 0, 1.0);

        // Forward to fragment shader
        out_color = color;
    }
#+END_SRC

_Fragment Shader_ -  Source Code (Extracted from _draw2d-shader.cpp_)


#+BEGIN_SRC cpp
   #version 330

   // This color comes from Vertex shader
   in vec3 out_color;

   void main()
   {
       // Set vertex colors
       gl_FragColor = vec4(out_color, 1.0);

   }
#+END_SRC

File: _CMakeLists.txt_

#+BEGIN_SRC cmake
   cmake_minimum_required(VERSION 3.5)
   project(GLFW_project)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw2d-shader  draw2d-shader.cpp   )
   target_link_libraries( draw2d-shader  glfw OpenGL::GL GLU )
#+END_SRC

File: _draw2d-shader.cpp_

#+BEGIN_SRC cpp
  // Draw many colored triangles from a single VBO (Vertex Buffer Object)
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <functional>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Librar ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>


  // Compile some  shader
  void compile_shader(GLuint m_program, const char* code, GLenum type);

  // Send data from memory to GPU VBO memory
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer
                    , GLint   shader_attr // Shader attribute location id
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate
                    );

  // ------------ Basic Data Structures -----------//

  // Wrapper for 2D vertex coordinates
  struct Vertex2D{  GLfloat x, y;  };
  // Wrapper for RGB colors
  struct ColorRGB { GLfloat r, g, b; };

  constexpr ColorRGB COLOR_R = { 1.0, 0.0, 0.0  }; // Red
  constexpr ColorRGB COLOR_G = { 0.0, 1.0, 0.0  }; // Green
  constexpr ColorRGB COLOR_B = { 0.0, 0.0, 1.0  }; // Blue


  class Model_Triangle
  {
      // Object position in World Coordinates
      float _x = 0.0, _y = 0.0;
      // Scale
      float _scale = 1.0;
      // Rotation angle around z axis
      float _angle = 0.0;

  public:
      Model_Triangle(float scale = 1.0){   }
      void rotate(float angle)          { _angle = angle; }
      void translate(float x , float y) { _x = x; _y = y; }
      void scale(float scale)           { _scale = scale; }
      void zoom(float factor)           {  _scale = factor + _scale; }

      // Render/draw this object
      void render(GLuint vao, GLint  u_model)
      {

          // Reset model matrix to indentiy matrix
          glm::mat4 _model(1.0);
          // Scale object (increase or decrease object size)
          _model =  glm::scale( _model, glm::vec3(_scale, _scale, _scale) );
          // Move to (X, Y) position
          _model = glm::translate( _model, glm::vec3(_x, _y, 0.0)  );
          // Rotate from a given angle around Z axis at current object X, Y  postion
          _model = glm::rotate( _model, glm::radians(_angle), glm::vec3(0, 0, 1) );

          // Set shader uniform variable.
          glUniformMatrix4fv(
              // Shader uniform variable location
              u_model
              // Number of matrices that will be set
              , 1
              // GL_FALSE => Matrix is in column-major order (Fortran matrix layout)
              // GL_TRUE  => Matrix is in row-major order (C, C++ array, matrix layout)
              , GL_FALSE
              // Pointer to first element transform matrix (homogeneous coordinate)
              , glm::value_ptr(_model)
          );
          glBindVertexArray(vao);
          // Draw 3 vertices
          glDrawArrays(GL_TRIANGLES, 0, 3);
          // Disable global state
          glBindVertexArray(0);
      }
  };


  // Global variable [WARNING] - Vulnerable to global "initialization fiasco"
  // undefined behavior.
  auto Cursor_Callback = std::function<void (GLFWwindow* window, double xpos, double ypos)>();

  int main(int argc, char** argv)
  {

      /* Initialize the library */
      if (!glfwInit()){ return -1; }

      // OpenGL Core Profile
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

      glfwSetErrorCallback([](int error, const char* description)
                           {
                              std::cerr << " [GLFW ERROR] " << error
                                        << ": " << description
                                        << std::endl;
                           });

      GLFWwindow* window = glfwCreateWindow(640, 480, "2D Drawing with Shader", NULL, NULL);
      if (!window){ glfwTerminate(); return -1; }

      // OpenGL context
      glfwMakeContextCurrent(window);
      glClearColor(0.0f, 0.5f, 0.6f, 1.0f);

      // Mouse move callback
      // Note: It is only possible to pass non-capturing lambda to this callback.
      glfwSetCursorPosCallback( window
                              , [](GLFWwindow* window, double xpos, double ypos)
                                {
                                    // Forward call to global variable std::function<>
                                    // (Function object)
                                    Cursor_Callback(window, xpos, ypos);
                                });

      // ====== S H A D E R - C O M P I L A T I O N ====//
      //                                                //

      // Note: The shader source code is at the end of file.
      extern const char* code_vertex_shader;
      extern const char* code_frag_shader;

      GLuint prog = glCreateProgram();
      // Compile shader code
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );

      // Bind current shader (enable it). Only one shader of the same type can
      // be bound at a time. For instance, only a single vertex shader can
      // be enabled at a time
      glUseProgram(prog);

      // Get shader uniform variable location for projection matrix
      // See shader code: "uniform mat4 projection;"
      const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
      assert( u_proj >= 0 && "Failed to find uniform variable" );

      // Get shader uniform variable  location for model matrix.
      const GLint u_model  = glGetUniformLocation(prog, "u_model");
      assert( u_model >= 0 && "Failed to find uniform variable" );

      // Get shader attribute location - the function glGetAttribLocation - returns (-1) on error.
      const GLint attr_position = glGetAttribLocation(prog, "position");
      assert( attr_position >= 0 && "Failed to get attribute location" );
      std::fprintf(stderr, " [TRACE] Attribute location attr_position = %d \n"
                  , attr_position);

      // Get shader index of color attribute variable.
      const GLint attr_color = glGetAttribLocation(prog, "color");
      assert( attr_color >= 0);


      // ====== U P L O A D - TO - G P U =========================//
      //                                                          //

      constexpr size_t NUM_VERTICES = 3;

      // Array of triangle vertex coordinates (X, Y)
      Vertex2D vertices[NUM_VERTICES] = {
        {  0.0,   0.2} // Vertex 0  (x =  0.0 ; y =  0.5)
      , { -0.2,  -0.2} // Vertex 1  (x = -0.5 ; y = -0.5)
      , {  0.2,  -0.2} // Vertex 2  (x =  0.5 ; y = -0.5)
      };

      ColorRGB colors[NUM_VERTICES] = {
            COLOR_R   // Color of vertex 0
          , COLOR_B   // Color of vertex 1
          , COLOR_G   // Color of vertex 2
      };

      // Always initialize with zero (0), otherwise, the values
      // of those variables will be undefined. (Undefine Behavior)
      GLuint vao_triangle = 0;
      GLuint vbo_vertices = 0;
      GLuint vbo_colors   = 0;

      // Send vertices to GPU VBO (vbo_vertices)
      send_buffer(  &vao_triangle    // Ponter to VAO [OUTPUT]
                  , &vbo_vertices    // Pointer VBO   [OUTPUT]
                  , sizeof(vertices) // Size of buffer sent to GPU (VBO memory)
                  , vertices         // Pointer to buffer
                  , attr_position    // Shader attribute location
                  , 2                // Each vertex has 2 coordinates (X, Y)
                  , GL_FLOAT         // Each vertex coordinate has type GLfloat (float)
                  );

      // Send colors to GPU VBO (vbo_colors)
      send_buffer(  &vao_triangle   // Pointer Vertex Array object
                  , &vbo_colors     // Pointer Vertex buffer object handle (aka token)
                  , sizeof(colors)  // Buffer size
                  , colors          // Pointer to buffer (addrress of first buffer element)
                  , attr_color      // Shader attribute location
                  , 3               // Each color has 3 coordinates (R, G, B)
                  , GL_FLOAT        // Each color coordiante has type GLfloat
                  );

      // ============== Set Shader Uniform Variables =============//
      //                                                          //

      int width, height;
      glfwGetWindowSize(window, &width, &height);

      // Window aspect ratio
      float aspect = static_cast<float>(width) / height;

      // Identity matrix
      const auto identity = glm::mat4(1.0);

      // Projection matrix - orthogonal projection for compensating
      // the aspect ratio.
      glm::mat4 Tproj = glm::ortho(-aspect, aspect, -1.0f, 1.0f, -1.0f, 1.0f);

      // Set projection matrix uniform variable
      glUniformMatrix4fv(u_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );
      // Set model matrix uniform variable
      glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(identity) );

      // Instatiate objects that will be rendered
      auto triangleA = Model_Triangle{};
      triangleA.scale(0.50);
      triangleA.rotate(122);

      auto triangleB = Model_Triangle{};
      triangleB.translate(-0.20, 0.30);
      triangleB.rotate(50);
      triangleB.scale(1.8);

      auto triangleC = Model_Triangle{};
      triangleC.translate(0.20, 0.20);
      triangleC.rotate(35);

      // Follows mouse coordinate
      auto triangleD = Model_Triangle{};
      triangleD.translate(-0.60, -0.50);
      triangleD.scale(1.50);
      // triangleD.scale(1.2);
      // triangleD.rotate(40);

      // --------- Set mouse callback ----------//

      constexpr float PI = 3.1415926536f;
      constexpr float FACTOR_RAD_TO_DEG = 180.0 / PI;

      Cursor_Callback = [&](GLFWwindow* window, double xpos, double ypos)
      {
          // Mouse normalized coordinate
          // =>> see: https://stackoverflow.com/questions/23870750/
          float xMouse = -1.0f + 2.0f * xpos / width;
          float yMouse =  1.0f - 2.0f * ypos / height;

          // Angle in degrees between X axis vector(1, 0, 0) and poit (xMouse, yMouse, 0) position.
          // Note: atan2f() returns angle in radians.
          float angle = atan2f(yMouse, xMouse) * FACTOR_RAD_TO_DEG ;
          fprintf(stderr, " [TRACE] Angle = %f \n", angle);

          // Triangle D follows mouse position
          triangleD.translate(xMouse, yMouse);
          triangleD.rotate(angle);

          triangleB.rotate(angle);

          // Show mouse position
           // std::fprintf(stderr, " [MOUSE] x = %f ; y = %f \n", xMouse, yMouse);
      };

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              triangleA.render(vao_triangle, u_model);
              triangleB.render(vao_triangle, u_model);
              triangleC.render(vao_triangle, u_model);
              triangleD.render(vao_triangle, u_model);

              //std::fprintf(stderr, " [TRACE] Redraw screen \n");

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }

          // Increase scale by 10%
          if( glfwGetKey(window, 'A' ) == GLFW_PRESS ){ triangleD.zoom(+0.10); }
          // Decrease scale by 10%
          if( glfwGetKey(window, 'B' ) == GLFW_PRESS ){ triangleD.zoom(-0.10); }


      }

      glfwTerminate();
      return 0;

  } // --- End of main() -----//


  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(
      #version 330 core

      // Supplied by GPU - attribute location (id = 2)
      // contains a (X, Y) vertex
      layout ( location = 2)  in vec2 position;
      layout ( location = 1 ) in vec3 color;     // Contains (Red, Green, Blue) components

      // Output to fragment shader
      out vec3 out_color;

      // Model matrix => projection coordinates from the local space (model space)
      // to view space .
      // Transform 4x4 matrix - supplied by the C++ side.
      uniform mat4 u_model;

      // Projection matrix => projections camera-space coordinates
      // to clip-space coordinates. (-1.0 to 1.0) range.
      uniform mat4 u_projection;

      void main()
      {
          // gl_Position => Global output variable that holds the
          // the current vertex position. It is a vector of
          // components (X, Y, Z = 0, W = ignored)
          gl_Position = u_projection * u_model * vec4(position, 0, 1.0);

          // Forward to fragment shader
          out_color = color;
      }

  )";

  // Fragment shader source code
  const char* code_frag_shader = R"(
      #version 330

      // This color comes from Vertex shader
      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor = vec4(out_color, 1.0);

      }
  )";

      // ====== I M P L E M E N T A T I O N S ==========//

  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);

      GLint is_compiled = GL_FALSE;
      // Check shader compilation result
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result,
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          GLint length;
          glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &length);
          assert( length > 0 );

          std::string out(length + 1, 0x00);
          GLint chars_written;
          glGetShaderInfoLog(shader_id, length, &chars_written, out.data());
          std::cerr << " [SHADER ERROR] = " << out << '\n';
          // Abort the exection of current process.
          std::abort();
      }

      glAttachShader(m_program, shader_id);
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );
      // glUseProgram(m_program);
  }

  // Upload buffer from main memory to GPU VBO
  // =>> Parameters VAO, VBO are allocated by the caller.
  void send_buffer( GLuint* pVao, GLuint* pVbo, GLsizei sizeBuffer
                  , void* pBufffer, GLint   shader_attr, GLint size
                  , GLenum type)
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);

      glEnableVertexAttribArray(shader_attr);

      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

      // ------ Disable Global state set by this function -----//
      //
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(shader_attr);

  }
#+END_SRC

** 2D Graphics - Chart with orthogonal projection

This sample applications draws a 2D chart by plotting two curves, the
functions f(x) and g(x). It is possible to adjust the range displayed
by the chart by setting xmin, xmax, ymin and ymax using the
console. By typing 'A' the chart is displayed adjusting the xmax or
ymax for preserving the aspect ratio. By typing 'B' the chart does not
preserve the aspect ratio and shows the full range xmin to xmax on the
X axis, and ymin to ymax on the Y axis.

  + f(x) = 100.0 - x^2
  + g(x) = 50 * sin(x / (2 * PI)) + 10

The significant features on this sample code are:

  + Orthogonal projection transform which allows drawing using user-defined
    coordinates (world-space coordinates), instead of NDC
    normalized-device coordinates with range -1.0 to 1.0 on each
    axis.

  + Sending interleaved vertex attributes, namely, positions and
    colors, to GPU with a single call to glBufferData() and a single
    VBO - Vertex Buffer Object.

  + Usage of threads for allowing the user controlling the displayed
    range by typing in the console (command line).

 *Projection matrix*

The orthogonal projection matrix is used for allowing user-defined
coordinates instead of normalized coordinates in the range -1.0 to
1.0 on for each axis. The orthogonal matrix without aspect-ratio
compensation is generated by using the following call to glm::ortho.

#+BEGIN_SRC cpp
   glm::mat4 proj = ortho(xmin, xmax, ymin, ymax, zNear = +1.0, zFar = -1.0);
#+END_SRC

 *Algorithm for avoiding chart distortion*

Consider the following rations $u_x$ and $u_y$:

\begin{eqnarray*}
   u_x &=& \frac{w}{\Delta_x} = \frac{ w }{ x_{max} - x_{min} } \\
   u_y &=& \frac{h}{\Delta_y} = \frac{ h }{ y_{max} - y_{min} } \\
\end{eqnarray*}

Where:

  + w - screen width in pixels.

  + h - screen height in pixels.

  + $\Delta_x$ screen width in world-space coordinates.

  + $\Delta_y$ screen height in world-space coordinates.

  + $u_y$ - The ratio $u_x$ represents how many pixels (real screen lenght)
    each user-defined unit on world-space coordinate systems
    represents across the X axis.

  + $u_x$ - The ratio $u_y$, is similar to $u_x$, but it is applicable
    to Y axis.

For instance, if the screen has width of 500 pixels and height of 600
pixels and $x_{min} = -50$,  $x_{max} = +50$,  $y_{min} = -200$,
$y_{max} = +200$. The ratios $u_x$ and $u_y$ will be:

\begin{eqnarray*}
   \Delta_x &=& x_{max} - x_{min} = 100 \\
   \Delta_y &=& y_{max} - y_{min} = 400 \\

   u_x &=& \frac{500}{100} = 5   \quad \text{pixels per X axis units} \\
   u_y &=& \frac{600}{400} = 1.5 \quad \text{pixels per Y axis units} \\
\end{eqnarray*}

The result means that any curve, will appear distorted, for instance a
square with side of 10, will be shown on the screen with the width of
10 * ux = 50 pixels and the height of 10 * uy = 10 * 1.5 = 15
pixels. As a result, the square will appear as rectangle. To avoid any
distortion, the ratios $u_x$ and $u_y$ must be equal, which is
expressed as:

\begin{eqnarray*}
   u_x                         &=& u_y                         \\
  \frac{x_{max} - x_{min}}{w}  &=& \frac{y_{max} - y_{min}}{h} \\
\end{eqnarray*}

If the variables w, h, $x_{min}$ and $y_{min}$ are fixed. $x_{max}$ or
$y_{max}$ must be adjusted for making the ratios $u_x$ and $u_y$
equal and avoiding any distortion.

If the adjusting is choosen for $x_{max}$, then its new value will be:

\begin{equation}
   x_{max}' = x_{min} + \frac{w}{h}( y_{max} - y_{min} )
\end{equation}

If the adjusting is choosen for $y_{max}$, then its adjusted value is:

\begin{equation}
   y_{max}' = y_{min} + \frac{h}{w}( x_{max} - x_{min} )
\end{equation}

By applying the adjusting for the previous case for $x_{max}$, its
adjusted value becomes:

\begin{equation}
   x_{max}' = (-50) + \frac{500}{600}( 200 - (-200) ) \approx 283.333
\end{equation}

The ratios $u_x$, $u_y$ become:


\begin{eqnarray*}
   u_x' &=& \frac{ w }{ x_{max}' - x_{min} } = \frac{ 500 }{ 283.333 - (-50) } \approx 1.50  \\
   u_y' &=& \frac{ h }{ y_{max} - y_{min} }  = \frac{ 600 }{ 200 - (-200) }  = 1.50    \\
\end{eqnarray*}

As the ratios became equal, a square of side 10 will not appear
distorted as its width and lenght in pixels, became equal.

 *Screenshots*


[[file:images/opengl-chart-2.png][file:images/opengl-chart-2.png]]

[[file:images/opengl-chart-1.png][file:images/opengl-chart-1.png]]


  *Files and shaders code*

Vertex Shader:

#+BEGIN_SRC cpp
  #version 330 core

  layout ( location = 0) in vec2 position;
  layout ( location = 1) in vec3 color;

  // Forwarded to fragment shader
  out vec3 out_color;

  uniform mat4 u_model;  // Model matrix
  uniform mat4 u_proj;   // Projection matrix

  void main()
  {
      // vec4(position, 0.0, 1.0) means => vec4(x, y, z = 0.0, w =1.0)
      gl_Position = u_proj * u_model * vec4(position, 0.0, 1.0);
      // Forward to fragment shader
      out_color = color;
  }
#+END_SRC

Fragment Shader:

#+BEGIN_SRC cpp
  #version 330

  in vec3 out_color;

  void main()
  {
      // Set vertex colors
      gl_FragColor =  vec4(out_color, 1.0);
  }
#+END_SRC

File: _CMakeLists.txt_

#+BEGIN_SRC cmake
   cmake_minimum_required(VERSION 3.5)
   project(Draw2D-Chart-GLFW)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw2d-chart  draw2d-chart.cpp   )
   target_link_libraries( draw2d-chart  glfw OpenGL::GL GLU )
#+END_SRC

File: _draw2d-chart.cpp_

#+BEGIN_SRC cpp
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <cassert>
  #include <algorithm>
  #include <thread>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES
  #define GL3_PROTOTYPES

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  // #include <GL/glut.h>

  // --------- OpenGL Math Library ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>
  #include <glm/gtc/matrix_access.hpp>

  struct Point2D { GLfloat x, y;  };
  struct ColorRGB{ GLfloat r, g, b; };

  struct Vertex2D
  {
      Point2D  position;
      ColorRGB color;
  };

  constexpr ColorRGB color_red    = { 1.0, 0.0, 0.0 };
  constexpr ColorRGB color_green  = { 0.0, 1.0, 0.0 };
  constexpr ColorRGB color_blue   = { 0.0, 0.0, 1.0 };
  constexpr ColorRGB color_white  = { 1.0, 1.0, 1.0 };
  constexpr ColorRGB color_yellow = { 1.0, 1.0, 0.0 };

  // ------------------------------------//
  // Shader code at the end of file.
  extern const char*  code_vertex_shader;
  extern const char*  code_frag_shader;

  void        compile_shader(GLuint m_program, const char* code, GLenum type);
  GLFWwindow* make_glfwWindow(int  width, int height, const char* title);

  // Upload vertices position and colors to GPU in a single call.
  void send_vertices( GLuint* pVao, GLuint* pVbo
                    , GLint attr_position
                    , GLint attr_color
                    , std::vector<Vertex2D> const& vertices );

  // using resize_callback_t = void (*) (GLFWwindow* window, int width, int height);
  using FuncResizeCallback = std::function<void (GLFWwindow* window, int width, int height)>;
  FuncResizeCallback resize_callback;


  /*  Ajust orthogonal projection matrix for keeping the aspect ratio.
   ,*  If the flag is false, the range (Xmin, Xmax), (Ymax, Ymin) is not adjusted.
   ,*******************************************************************/
  void adjust_window_range( GLFWwindow* window
                          , GLint uniform_projection_id
                          , bool flag
                          , float xmin, float xmax, float ymin, float ymax);


  template<typename Function>
  auto make_curve(  ColorRGB color, float xmin, float xmax
                  , size_t npoints, Function&& fun) -> std::vector<Vertex2D>
  {
      std::vector<Vertex2D> curve;
      // Reserve pre-allocated space in order to avoid multiple allocations
      // via vector.push_back(Item)
      curve.reserve(npoints);
      float x = xmin;
      float y = 0.0;
      float dx = (xmax - xmin) / npoints;

      for(size_t n = 0; n < npoints; n++)
      {
          y = fun(x);
          curve.push_back( Vertex2D{ Point2D{x, y}, color } );
          // std::fprintf(stderr, " [TRACE] x = %f ; y = %f \n", x, y);
          x = x + dx;
      }
      return curve;
  }

  int main()
  {
      // Initialize GLFW
      if (!glfwInit()){ return -1; }
      const char* title = "2D Scientific Chart with Orthogonal projection.";
      GLFWwindow* window = make_glfwWindow(600, 400, title);

      // ========== Shader settings ==================//
      //
      GLuint prog = glCreateProgram();
      // Compile shader code
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );
      glUseProgram(prog);
      // ------- Shader attribute locations -------//
      //
      const GLint attr_position = glGetAttribLocation(prog, "position");
      const GLint attr_color    = glGetAttribLocation(prog, "color");
      assert( attr_color >= 0 );
      // --------- Shader Uniform Variables -------//
      //
      const GLint u_proj  = glGetUniformLocation(prog, "u_proj");
      const GLint u_model = glGetUniformLocation(prog, "u_model");
      // Note: The error checking for other uniforms are missing
      // for breviety purposes.
      assert( u_model >= 0 );

      // ------ Default values for uniform variables ----------//
      //
      const auto matrix_identity = glm::mat4(1.0);
      glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity));
      glUniformMatrix4fv(u_proj,  1, GL_FALSE, glm::value_ptr(matrix_identity));

      // Forward callback to global variable.
      glfwSetFramebufferSizeCallback(window, [](GLFWwindow* window, int width, int height){
           resize_callback(window, width, height);
      });

       glm::mat4 model_rectangle = glm::mat4(1.0);
      model_rectangle = glm::translate(model_rectangle, glm::vec3(5.0, 4.0, 0.0));

      // ==== O R T H O G O N A L - P R O J E C T I O N =====//
      //
      float xmin = -20.0f, xmax = +10.0f;
      float ymin = -5.0f, ymax  = +100.0f;
      float zNear = +1.0, zFar = -1.0;

      bool aspect_ratio_flag = true;
      adjust_window_range(window, u_proj, aspect_ratio_flag, xmin, xmax, ymin, ymax);

      resize_callback = [&](GLFWwindow* window, int width, int height)
      {
          // std::fprintf(stderr, " [TRACE] Window resize to width = %d ; height = %d \n", width, height);
          // Resize windo view port to the whole window
          glViewport(0, 0, width, height);
      };

      // --- Console loop thread callback =>> Allows user to adjust chart range
      // using console.
      auto console_thread = std::thread( [&]{
          // glfwMakeContextCurrent(window);
          for(;;){
              std::cout << " Enter chart range (xmin, xmax, ymin, ymax): ";
              std::cin >> xmin >> xmax >> ymin >> ymax;
              // Send an empty envent to the render loop for redrawing the window.
              // It makes the subroutine glfwWaitEvents() return to calling code.
              glfwPostEmptyEvent();

          }
      });

      console_thread.detach();

      // ======= U P L O A D - T O - G P U ===========//
      //

  #if 1
      // X, Y axis lines at point (0, 0)
      auto chart_axis = std::vector<Vertex2D> {
              // X axis Line - color green
              { { -500.0, 0}, color_green }, { {500.0, 0}, color_green }
              // Y axis Line  - color blue
            , { {0, -500.0}, color_blue },  { {0, 500.0}, color_blue }
      };
      GLuint vao_axis = 0, vbo_axis = 0;
      send_vertices(&vao_axis, &vbo_axis, attr_position, attr_color, chart_axis);
  #endif

      auto curve = std::vector<Vertex2D>{};

      GLuint vao_quadratic_curve = 0;
      GLuint vbo_quadratic_curve = 0;
      curve = make_curve( color_red, -20.0, 20.0, 500
                        , [](float x){ return 100.0 - x * x;  });
      GLint quadratic_curve_points = curve.size();
      send_vertices( &vao_quadratic_curve, &vbo_quadratic_curve
                   , attr_position, attr_color, curve );

      // Sine curve f(x) = 25 * sin(x / (2·PI) ) + + 60.0;
      GLuint vao_sine_curve = 0;
      GLuint vbo_sine_curve = 0;
      constexpr float PI_2 = 2.0 * 3.141592653589;
      curve = make_curve(  color_yellow, -50.0, 200.0, 500
                       , [](float x){ return 25.0 * sin(x / PI_2) + 60.0;  } );
      GLint sine_curve_points = curve.size();
      send_vertices( &vao_sine_curve, &vbo_sine_curve
                   , attr_position, attr_color, curve );


      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT  | GL_DEPTH_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // Adjust orthogonal projection and range of coordinates shown in the window.
              adjust_window_range(window, u_proj, aspect_ratio_flag, xmin, xmax, ymin, ymax);

              // Draw lines for X and Y axis
              //-------------------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity));
              glBindVertexArray(vao_axis);
              glDrawArrays(GL_LINES, 0, 4);

              // Draw curve quadratic curve f(x) = 100.0 - x^2
              //-------------------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity));
              glBindVertexArray(vao_quadratic_curve);
              glDrawArrays(GL_POINTS, 0, quadratic_curve_points);

              // Draw sine curve f(x) = 50 * sin(x) + 10.0;
              //-------------------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity));
              glBindVertexArray(vao_sine_curve);
              glDrawArrays(GL_LINE_STRIP, 0, sine_curve_points);


           // ====== END RENDERING ==============//

          // Swap front and back buffers
          glfwSwapBuffers(window);
          // Wait for events - blocks current thread until some event arrives.
          glfwWaitEvents();

          // ====== PROCESS EVENTS =============//

            // std::fprintf(stderr, " [TRACE] Waiting events. \n");

          if( glfwGetKey(window, 'A') == GLFW_PRESS ){  aspect_ratio_flag = true;  }
          if( glfwGetKey(window, 'B') == GLFW_PRESS ){  aspect_ratio_flag = false; }

      } // --- End of render loop --- //

      return 0;
  }

  // --------- S H A D E R S --------------------------------//

  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(
      #version 330 core

      layout ( location = 0) in vec2 position;
      layout ( location = 1) in vec3 color;

      // Forwarded to fragment shader
      out vec3 out_color;

      uniform mat4 u_model;  // Model matrix
      uniform mat4 u_proj;   // Projection matrix

      void main()
      {
          // vec4(position, 0.0, 1.0) means => vec4(x, y, z = 0.0, w =1.0)
          gl_Position = u_proj * u_model * vec4(position, 0.0, 1.0);
          // Forward to fragment shader
          out_color = color;
      }

  )";

  // Fragment shader source code
  const char* code_frag_shader = R"(
      #version 330

      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor =  vec4(out_color, 1.0);
      }
  )";


  // --------- I M P L E M E N T A T I O N S -----------------//

  GLFWwindow*
  make_glfwWindow(int  width, int height, const char* title)
  {

      glfwSetErrorCallback([](int error, const char* description)
                           { std::fprintf( stderr, " [GLFW ERROR] Error = %d ; Description = %s \n"
                                          , error, description);
                           });

      GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
      assert( window != nullptr && "Failed  to create Window");

      // OpenGL context
      glfwMakeContextCurrent(window);
      // Pain whole screen as black - dark screen colors are better
      // for avoding eye strain due long hours staring on monitor.
      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
      // Set - OpenGL Core Profile - version 3.3
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

      // Make the window the topmost (Always on top)
      glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);

      glEnable(GL_COLOR_MATERIAL);
      glEnable(GL_DEPTH_TEST);
      glEnable(GL_BLEND);

      return window;
  }


  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);

      GLint is_compiled = GL_FALSE;
      // Check shader compilation result
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result,
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          std::cerr << " [SHADER ERROR] =>> Abort execution. " << '\n';
          // Abort the exection of current process.
          std::abort();
      }

      glAttachShader(m_program, shader_id);
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );
      // glUseProgram(m_program);
  }


  // Upload vertices from main memory to GPU memory.
  // Vertices position and colors are uploaded in a single call.
  void send_vertices( GLuint* pVao, GLuint* pVbo
                    , GLint attr_position
                    , GLint attr_color
                    , std::vector<Vertex2D> const& vertices )
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;
      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);
      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex2D)
                  , vertices.data(), GL_STATIC_DRAW);

      glEnableVertexAttribArray(attr_position);
      glEnableVertexAttribArray(attr_color);

      static_assert( sizeof(Vertex2D) == 5 * sizeof(float)
                   ,"Vertex2D size assumption does not hold." );

      static_assert( sizeof(Point2D) == offsetof(Vertex2D, color)
                   , "Invalid offsetof() assumption");

      // Set data layout - how data will be interpreted.
      // => Each vertex has 2 coordinates.
      glVertexAttribPointer( attr_position     // Position vertex shader attribute
                            , 2                // Each position has 2 coordinates (X, Y)
                            , GL_FLOAT         // Type of each coordinate
                            , GL_FALSE
                            , sizeof(Vertex2D) // Offset to next coordinates (5 floats in this case)
                            , nullptr
                            );

      glVertexAttribPointer( attr_color
                             // Each color has 3 components R, G, B
                            , 3
                             // Type of each color coordinate
                            , GL_FLOAT
                            , GL_FALSE
                             // Offset to next coordinates (next row)
                            , sizeof(Vertex2D)
                             // Offset to color member variable in class Vertex2D
                            , reinterpret_cast<void*>( offsetof(Vertex2D, color) )
                            );

      // ------ Disable Global state set by this function -----//
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(attr_position);
      glDisableVertexAttribArray(attr_color);
  }

  void adjust_window_range( GLFWwindow* window
                          , GLint uniform_projection_id
                          , bool flag
                          , float xmin, float xmax, float ymin, float ymax)
  {
      constexpr float zFar  = -1.0f;
      constexpr float zNear = +1.0f;

      if(flag == false)
      {
          glm::mat4 proj_1 = glm::ortho(xmin, xmax, ymin, ymax, zNear, zFar);
          glUniformMatrix4fv(uniform_projection_id, 1, GL_FALSE, glm::value_ptr(proj_1));
          return;
      }

      int width, height;
      glfwGetWindowSize(window, &width, &height);
      float k_aspect = static_cast<float>(width) / static_cast<float>(height);
      float dx = xmax - xmin;
      float dy = ymax - ymin;

      if(dx > dy){
          ymax =  ymin + (1.0f / k_aspect ) * dx;
          // std::fprintf(stderr, " [TRACE] Adjust range => ymax = %f \n", ymax);
      } else {
          xmax = xmin + k_aspect * dy;
          // std::fprintf(stderr, " [TRACE] Adjust range => xmax = %f \n", ymax);
      }

      dx = xmax - xmin;
      dy = ymax - ymin;
      float ux = width / dx;
      float uy = height / dy;

      // std::fprintf(stderr, " [TRACE] ux = %f ; uy = %f \n", ux, uy);

      glm::mat4 proj_2 = glm::ortho(xmin, xmax, ymin, ymax, zNear, zFar);
      glUniformMatrix4fv(uniform_projection_id, 1, GL_FALSE, glm::value_ptr(proj_2));
  }

#+END_SRC
** 2D Graphics - IBO - Index Buffer Object 

This code uses OpenGL IBO (Index Buffer Objects) for drawing triangles
and lines OpenGL primitives. The IBO is useful for drawing complex
objects without repeating vertices, which saves memory and bandwith
and increases performance. 

  *Screenshot* 

#+CAPTION: Triangles IBO - Index Buffer Object 
[[file:images/opengl-ibo-triangles.png][file:images/opengl-ibo-triangles.png]] 


  *Code Highlights* 

Vertices and colors data structures: 

#+BEGIN_SRC cpp 
   struct Point2D  { GLfloat x, y;    };
   struct ColorRGB { GLfloat r, g, b; };
   struct Vertex2D { Point2D  position; ColorRGB color; };

   using VertexArray = std::vector<Vertex2D>;
   using IndexArray  = std::vector<GLuint>;
#+END_SRC

The next blocks defines the triangles vertices and the connection
between those vertices. Each three indices in the 'triangles_indices'
variables represents a triangle. Without using IBO (Index Buffer
Object), there would be duplicated vertices, then the content of array
'vertices' would be [V0, V1, V2, V1, V3, V4, V3, V5, V6, V2, V7, V5], 


#+BEGIN_SRC cpp 
    // Triangle side 
    float a = 1.0 / 5.0; 
    // Triangle height 
    float h = sqrt(3.0) * a;
    
    auto vertices = VertexArray {
          Vertex2D{ { 0,       0  }, color_green   } // V0 - vertex 0 
        , Vertex2D{ { 2 * a,   0  }, color_green   } // V1 
        , Vertex2D{ { a,       h  }, color_green   } // V2 

        , Vertex2D{ { 3 * a,   h  }, color_blue    } // V3
        , Vertex2D{ { 4 * a,   0  }, color_blue    } // V4

        , Vertex2D{ { 2 * a, 2 * h }, color_red    } // V5
        , Vertex2D{ { 4 * a, 2 * h }, color_red    } // V6
        , Vertex2D{ {     0, 2 * h }, color_yellow } // V7 - vertex 7 
    };
    
    // Indices for GL_TRIANGLE drawing primitive. 
    auto triangles_indices = IndexArray {
          0, 1, 2  // Draw triangle with vertices V0, V1, V2 (Triangle A)
        , 1, 3, 4  // Draw triangle with vertices V1, V3, V4 (Triangle B)
        , 3, 5, 6  // Draw triangle with vertices V3, V5, V6 (Triangle C)
        , 2, 7, 5  // Draw triangle with vertices V2, V7, V5 (Triangle D)
    };
#+END_SRC

This index array defines the connections between vertices for
GL_LINES primitives, each 2 indices represents a line. 

#+BEGIN_SRC cpp 
   // Indices for GL_LINES drawing primitive 
    auto lines_indices = IndexArray {
          0, 1 // Line connecting vertices V0 and V1 
        , 0, 2 // Line connecting vertices V0 and V2 
        , 1, 2 // Line connecting vertices V1 and V2 
        
        , 2, 7 
        , 5, 7 
        , 2, 5 

        , 1, 3
        , 1, 4
        , 3, 4

        , 3, 5
        , 3, 6
        , 5, 6
    };
#+END_SRC

In the following code highlight, the vertices indices and data are
sent to the GPU using the subroutines send_vertices() and
send_indices(). These functions uses the following parameters: vao
(Vertex Array Object); vbo (Vertex Buffer Object) and ibo (Index
Buffer Objects), which are supposed to be allocated by calling
code. 

#+BEGIN_SRC cpp 
    // ------- Upload data for drawing traingle primitives --------//
    //
    GLuint vao_triangles = 0, vbo_triangles = 0, ibo_triangles = 0;    

    send_vertices( &vao_triangles, &vbo_triangles
                 , attr_position, attr_color, vertices);

    send_indices(&vao_triangles, &ibo_triangles, triangles_indices);


    // -------- Upload data for drawing lines primitives ----------// 
    //
    GLuint vao_lines = 0, vbo_lines = 0, ibo_lines = 0;  
    send_vertices( &vao_lines, &vbo_lines
                 , attr_position, attr_color, vertices);     
    send_indices(&vao_lines, &ibo_lines, lines_indices);
#+END_SRC

At the rendering loop. The OpenGL glDrawElements() subroutine is used
,instead of glDrawArrays(), for drawing triangles and lines
primitives. This subroutine uses the vertices indices instead of using
the vertices ordering. For instance, if glDrawArrays() was used, each
three vertices from the current bound VBO would be used for drawing a
triangle.

#+BEGIN_SRC cpp 
   // ====== BEGIN RENDERING ============//

       // ---- Draw triangles primitives using IBO -------// 
       glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_triangle_primtives));
       glBindVertexArray(vao_triangles);
       // Draw OpenGL primitives between vertices designated by their
       // IBO - Index Buffer Object.         
       glDrawElements(GL_TRIANGLES, triangles_indices.size() , GL_UNSIGNED_INT, nullptr);

       // ----- Draw lines using IBO -----------------------//
       glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_lines_primitives));
       glBindVertexArray(vao_lines);
       glDrawElements(GL_LINES, lines_indices.size() , GL_UNSIGNED_INT, nullptr);            

   // ====== END RENDERING ==============//

#+END_SRC

  *Files / Sources* 

File: _CMakeLists.txt_

#+BEGIN_SRC cmake
   cmake_minimum_required(VERSION 3.5)
   project(Draw2D-Chart-GLFW)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw2d-ibo-triangles  draw2d-ibo-triangles.cpp   )
   target_link_libraries( draw2d-ibo-triangles  glfw OpenGL::GL GLU )
#+END_SRC

File: _draw2d-ibo-triangles.cpp_ 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Library ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>
  #include <glm/gtc/matrix_access.hpp>

  struct Point2D  { GLfloat x, y;    };
  struct ColorRGB { GLfloat r, g, b; };
  struct Vertex2D { Point2D  position; ColorRGB color; };

  extern const char*  code_vertex_shader;
  extern const char*  code_frag_shader;

  void        compile_shader(GLuint m_program, const char* code, GLenum type);
  GLFWwindow* make_glfwWindow(int  width, int height, const char* title);

  // Send vertices (position and color of each vertex to GPU memory)
  void send_vertices( GLuint* pVao, GLuint* pVbo
                    , GLint attr_position
                    , GLint attr_color 
                    , std::vector<Vertex2D> const& vertices );

  // Send vertices indices to GPU memory. 
  void send_indices(GLuint* pVao, GLuint* pVbi
                  , std::vector<GLuint> const& indices);

  constexpr ColorRGB color_red    = { 1.0, 0.0, 0.0 };
  constexpr ColorRGB color_green  = { 0.0, 1.0, 0.0 };        
  constexpr ColorRGB color_blue   = { 0.0, 0.0, 1.0 };
  constexpr ColorRGB color_white  = { 1.0, 1.0, 1.0 };
  constexpr ColorRGB color_yellow = { 1.0, 1.0, 0.0 };

  int main(int argc, char** argv)
  {
      if (!glfwInit()){ return -1; }

      /* Create a windowed mode window and its OpenGL context */
      GLFWwindow* window = make_glfwWindow(640, 480, "Draw 2D - IBO - Index Buffer Object");

      // ======= S H A D E R - C O M P I L A T I O N ==========// 
      // 
      GLuint prog = glCreateProgram();
      // Compile shader code 
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;    
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );
      glUseProgram(prog);    
      // ------- Shader attribute locations -------//
      const GLint attr_position = glGetAttribLocation(prog, "position");
      const GLint attr_color    = glGetAttribLocation(prog, "color");
      assert( attr_position >= 0 );
      assert( attr_color >= 0 );
      // --------- Shader Uniform Variables -------//
      const GLint u_proj  = glGetUniformLocation(prog, "u_proj");
      const GLint u_model = glGetUniformLocation(prog, "u_model");
      assert(u_proj >= 0);
      assert(u_model >= 0);

      // ------ Default values for uniform variables ----------//
      const auto matrix_identity = glm::mat4(1.0);
      glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity));
      glUniformMatrix4fv(u_proj,  1, GL_FALSE, glm::value_ptr(matrix_identity));

    
      //  ======= U P L O A D - T O - G P U =====================//
      //     

      using VertexArray = std::vector<Vertex2D>;
      using IndexArray = std::vector<GLuint>;

      // Triangle side 
      float a = 1.0 / 5.0; 
      // Triangle height 
      float h = sqrt(3.0) * a;
    
      auto vertices = VertexArray {
            Vertex2D{ { 0,       0  }, color_green   } // V0 - vertex 0 
          , Vertex2D{ { 2 * a,   0  }, color_green   } // V1 
          , Vertex2D{ { a,       h  }, color_green   } // V2 

          , Vertex2D{ { 3 * a,   h  }, color_blue    } // V3
          , Vertex2D{ { 4 * a,   0  }, color_blue    } // V4

          , Vertex2D{ { 2 * a, 2 * h }, color_red    } // V5
          , Vertex2D{ { 4 * a, 2 * h }, color_red    } // V6
          , Vertex2D{ {     0, 2 * h }, color_yellow } // V7 - vertex 7 
      };
    
      // Indices for GL_TRIANGLE drawing primitive. 
      auto triangles_indices = IndexArray {
            0, 1, 2  // Draw triangle with vertices V0, V1, V2 (Triangle A)
          , 1, 3, 4  // Draw triangle with vertices V1, V3, V4 (Triangle B)
          , 3, 5, 6  // Draw triangle with vertices V3, V5, V6 (Triangle C)
          , 2, 7, 5  // Draw triangle with vertices V2, V7, V5 (Triangle D)
      };

      // Indices for GL_LINES drawing primitive 
      auto lines_indices = IndexArray {
            0, 1 // Line connecting vertices V0 and V1 
          , 0, 2 // Line connecting vertices V0 and V2 
          , 1, 2 // Line connecting vertices V1 and V2 
        
          , 2, 7 
          , 5, 7 
          , 2, 5 

          , 1, 3
          , 1, 4
          , 3, 4

          , 3, 5
          , 3, 6
          , 5, 6
      };

      // ------- Upload data for drawing traingle primitives --------//
      //
      GLuint vao_triangles = 0, vbo_triangles = 0, ibo_triangles = 0;    

      send_vertices( &vao_triangles, &vbo_triangles
                   , attr_position, attr_color, vertices);

      send_indices(&vao_triangles, &ibo_triangles, triangles_indices);


      // -------- Upload data for drawing lines primitives ----------// 
      //
      GLuint vao_lines = 0, vbo_lines = 0, ibo_lines = 0;  
      send_vertices( &vao_lines, &vbo_lines
                   , attr_position, attr_color, vertices);     
      send_indices(&vao_lines, &ibo_lines, lines_indices);

      // ==== Model matrices for translating drawings =======//
      //      
      glm::mat4 model_triangle_primtives = matrix_identity;
      glm::mat4 model_lines_primitives = matrix_identity;   
      // Translate triangles to point (x = -0.7, y = -0.8, z = 0.0)
      model_triangle_primtives = glm::translate(model_triangle_primtives, glm::vec3(-0.7, -0.8, 0.0));

      //  ======= R E N D E R  - L O O P ===================//
      //                                                    //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT  | GL_DEPTH_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//
        
              // ---- Draw triangles primitives using IBO -------// 
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_triangle_primtives));
              glBindVertexArray(vao_triangles);
              // Draw OpenGL primitives between vertices designated by their
              // IBO - Index Buffer Object.         
              glDrawElements(GL_TRIANGLES, triangles_indices.size() , GL_UNSIGNED_INT, nullptr);
            
              // ----- Draw lines using IBO -----------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_lines_primitives));
              glBindVertexArray(vao_lines);
              glDrawElements(GL_LINES, lines_indices.size() , GL_UNSIGNED_INT, nullptr);            

          // ====== END RENDERING ==============//

          glfwSwapBuffers(window);
          glfwPollEvents();
      }

      glfwTerminate();
      return 0;
  }

  // ---------- S H A D E R S - C O D E  ---------------------// 

  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(    
      #version 330 core 

      layout ( location = 0) in vec2 position;
      layout ( location = 1) in vec3 color;   
    
      // Forwarded to fragment shader 
      out vec3 out_color;
    
      uniform mat4 u_model;  // Model matrix 
      uniform mat4 u_proj;   // Projection matrix 

      void main()
      {
          // vec4(position, 0.0, 1.0) means => vec4(x, y, z = 0.0, w =1.0)
          gl_Position = u_proj * u_model * vec4(position, 0.0, 1.0);
        
          // Forward to fragment shader 
          out_color = color; 
      }

  )";

  // Fragment shader source code 
  const char* code_frag_shader = R"(
      #version 330 

      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor =  vec4(out_color, 1.0);
      }
  )";

  // --------- I M P L E M E N T A T I O N S -----------------//

  GLFWwindow* 
  make_glfwWindow(int  width, int height, const char* title)
  {

      glfwSetErrorCallback([](int error, const char* description)
                           { std::fprintf( stderr, " [GLFW ERROR] Error = %d ; Description = %s \n"
                                          , error, description);
                           });

      GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
      assert( window != nullptr && "Failed  to create Window");

      // OpenGL context 
      glfwMakeContextCurrent(window);
      // Set window color 
      glClearColor(0.0f, 0.5f, 3.0f, 1.0f);
      // Set - OpenGL Core Profile - version 3.3
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

      // Make the window the topmost (Always on top)
      glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);

      glEnable(GL_COLOR_MATERIAL);
      glEnable(GL_DEPTH_TEST);
      glEnable(GL_BLEND);

      return window;
  }


  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);
    
      GLint is_compiled = GL_FALSE;
      // Check shader compilation result 
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result, 
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          std::cerr << " [SHADER ERROR] =>> Abort execution. " << '\n';
          // Abort the exection of current process. 
          std::abort();
      }          

      glAttachShader(m_program, shader_id);   
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );   
      // glUseProgram(m_program);         
  }

  // Upload vertices from main memory to GPU memory.
  // Vertices position and colors are uploaded in a single call.
  void send_vertices( GLuint* pVao, GLuint* pVbo
                    , GLint attr_position
                    , GLint attr_color 
                    , std::vector<Vertex2D> const& vertices )
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;
      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);
      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex2D)
                  , vertices.data(), GL_STATIC_DRAW);   

      glEnableVertexAttribArray(attr_position);    
      glEnableVertexAttribArray(attr_color);    
   
      // Set data layout - how data will be interpreted.
      // => Each vertex has 2 coordinates. 
      glVertexAttribPointer( attr_position, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex2D), nullptr);

      glVertexAttribPointer( attr_color, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex2D)     
                             // Offset to color member variable in class Vertex2D
                            , reinterpret_cast<void*>( offsetof(Vertex2D, color) )
                            );

      // ------ Disable Global state set by this function -----//
      // Unbind VAO 
      glBindVertexArray(0);
      // Unbind VBO 
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute 
      glDisableVertexAttribArray(attr_position);
      glDisableVertexAttribArray(attr_color);
  }

  void send_indices(GLuint* pVao, GLuint* pVbi, std::vector<GLuint> const& indices)
  {
      GLuint& vao = *pVao;
      GLuint& vbi = *pVbi;
      glBindVertexArray(vao);
      // Generate index buffer object 
      glGenBuffers(1, &vbi); 
      // Bind this index buffer object - only one IBO can 
      // be bound at a time. (It is a global state!!)
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, vbi );
      // Upload indices to GPU - This VBI object is a handle 
      // (token, akin to file descriptor) that refers 
      // to the data sent to the GPU on the next line. 
      glBufferData( GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint)
                      , indices.data(), GL_STATIC_DRAW);    
      // ----------- Unset global state -------------//
      // 
      glBindVertexArray(0);
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );
  }
#+END_SRC
** 3D Graphics - Rotating cube

This sample application contains: two cubes; two grid planes for
visual reference; a coordinate axis for visual debugging and a camera
that always points to the origin. The camera has the following
controls: right arrow, rotates the camera's position in a
counterclockwise way around Y axis (red line); if left arrow is typed,
the camera position rotates in a clockwise way around Y axis (red
line). If up arrow is typed, the camera position moves in the positive
direction of Y axis. If down arrow is typed, the reverse
happens.

 *Screenshots*

[[file:images/opengl-draw3d-rotating-cube1.png][file:images/opengl-draw3d-rotating-cube1.png]]

[[file:images/opengl-draw3d-rotating-cube2.png][file:images/opengl-draw3d-rotating-cube2.png]]

  *Project Files*

Vertex Shader Code:

#+BEGIN_SRC cpp
   #version 330 core

   layout ( location = 0)  in vec3 position;
   layout ( location = 1) in vec3 color;
   out vec3 out_color;
   uniform mat4 u_model;       // Model matrix
   uniform mat4 u_view;        // Camera's view matrix
   uniform mat4 u_projection;  // Camera's projection matrix

   void main()
   {
       gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);

       // Forward to fragment shader
       out_color = color; // vec3(0.56, 0.6, 0.0);
   }
#+END_SRC

Fragment Shader Code:

#+BEGIN_SRC cpp
   #version 330

   // This color comes from Vertex shader
   in vec3 out_color;

   void main()
   {
       // Set vertex colors
       gl_FragColor =  vec4(out_color, 1.0);
       // gl_FragColor = vec4(0.3, 0.6, 0.0, 1.0);
   }
#+END_SRC

File: CmakeLists.txt

#+BEGIN_SRC cmake
   cmake_minimum_required(VERSION 3.5)
   project(GLFW_project)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw3d-cube  draw2d-cube.cpp   )
   target_link_libraries( draw3d-cube  glfw OpenGL::GL GLU )
#+END_SRC

File: draw3d-cube.cpp

#+BEGIN_SRC cpp
  // Draw many colored triangles from a single VBO (Vertex Buffer Object)
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <functional>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Librar ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>

  // #define GLUT_ENABLED

  #if defined(GLUT_ENABLED)
      #include <GL/glut.h>
  #endif

  #define GL_CHECK(funcall)\
      do { \
          (funcall); \
          GLint error = glGetError();  \
          if(error == GL_NO_ERROR){ break; } \
          std::fprintf(stderr, " [OPENGL ERROR] Error code = %d ; line = %d ; call = '%s'  \n" \
                        , error, __LINE__, #funcall ); \
          abort(); \
      } while(0)

  GLFWwindow* make_glfwWindowi(int  width, int height, const char* title);

  // Compile some  shader
  void compile_shader(GLuint m_program, const char* code, GLenum type);

  // Send data from memory to GPU VBO memory
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer
                    , GLint   shader_attr // Shader attribute location id
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate
                    );

  // ------------ Basic Data Structures -----------//

  // Wrapper for 2D vertex coordinates
  struct Vertex3D{  GLfloat x, y, z;  };
  // Wrapper for RGB colors
  struct ColorRGB { GLfloat r, g, b; };

  struct Geometry {
      std::vector<Vertex3D> vertices;
      std::vector<ColorRGB> colors;
  };

  struct RenderObject {
      GLuint     u_model;     // Shader uniform variable for model matrix
      GLuint     vao;         // Vertex Array object
      glm::mat4  model;       // Object model matrix
      GLenum     draw_type;   // Draw type
      GLint      n_vertices;  // Number of vertices

      RenderObject(){ model = glm::mat4(1.0);  }
      // Explicit copy constructor
      RenderObject(const RenderObject&) = default;
      // Explicit copy assignment operator
      RenderObject& operator=(const RenderObject&) = default;

      void render()
      {
          glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model) );
          glBindVertexArray(vao);
          glDrawArrays(draw_type, 0, n_vertices);
      }
  };


  Geometry make_grid_geometry(size_t n_grid, float dx, const ColorRGB& color);
  Geometry make_cube_geometry(float w);

  constexpr ColorRGB color_red   = {1.0, 0.0, 0.0};
  constexpr ColorRGB color_green = {0.0, 1.0, 0.0};
  constexpr ColorRGB color_blue  = {0.0, 0.0, 1.0};
  constexpr ColorRGB color_yelllow    = { 0.80,  1.000, 0.100 };
  constexpr ColorRGB color_gray       = { 0.47,  0.390, 0.380 };
  constexpr ColorRGB color_dark_green = { 0.027, 0.392, 0.050 };
  constexpr ColorRGB color_dark_blue  = { 0.109, 0.066, 0.411 };

  // Send vertices to GPU
  void send_vertices( GLuint* pVao, GLuint* pVbo,  GLint shader_attr
                  ,   std::vector<Vertex3D>& vertices )
  {
      send_buffer(pVao, pVbo, sizeof(Vertex3D) * vertices.size(), vertices.data(), shader_attr, 3, GL_FLOAT );
  }

  // Send color coordinates to GPU
  void send_colors( GLuint* pVao, GLuint* pVbo,  GLint shader_attr
                  ,   std::vector<ColorRGB>& vertices )
  {
      send_buffer(pVao, pVbo, sizeof(Vertex3D) * vertices.size(), vertices.data(), shader_attr, 3, GL_FLOAT );
  }

  struct Camera{
      // Current location of camera in world coordinates
      glm::vec3 cam_eye  = { 2.0, 4.0, 5.0 };
      // Point to where the camera is looking at in world coordinates.
      glm::vec3 cam_targ = { 0.0, 0.0, 0.0  };
      // Current  camera up vector (orientation) - Y axis (default)
      glm::vec3 cam_up = { 0.0, 1.0, 0.0 };

      // Field of view
      float fov_angle = glm::radians(60.0);
      // Aspect ratio
      float aspect   = 1.0;
      float zFar     = 20.0;
      float zNear    = 0.1;

      // ID of shader's view uniform variable - for setting view matrix
      GLuint shader_uniform_view;
      // ID of shader's projection uniform variable for setting projection matrix.
      GLuint shader_uniform_proj;

      Camera(GLuint uniform_view, GLuint uniform_proj, float aspect):
          shader_uniform_view(uniform_view)
        , shader_uniform_proj(uniform_proj)
        , aspect(aspect)
      {  update_view();  }

      void update_view()
      {
          // Create View matrix that maps from world-space coordinates to
          // camera-space coordinates
          auto Tview = glm::lookAt(cam_eye, cam_targ, cam_up);

          // Create projection matrix coordinates that maps from
          // camera-space coordinates to NDC (Normalized Device Coordinates).
          auto Tproj = glm::perspective( fov_angle
                                       , aspect
                                       , zNear
                                       , zFar );
          // Set shader uniform variables.
          glUniformMatrix4fv(shader_uniform_view, 1, GL_FALSE, glm::value_ptr(Tview) );
          glUniformMatrix4fv(shader_uniform_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );

      }

      // Rotate camera around Y axis
      void rotate_y(float angle)
      {
          float a = glm::radians(angle);
          float C = cosf(a), S = sinf(a);
          float x = this->cam_eye.x;
          float y = this->cam_eye.y;
          float z = this->cam_eye.z;
          // Apply Y-axis rotation matrix directly to Y axis.
          this->cam_eye.x = x * C + z * S;
          this->cam_eye.y = y;
          this->cam_eye.z = -x * S + z * C;
          this->update_view();
      }

  };

  int main(int argc, char** argv)
  {

      /* Initialize the library */
      if (!glfwInit()){ return -1; }

      #if defined(GLUT_ENABLED)
          glutInit(&argc, argv);
      #endif

      // ====== S H A D E R - C O M P I L A T I O N ====//
      //                                                //

      GLFWwindow* window = make_glfwWindowi(640, 480, "Draw Cube 3D");

      // Note: The shader source code is at the end of file.
      extern const char* code_vertex_shader;
      extern const char* code_frag_shader;

      GLuint prog = glCreateProgram();
      // Compile shader code
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );
      glUseProgram(prog);

      // Get shader uniform variable location for projection matrix
      // See shader code: "uniform mat4 projection;"
      const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
      assert( u_proj >= 0 && "Failed to find u_projection uniform variable" );

      const GLint u_view = glGetUniformLocation(prog, "u_view");
      assert( u_proj >= 0 && "Failed to find u_view uniform variable" );

      // Get shader uniform variable  location for model matrix.
      const GLint u_model  = glGetUniformLocation(prog, "u_model");
      assert( u_model >= 0 && "Failed to find uniform variable" );

      // Get shader attribute location - the function glGetAttribLocation - returns (-1) on error.
      const GLint attr_position = glGetAttribLocation(prog, "position");
      assert( attr_position >= 0 && "Failed to get attribute location" );

      // Get shader attribute of color
      const GLint attr_color = glGetAttribLocation(prog, "color");
      if( attr_color < 0){ std::fprintf(stderr, " [WARNING] Shader color attribute location not found. \n"); };


      // ====== U P L O A D - TO - G P U =========================//
      //                                                          //

      // ----- Upload Cube vertices and colors ----------------//
          Geometry cube_geometry = make_cube_geometry(0.3);
      GLuint vao_cube     = 0;
      GLuint vbo_vertices = 0;
      GLuint vbo_colors   = 0;
      // Upload geometry cube data to GPU
      send_vertices(&vao_cube, &vbo_vertices, attr_position, cube_geometry.vertices);
      send_colors(&vao_cube, &vbo_colors, attr_color, cube_geometry.colors);
      std::fprintf(stderr, " [TRACE] vao_cube = %d \n", vao_cube );

      // ------- Upload grid vertices and colors ------------------//
      Geometry grid_geometry = make_grid_geometry(20, 0.1f, ColorRGB{0.0f, 0.9f, 0.5f});
      GLuint vao_grid = 0;
      GLuint vbo_grid_vertices = 0;
      send_vertices(&vao_grid, &vbo_grid_vertices, attr_position, grid_geometry.vertices);
      send_colors(&vao_grid, &vbo_grid_vertices, attr_color, grid_geometry.colors);

      // ----- X, Y, Z axis for visual debugging ----------------
      // X axis (GREEN) ; Y axis (RED); Z axis (BLUE)
      GLuint vao_axis = 0;
      GLuint vbo_axis_vertices = 0;
      GLuint vbo_axis_colors = 0;
      float axis_len = 5.0;

      // Each two points represents a unconnected line (GL_LINES)
      std::vector<Vertex3D> axis_vertices {
          // Line for X axis - from (0.0, 0.0, 0.0) to (axis_len, 0.0, 0.0)
            Vertex3D{0.0f, 0.0f, 0.0f}, Vertex3D{axis_len, 0.0f, 0.0f}
          // Line for Y axis
          , Vertex3D{0.0f, 0.0f, 0.0f}, Vertex3D{0.0f, axis_len, 0.0f}
          // Line for Z axis
          , Vertex3D{0.0f, 0.0f, 0.0f}, Vertex3D{0.0f, 0.0, axis_len}
      };

      auto axis_colors = std::vector<ColorRGB>{
            // Color of X axis line
            color_green, color_green
            // Color of Y axis line
           , color_red,  color_red
            // Color of Z axis line
           , color_blue, color_blue
      };

      send_vertices(&vao_axis, &vbo_axis_vertices, attr_position, axis_vertices);
      send_colors(&vao_axis,   &vbo_axis_colors,   attr_color,    axis_colors  );

      // ============== Set Shader Uniform Variables =============//
      //                                                          //

      int width, height;
      glfwGetWindowSize(window, &width, &height);
      // Window aspect ratio
      float aspect = static_cast<float>(width) / height;
      // Identity matrix
      const auto identity = glm::mat4(1.0);


      // Set projection matrix uniform variable
      glUniformMatrix4fv(u_proj, 1, GL_FALSE, glm::value_ptr(identity) );

      // ==== R E N D E R I N G - O B J E C T S ==========================//
      //                                                                  //

      RenderObject cube1{};
      cube1.vao        = vao_cube;
      cube1.u_model    = u_model;
      cube1.draw_type  = GL_QUADS;
      cube1.n_vertices = 24;
      // cube1.model = glm::scale(cube1.model, glm::vec3(0.5, 0.5, 0.5));
      cube1.model = glm::translate(cube1.model, glm::vec3(0.2, 1.20, +0.4));
      cube1.model = glm::rotate(cube1.model, glm::radians(45.0f), glm::vec3(1.0, 1.0, 0.0));

      // Call copy constructor (copy all data from cube1)
      RenderObject cube2 = cube1;
      cube2.model = glm::mat4(1.0);
      cube2.model = glm::translate(cube2.model, glm::vec3(-1.20, 1.2, 0.4));
      cube2.model = glm::scale(cube2.model, glm::vec3(1.5, 1.5, 1.5));
      // cube2.model = glm::rotate(cube2.model, glm::radians(60.0f), glm::vec3(1.0, 0.0, 1.0));


      // Grid in the plane containing the axis X and Y
      RenderObject grid_xy{};
      grid_xy.vao        = vao_grid;
      grid_xy.u_model    = u_model;
      grid_xy.draw_type  = GL_LINES; // Unconnected lines
      grid_xy.n_vertices = grid_geometry.vertices.size();
      grid_xy.model = glm::translate(grid_xy.model, glm::vec3(0.0, 1.5, -2.2));
      //grid_xy.model = glm::scale(grid_xy.model, glm::vec3(4.0, 4.0, 4.0));

      // Grid in the plane which contains the axis X and Z
      RenderObject grid_xz = grid_xy;
      grid_xz.model = glm::mat4(1.0);
      grid_xz.model = glm::rotate(grid_xz.model, glm::radians(-90.0f), glm::vec3(1.0, 0.0, 0.0));
       // grid_xz.model = glm::scale(grid_xz.model, glm::vec3(4.0, 4.0, 4.0));


      // Axis which is positioned at the origin of WCS (World Coordinate System)
      RenderObject axis_world;
      axis_world.u_model   = u_model;
      axis_world.vao       = vao_axis;
      axis_world.draw_type = GL_LINES;
      axis_world.n_vertices = axis_vertices.size();


      Camera camera(u_view, u_proj, width / height);

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT  | GL_DEPTH_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // GL_CHECK( ::glutWireTeapot(0.50) );

              // ------ Draw Grid ----------
              axis_world.render();
              grid_xy.render();
              grid_xz.render();
              cube1.render();
              cube2.render();

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwWaitEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }

          if( glfwGetKey(window, GLFW_KEY_RIGHT ) == GLFW_PRESS ){ camera.rotate_y(+10.0); }
          if( glfwGetKey(window, GLFW_KEY_LEFT  ) == GLFW_PRESS ){ camera.rotate_y(-10.0); }

          // Move camera up (positive Y axis)
          if( glfwGetKey(window, GLFW_KEY_UP  ) == GLFW_PRESS ){
              camera.cam_eye.y += 0.5;
              camera.update_view();
          }

          // Move camera down (negative Y axis)
          if( glfwGetKey(window, GLFW_KEY_DOWN  ) == GLFW_PRESS )
          {
              camera.cam_eye.y -= 0.5;
              camera.update_view();
          }

          // Rotate cube 1 in counter counter clockwise way around Y axis
          if( glfwGetKey(window, 'A'  ) == GLFW_PRESS )
          {
              cube1.model = glm::rotate( cube1.model, glm::radians(+10.0f), glm::vec3(0.0, 1.0, 0.0) );
          }
          // Rotate cube 1 in counter clockwise way around Y axis
          if( glfwGetKey(window, 'S'  ) == GLFW_PRESS )
          {
              cube1.model = glm::rotate( cube1.model, glm::radians(-10.0f), glm::vec3(0.0, 1.0, 0.0) );
          }

          // Rotate cube 1 in counter counter clockwise way around X axis (positive rotation)
          if( glfwGetKey(window, 'Z'  ) == GLFW_PRESS )
          {
              cube1.model = glm::rotate( cube1.model, glm::radians(+10.0f), glm::vec3(1.0, 0.0, 0.0) );
          }
          // Rotate cube 1 in counter counter clockwise way around X axis (negative rotation)
          if( glfwGetKey(window, 'X'  ) == GLFW_PRESS )
          {
              cube1.model = glm::rotate( cube1.model, glm::radians(-10.0f), glm::vec3(1.0, 0.0, 0.0) );
          }


      }

      glfwTerminate();
      return 0;

  } // --- End of main() -----//


  // ---------- S H A D E R - P R O G R A M S  -------------------------//
  //

  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(
      #version 330 core

      layout ( location = 0)  in vec3 position;
      layout ( location = 1) in vec3 color;
      out vec3 out_color;
      uniform mat4 u_model;       // Model matrix
      uniform mat4 u_view;        // Camera's view matrix
      uniform mat4 u_projection;  // Camera's projection matrix

      void main()
      {
          gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);

          // Forward to fragment shader
          out_color = color; // vec3(0.56, 0.6, 0.0);
      }

  )";

  // Fragment shader source code
  const char* code_frag_shader = R"(
      #version 330

      // This color comes from Vertex shader
      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor =  vec4(out_color, 1.0);
          // gl_FragColor = vec4(0.3, 0.6, 0.0, 1.0);
      }
  )";


      // ====== I M P L E M E N T A T I O N S ==========//

  GLFWwindow*
  make_glfwWindowi(int  width, int height, const char* title)
  {

      glfwSetErrorCallback([](int error, const char* description)
                           { std::fprintf( stderr, " [GLFW ERROR] Error = %d ; Description = %s \n"
                                          , error, description);
                           });

      GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
      assert( window != nullptr && "Failed  to create Window");

      // OpenGL context
      glfwMakeContextCurrent(window);
      // Pain whole screen as black - dark screen colors are better
      // for avoding eye strain due long hours staring on monitor.
      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

      // Set - OpenGL Core Profile - version 3.3
      GL_CHECK( glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3) );
      GL_CHECK( glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3) );
      GL_CHECK( glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE) );

      GL_CHECK( glEnable(GL_COLOR_MATERIAL) );
      GL_CHECK( glEnable(GL_DEPTH_TEST)     );
      GL_CHECK( glEnable(GL_BLEND)          );

      return window;
  }

  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);

      GLint is_compiled = GL_FALSE;
      // Check shader compilation result
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result,
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          GLint length;
          glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &length);
          assert( length > 0 );

          std::string out(length + 1, 0x00);
          GLint chars_written;
          glGetShaderInfoLog(shader_id, length, &chars_written, out.data());
          std::cerr << " [SHADER ERROR] = " << out << '\n';
          // Abort the exection of current process.
          std::abort();
      }

      glAttachShader(m_program, shader_id);
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );
      // glUseProgram(m_program);
  }

  // Upload buffer from main memory to GPU VBO
  // =>> Parameters VAO, VBO are allocated by the caller.
  void send_buffer( GLuint* pVao, GLuint* pVbo, GLsizei sizeBuffer
                  , void* pBufffer, GLint   shader_attr, GLint size
                  , GLenum type)
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;
      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);
      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);
      glEnableVertexAttribArray(shader_attr);
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);
      // ------ Disable Global state set by this function -----//
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(shader_attr);

  }


  Geometry
  make_grid_geometry(size_t n_grid, float dx, const ColorRGB& color)
  {
      std::vector<Vertex3D> grid_vertices;
      std::vector<ColorRGB> grid_colors ;

      float dy = dx;
      float grid_w  = n_grid * dx;
      float grid_h  = n_grid * dy;

      // Draw horizontal lines - parallel to X axis
      for(size_t n = 0; n < 2 * n_grid; n++)
      {
          // Line Vertex A (BEGIN)
          grid_vertices.push_back( Vertex3D{ -grid_w, dy * n - grid_h, 0 } );
          // Color of vertex A
          grid_colors.push_back(color);
          // Line Vertex B (END)
          grid_vertices.push_back( Vertex3D{ +grid_w, dy * n - grid_h, 0  } );
          // Color of vertex B
          grid_colors.push_back(color);
      }

       // Draw horizontal lines - parallel to Y axis
      for(size_t n = 0; n < 2 * n_grid; n++)
      {
          // Line point A (BEGIN)
          grid_vertices.push_back( Vertex3D{ dx * n - grid_w, -grid_h, 0 } );
          // Color of Vertex A
          grid_colors.push_back(color);
          // Line pojnt B (END)
          grid_vertices.push_back( Vertex3D{ dx * n - grid_w, +grid_h, 0  } );
          // Color of Vertex B
          grid_colors.push_back(color);

      }

      return Geometry{ grid_vertices, grid_colors };

  }

  Geometry
  make_cube_geometry(float w)
  {
      // Array of cube vertex coordinates (X, Y)
      auto vertices = std::vector<Vertex3D> {
          // Top face {y = w}
          { w, w, -w}
        , {-w, w, -w}
        , {-w, w,  w}
        , { w, w,  w}

        // Bottom face , {y = -w}
        , { w, -w,  w}
        , {-w, -w,  w}
        , {-w, -w, -w}
        , { w, -w, -w}

        // Front face  , {z = w}
        , { w,  w, w}
        , {-w,  w, w}
        , {-w, -w, w}
        , { w, -w, w}

        // Back face , {z = -w}
        , { w, -w, -w}
        , {-w, -w, -w}
        , {-w,  w, -w}
        , { w,  w, -w}

        // Left face , {x = -w}
        , {-w,  w,  w}
        , {-w,  w, -w}
        , {-w, -w, -w}
        , {-w, -w,  w}

        // Right face , {x = w}
        , {w,  w, -w}
        , {w,  w,  w}
        , {w, -w,  w}
        , {w, -w, -w}
      };

      // std::fprintf(stderr, " [TRACE] Number of cube vertices = %zu \n", cube_vertices.size() );

      auto colors = std::vector<ColorRGB> {
             color_red
          ,  color_red
          ,  color_red
          ,  color_red

          , color_blue
          , color_blue
          , color_blue
          , color_blue

          , color_green
          , color_green
          , color_green
          , color_green

          , color_gray
          , color_gray
          , color_gray
          , color_gray

          , color_dark_green
          , color_dark_green
          , color_dark_green
          , color_dark_green

          , color_dark_blue
          , color_dark_blue
          , color_dark_blue
          , color_dark_blue
      };

      return Geometry{ vertices, colors };
  }
#+END_SRC
** 3D Graphics - Quaternion

The class Transform has the fields, position for setting the object
position in world-coordinates; scale for adjusting object size and
rotation, which is a quaternion for encoding rotation around an
arbitrary axis. The use of quaternions saves the usage of many matrix
multiplications for each transform and also allows easier accumulation
of intermediate rotations.

Quaternions are also used in the camera class for providing
YRP (Yaw-Pitch-Roll) camera rotation and free movement in the
space. The keys arrow-left, arrow-right rotates the direction to where
camera is looking at to right or to the left. The key arrow-up, moves
the camera position in the direction to where the camera is looking
at. The key arrow-down moves the camera in the backward direction to
where the camera is looking at. The key 'S' rotates the camera up, the
key 'D' rotates the camera down.

The scene, has a blue square on the plane XY; a green square on plane
XZ; a teapot and torus. The torus can be moved, scaled and rotated in
the space by just changing its transform object parameters. By typing
the key 'B', the teapot scale is increased, and by typing 'N' its
scale is decrease. The keys 'J', 'L' rotates the teapot around the Y
axis. The key 'P' moves the teapot up across Y axis. The key 'O' moves
the teapot down across the Y axis.

Note: This code requires the GLUT library which provides the sample
wireframe teapot and torus.

  *Screenshots*

 [[file:images/opengl-draw3d-camera1.png][file:images/opengl-draw3d-camera1.png]]

 [[file:images/opengl-draw3d-camera2.png][file:images/opengl-draw3d-camera2.png]]


  *Code Highlights*

Transform class using quaternion:

#+BEGIN_SRC cpp

  // Transform object that combines - translation, scale and rotation (quaternion)
  struct Transform
  {
      glm::vec4 position = {0.0, 0.0, 0.0, 1.0};
      glm::vec3 scale    = {1.0, 1.0, 1.0};
      glm::quat rotation = {1.0, 0.0, 0.0, 0.0};

      void set_scale(float k){ scale[0]  = k; scale[1] = k;  scale[2]  = k;  }
      void add_scale(float k){ scale[0] += k; scale[1] += k; scale[2] += k;  }

      void set_position(float x, float y, float z)
      {  this->position = glm::vec4(x, y, z, 1.0);  };

      void set_rotation(float angle, glm::vec3 const& axis)
      { this->rotation = glm::angleAxis( glm::radians(angle), axis );  }

      void translate(float dx, float dy, float dz)
      {
          this->position[0] += dx;
          this->position[1] += dy;
          this->position[2] += dz;
      }

      // Rotation increment.
      void rotate(float angle, glm::vec3 const& axis)
      {
          auto q = glm::angleAxis( glm::radians(angle), axis );
          this->rotation = q * this->rotation;
      }

      // Get model affine transform - comprised of scale, translation and translation.
      glm::mat4 transform()
      {
          // Get transformation matrix from quaternion
          glm::mat4 trf = glm::mat4_cast(rotation);
          // Multiply all elements of column X axis scale
          trf[0] = scale[0] * glm::column(trf, 0);
          trf[1] = scale[1] * glm::column(trf, 1);
          trf[2] = scale[2] * glm::column(trf, 2);
          trf[3] = position;
          return trf;
      }
  };
#+END_SRC

Camera class using quaternions for rotating the camera:

#+BEGIN_SRC cpp
  struct Camera
  {
      // Current location of camera in world coordinates
      glm::vec3 eye  = { 2.0, 4.0, 5.0 };
      // Direction to where camera is looking at.
      glm::vec3 forward =  {-1.0, 0.0, -1.0 };
      // Current  camera up vector (orientation) - Y axis (default)
      glm::vec3 up = { 0.0, 1.0, 0.0 };

      // Field of view
      float fov_angle = glm::radians(60.0);
      // Aspect ratio
      float aspect   = 1.0;
      float zFar     = 20.0;
      float zNear    = 0.1;

      // ID of shader's view uniform variable - for setting view matrix
      GLuint shader_uniform_view;
      // ID of shader's projection uniform variable for setting projection matrix.
      GLuint shader_uniform_proj;

      Camera(GLuint uniform_view, GLuint uniform_proj, float aspect):
          shader_uniform_view(uniform_view), shader_uniform_proj(uniform_proj), aspect(aspect)
      {  update_view();  }

      void update_view()
      {
          // Point to where camera is looking at.
          auto cam_at = this->eye + this->forward;
          // Create View matrix (maps from world-space to camera-space)
          auto Tview = glm::lookAt(eye, cam_at, up);
          // Create projection matrix maps - camera-space to NDC (Normalized Device Coordinates).
          auto Tproj = glm::perspective( fov_angle, aspect, zNear, zFar );
          // Set shader uniform variables.
          glUniformMatrix4fv(shader_uniform_view, 1, GL_FALSE, glm::value_ptr(Tview) );
          glUniformMatrix4fv(shader_uniform_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );
      }

      // Rotate around camera's Up vecto.
      void rotate_yaw(float angle)
      {
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), this->up);
          // Rotate current forward vector
          forward = forward * q;
          std::cout << " [FORWARD VECTOR ] " << glm::to_string(forward) << '\n';
          this->update_view();
      }

      // Rotate around camera's pitch axis (X axis) elevate camera view.
      void rotate_pitch(float angle)
      {
          glm::vec3 axis = glm::cross(this->up, this->forward);
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), axis);
          forward = q * forward;
          this->update_view();
      }

      void rotate_roll(float angle)
      {
          glm::quat q = glm::angleAxis(glm::radians(angle), this->forward);
          this->up = q * this->up;
          this->update_view();
      }

      // Move at forward vector direction (to where camera is looking at).
      void move_forward(float factor)
      {
          this->eye = this->eye + factor * this->forward;
          this->update_view();
      }
      // Move camera to specific point in the space.
      void set_position(float dx, float dy, float dz)
      {
          this->eye = glm::vec3(dx, dy, dz);
          this->update_view();
      }

      // Set position to where camera is looking at.
      void look_at(const glm::vec3& at)
      {
          this->forward = at - this->eye;
          this->update_view();
      }

  };
#+END_SRC


  *Files*

Vertex Shader Code:

#+BEGIN_SRC cpp
  #version 330 core

  layout ( location = 0)  in vec3 position;
  // layout ( location = 1) in vec3 color;
  out vec3 out_color;
  uniform mat4 u_model;       // Model matrix
  uniform mat4 u_view;        // Camera's view matrix
  uniform mat4 u_projection;  // Camera's projection matrix
  uniform vec3 u_color;       // Unique color to all vertices set by the C++-side

  void main()
  {
      gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);
      // Forward to fragment shader
      out_color = u_color;  // color; // vec3(0.56, 0.6, 0.0);
  }
#+END_SRC

Fragment Shader Code:

#+BEGIN_SRC cpp
  #version 330

  in vec3 out_color;

  void main()
  {
      // Set vertex colors
      gl_FragColor =  vec4(out_color, 1.0);
  }
#+END_SRC

File: _CMakeLists.txt_


#+BEGIN_SRC cmake
   cmake_minimum_required(VERSION 3.5)
   project(GLFW_project)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw3d-camera  draw3d-camera.cpp        )
   target_link_libraries( draw3d-camera  glfw OpenGL::GL GLU glut )
#+END_SRC


File: _draw3d-camera.cpp_

#+BEGIN_SRC cpp
  #include <iostream>
  #include <vector>
  #include <array>
  #include <cmath>
  #include <functional>
  #include <iomanip>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Librar ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>
  #include <glm/gtc/matrix_access.hpp>

  #define GLUT_ENABLED

  #if defined(GLUT_ENABLED)
      #include <GL/glut.h>
  #endif

  GLFWwindow* make_glfwWindowi(int  width, int height, const char* title);
  // Compile some  shader
  void compile_shader(GLuint m_program, const char* code, GLenum type);

  // ------------ Basic Data Structures -----------//

  // Wrapper for 2D vertex coordinates
  struct Vertex3D{  GLfloat x, y, z;  };
  // Wrapper for RGB colors
  struct ColorRGB { GLfloat r, g, b; };

  // Transform object that combines - translation, scale and rotation (quaternion)
  struct Transform
  {
      glm::vec4 position = {0.0, 0.0, 0.0, 1.0};
      glm::vec3 scale    = {1.0, 1.0, 1.0};
      glm::quat rotation = {1.0, 0.0, 0.0, 0.0};

      void set_scale(float k){ scale[0]  = k; scale[1] = k;  scale[2]  = k;  }
      void add_scale(float k){ scale[0] += k; scale[1] += k; scale[2] += k;  }

      void set_position(float x, float y, float z)
      {  this->position = glm::vec4(x, y, z, 1.0);  };

      void set_rotation(float angle, glm::vec3 const& axis)
      { this->rotation = glm::angleAxis( glm::radians(angle), axis );  }

      void translate(float dx, float dy, float dz)
      {
          this->position[0] += dx;
          this->position[1] += dy;
          this->position[2] += dz;
      }

      // Rotation increment.
      void rotate(float angle, glm::vec3 const& axis)
      {
          auto q = glm::angleAxis( glm::radians(angle), axis );
          this->rotation = q * this->rotation;
      }

      // Get model affine transform - comprised of scale, translation and translation.
      glm::mat4 transform()
      {
          // Get transformation matrix from quaternion
          glm::mat4 trf = glm::mat4_cast(rotation);
          // Multiply all elements of column X axis scale
          trf[0] = scale[0] * glm::column(trf, 0);
          trf[1] = scale[1] * glm::column(trf, 1);
          trf[2] = scale[2] * glm::column(trf, 2);
          trf[3] = position;
          return trf;
      }
  };

  struct Camera
  {
      // Current location of camera in world coordinates
      glm::vec3 eye  = { 2.0, 4.0, 5.0 };
      // Direction to where camera is looking at.
      glm::vec3 forward =  {-1.0, -1.0, -1.0 };
      // Current  camera up vector (orientation) - Y axis (default)
      glm::vec3 up = { 0.0, 1.0, 0.0 };

      // Field of view
      float fov_angle = glm::radians(60.0);
      // Aspect ratio
      float aspect   = 1.0;
      float zFar     = 20.0;
      float zNear    = 0.1;

      // ID of shader's view uniform variable - for setting view matrix
      GLuint shader_uniform_view;
      // ID of shader's projection uniform variable for setting projection matrix.
      GLuint shader_uniform_proj;

      Camera(GLuint uniform_view, GLuint uniform_proj, float aspect):
          shader_uniform_view(uniform_view), shader_uniform_proj(uniform_proj), aspect(aspect)
      {  update_view();  }

      void update_view()
      {
          // Point to where camera is looking at.
          auto cam_at = this->eye + this->forward;
          // Create View matrix (maps from world-space to camera-space)
          auto Tview = glm::lookAt(eye, cam_at, up);
          // Create projection matrix maps - camera-space to NDC (Normalized Device Coordinates).
          auto Tproj = glm::perspective( fov_angle, aspect, zNear, zFar );
          // Set shader uniform variables.
          glUniformMatrix4fv(shader_uniform_view, 1, GL_FALSE, glm::value_ptr(Tview) );
          glUniformMatrix4fv(shader_uniform_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );
      }

      // Rotate around camera's Up vecto.
      void rotate_yaw(float angle)
      {
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), this->up);
          // Rotate current forward vector
          forward = forward * q;
          std::cout << " [FORWARD VECTOR ] " << glm::to_string(forward) << '\n';
          this->update_view();
      }

      // Rotate around camera's pitch axis (X axis) elevate camera view.
      void rotate_pitch(float angle)
      {
          glm::vec3 axis = glm::cross(this->up, this->forward);
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), axis);
          forward = q * forward;
          this->update_view();
      }

      void rotate_roll(float angle)
      {
          glm::quat q = glm::angleAxis(glm::radians(angle), this->forward);
          this->up = q * this->up;
          this->update_view();
      }

      // Move at forward vector direction (to where camera is looking at).
      void move_forward(float factor)
      {
          this->eye = this->eye + factor * this->forward;
          this->update_view();
      }
      // Move camera to specific point in the space.
      void set_position(float dx, float dy, float dz)
      {
          this->eye = glm::vec3(dx, dy, dz);
          this->update_view();
      }

      // Set position to where camera is looking at.
      void look_at(const glm::vec3& at)
      {
          this->forward = at - this->eye;
          this->update_view();
      }

  };

  void send_buffer( GLuint* pVao, GLuint* pVbo, GLsizei sizeBuffer
          , void* pBufffer, GLint   shader_attr, GLint size, GLenum type);


  constexpr ColorRGB color_red   = {1.0, 0.0, 0.0};
  constexpr ColorRGB color_green = {0.0, 1.0, 0.0};
  constexpr ColorRGB color_blue  = {0.0, 0.0, 1.0};
  constexpr ColorRGB color_yellow    = { 0.80,  1.000, 0.100 };
  constexpr ColorRGB color_gray       = { 0.47,  0.390, 0.380 };
  constexpr ColorRGB color_dark_green = { 0.027, 0.392, 0.050 };
  constexpr ColorRGB color_dark_blue  = { 0.109, 0.066, 0.411 };
  constexpr ColorRGB color_white      = { 1.0, 1.0, 1.0 };

  const glm::vec3 AXIS_X = { 1.0, 0.0, 0.0 };
  const glm::vec3 AXIS_Y = { 0.0, 1.0, 0.0 };
  const glm::vec3 AXIS_Z = { 0.0, 0.0, 1.0 };

  int main(int argc, char** argv)
  {

      /* Initialize the library */
      if (!glfwInit()){ return -1; }

      #if defined(GLUT_ENABLED)
          glutInit(&argc, argv);
      #endif
                                                //
      GLFWwindow* window = make_glfwWindowi(640, 480, "OpenGL quaternion");
      // Note: The shader source code is at the end of file.
      extern const char* code_vertex_shader;
      extern const char* code_frag_shader;

      // ====== S H A D E R - C O M P I L A T I O N ====//
      //
      GLuint prog = glCreateProgram();
      // Compile shader code
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );
      glUseProgram(prog);

      // --------- Shader Uniform Variables -------//
      const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
      const GLint u_view  = glGetUniformLocation(prog, "u_view");
      const GLint u_model = glGetUniformLocation(prog, "u_model");
      const GLint u_color = glGetUniformLocation(prog, "u_color");
      assert( u_color >= 0 );
      // ------- Shader attribute locations -------//
      const GLint attr_position = glGetAttribLocation(prog, "position");
      const GLint attr_color    = glGetAttribLocation(prog, "color");


      // ============== Set Shader Uniform Variables =============//
      //                                                          //

      int width, height;
      glfwGetWindowSize(window, &width, &height);
      // Window aspect ratio
      float aspect = static_cast<float>(width) / height;
      // Identity matrix
      const auto identity = glm::mat4(1.0);
      // Set projection matrix uniform variable
      glUniformMatrix4fv(u_proj, 1, GL_FALSE, glm::value_ptr(identity) );

      // ====== U P L O A D - TO - G P U =========================//

      Camera camera(u_view, u_proj, width / height);

      // Plane XY grid (vertical) - contains axis X and Y
      Transform model_grid_xy;
      model_grid_xy.set_position(0.0, 0.0, -2.0);

      // Plane XZ grid (horizontal) - contains axis X and Z
      Transform model_grid_xz;
      model_grid_xz.set_rotation(90.0f, AXIS_X);

      Transform model_teapot;
      model_teapot.set_scale(0.4);
      model_teapot.set_position(0.0, 0.50, 0.2);
      model_teapot.set_rotation(-90.0, glm::vec3(1.0, 0.0, 0.0) );


      auto plane_vertices = std::vector<Vertex3D>{
            {0.0, 0.0, 0.0}, {4.0, 0.0, 0.0}
          , {4.0, 0.0, 4.0} ,{0.0, 0.0, 4.0}
      };

      GLuint vao_plane          = 0;
      GLuint vbo_plane_vertices = 0;
      send_buffer( &vao_plane, &vbo_plane_vertices, sizeof(Vertex3D) * plane_vertices.size()
                  , plane_vertices.data(), attr_position, 3, GL_FLOAT );

      Transform model_plane_xz;
      model_plane_xz.set_position(-2, 0, -2);

      Transform model_plane_xy;
      model_plane_xy.set_position(-2, 0, -2);
      model_plane_xy.set_rotation(-90.0, AXIS_X);

      Transform model_torus;
      model_torus.set_position(-3, 2, 0);
      model_torus.rotate(90.0, AXIS_Y);

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT  | GL_DEPTH_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // ---- Draw horizontal plane XZ (square) ------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_plane_xz.transform()) );
              glUniform3fv(u_color, 1, &color_green.r );
              glBindVertexArray(vao_plane);
              glDrawArrays(GL_QUADS, 0, 4 );

              // ---- Draw vertical plane XY (square) ------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_plane_xy.transform()) );
              glUniform3fv(u_color, 1, &color_blue.r );
              glBindVertexArray(vao_plane);
              glDrawArrays(GL_QUADS, 0, 4 );

              // ----- Draw teapot over plane -----------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_teapot.transform()) );
              glUniform3fv(u_color, 1, &color_red.r );
              glutWireTeapot(2.5);

              // ----- Draw Torus ------------------------------------//
              glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(model_torus.transform()) );
              glUniform3fv(u_color, 1, &color_dark_green.r );
              glutWireTorus(1.0f, 2.00f, 32, 32);

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwWaitEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }

          // Rotate camera around its Z axis or forward vector
          if( glfwGetKey(window, 'T') == GLFW_PRESS ){ camera.rotate_roll(+5.0);  }
          if( glfwGetKey(window, 'Y') == GLFW_PRESS ){ camera.rotate_roll(-5.0); }

          // Rotate camera around its local X axis
          if( glfwGetKey(window, 'S') == GLFW_PRESS ){ camera.rotate_pitch(+5.0); }
          if( glfwGetKey(window, 'D') == GLFW_PRESS ){ camera.rotate_pitch(-5.0); }


          // Rotate camera.
          if( glfwGetKey(window, GLFW_KEY_UP ) == GLFW_PRESS   ){ camera.move_forward(+0.2);  }
          if( glfwGetKey(window, GLFW_KEY_DOWN ) == GLFW_PRESS ){ camera.move_forward(-0.2);  }
          if( glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS  ){ camera.rotate_yaw(+10.0);   }
          if( glfwGetKey(window, GLFW_KEY_LEFT ) == GLFW_PRESS  ){ camera.rotate_yaw(-10.0);   }

          // Reset camera - look at origin
          if( glfwGetKey(window, 'R' ) == GLFW_PRESS  ){
              camera.up = AXIS_Y;
              camera.set_position(4.0, 3.0, 2.5);
              camera.look_at( {0.0, 0.0, 0.0} );
          }

          // Rotate teapot
          if( glfwGetKey(window,  'H' ) == GLFW_PRESS   ){ model_teapot.rotate(+10.0, AXIS_Y) ;  }
          if( glfwGetKey(window,  'K' ) == GLFW_PRESS   ){ model_teapot.rotate(-10.0, AXIS_Y) ;  }
          // Move teapot up and down across Y axis
          if( glfwGetKey(window,  'P' ) == GLFW_PRESS   ){ model_teapot.translate(0.0, +0.1, 0.0) ;  }
          if( glfwGetKey(window,  'O' ) == GLFW_PRESS   ){ model_teapot.translate(0.0, -0.1, 0.0) ;  }

          // Decrease or increase Teapot size
          if( glfwGetKey(window,  'B' ) == GLFW_PRESS   ){ model_teapot.add_scale(+0.1) ;  }
          if( glfwGetKey(window,  'N' ) == GLFW_PRESS   ){ model_teapot.add_scale(-0.1) ;  }

      }

      glfwTerminate();
      return 0;

  } // --- End of main() -----//

  // ---------- S H A D E R - P R O G R A M S  -------------------------//
  //

  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(
      #version 330 core

      layout ( location = 0)  in vec3 position;
      // layout ( location = 1) in vec3 color;
      out vec3 out_color;
      uniform mat4 u_model;       // Model matrix
      uniform mat4 u_view;        // Camera's view matrix
      uniform mat4 u_projection;  // Camera's projection matrix
      uniform vec3 u_color;       // Unique color to all vertices set by the C++-side

      void main()
      {
          gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);
          // Forward to fragment shader
          out_color = u_color;  // color; // vec3(0.56, 0.6, 0.0);
      }

  )";

  // Fragment shader source code
  const char* code_frag_shader = R"(
      #version 330

      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor =  vec4(out_color, 1.0);
      }
  )";

      // ====== I M P L E M E N T A T I O N S ==========//

  GLFWwindow*
  make_glfwWindowi(int  width, int height, const char* title)
  {

      glfwSetErrorCallback([](int error, const char* description)
                           { std::fprintf( stderr, " [GLFW ERROR] Error = %d ; Description = %s \n"
                                          , error, description);
                           });

      GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
      assert( window != nullptr && "Failed  to create Window");

      // OpenGL context
      glfwMakeContextCurrent(window);
      // Pain whole screen as black - dark screen colors are better
      // for avoding eye strain due long hours staring on monitor.
      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

      // Set - OpenGL Core Profile - version 3.3
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

      glEnable(GL_COLOR_MATERIAL);
      glEnable(GL_DEPTH_TEST);
      glEnable(GL_BLEND);

      return window;
  }

  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);

      GLint is_compiled = GL_FALSE;
      // Check shader compilation result
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result,
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          std::cerr << " [ERROR] Shader compilation error. " << '\n';
          std::abort();
      }

      glAttachShader(m_program, shader_id);
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );
      // glUseProgram(m_program);
  }

  // Upload buffer from main memory to GPU VBO
  // =>> Parameters VAO, VBO are allocated by the caller.
  void send_buffer( GLuint* pVao, GLuint* pVbo, GLsizei sizeBuffer
                  , void* pBufffer, GLint   shader_attr, GLint size
                  , GLenum type)
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;
      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);
      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Upload data to current VBO buffer in GPU
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);
      glEnableVertexAttribArray(shader_attr);
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);
      // ------ Disable Global state set by this function -----//
      // Unbind VAO
      glBindVertexArray(0);
      // Unbind VBO
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute
      glDisableVertexAttribArray(shader_attr);

  }
#+END_SRC
** 3D Graphics - 3D Surface wireframe chart  

This code draws a wireframe surface of a function of two variables
y = f(x, z) using GL_LINE primitives. 

\begin{equation} 
   y = f(x, z) = \frac{10 \cdot \sin x \cdot \sin z}{z}
\end{equation}

 *Screenshot* 

#+CAPTION: 3D surface wireframe chart of f(x, z)
[[file:images/opengl-draw3d-surface-wireframe-plot.png][file:images/opengl-draw3d-surface-wireframe-plot.png]]


 *Code Highlights* 

Data structures: 

#+BEGIN_SRC cpp 

  struct Position { GLfloat x, y, z;  };
  struct Normal   { GLfloat x, y, z;  };
  struct Color    { GLfloat r, g, b;  };

  struct Vertex   {  
      Position position; // Vertex position in space 
      Normal   normal;   // Vertex normal vector for illumination (Future use)
      Color    color;    // Vertex color (RGB)
  };


  // Mesh - set of vertices (position and attributes) that represents 
  // some surface or solid. 
  struct Mesh 
  {
      std::vector<Vertex> vertices{};
      std::vector<GLuint> indices{}; 
      GLfloat line_width = 1.0;
      GLenum  draw_type; 
      GLuint vao = 0, vbo = 0, ibo = 0;
    
      // Draw mesh using indices 
      void draw_indices()
      {
          // Check wheter the mesh was sent to GPU.
          assert( vao != 0 && ibo != 0 );
          // Note: The subroutine glLineWidth is stateful!!
          glLineWidth(line_width);
          glBindVertexArray(vao);
          glDrawElements(draw_type, indices.size(), GL_UNSIGNED_INT, nullptr);
      }

      // Draw mesh using vertices 
      void draw_vertices()
      {
          assert( vao != 0 );
          glLineWidth(line_width);       
          glBindVertexArray(vao);
          glDrawArrays(draw_type, 0, vertices.size());
      }
  };
#+END_SRC

Subroutine for generating surface mesh: 

#+BEGIN_SRC cpp 
  Mesh generate_surface_wireframe_mesh(  
                               float xmin, float xmax
                             , float zmin, float zmax
                             , size_t Nx, size_t Nz
                             , Color color 
                             , SurfaceFunction const& function)
  {
      assert( xmax > xmin );
      assert( zmax > zmin );
      assert( Nx  != 0 && Nz  != 0 );

      std::cout << " [TRACE] Nx = " << Nx << " ; Nz = " << Nz << '\n';

      Mesh mesh;
      mesh.draw_type = GL_LINES;

      float dx = (xmax - xmin) / Nx;
      float dz = (zmax - zmin) / Nz; 

      // Intial allocation for avoiding many dynamic allocations
      mesh.vertices.reserve( Nx * Nz );
      mesh.indices.reserve( 2 * Nx * Nz  );
      float x, y, z, y_h;

      // Draw lines parallel to plane XY  
      for(size_t j = 0; j < Nz; j++)
      {   for(size_t i = 0; i < Nx; i++)
          {
              x = xmin + i * dx;
              z = zmin + j * dz; 
              y = function(x, z);
              y_h = function(x + dx, z);

              // Draw line segments in planes parallel to plane XY.
              //---------------------------------------------------------------------//
              // Initial vertex of line  segment
              mesh.vertices.push_back( Vertex{ Position{x, y, z}, zero_normal, color } );        
              // Final vertex of line segment 
              mesh.vertices.push_back( Vertex{ Position{x + dx, y_h, z}, zero_normal, color } );

          }
      }

      for(size_t i = 0; i < Nx; i++)
      {   for(size_t j = 0; j < Nz; j++)
          {
              x = xmin + i * dx;
              z = zmin + j * dz; 
              y = function(x, z);
              y_h = function(x, z + dz);

              // Draw line segments in planes parallel to plane YZ.
              mesh.vertices.push_back( Vertex{ Position{x, y, z       }, zero_normal, color } );
              mesh.vertices.push_back( Vertex{ Position{x, y_h, z + dz}, zero_normal, color } );

           }
      }
      return mesh;
  }

#+END_SRC

Vertex shader: 

#+BEGIN_SRC cpp 
  #version 330 core 

  layout ( location = 0)  in vec3 position;
  layout ( location = 1) in vec3 color;   

  out vec3 out_color;
  out vec3 out_coord; 
  out vec3 out_eye;

  uniform vec3 u_eye;  // Cameras's position in space
  uniform mat4 u_model;       // Model matrix 
  uniform mat4 u_view;        // Camera's view matrix    
  uniform mat4 u_projection;  // Camera's projection matrix 


  void main()
  {
      gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);

      // Forward to fragment shader 
      out_coord  = position;
      out_color = color; // vec3(0.56, 0.6, 0.0);
      out_eye = u_eye;
  }
#+END_SRC


Fragment shader: 

#+BEGIN_SRC cpp 
  #version 330 

  in vec3 out_color;
  in vec3 out_coord;
  in vec3 out_eye; 

  void main()
  {
      float k;

      if(gl_FrontFacing)
          k = 1.0; // 2.0;
      else 
          k = 0.1; // 0.01;

      float factor = distance(out_eye, out_coord) ;

      // Set vertex colors
      vec3 color = (out_coord / 2.0 / factor ) + k * out_color * ( 20.0 / factor ) ;
      // vec3 color =  k * out_color * ( 20.0 / factor ) ;

      // vec3 color = 1.0 / fac + (out_color / 2.0 + 0.5) * k;

      gl_FragColor =  vec4( color , 1.0);
      // gl_FragColor = vec4(0.3, 0.6, 0.0, 1.0);
  }
#+END_SRC

 *Source code* 

File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.5)
   project(OpenGL_3D_Wireframe_Surface_Chart)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)
   include_directories(${glm_SOURCE_DIR})


   # Download pre-compiled GLEW when building under Windows NT OS (x64)
   IF(WIN32)
      FetchContent_Declare(
         glew-release 
         URL     https://megalink.dl.sourceforge.net/project/glew/glew/2.1.0/glew-2.1.0-win32.zip
         # https://github.com/nigels-com/glew/archive/glew-2.2.0.zip
      )
      FetchContent_MakeAvailable(glew-release)
      include_directories( ${glew-release_SOURCE_DIR}/include  ${glm_SOURCE_DIR} )        
      link_directories(  ${glew-release_SOURCE_DIR}/lib/Release/x64 )

      set( GLEW_LIB_PATH1 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32.lib )
      set( GLEW_LIB_PATH2 ${glew-release_SOURCE_DIR}/lib/Release/x64/glew32s.lib )
   ENDIF()


   MACRO(ADD_OPENGL_APP target sources)
      add_executable( ${target} ${sources} )
      message([TRACE] " Add OpenGL executable = ${target} ")

      target_link_libraries( ${target} glfw
                                       OpenGL::GL
                                       ${GLEW_LIB_PATH1}
                                       ${GLEW_LIB_PATH2} )

       IF(MINGW)
           # Statically link against MINGW dependencies
           # for making easier to deploy on other machines. 
           target_link_options( ${target} PRIVATE                                 
                                    -static-libgcc
                                    -static-libstdc++
                                    -Wl,-Bstatic,--whole-archive -lwinpthread
                                      -Wl,--no-whole-archive				     
                                    )
        ENDIF()       


        # Copy GLEW DLL shared library to same directory as the executable.		 
        IF(WIN32)				 
           add_custom_command(TARGET ${target} POST_BUILD 
                          COMMAND ${CMAKE_COMMAND} -E copy_if_different
                          "${glew-release_SOURCE_DIR}/bin/Release/x64/glew32.dll"              
                          $<TARGET_FILE_DIR:${target}>)
        ENDIF()	   				   
   ENDMACRO()     

        # ======= T A R G E T S ============================#
        #                                                   #

   ADD_OPENGL_APP( draw3d-plot-surface draw3d-plot-surface.cpp )
#+END_SRC


File: _draw3d-plot-surface.cpp_ 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <sstream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <functional>
  #include <thread>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Librar ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>

  // #define GLUT_ENABLED 

  #if defined(GLUT_ENABLED)
      #include <GL/glut.h>
  #endif 

  #define GL_CHECK(funcall)\
      do { \
          (funcall); \
          GLint error = glGetError();  \
          if(error == GL_NO_ERROR){ break; } \
          std::fprintf(stderr, " [OPENGL ERROR] Error code = %d ; line = %d ; call = '%s'  \n" \
                        , error, __LINE__, #funcall ); \
          abort(); \
      } while(0)

  GLFWwindow* make_glfwWindow(int  width, int height, const char* title);

  // Compile some  shader 
  void compile_shader(GLuint m_program, const char* code, GLenum type);

  // Send data from memory to GPU VBO memory 
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller 
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer 
                    , GLint   shader_attr // Shader attribute location id 
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate                   
                    );

  // ------------ Basic Data Structures -----------// 


  struct Position { GLfloat x, y, z;  };
  struct Normal   { GLfloat x, y, z;  };
  struct Color    { GLfloat r, g, b;  };

  struct Vertex   {  
      Position position; // Vertex position in space 
      Normal   normal;   // Vertex normal vector for illumination (Future use)
      Color    color;    // Vertex color (RGB)
  };

  std::ostream& operator<<(std::ostream& os, Vertex const& v)
  {
      return os << " Vertex{ x = " << v.position.x << " ; " 
                << " y = " << v.position.y << " ; z = " << v.position.z << " } ";
  }

  // Mesh - set of vertices (position and attributes) that represents 
  // some surface or solid. 
  struct Mesh 
  {
      std::vector<Vertex> vertices{};
      std::vector<GLuint> indices{}; 
      GLfloat line_width = 1.0;
      GLenum  draw_type; 
      GLuint vao = 0, vbo = 0, ibo = 0;
    
      // Draw mesh using indices 
      void draw_indices()
      {
          // Check wheter the mesh was sent to GPU.
          assert( vao != 0 && ibo != 0 );
          // Note: The subroutine glLineWidth is stateful!!
          glLineWidth(line_width);
          glBindVertexArray(vao);
          glDrawElements(draw_type, indices.size(), GL_UNSIGNED_INT, nullptr);
      }

      // Draw mesh using vertices 
      void draw_vertices()
      {
          assert( vao != 0 );
          glLineWidth(line_width);       
          glBindVertexArray(vao);
          glDrawArrays(draw_type, 0, vertices.size());
      }
  };


  // Send/upload mesh data to GPU 
  // attr_position =>> Shader attribute location for vertex position 
  // attr_color    =>> Shader attribute location for vertex color 
  void send_mesh( Mesh& mesh , GLint attr_position , GLint attr_color ); 

  constexpr Position origin = { 0.0, 0.0, 0.0};
  constexpr Position position_x(float x){ return {x, 0.0, 0.0};  }
  constexpr Position position_y(float y){ return {0.0, y, 0.0};  }
  constexpr Position position_z(float z){ return {0.0, 0.0, z};  }

  constexpr Normal zero_normal = { 0.0, 0.0 , 0.0};
  constexpr Color  color_red   = {1.0, 0.0, 0.0};
  constexpr Color  color_green = {0.0, 1.0, 0.0};        
  constexpr Color  color_blue  = {0.0, 0.0, 1.0};

  const glm::mat4 matrix_identity = glm::mat4(1.0);


  struct Camera
  {
      // Current location of camera in world coordinates
      glm::vec3 eye  = { 2.0, 4.0, 5.0 };
      // Direction to where camera is looking at.
      glm::vec3 forward =  {-1.0, 0.0, -1.0 };
      // Current  camera up vector (orientation) - Y axis (default)
      glm::vec3 up = { 0.0, 1.0, 0.0 };

      // Field of view
      float fov_angle = glm::radians(60.0);
      // Aspect ratio
      float aspect   = 1.0;
      float zFar     = 100.0;
      float zNear    = 0.1;

      // ID of shader's view uniform variable - for setting view matrix
      GLint shader_uniform_view = -1;
      // ID of shader's projection uniform variable for setting projection matrix.
      GLint shader_uniform_proj = -1;

      GLint shader_uniform_eye = -1;

      Camera(GLuint uniform_view, GLuint uniform_proj, GLuint uniform_eye, float aspect):
           shader_uniform_view(uniform_view)
         , shader_uniform_proj(uniform_proj)
         , shader_uniform_eye(uniform_eye)
         , aspect(aspect)
      {  update_view();  }

      void update_view()
      {

          // Point to where camera is looking at.
          auto cam_at = this->eye + this->forward;
          // Create View matrix (maps from world-space to camera-space)
          auto Tview = glm::lookAt(eye, cam_at, up);
          // Create projection matrix maps - camera-space to NDC (Normalized Device Coordinates).
          auto Tproj = glm::perspective( fov_angle, aspect, zNear, zFar );
          // Set shader uniform variables.
          glUniformMatrix4fv(shader_uniform_view, 1, GL_FALSE, glm::value_ptr(Tview) );
          glUniformMatrix4fv(shader_uniform_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );
          glUniform3fv(shader_uniform_eye, 1, glm::value_ptr(eye));
      }

      // Rotate around camera's Up vecto.
      void rotate_yaw(float angle)
      {
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), this->up);
          // Rotate current forward vector
          forward = forward * q;
          // std::cout << " [FORWARD VECTOR ] " << glm::to_string(forward) << '\n';
          this->update_view();
      }

      // Rotate around camera's pitch axis (X axis) elevate camera view.
      void rotate_pitch(float angle)
      {
          glm::vec3 axis = glm::cross(this->up, this->forward);
          // Build quaternion from axis angle
          glm::quat q = glm::angleAxis(glm::radians(angle), axis);
          forward = q * forward;
          this->update_view();
      }

        // Move at forward vector direction (to where camera is looking at).
      void move_forward(float factor)
      {
          this->eye = this->eye + factor * this->forward;
          this->update_view();
      }
      // Move camera to specific point in the space.
      void set_position(float x, float y, float z)
      {
          this->eye = glm::vec3(x, y, z);
          this->update_view();
      }

      // Set position to where camera is looking at.
      void look_at(const glm::vec3& at)
      {
          this->forward = at - this->eye;
          this->update_view();
      }

  };

  using SurfaceFunction = std::function<float (float, float)>;

  // Nx - Number of points in the Xmin, Xmax interval 
  // Ny - Number of points in the Ymin, Ymax interval 
  Mesh generate_surface_wireframe_mesh(  
                               float xmin, float xmax
                             , float zmin, float zmax
                             , size_t Nx, size_t Nz
                             , Color color 
                             , SurfaceFunction const& function);

  int main(int argc, char** argv)
  {

      /* Initialize the library */
      if (!glfwInit()){ return -1; }

      #if defined(GLUT_ENABLED)
          glutInit(&argc, argv);
      #endif

      // ====== S H A D E R - C O M P I L A T I O N ====//
      //                                                // 
    
      GLFWwindow* window = make_glfwWindow(640, 480, "Plot 3D surface");

      // Note: The shader source code is at the end of file.
      extern const char* code_vertex_shader;
      extern const char* code_frag_shader;

      GLuint prog = glCreateProgram();
      // Compile shader code 
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;    
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );
      glUseProgram(prog);

      // Get shader uniform variable location for projection matrix
      // See shader code: "uniform mat4 projection;"
      const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
      assert( u_proj >= 0 && "Failed to find u_projection uniform variable" );

      const GLint u_view = glGetUniformLocation(prog, "u_view");
      assert( u_proj >= 0 && "Failed to find u_view uniform variable" );

      // Get shader uniform variable  location for model matrix.
      const GLint u_model  = glGetUniformLocation(prog, "u_model");
      assert( u_model >= 0 && "Failed to find uniform variable" );  

      const GLint u_camera_eye = glGetUniformLocation(prog, "u_eye");
      printf(" [TRACE] u_camera_eye = %d \n", u_camera_eye);
      assert( u_camera_eye >= 0 );  

      // Get shader attribute location - the function glGetAttribLocation - returns (-1) on error.
      const GLint attr_position = glGetAttribLocation(prog, "position");
      assert( attr_position >= 0 && "Failed to get attribute location" );

      // Get shader attribute of color 
      const GLint attr_color = glGetAttribLocation(prog, "color");
      if( attr_color < 0){ std::fprintf(stderr, " [WARNING] Shader color attribute location not found. \n"); };

      glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(matrix_identity) );
      glUniformMatrix4fv(u_proj,  1, GL_FALSE, glm::value_ptr(matrix_identity) );

      // ====== U P L O A D - TO - G P U =========================// 
      //                                                          //

      // ----- X, Y, Z axis for visual debugging ----------------
      // X axis (GREEN) ; Y axis (RED); Z axis (BLUE)
      GLuint vao_axis = 0; 
      GLuint vbo_axis_vertices = 0;
      GLuint vbo_axis_colors = 0;
      float axis_len = 100.0;


      Mesh mesh_axis{};
      mesh_axis.vertices = {
            // X axis line  
            { origin,                  zero_normal,  color_green }
          , { position_x(axis_len),    zero_normal,  color_green }
            // Y axis line 
          , { origin,                   zero_normal,  color_red  }
          , { position_y(axis_len),     zero_normal,  color_red  }  
            //  Z axis line
          , { origin,                   zero_normal,  color_blue }
          , { position_z(axis_len),     zero_normal,  color_blue } 
      };
      mesh_axis.line_width = 10.0;
      mesh_axis.draw_type  = GL_LINES;
      send_mesh(mesh_axis, attr_position, attr_color);
    

      Mesh mesh_surface = generate_surface_wireframe_mesh(
                                -20, +20.0  // Xmax, Xmin 
                              , -20, +20.0  // Zmax, Zmin 
                              ,  200, 200   // Nx, Nz     => Number of points on X and Z axis
                              , color_green // Surface wireframe color 
                              // , [&](float x, float z){ return 25.0 - x * x - z * z ;}
                              , [&](float x, float z){ return 10.0 * sin(x) * sin(z) / z  ; }
                          ); 
      mesh_surface.line_width = 0.25;
      mesh_surface.draw_type  = GL_LINES;
      send_mesh(mesh_surface, attr_position, attr_color);

      // ============== Set Shader Uniform Variables =============// 
      //                                                          // 

      int width, height;
      glfwGetWindowSize(window, &width, &height);
      // Window aspect ratio
      float aspect = static_cast<float>(width) / height;

      // Set projection matrix uniform variable
      // glUniformMatrix4fv(u_proj, 1, GL_FALSE, glm::value_ptr(identity) );
    
      Camera camera(u_view, u_proj, u_camera_eye, width / height);
      camera.set_position(-23.0, 21.0, -22.0);
      camera.look_at({0.0, 0.0, 0.0});

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT  | GL_DEPTH_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//    

              // Draw axis lines
              mesh_axis.draw_vertices();           

              // Draw surface
              mesh_surface.draw_vertices(); 
              // mesh_surface.draw_indices();
             

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwWaitEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }

          // Move camera to direction to where it is looking at.
          if( glfwGetKey(window, GLFW_KEY_UP ) == GLFW_PRESS    ){ camera.move_forward(+0.5);  }
          if( glfwGetKey(window, GLFW_KEY_DOWN ) == GLFW_PRESS  ){ camera.move_forward(-0.5);  }

          // Rotate around its Y axis 
          if( glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS  ){ camera.rotate_yaw(+5.0);   }
          if( glfwGetKey(window, GLFW_KEY_LEFT ) == GLFW_PRESS  ){ camera.rotate_yaw(-5.0);   }

          // Rotate camera around its local X axis
          if( glfwGetKey(window, 'S') == GLFW_PRESS ){ camera.rotate_pitch(+5.0); }
          if( glfwGetKey(window, 'D') == GLFW_PRESS ){ camera.rotate_pitch(-5.0); }

          // Reset camera - look at origin
          if( glfwGetKey(window, 'R' ) == GLFW_PRESS  )
          {
              camera.set_position(4.0, 3.0, 2.5);
              camera.look_at( {0.0, 0.0, 0.0} );
          }

      }

      glfwTerminate();
      return 0;

  } // --- End of main() -----//


  // ---------- S H A D E R - P R O G R A M S  -------------------------//
  //

  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(    
      #version 330 core 

      layout ( location = 0)  in vec3 position;
      layout ( location = 1) in vec3 color;   

      out vec3 out_color;
      out vec3 out_coord; 
      out vec3 out_eye;

      uniform vec3 u_eye;  // Cameras's position in space
      uniform mat4 u_model;       // Model matrix 
      uniform mat4 u_view;        // Camera's view matrix    
      uniform mat4 u_projection;  // Camera's projection matrix 
    

      void main()
      {
          gl_Position = u_projection * u_view * u_model * vec4(position, 1.0);
       
          // Forward to fragment shader 
          out_coord  = position;
          out_color = color; // vec3(0.56, 0.6, 0.0);
          out_eye = u_eye;
      }

  )";

  // Fragment shader source code 
  const char* code_frag_shader = R"(
      #version 330 

      in vec3 out_color;
      in vec3 out_coord;
      in vec3 out_eye; 

      void main()
      {
          float k;

          if(gl_FrontFacing)
              k = 1.0; // 2.0;
          else 
              k = 0.1; // 0.01;

          float factor = distance(out_eye, out_coord) ;

          // Set vertex colors
          vec3 color = (out_coord / 2.0 / factor ) + k * out_color * ( 20.0 / factor ) ;
          // vec3 color =  k * out_color * ( 20.0 / factor ) ;
        
          // vec3 color = 1.0 / fac + (out_color / 2.0 + 0.5) * k;

          gl_FragColor =  vec4( color , 1.0);
          // gl_FragColor = vec4(0.3, 0.6, 0.0, 1.0);
      }
  )";


      // ====== I M P L E M E N T A T I O N S ==========// 

  GLFWwindow* 
  make_glfwWindow(int  width, int height, const char* title)
  {

      glfwSetErrorCallback([](int error, const char* description)
                           { std::fprintf( stderr, " [GLFW ERROR] Error = %d ; Description = %s \n"
                                          , error, description);
                           });

      GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
      assert( window != nullptr && "Failed  to create Window");

      // OpenGL context 
      glfwMakeContextCurrent(window);
      // Pain whole screen as black - dark screen colors are better 
      // for avoding eye strain due long hours staring on monitor.
      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

      // Set - OpenGL Core Profile - version 3.3
      GL_CHECK( glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3) ); 
      GL_CHECK( glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3) );
      GL_CHECK( glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE) );

      GL_CHECK( glEnable(GL_COLOR_MATERIAL) );
      GL_CHECK( glEnable(GL_DEPTH_TEST)     );
      GL_CHECK( glEnable(GL_BLEND)          );

      return window;
  }

  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);
      GLint is_compiled = GL_FALSE;
      // Check shader compilation result 
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);
      // If there is any shader compilation result, 
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          GLint length;
          glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &length);
          assert( length > 0 );

          std::string out(length + 1, 0x00);
          GLint chars_written;
          glGetShaderInfoLog(shader_id, length, &chars_written, out.data());
          std::cerr << " [SHADER ERROR] = " << out << '\n';
          // Abort the exection of current process. 
          std::abort();
      }          

      glAttachShader(m_program, shader_id);   
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );   
      // glUseProgram(m_program);         
  }

  //  Send  mesh data to GPU ----//
  void send_mesh( Mesh& mesh , GLint attr_position , GLint attr_color   ) 
  { 
      GLuint& vao = mesh.vao;
      GLuint& vbo = mesh.vbo;
      GLuint& ibo = mesh.ibo;

      // ------------- Upload vertices --------------//
    
      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);
      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size() * sizeof(Vertex)
                  , mesh.vertices.data(), GL_STATIC_DRAW);   

      glEnableVertexAttribArray(attr_position);    
      glEnableVertexAttribArray(attr_color);    
   
      // Set data layout - how data will be interpreted.
      // => Each vertex has 2 coordinates. 
      glVertexAttribPointer( attr_position, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), nullptr);

      glVertexAttribPointer( attr_color, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex)     
                             // Offset to color member variable in class Vertex2D
                            , reinterpret_cast<void*>( offsetof(Vertex, color) )
                            );

      // -------- Upload indices ----------------------//
      //
      if (!mesh.indices.empty())
      {
          glBindVertexArray(vao);
          glGenBuffers(1, &ibo);
          glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
          glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size() * sizeof(GLuint)
                       , mesh.indices.data(), GL_STATIC_DRAW );
      }

      // ------ Disable Global state set by this function -----//
      // Unbind VAO 
      glBindVertexArray(0);
      // Unbind VBO 
      glBindBuffer(GL_ARRAY_BUFFER, 0);
      // Unbind IBO 
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0);
      // Disable current shader attribute 
      glDisableVertexAttribArray(attr_position);
      glDisableVertexAttribArray(attr_color);

  }


  Mesh generate_surface_wireframe_mesh(  
                               float xmin, float xmax
                             , float zmin, float zmax
                             , size_t Nx, size_t Nz
                             , Color color 
                             , SurfaceFunction const& function)
  {
      assert( xmax > xmin );
      assert( zmax > zmin );
      assert( Nx  != 0 && Nz  != 0 );

      std::cout << " [TRACE] Nx = " << Nx << " ; Nz = " << Nz << '\n';

      Mesh mesh;
      mesh.draw_type = GL_LINES;

      float dx = (xmax - xmin) / Nx;
      float dz = (zmax - zmin) / Nz; 

      // Intial allocation for avoiding many dynamic allocations
      mesh.vertices.reserve( Nx * Nz );
      mesh.indices.reserve( 2 * Nx * Nz  );
      float x, y, z, y_h;

      // Draw lines parallel to plane XY  
      for(size_t j = 0; j < Nz; j++)
      {   for(size_t i = 0; i < Nx; i++)
          {
              x = xmin + i * dx;
              z = zmin + j * dz; 
              y = function(x, z);
              y_h = function(x + dx, z);

              // Draw line segments in planes parallel to plane XY.
              mesh.vertices.push_back( Vertex{ Position{x, y, z}, zero_normal, color } );
              mesh.vertices.push_back( Vertex{ Position{x + dx, y_h, z}, zero_normal, color } );

          }
      }

      for(size_t i = 0; i < Nx; i++)
      {   for(size_t j = 0; j < Nz; j++)
          {
              x = xmin + i * dx;
              z = zmin + j * dz; 
              y = function(x, z);
              y_h = function(x, z + dz);

              // Draw line segments in planes parallel to plane YZ.
              mesh.vertices.push_back( Vertex{ Position{x, y, z       }, zero_normal, color } );
              mesh.vertices.push_back( Vertex{ Position{x, y_h, z + dz}, zero_normal, color } );

           }
      }
      return mesh;
  }

#+END_SRC


