<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-08-09 Wed 18:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Embedded Scripting Languages</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp/c++ embedded scripting languages survey"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Embedded Scripting Languages</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4c5951c">1. Embedded Scripting Languages</a>
<ul>
<li><a href="#org192fff9">1.1. Overview</a></li>
<li><a href="#org3ae75d8">1.2. Embedded Scripting Languages Selection</a></li>
<li><a href="#orgc17ba52">1.3. MuParser - Math expression parser</a></li>
<li><a href="#org0fd1f2b">1.4. Exprtk - Math expression parser</a></li>
<li><a href="#org3e7e92d">1.5. Lua scripting engine</a>
<ul>
<li><a href="#orge066c74">1.5.1. Overview</a></li>
<li><a href="#orgc7436c7">1.5.2. Further Reading</a></li>
<li><a href="#org4178e7b">1.5.3. Example project with Sol2 C++ binding library</a></li>
</ul>
</li>
<li><a href="#orgab47671">1.6. Squirrel Scripting Language</a>
<ul>
<li><a href="#orga6572d4">1.6.1. Overview</a></li>
<li><a href="#orgf0eeec3">1.6.2. Building Squirrel standalone REPL interpreter</a></li>
<li><a href="#orgf5e014c">1.6.3. Example - embedding Squirrel with Squall Library</a></li>
</ul>
</li>
<li><a href="#org5698bba">1.7. Duktape - Embeddable Javascript Engine</a>
<ul>
<li><a href="#org0c49fad">1.7.1. Overview</a></li>
<li><a href="#org88125a9">1.7.2. Example project with DukGlue C++ binding library</a></li>
<li><a href="#org794a4a1">1.7.3. Example project with Duktape-CC binding library</a></li>
</ul>
</li>
<li><a href="#org0b113cb">1.8. QuickJS - ES20 Javascript Engine</a></li>
<li><a href="#org098b4dc">1.9. Chaiscript</a></li>
<li><a href="#org6f474af">1.10. Python Engine via Pybind11</a></li>
<li><a href="#orgd967991">1.11. Scheme-like lisp interpreter</a>
<ul>
<li><a href="#orgfbc8fb1">1.11.1. Overview</a></li>
<li><a href="#org8de5ddf">1.11.2. Code</a></li>
<li><a href="#org3b65050">1.11.3. dotted list sexp parser algorithm</a></li>
<li><a href="#orgb472bae">1.11.4. sexp parser algorithm without dotted list</a></li>
<li><a href="#org9786615">1.11.5. Interpreter for Kotlin - Java Platform</a></li>
<li><a href="#org70d4034">1.11.6. Further Reading</a></li>
</ul>
</li>
<li><a href="#orgfb2baa8">1.12. Expression interpreter</a>
<ul>
<li><a href="#org910d903">1.12.1. Overview</a></li>
<li><a href="#org6ea15ce">1.12.2. Code</a></li>
</ul>
</li>
<li><a href="#orgfa94dd1">1.13. Operator Precedence Climbing Algorithm</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org4c5951c" class="outline-2">
<h2 id="org4c5951c"><span class="section-number-2">1</span> Embedded Scripting Languages</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org192fff9" class="outline-3">
<h3 id="org192fff9"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Embedded scripting languages, sometimes called extension languages,
are programming languages available as self-contained software
libraries and designed to be embedded in a host programming language,
often a compiled statically typed language. Embedded scripting
languages allow adding new features, modifying the behavior of a
program at runtime without recompilation and source code
modification. Since embedded scripting languages are available as
libraries, the host language can inspect variables defined by a
scripting language program and call functions defined in the scripting
language for possibly allowing end-users to customize and configure
the application. Functions, also called subroutines or procedure, or
performance-intensive functions, that would not be suitable to
implement in a scripting language, registered by the host language can
also be called by the embedded scripting language.
</p>


<p>
Embedded scripting is useful for a wide range of user-case, including,
video games, interactivity, repl, configuration languages, sandboxing
and DSL - domain-specific programming languages. In video game
programming, languages such as Lua, Moonscript or GDScript (Godot game
engine) allow non-programmers such as game designers or game modders
to configure, extend and add new functionality to games written in C++
at runtime without any recompilation and dealing with low level
programming. These programming languages can also be useful for adding
interactivity, faster iteration cycle and feedback. An example of this
case is the beloved text editor Emacs that uses Elisp as its embedded
scripting language. End-users can inspect, modify and customize Emacs
behavior at runtime with instantaneous feedback by just evaluating
Elisp functions or modifying variables at the scratch buffer or Elisp
interactive REPL, the IELM repl. Another case where embedded scripting
can be found is web browsers, that are usually written in C++ and use
JavaScript, also known by the official name of ECMascript, and html
(non-turing complete) as its embedded scripting languages. Html
defines how the user interface look like and JavaScript modifies the
browser behavior and the html interface at runtime allowing curious
users to evaluate JavaScript, in the development tools console for
inspecting and interacting with html DOM (Domain Object Model) objects
with instantaneous feedback and synchronization between a modified DOM
element and its graphical representation.
</p>


<p>
<b>Common API Functionalities</b>
</p>

<p>
Some common API functionalities of a embedded scripting language API
are evaluation of source code provided as string, file or input
stream; ability to register functions of the host language and call
them from the scripting language and possiblity insptecting variables
defined in the scripting language. Another common feature is the
ability to call functions defined in the scripting language from the
host language. The following code block provide some examples about
theses features.
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-type">Engine</span> <span class="org-variable-name">engine</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Ability to evaluate source code at runtime </span>
<span class="org-type">value</span>* <span class="org-variable-name">result</span> = engine.eval<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"10 * 3 - 5 / 100 * x3 + 2.51 * if(x &gt; 0, 1/x, 0/0) ;"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span> result == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
   printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"There was an error =&gt; shutdown the application."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   exit<span class="org-rainbow-delimiters-depth-2">(</span>-1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> 

printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Result = %f "</span>, result-&gt;to_float<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Interactive Python-like REPL </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span>;;<span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">user_input</span> = getline_from_console<span class="org-rainbow-delimiters-depth-2">()</span>:
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>user_input == <span class="org-string">"quit"</span> || user_input == <span class="org-string">"exit"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
   result = engine.eval<span class="org-rainbow-delimiters-depth-2">(</span>line<span class="org-rainbow-delimiters-depth-2">)</span>;
   assert <span class="org-rainbow-delimiters-depth-2">(</span> result == <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-2">)</span>;
   printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" RESULT&gt;&gt; %s "</span>, result-&gt;to_string<span class="org-rainbow-delimiters-depth-3">()</span>.to_cstr<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">----  Ability to register functions of the host language -------//</span>

<span class="org-type">value</span>* <span class="org-function-name">udf_user_defined_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">value</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">.... ... do computations here... </span>
     <span class="org-keyword">return</span> result; 
<span class="org-rainbow-delimiters-depth-1">}</span>

engine.add_function<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"user_defined_function, "</span>&amp;udf_user_defined_function<span class="org-rainbow-delimiters-depth-1">)</span>;

result = egine.eval<span class="org-rainbow-delimiters-depth-1">(</span>r<span class="org-warning">"</span><span class="org-string">(</span>
<span class="org-string">       x = 10.2512; </span>
<span class="org-string">       y = user_defined_function('hello', x);</span>
<span class="org-string">       z = x + y;</span>
<span class="org-string">       return z;</span>
<span class="org-string"> )"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">------- Ability to call functions defined in the scripting language -------//</span>

engine.eval<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" def myfunc(x, y) = 3 * x + 5.1 * y; "</span><span class="org-rainbow-delimiters-depth-2">)</span>

FuncObject* = engine.getFunction<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"myfunc"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-type">assert</span> <span class="org-variable-name">FuncObject</span> != <span class="org-constant">nullptr</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = engine.make_args<span class="org-rainbow-delimiters-depth-2">()</span>;
args-&gt;add_int<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span>;
args-&gt;add_float<span class="org-rainbow-delimiters-depth-2">(</span>20.0<span class="org-rainbow-delimiters-depth-2">)</span>;
result = FuncObject-&gt;call<span class="org-rainbow-delimiters-depth-2">(</span>args<span class="org-rainbow-delimiters-depth-2">)</span>;
</pre>
</div>


<p>
<b>Reasonable Features of Embedded Scripting Languages</b>
</p>

<p>
This section lsits some reasonable features that a language designed
to be embedded should have:
</p>

<ul class="org-ul">
<li><span class="underline">Ligthweight</span> -  Small footprint, small size and memory requirements.</li>

<li><span class="underline">Scripting Engine as a library</span>:
<ul class="org-ul">
<li>Must be available as C or C++ library which exposes the
interpreter API allowing the client code to evaluate scripting
code from strings or files and also to retrieve objects from the
virtual machine memory.</li>
</ul></li>

<li><span class="underline">Sandboxing or capability limitations</span>
<ul class="org-ul">
<li>A reasonable requirement for an embedded scripting language is
limiting the capabilities and APIs which can be used possibly
allowing the execution of non-trusted scripts. Example: the
Javascript engines of most web browsers do not allow the script
to interact with file systems or operating system APIs.</li>
</ul></li>

<li><span class="underline">Permissive License for static linking</span></li>

<li><span class="underline">Use Cases</span>
<ul class="org-ul">
<li>DSL - Domain Specific Languages</li>
<li>Game Engines</li>
<li>Configuration files =&gt; Data Description language.</li>
<li>User content</li>
<li>Allow application runtime changes without recompilation.</li>
<li>User extension without modification of source code.</li>
</ul></li>
</ul>

<p>
<b>Examples of embedded scripting languages usage and use-cases</b>
</p>

<ul class="org-ul">
<li>TCL - Tool Command Language =&gt; Used by many EDA - Electronic
Design Automation Sofware in electronic engineering.</li>

<li>JavaScript =&gt; Used in Web Browsers, which are written mostly in
C++, for controlling user interaction, animation and etc.</li>

<li>TinyScheme =&gt; Used by GNU GIMP drawing application ans Apple's
MacOSX sandbox configuration.</li>

<li>Lua language =&gt; Used by many game engines and also by
applications such as: Nginx web server; Linux Conky; Geany
Editor; NMap editor and so on.</li>

<li>Squirrel Language =&gt; Used in game engines</li>

<li>Python
<ul class="org-ul">
<li>=&gt; Python is used as embedded scripting language by GDB - GNU
Debugger ; WinDBG  - Windows Debugger; IDA - Debugger for
Reverse Engineering.</li>
<li>Disadvantages: Python has a large footprint; it was not
designed as an embedded scripting language and it is not
possible to forbid the interpreter from calling file system
and process creation APIs.</li>
</ul></li>

<li>AutoLisp [proprietary] =&gt; Lisp-like language used in Autocad.</li>

<li>SQL (Structured Query Language) =&gt; Many databases are
implemented in C or C++ uses SQL as scripting language and
domain specific language (DSL) for querying and storing
data. Example: SQLite, Postgres SQL, &#x2026;</li>

<li>Emacs Lisp =&gt; Emacs core, including the LISP
engine/interpreter, is written in C and other parts are
written in Emacs Lisp. This lisp dialect allows extending Emacs
at with custom extensions (plugins) and also modifying the
application behavior at runtime.</li>

<li>VBA - Visual Basic for Application [proprietary] =&gt; Used in
Microsft Office Suite, specially in Microsft Excel.</li>
</ul>

<p>
<b>Considerations for choosing embedded scripting languages</b>
</p>

<ul class="org-ul">
<li>Small footprint and small overhead</li>

<li>Stability of C or C++ API</li>

<li>C++ API bindings</li>

<li>Permissive license for static linking or option of dual license
for static linking.</li>

<li>Documentation and of C or C++ binding APIs, examples about binding
code</li>

<li>Garbage collector implementation</li>

<li>Heavy duty computations with significant overhead should be
performed on the C++-side, specially loops.</li>

<li>JIT - Just-In-Time compiler =&gt; can increase the performance by
translating bytecodes into machine code.
<ul class="org-ul">
<li>Example: Lua JIT, Javascript V8 engine used by Chrome browser.</li>
</ul></li>

<li>Features for running untrusted scripts or configuration: 

<ul class="org-ul">
<li>Ability for restricting capabilities such as creating process,
accessing the file system and so on.</li>

<li>Non-turing complete =&gt; better for configuration</li>
</ul></li>

<li>Familiarity of the targe audience

<ul class="org-ul">
<li>Lua is pervasive in Games</li>

<li>TCL is pervasive on Electronic Design Automation Software</li>

<li>Javascript is widely used on the Web, NodeJS and also as
embedded scripting language of web browsers.</li>
</ul></li>
</ul>

<p>
<b>Further Reading</b> 
</p>

<ul class="org-ul">
<li><a href="https://accu.org/index.php/journals/351">ACCU - Embedded Scripting Languages</a></li>

<li><a href="https://github.com/dbohdan/embedded-scripting-languages">GitHub - dbohdan/embedded-scripting-languages: A list of embedded scripting languages</a></li>

<li><a href="https://articles.emptycrate.com/2016/03/26/so-you-want-to-embed-a-scripting-language.html">EmptyCrate.com: So You Want to Embed A Scripting Language in Your Application</a></li>

<li><a href="https://softwareengineering.stackexchange.com/questions/403911/what-makes-a-scripting-language-embeddable">What makes a scripting language "embeddable"? - Software Engineering Stack Exchange</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3ae75d8" class="outline-3">
<h3 id="org3ae75d8"><span class="section-number-3">1.2</span> Embedded Scripting Languages Selection</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Selection of embedded scripting languages and engines available as  libraries:
</p>

<p>
<b>Non categorized:</b>
</p>

<ul class="org-ul">
<li><a href="http://tcl-lang.org/">TCL</a> - Tool Command Language
<ul class="org-ul">
<li>License: akin to BSD</li>
<li>Implementation: C</li>
<li>Syntax Type: N/A</li>
<li>Note: pervasive in EDA - Electronic Design Automation software.</li>
<li>See:
<ul class="org-ul">
<li><a href="https://wiki.tcl-lang.org/page/How+to+embed+Tcl+in+C+applications">How to embed Tcl in C applications</a></li>
</ul></li>
</ul></li>

<li><a href="https://github.com/mruby/mruby">mruby</a> (Embeddable Ruby implementation)
<ul class="org-ul">
<li>License: BSD</li>
<li>Implementation: C</li>
<li>Syntax type: Ruby</li>
</ul></li>

<li><a href="https://github.com/munificent/wren">Wren</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C</li>
<li>Syntax Type: N/A</li>
</ul></li>

<li><a href="https://www.jinx-lang.org/">Jinx</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C++17</li>
<li>Syntax Type: N/A</li>
</ul></li>

<li><a href="https://marcobambini.github.io/gravity">Gravity</a>
<ul class="org-ul">
<li>License: -</li>
<li>Implementation: C</li>
<li>Syntax type: Apple's SWIFT language</li>
</ul></li>

<li><a href="https://github.com/GaijinEntertainment/daScript">DaScript</a> 
<ul class="org-ul">
<li>License: -</li>
<li>Implementation: C++14</li>
<li>Syntax type: Akin to Python</li>
</ul></li>
</ul>

<p>
<b>Lua or similar to Lua (mimics Lua syntax)</b>
</p>

<ul class="org-ul">
<li><a href="http://lua.org/">Lua</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C</li>
<li>Syntax Type: syntax inspired by scheme.</li>
</ul></li>

<li><a href="http://luajit.org/">LuaJIT</a> (Lua with JIT - Just-in-Time compiler which translates
bytecodes to native machine code for better performance.)
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C</li>
<li>Syntax type:  lua</li>
</ul></li>

<li><a href="http://www.gmscript.com/">GameMonkey Script</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C++</li>
<li>Syntax type: Akin to Lua</li>
</ul></li>

<li><a href="http://squirrel-lang.org/">Squirrel</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C++</li>
<li>Syntax type:    Lua-like</li>
<li>Note: Despite be implemented in C++, does not expose a C++ API,
it exposes a C API.</li>
</ul></li>

<li><a href="https://github.com/mingodad/squilu">Squilu</a> (Squirrel fork)
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C++</li>
<li>Syntax type: Lua-like</li>
</ul></li>
</ul>

<p>
<b>Similar to C++ (syntax that mimics C++)</b>
</p>

<ul class="org-ul">
<li><a href="http://www.angelcode.com/angelscript/">AngelScript</a>  (Note: statically typed)
<ul class="org-ul">
<li>License: Zlib</li>
<li>Implementation: C++</li>
<li>Syntax type: C++-like</li>
</ul></li>
</ul>


<p>
<b>Smiliar to Javascript or subset of Javascript (ECMAScript)</b>
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a> - Java Script Engine (VM - Virtual Machine)
used by Mozzila Firefox. 
<ul class="org-ul">
<li>License: MPL 2.0</li>
<li>Implementation: C and C++</li>
<li>Syntax tyope: JavScript (ECMAscript)</li>
<li>Used by:
<ul class="org-ul">
<li>Firefox Web Browser</li>
<li>MongoDB Document Database</li>
<li><a href="https://blog.couchdb.org/2020/02/26/the-road-to-couchdb-3-0-update-to-javascript-engine/">CoucheDB</a></li>
<li>Adobe Acrobat Reader</li>
</ul></li>
<li>See:
<ul class="org-ul">
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/How_to_embed_the_JavaScript_engine">Mozilla - How to embed the JavaScript engine</a></li>
</ul></li>
<li>Repository:
<ul class="org-ul">
<li><a href="https://github.com/ricardoquesada/Spidermonkey/">https://github.com/ricardoquesada/Spidermonkey/</a></li>
</ul></li>
</ul></li>

<li><a href="http://duktape.org/">Duktape</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C</li>
<li>Syntax type: Javascript (aka ECMAScript) E5/E5.1</li>
</ul></li>

<li><a href="https://github.com/espruino/Espruino">Espruino</a>
<ul class="org-ul">
<li>License: MPL 2</li>
<li>Implementation: C</li>
<li>Syntax type: ES5 - Javascript (ECMaScript)</li>
</ul></li>

<li><a href="https://github.com/jerryscript-project/jerryscript">JerryScript</a>
<ul class="org-ul">
<li>License: Apache v2</li>
<li>Implementation: C</li>
<li>Syntax type: Javascript (ECMAScript)</li>
</ul></li>

<li><a href="http://chaiscript.com/">ChaiScript</a> 
<ul class="org-ul">
<li>License: BSD</li>
<li>Implementation: C++</li>
<li>Syntax type: Javascript-like</li>
</ul></li>
</ul>

<p>
<b>Similar to Lisp or Scheme</b>
</p>

<ul class="org-ul">
<li><a href="https://gitlab.com/embeddable-common-lisp/ecl">ECL - Embeddable Common Lisp</a>
<ul class="org-ul">
<li>License: LGPL - 2</li>
<li>Implementation: C</li>
<li>Syntax type:    Lisp, Common Lisp</li>
</ul></li>

<li><a href="http://tinyscheme.sourceforge.net/">TinyScheme</a>
<ul class="org-ul">
<li>License: BSD</li>
<li>Implementation: C</li>
<li>Syntax tyope: scheme, lisp</li>
<li>Note: Used in GNU GIMP as scripting language and Apple MacOSX's
sandbox as configuration language.</li>
</ul></li>

<li><a href="https://ccrma.stanford.edu/software/snd/snd/s7.html">S7 Scheme</a> (Variant of TinyScheme)
<ul class="org-ul">
<li>License: BSD</li>
<li>Implementation: C</li>
<li>Syntax type: C</li>
</ul></li>

<li><a href="https://github.com/ashinn/chibi-scheme">Chibi Scheme</a>
<ul class="org-ul">
<li>Implementation: C</li>
<li>Syntax type: Scheme, Lisp</li>
</ul></li>

<li><a href="https://janet-lang.org/">Janet Language</a>
<ul class="org-ul">
<li>License: MIT</li>
<li>Implementation: C</li>
<li>Syntax type: Clojure, Lisp</li>
</ul></li>

<li><a href="https://github.com/SuperFola/Ark">ArkScript</a>  
<ul class="org-ul">
<li>License: MPL license</li>
<li>Implementation: C</li>
<li>Syntax type: Lisp-like, more clojure-like</li>
</ul></li>
</ul>

<p>
License obligations and requirements:
</p>

<ul class="org-ul">
<li><b>LGPL</b> allows dynamically linking of closed source
applications, but static linking requires source code disclosure
and release under the same license. Some LGPL libraries, such as
QT, allows static linking via commercial license.</li>

<li>MIT, BSD, APACHE and so on =&gt; Add a copy of the license; Give credit.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc17ba52" class="outline-3">
<h3 id="orgc17ba52"><span class="section-number-3">1.3</span> MuParser - Math expression parser</h3>
<div class="outline-text-3" id="text-1-3">
<p>
MuParser is a non-turing complete embedded scripting engine for
evaluating math expressions. 
</p>

<p>
Web Site: 
</p>
<ul class="org-ul">
<li><a href="https://beltoforion.de/article.php?a=muparser">https://beltoforion.de/article.php?a=muparser</a></li>
</ul>

<p>
Repository: 
</p>
<ul class="org-ul">
<li><a href="https://github.com/beltoforion/muparser/">https://github.com/beltoforion/muparser/</a></li>
</ul>

<p>
Conan Reference: 
</p>
<ul class="org-ul">
<li><a href="https://bintray.com/conan-community/conan/muparser%3Aconan/2.2.6%3Astable">muparser/2.2.6@conan/stable</a></li>
</ul>

<p>
<b>Sample Project</b>
</p>

<p>
File: <b>CMakeLists.txt</b>
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.9)
<span class="org-function-name">project</span>(cppexperiments)

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)

<span class="org-comment"># ============= Conan Bootstrap =============================#</span>

<span class="org-comment"># Download automatically, you can also just copy the conan.cmake file</span>
<span class="org-keyword">if</span>(NOT EXISTS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/conan.cmake"</span>)
   <span class="org-function-name">message</span>(STATUS <span class="org-string">"Downloading conan.cmake from https://github.com/conan-io/cmake-conan"</span>)
   <span class="org-function-name">file</span>(DOWNLOAD <span class="org-string">"https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"</span>
                 <span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/conan.cmake"</span>)
<span class="org-keyword">endif</span>()

<span class="org-function-name">include</span>(${<span class="org-variable-name">CMAKE_BINARY_DIR</span>}/conan.cmake)

<span class="org-comment"># Possible values "default" and "llvm8"</span>
<span class="org-function-name">set</span>(CONAN_PROFILE default)

<span class="org-function-name">conan_cmake_run</span>(REQUIRES
                muparser/2.2.6@conan/stable
                BASIC_SETUP
                BUILD missing)

 <span class="org-comment">#======= Targets Settings ===============+#</span>

<span class="org-function-name">add_executable</span>(muparser1_formula muparser1_formula.cpp)
<span class="org-function-name">target_link_libraries</span>(muparser1_formula muparser)
</pre>
</div>

<p>
File: <b>muparser1_formula.cpp</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">muParser.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Defined for UNIX-like: Linux, Mac OSX, QNX, ...</span>
<span class="org-preprocessor">#if</span> __unix__
<span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">unistd.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#endif</span>

<span class="org-type">bool</span> <span class="org-function-name">isTTY_terminal</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-preprocessor">   #if</span> __unix__
      <span class="org-keyword">return</span> ::ttyname<span class="org-rainbow-delimiters-depth-2">(</span>STDIN_FILENO<span class="org-rainbow-delimiters-depth-2">)</span> != <span class="org-constant">nullptr</span>;
<span class="org-preprocessor">   #else</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-preprocessor">   #endif</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-function-name">future_value</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">PV</span>, <span class="org-type">double</span> <span class="org-variable-name">rate</span>, <span class="org-type">double</span> <span class="org-variable-name">nper</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> PV * <span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-2">(</span>1 + rate / 100.0, nper<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">mu</span>::<span class="org-type">Parser</span> <span class="org-variable-name">p1</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n====== EXPERIMENT 1 - Simple math expression ======="</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    p1.SetExpr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"2^1 + 2^3 + 2^4"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] p1-A value: "</span>
              &lt;&lt; p1.GetExpr<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; p1.Eval<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    p1.SetExpr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] p1-B value: "</span>
              &lt;&lt; p1.GetExpr<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; p1.Eval<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n====== EXPERIMENT 2 - Expression with variables ======="</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    p1.DefineConst<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"pi"</span>, 3.1415<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">double</span> <span class="org-variable-name">x</span> = 10.0, <span class="org-variable-name">y</span> = 4.5;
    p1.DefineVar<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"x"</span>, &amp;x<span class="org-rainbow-delimiters-depth-2">)</span>;
    p1.DefineVar<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"y"</span>, &amp;y<span class="org-rainbow-delimiters-depth-2">)</span>;
    p1.SetExpr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" 3 * pi + sin(pi) + 4 * x + y - 5"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] p1-C value: "</span>
              &lt;&lt; p1.GetExpr<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; p1.Eval<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n====== EXPERIMENT 3 - Expression with custom function ======="</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    p1.DefineFun<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"fv"</span>, &amp;future_value<span class="org-rainbow-delimiters-depth-2">)</span>;

    p1.DefineFun<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"payoff"</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">double</span> <span class="org-variable-name">S</span>, <span class="org-type">double</span> <span class="org-variable-name">K</span><span class="org-rainbow-delimiters-depth-3">){</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::max<span class="org-rainbow-delimiters-depth-4">(</span>S - K, 0.0<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    p1.SetExpr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"fv(100, 2, 8) + payoff(100, 90)"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] p1-D value: "</span> &lt;&lt; p1.GetExpr<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; p1.Eval<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;


    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n====== EXPERIMENT 4 - Parser error handling ======="</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">When an error happens it throws an exception: mu::ParserError</span>
    <span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-2">{</span>
        p1.SetExpr<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"10.2 * 5.0 + a * 3"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">double</span> <span class="org-variable-name">value</span> = p1.Eval<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] p1-E value: "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">mu</span>::<span class="org-type">ParserError</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] p1-C Parser error: "</span> &lt;&lt; ex.GetMsg<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n====== EXPERIMENT 5 - Calutor Interactive Shell ======"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>isTTY_terminal<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" === Calculator Started OK. ====="</span> &lt;&lt; <span class="org-constant">std</span>::endl;

        <span class="org-constant">mu</span>::<span class="org-type">Parser</span> <span class="org-variable-name">p2</span>;
        <span class="org-type">double</span> <span class="org-variable-name">ans</span> = 0.0;
        p2.DefineVar<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ans"</span>, &amp;ans<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>;

        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" EXPR =&gt; "</span>;
            <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-4">)</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-4">)</span>
                <span class="org-keyword">continue</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">"quit"</span><span class="org-rainbow-delimiters-depth-4">)</span>
                <span class="org-keyword">break</span>;

            p2.SetExpr<span class="org-rainbow-delimiters-depth-4">(</span>line<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                ans = p2.Eval<span class="org-rainbow-delimiters-depth-5">()</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; ans = "</span> &lt;&lt; ans &lt;&lt; <span class="org-string">"\n\n"</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">mu</span>::<span class="org-type">ParserError</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] Parser error "</span> &lt;&lt; ex.GetMsg<span class="org-rainbow-delimiters-depth-5">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-preprocessor">#if</span> _WIN32
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter RETURN to exit. "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cin.get<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-preprocessor">#endif</span>
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Program output:</b>
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./muparser1_formula 

====== EXPERIMENT 1 - Simple math expression =======
 [*] p1-A value: 2^1 + 2^3 + 2^4  = 26
 [*] p1-B value: 3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3  = 43.0314

====== EXPERIMENT 2 - Expression with variables =======
 [*] p1-C value:  3 * pi + sin(pi) + 4 * x + y - 5  = 48.9246

====== EXPERIMENT 3 - Expression with custom <span class="org-keyword">function</span> =======
 [*] p1-D value: fv(100, 2, 8) + payoff(100, 90)  = 127.166

====== EXPERIMENT 4 - Parser error handling =======
 [ERROR] p1-C Parser error: Unexpected token <span class="org-string">"a"</span> found at position 13.

====== EXPERIMENT 5 - Calutor Interactive Shell ======
 === Calculator Started OK. =====
 EXPR =&gt; 9.81 * sin(3.1415 / 2.0) + 100 * sqrt(285.6) + exp(3.65)
 =&gt; ans = 1738.26

 EXPR =&gt; ans / 100.0 - 80.0
 =&gt; ans = -62.6174

 EXPR =&gt; ans * ans
 =&gt; ans = 3920.94

 EXPR =&gt; 

</pre>
</div>
</div>
</div>

<div id="outline-container-org0fd1f2b" class="outline-3">
<h3 id="org0fd1f2b"><span class="section-number-3">1.4</span> Exprtk - Math expression parser</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Exprtk is a MIT-license single-header, header-only and turing-complete
math expression parsing engine.
</p>

<p>
Official Web Site: 
</p>

<ul class="org-ul">
<li><a href="http://www.partow.net/programming/exprtk/">http://www.partow.net/programming/exprtk/</a></li>
</ul>

<p>
Official repository: 
</p>

<ul class="org-ul">
<li><a href="https://github.com/ArashPartow/exprtk/">https://github.com/ArashPartow/exprtk/</a></li>
</ul>

<p>
Features: 
</p>

<ul class="org-ul">
<li>Header-only library in  a single file.</li>
<li>Turing-complete</li>
<li>Sandboxed</li>
<li>Supports binding to defined-functions in C++-side.</li>
<li>Functions can operate on vectors</li>
<li>Control structures: for-loop; if-else; ternary operator.</li>
</ul>

<p>
Drawbacks: 
</p>

<ul class="org-ul">
<li>The library exprtk.hpp has one megabyte (1 mb) in a single header
file which significantly slows down the compile-time. Header-only
design should only be used for small libraries.</li>
</ul>


<p>
<b>Sample Project</b> 
</p>

<ul class="org-ul">
<li>GIST: <a href="https://gist.github.com/2ff870b653b2ec1519bf0423165db1c5">https://gist.github.com/2ff870b653b2ec1519bf0423165db1c5</a></li>

<li>Note: The static library target 'mparser' makes the compile-time
of the client code 'main.cpp' faster by using the PIMPL
(Pointer-To-Implementation) design pattern and not exposing
exprtk.hpp in the library header file.</li>
</ul>

<p>
File: CMakeLists.txt 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.9)
<span class="org-function-name">project</span>(exprk-parser)

<span class="org-comment">#========== Global Configurations =============#</span>
<span class="org-comment">#----------------------------------------------#</span>

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)     
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)
<span class="org-function-name">set</span>(CMAKE_CXX_EXTENSIONS OFF)

<span class="org-comment">#----------- Add dependencies --------------------------#</span>

<span class="org-comment">#============= Functions and macros ===========================#</span>
<span class="org-keyword">macro</span>(Download_Single_Headerlib FILE URL)
    <span class="org-function-name">file</span>(DOWNLOAD ${<span class="org-variable-name">URL</span>} ${<span class="org-variable-name">CMAKE_BINARY_DIR</span>}/include/${<span class="org-variable-name">FILE</span>})
    <span class="org-keyword">IF</span>(NOT Download_Single_Headerlib_flag)
       <span class="org-function-name">include_directories</span>(${<span class="org-variable-name">CMAKE_BINARY_DIR</span>}/include)
       <span class="org-function-name">set</span>(Download_Single_Headerlib_flag TRUE)
    <span class="org-keyword">ENDIF</span>()
<span class="org-keyword">endmacro</span>()

<span class="org-function-name">Download_Single_Headerlib</span>( exprtk.hpp 
                           https://github.com/ArashPartow/exprtk/raw/d81ac1a2ddd9877a7981d32c731fd9a75544ec68/exprtk.hpp )

<span class="org-comment">#-----------  Target settings -------------------------------#</span>

          <span class="org-function-name">add_library</span>( mparser mparser.cpp mparser.hpp )
       <span class="org-function-name">add_executable</span>( main main.cpp )
<span class="org-function-name">target_link_libraries</span>( main mparser )
</pre>
</div>

<p>
File: mparser.hpp  (cmake target: mparser static library)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> _MPARSER_HPP_
<span class="org-preprocessor">#define</span> <span class="org-variable-name">_MPARSER_HPP_</span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>


<span class="org-comment-delimiter">// </span><span class="org-comment">Unique-ownership smart pointer for implementing PimPl</span>
<span class="org-comment-delimiter">// </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: It was created because std::uniqe_ptr does </span>
<span class="org-comment-delimiter">//       </span><span class="org-comment">not support 'incomplete types'.</span>
<span class="org-comment-delimiter">//  </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: PimPl (Pointer-To-Implementation) idiom </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">is a technique for reducing compile-time and </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">maintaining ABI stability which mitigates the </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">fragile-ABI problem.</span>
<span class="org-comment-delimiter">// </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">disposer</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">pimpl_ptr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">T</span>*       <span class="org-variable-name">m_hnd</span>;    
<span class="org-function-name">public</span>:
    <span class="org-function-name">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>
        : m_hnd<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">, m_disp(disp) </span>
        <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : m_hnd<span class="org-rainbow-delimiters-depth-2">(</span>hnd<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">this</span>-&gt;release<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Disable copy constructor </span>
    <span class="org-function-name">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">pimpl_ptr</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Disable copy-</span>
    <span class="org-type">pimpl_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">pimpl_ptr</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Move Ctor </span>
    <span class="org-function-name">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">pimpl_ptr</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-3">(</span>m_hnd, rhs.m_hnd<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator </span>
    <span class="org-type">pimpl_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">pimpl_ptr</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-3">(</span>m_hnd, rhs.m_hnd<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">T</span>* <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_hnd; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">release</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: it is not possible to delete incomplete type </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">in this way: 'delete m_hnd;'</span>
        disposer<span class="org-rainbow-delimiters-depth-3">(</span>m_hnd<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_hnd = <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">this</span>-&gt;release<span class="org-rainbow-delimiters-depth-3">()</span>;
        m_hnd = hnd;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_hnd == <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span>&amp;   <span class="org-keyword">operator</span><span class="org-function-name">*</span> <span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> *m_hnd; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span>*   <span class="org-keyword">operator</span><span class="org-function-name">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_hnd; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-keyword">class</span> <span class="org-type">MathEvaluator</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">struct</span> <span class="org-type">impl</span>;
    <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">dispose</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">impl</span>* <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">pimpl_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">impl</span>, <span class="org-constant">MathEvaluator</span>::dispose<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_pimpl</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">MathEvaluator</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    ~<span class="org-function-name">MathEvaluator</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-type">MathEvaluator</span>&amp; <span class="org-function-name">add_var</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">ref</span><span class="org-rainbow-delimiters-depth-2">)</span>;   

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register function pointer callback or non-capture lambda </span>
    <span class="org-type">MathEvaluator</span>&amp; <span class="org-function-name">add_function</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">double</span> <span class="org-function-name">fptr</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Register function of two variables </span>
    <span class="org-type">MathEvaluator</span>&amp; <span class="org-function-name">add_function</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">double</span> <span class="org-function-name">fptr</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">double</span>  <span class="org-function-name">eval_code</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span>;    
    <span class="org-type">bool</span>    <span class="org-function-name">compile</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">double</span>  <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-type">void</span>    <span class="org-function-name">repl</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-preprocessor">#endif</span>
</pre>
</div>

<p>
File: mparser.cpp (cmake target: mparser static library)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">"mparser.hpp"</span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">exprtk.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--------------------------------------------------// </span>

<span class="org-keyword">struct</span> <span class="org-constant">MathEvaluator</span>::<span class="org-type">impl</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">exprtk</span>::<span class="org-type">expression</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>   <span class="org-variable-name">expr</span>;
    <span class="org-constant">exprtk</span>::<span class="org-type">symbol_table</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">symbol_table</span>;
    <span class="org-constant">exprtk</span>::<span class="org-type">parser</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>       <span class="org-variable-name">parser</span>;     
    <span class="org-constant">std</span>::<span class="org-type">string</span>                  <span class="org-variable-name">code</span>; 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Println function </span>
    <span class="org-constant">exprtk</span>::<span class="org-constant">rtl</span>::<span class="org-constant">io</span>::<span class="org-type">println</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">println</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">static method </span>
<span class="org-type">void</span> 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">dispose</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">impl</span>* <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">delete</span> p;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">MathEvaluator</span>::MathEvaluator<span class="org-rainbow-delimiters-depth-1">()</span>: m_pimpl<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">impl</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>    
    m_pimpl-&gt;symbol_table.add_constants<span class="org-rainbow-delimiters-depth-2">()</span>;
    m_pimpl-&gt;expr.register_symbol_table<span class="org-rainbow-delimiters-depth-2">(</span>m_pimpl-&gt;symbol_table<span class="org-rainbow-delimiters-depth-2">)</span>;    
    m_pimpl-&gt;symbol_table.add_function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"println"</span>, m_pimpl-&gt;println<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">MathEvaluator</span>&amp; 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">add_var</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">ref</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    m_pimpl-&gt;symbol_table.add_variable<span class="org-rainbow-delimiters-depth-2">(</span>name, ref<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">MathEvaluator</span>&amp; 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">add_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-function-name">fptr</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    m_pimpl-&gt;symbol_table.add_function<span class="org-rainbow-delimiters-depth-2">(</span>name, fptr<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">MathEvaluator</span>&amp; 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">add_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-function-name">fptr</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    m_pimpl-&gt;symbol_table.add_function<span class="org-rainbow-delimiters-depth-2">(</span>name, fptr<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">bool</span> 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">compile</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">bool</span> <span class="org-variable-name">r</span> = m_pimpl-&gt;parser.compile<span class="org-rainbow-delimiters-depth-2">(</span>code, m_pimpl-&gt;expr<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>r<span class="org-rainbow-delimiters-depth-2">){</span> 
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">err</span> = <span class="org-string">"Error: "</span>;
        err = err + m_pimpl-&gt;parser.error<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" Error: "</span> &lt;&lt; err &lt;&lt; <span class="org-string">"\n"</span>;
         <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [PARSER] Unable to parse expression."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> r;
 <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> 
<span class="org-function-name">MathEvaluator</span>::<span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> m_pimpl-&gt;expr.value<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-constant">MathEvaluator</span>::<span class="org-function-name">repl</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>; 
    <span class="org-type">double</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" EXPRTK $ &gt;&gt; "</span>;
        <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>line.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">continue</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>line == <span class="org-string">"exit"</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">return</span>;
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">this</span>-&gt;compile<span class="org-rainbow-delimiters-depth-4">(</span>line<span class="org-rainbow-delimiters-depth-4">)</span>;            
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-keyword">this</span>-&gt;value<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">'\n'</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">'\n'</span>;

        <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
File: main.cpp  (cmake target: main)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string">"mparser.hpp"</span>

<span class="org-type">double</span> <span class="org-function-name">myfun</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">void</span>   <span class="org-function-name">test_engine</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MathEvaluator</span>&amp; <span class="org-variable-name">engine</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] I am up and running Ok. "</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">MathEvaluator</span> <span class="org-variable-name">engine</span>;    
    <span class="org-type">double</span> <span class="org-variable-name">x</span> = 1.0, <span class="org-variable-name">y</span> = 2.0, <span class="org-variable-name">z</span> = 3.0;
    engine.add_var<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"x"</span>, x<span class="org-rainbow-delimiters-depth-2">)</span>
        .add_var<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"y"</span>, y<span class="org-rainbow-delimiters-depth-2">)</span>
        .add_var<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"z"</span>, z<span class="org-rainbow-delimiters-depth-2">)</span>
        .add_function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"myfun"</span>, &amp;myfun<span class="org-rainbow-delimiters-depth-2">)</span>;

    assert<span class="org-rainbow-delimiters-depth-2">(</span>argc == 2<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">command</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>argv<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>command == <span class="org-string">"test"</span> <span class="org-rainbow-delimiters-depth-2">){</span> test_engine<span class="org-rainbow-delimiters-depth-3">(</span>engine, x<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>command == <span class="org-string">"repl"</span> <span class="org-rainbow-delimiters-depth-2">){</span> engine.repl<span class="org-rainbow-delimiters-depth-3">()</span>;          <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] Shutdown engine Ok. "</span> &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">-----------------------------------------//</span>


<span class="org-type">double</span> <span class="org-function-name">myfun</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"  [TRACE] a = "</span> &lt;&lt; a &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"  [TRACE] b = "</span> &lt;&lt; b &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-type">double</span> <span class="org-variable-name">r</span> =  3.0 * a + 5.0 * b;
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"  [TRACE] result = "</span> &lt;&lt; r &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"---------------------------------\n"</span>;
    <span class="org-keyword">return</span> r;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">void</span> <span class="org-function-name">test_engine</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MathEvaluator</span>&amp; <span class="org-variable-name">engine</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span> = R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">        // Define local variables </span>
<span class="org-string">        var a := 2.0 / exp(x) * x^2 + y;</span>
<span class="org-string">        var b := 10.0 * sqrt(x) + z;</span>

<span class="org-string">        // println('\n =&gt; x = ', x);</span>
<span class="org-string">        // println('\n =&gt; y = ', y);</span>

<span class="org-string">        // Call custom function</span>
<span class="org-string">        var k := myfun(x, y);</span>

<span class="org-string">        // Comment: the last expression is returned </span>
<span class="org-string">        4.0 * a + 3 * b + 10 * z + k;        </span>
<span class="org-string">    )</span><span class="org-default">"</span>;        
    engine.compile<span class="org-rainbow-delimiters-depth-2">(</span>code<span class="org-rainbow-delimiters-depth-2">)</span>;

    x = 3.0;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; engine = "</span> &lt;&lt; engine.value<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    x = 5.0;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; engine = "</span> &lt;&lt; engine.value<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    x = 15.0;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; engine = "</span> &lt;&lt; engine.value<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    x = -15.0;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; engine = "</span> &lt;&lt; engine.value<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    x = 20.0;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; engine = "</span> &lt;&lt; engine.value<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;


    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code2</span> = R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">        // Vector/array variable </span>
<span class="org-string">        var xs [6] := {  2.0, 10.2,   -2.50,  9.256, 100.0,  25.0 };</span>
<span class="org-string">        var ys [6] := { -2.0,  1.225, -5.56, 19.000, 125.0, 125.0 };</span>

<span class="org-string">        println(' =&gt; xs =', xs);</span>
<span class="org-string">        println(' =&gt; ys = ', ys);</span>
<span class="org-string">        println(' =&gt; 3 * xs + 4 * ys = ', 3 * xs + 4 * ys);</span>
<span class="org-string">        println(' =&gt; sum(xs) = ', sum(ys) );</span>
<span class="org-string">        println(' =&gt; sum(ys) = ', sum(xs) );</span>

<span class="org-string">    )</span><span class="org-default">"</span>;
    engine.compile<span class="org-rainbow-delimiters-depth-2">(</span>code2<span class="org-rainbow-delimiters-depth-2">)</span>;
    engine.value<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
<b>Building</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git clone https://gist.github.com/2ff870b653b2ec1519bf0423165db1c5 gist &amp;&amp; <span class="org-builtin">cd</span> gist 
$ cmake --config Debug -H. -B_build  
$ cmake --build _build --target 
</pre>
</div>

<p>
<b>Running</b> 
</p>

<p>
Running 'test' subcommand. 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Redirect std::cerr or stderr to file </span>
$ _build/main test 2&gt; out.log
 [TRACE] I am up and running Ok. 
 =&gt; x = 3 ; engine = 121.546
 =&gt; x = 5 ; engine = 140.43
 =&gt; x = 15 ; engine = 218.19
 =&gt; x = -15 ; engine = -nan
 =&gt; x = 20 ; engine = 251.164
 =&gt; xs =   2.00000   10.20000   -2.50000    9.25600  100.00000   25.00000
 =&gt; ys =   -2.00000    1.22500   -5.56000   19.00000  125.00000  125.00000
 =&gt; 3 * xs + 4 * ys =   -2.00000   35.50000  -29.74000  103.76800  800.00000  575.00000
 =&gt; sum(xs) =  262.66500
 =&gt; sum(ys) =  143.95600

<span class="org-comment-delimiter"># </span><span class="org-comment">View log file </span>
$ _build/main test 2&gt; out.log
 [TRACE] I am up and running Ok. 
 =&gt; x = 3 ; engine = 121.546
 =&gt; x = 5 ; engine = 140.43
 =&gt; x = 15 ; engine = 218.19
 =&gt; x = -15 ; engine = -nan
 =&gt; x = 20 ; engine = 251.164
 =&gt; xs =   2.00000   10.20000   -2.50000    9.25600  100.00000   25.00000
 =&gt; ys =   -2.00000    1.22500   -5.56000   19.00000  125.00000  125.00000
 =&gt; 3 * xs + 4 * ys =   -2.00000   35.50000  -29.74000  103.76800  800.00000  575.00000
 =&gt; sum(xs) =  262.66500
 =&gt; sum(ys) =  143.95600
</pre>
</div>

<p>
Running 'repl' subcommand for interactive shell.
</p>

<div class="org-src-container">
<pre class="src src-sh"> rlwrap _build/main repl 
 [TRACE] I am up and running Ok. 
 EXPRTK $ &gt;&gt; sin(pi) * 2.0  + 5.3 * cos(3/2 * pi)
-7.28665e-16
 EXPRTK $ &gt;&gt; exp(3.1)
22.198
 EXPRTK $ &gt;&gt; var a := exp(2.5); var b := a * 3.0 + 10.0; 3 * a + b
83.095
 EXPRTK $ &gt;&gt; 
 EXPRTK $ &gt;&gt; println(<span class="org-string">' x = '</span>, x)
 x =    1.00000
0
 EXPRTK $ &gt;&gt; myfun(5.1, 2.56)
  [TRACE] a = 5.1
  [TRACE] b = 2.56
  [TRACE] result = 28.1
---------------------------------
28.1
 EXPRTK $ &gt;&gt; 
 EXPRTK $ &gt;&gt; myfun(5.1, 2.0 * pi + 10.0)
  [TRACE] a = 5.1
  [TRACE] b = 16.2832
  [TRACE] result = 96.7159
---------------------------------
96.7159
 EXPRTK $ &gt;&gt; 
 EXPRTK $ &gt;&gt; exit
 [TRACE] Shutdown engine Ok. 

</pre>
</div>
</div>
</div>
<div id="outline-container-org3e7e92d" class="outline-3">
<h3 id="org3e7e92d"><span class="section-number-3">1.5</span> Lua scripting engine</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orge066c74" class="outline-4">
<h4 id="orge066c74"><span class="section-number-4">1.5.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Lua (moon in Portuguese) is a ligthweight multi paradigm scripting
language written in C. Due to Lua be available as small footprint
library, this language is widely used as embedded scripting by many
applications for scripting and as configuration or data description
language.
</p>

<p>
Use cases: 
</p>

<ul class="org-ul">
<li>Scripting for C or C++ applications</li>

<li>Extension language =&gt; Add new functionality and updates without
recompilation.</li>

<li>Provide interactive REPL or shell to C or C++ applications.</li>

<li>Program configuration (settings)</li>

<li>Data description language</li>
</ul>

<p>
Some applications using Lua: 
</p>

<ul class="org-ul">
<li><a href="https://nmap.org/book/nse-language.html">Nmap</a> network scanner</li>
<li>MediaWiki (engine used by Wikipedia)</li>
<li>Nginx Web Server</li>
<li>Redis Database</li>
<li>Linux Conky</li>
<li>LuaTex</li>
<li>NetBSD</li>
<li>Cheat Engine</li>
<li>Geany text editor</li>
<li><a href="https://github.com/xmake-io/xmake">Xmake</a> building system for C, C++, Objective-C, Swift, Assembly,
Golang, Rust, Dlang and Cuda</li>
<li><a href="https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games">Lots of games</a> use lua for scripting and allow non-programmers,
such as end-users and game artists to contribute to the game
development, create animations, movements, finite state machines
and so on.</li>
<li>&#x2026; &#x2026;</li>
</ul>

<p>
More at: 
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/List_of_applications_using_Lua">List of applications using Lua - Wikipedia</a></li>

<li><a href="https://web.archive.org/web/20180322033939/https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games">Category:Lua-scripted video games - Wikipedia</a></li>
</ul>


<p>
<b>Repository and  C++ Binding Libraries</b> 
</p>

<ul class="org-ul">
<li>Official Repository Mirror
<ul class="org-ul">
<li><a href="https://github.com/lua/lua">https://github.com/lua/lua</a></li>
</ul></li>

<li>Lua Bind
<ul class="org-ul">
<li><a href="https://www.rasterbar.com/products/luabind/docs.html">https://www.rasterbar.com/products/luabind/docs.html</a></li>
<li><a href="https://sourceforge.net/projects/luabind/">https://sourceforge.net/projects/luabind/</a></li>
<li><a href="https://github.com/luabind/luabind">https://github.com/luabind/luabind</a></li>
</ul></li>

<li>Sol2 (means 'sun' 2 in Portuguese)
<ul class="org-ul">
<li><a href="https://github.com/ThePhD/sol2">https://github.com/ThePhD/sol2</a></li>
<li><a href="https://sol2.readthedocs.io/en/latest/">https://sol2.readthedocs.io/en/latest/</a></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc7436c7" class="outline-4">
<h4 id="orgc7436c7"><span class="section-number-4">1.5.2</span> Further Reading</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
<b>Documentation</b> 
</p>

<ul class="org-ul">
<li><a href="https://www.lua.org/manual/5.1/manual.html">Lua 5.1 Reference Manual</a> - Documentation</li>

<li><a href="https://en.wikipedia.org/wiki/Lua_(programming_language)">Lua (programming language) - Wikipedia</a></li>
</ul>

<p>
<b>Lua C API</b>
</p>

<ul class="org-ul">
<li><a href="https://www.lua.org/pil/24.1.html">Programming in Lua : 24.1</a></li>

<li><a href="http://lua-users.org/wiki/BindingCodeToLua">lua-users wiki: Binding Code To Lua</a></li>

<li><a href="http://lua-users.org/wiki/SimpleLuaApiExample">lua-users wiki: Simple Lua Api Example</a></li>

<li><a href="http://webserver2.tecgraf.puc-rio.br/lua/local/pil/24.html">Programming in Lua : 24</a></li>

<li><a href="https://chsasank.github.io/lua-c-wrapping.html">Exposing C functions to Lua</a></li>
</ul>

<p>
<b>Lua embedded in Geany Text Editor</b> 
</p>

<ul class="org-ul">
<li><a href="https://plugins.geany.org/geanylua/geanylua-intro.html">https://plugins.geany.org/geanylua/geanylua-intro.html</a></li>

<li><a href="https://github.com/geany/geany-plugins/tree/master/geanylua/examples">https://github.com/geany/geany-plugins/tree/master/geanylua/examples</a></li>

<li><a href="https://github.com/DGivney/geany-lua-scripts">https://github.com/DGivney/geany-lua-scripts</a>
<ul class="org-ul">
<li>Collection of Lua scripts for Geany text editor</li>
</ul></li>

<li><a href="https://github.com/geany/geany-plugins/tree/master/geanylua">https://github.com/geany/geany-plugins/tree/master/geanylua</a></li>
</ul>

<p>
<b>Lua scripting in NMap Network Scanner</b> 
</p>

<ul class="org-ul">
<li><a href="https://nmap.org/book/nse-language.html">Script Language | Nmap Network Scanning</a>
<ul class="org-ul">
<li>"The core of the Nmap Scripting Engine <b>is an embeddable Lua</b>
<b>interpreter</b>. <span class="underline">Lua is a lightweight language designed for</span>
<span class="underline">extensibility. It offers a powerful and well-documented API for</span>
interfacing with other software such as Nmap. The second part of
<span class="underline">the Nmap Scripting Engine is the NSE Library, which connects Lua</span>
<span class="underline">and Nmap</span>. This layer handles issues such as initialization of
the Lua interpreter, scheduling of parallel script execution,
script retrieval and more. It is also the heart of the NSE
network I/O framework and the exception handling mechanism. It
also includes utility libraries to make scripts more powerful
and convenient. The utility library modules and extensions are
described in the section called 'NSE Libraries'."</li>
</ul></li>

<li><a href="https://github.com/nmap/nmap/tree/master/nselib">Nmap Scripting Engine Source Code</a> / GITHUB</li>

<li><a href="https://dev.to/citizen428/extending-nmap-withlua-bpa">Extending Nmap WithLua - DEV</a></li>
</ul>


<p>
<b>Lua Scripting in Wireshark - Network Capture Application</b>
</p>

<ul class="org-ul">
<li><a href="https://wiki.wireshark.org/Lua">Lua - The Wireshark Wiki</a></li>

<li><a href="https://sharkfestus.wireshark.org/sharkfest.09/DT06_Bjorlykke_Lua%20Scripting%20in%20Wireshark.pdf">Lua Scripting in Wireshark</a></li>
</ul>

<p>
<b>Lua Scripting in XMake Building System</b> 
</p>

<ul class="org-ul">
<li><a href="https://github.com/xmake-io/xmake">https://github.com/xmake-io/xmake</a></li>

<li><a href="https://github.com/xmake-io/xmake/search?l=C%2B%2B&amp;q=lua&amp;type=">Search for usages of Lua C API in Xmake source code</a></li>
</ul>

<p>
<b>Lua scripting on NetBSD Kernel</b> 
</p>

<ul class="org-ul">
<li><a href="https://www.netbsd.org/gallery/presentations/mbalmer/fosdem2012/kernel_mode_lua.pdf">Lua in teh NetBSD Kernel</a></li>

<li><a href="https://2018.eurobsdcon.org/static/slides/Fast,%20Flexible%20Packet%20Filtering%20in%20NetBSD%20using%20Lua%20Kernel%20Scripts%20-%20Andrew%20von%20Dollen.pdf">Lua Kernel Scripting in NetBSD - Fast, Flexible Packet Filtering</a></li>

<li><a href="https://www.lua.org/wshop13/Cormack.pdf">Towards a Lua scripted operating system</a></li>

<li><a href="https://www.slideshare.net/eurobsdcon/lneto-npf-scripting">NPF scripting with Lua by Lourival Vieira Neto</a></li>
</ul>


<p>
<b>Lua scripting on Redis Database</b> 
</p>

<ul class="org-ul">
<li><a href="https://www.slideshare.net/itamarhaber/redis-lua-scripts">Redis Lua Scripts</a></li>

<li><a href="https://www.slideshare.net/RedisLabs/redis-lua-scripts-a-primer-and-use-cases">Redis: Lua scripts - a primer and use cases</a></li>
</ul>


<p>
<b>Lua scripting on Nginx Web Server</b> 
</p>

<ul class="org-ul">
<li><a href="https://www.nginx.com/resources/wiki/modules/lua/">Lua on NGINX web server</a></li>

<li><a href="https://blog.cloudflare.com/pushing-nginx-to-its-limit-with-lua/">Pushing Nginx to its limit with Lua</a> - CloudFlare</li>

<li><a href="https://www.slideshare.net/gakhov/implementing-a-fileserver-with-nginx-and-lua">Implementing a Fileserver with Nginx and Lua</a></li>
</ul>


<p>
<b>Lua scripting on Unreal Engine / game engine</b> 
</p>

<ul class="org-ul">
<li><a href="https://tylerneylon.com/a/learn-lua/">Learn Lua in 15 Minutes</a></li>

<li><a href="https://matt.blwt.io/post/lua-the-little-language-that-could/">Lua: The Little Language That Could</a></li>

<li><a href="https://www.slideshare.net/Codemotion/roberto-de-ioris-scriptiamo-unreal-engine-con-lua-codemotion-rome-2019">Roberto De Ioris - Scriptiamo Unreal Engine con Lua - Codemotion Rome</a></li>

<li><a href="https://github.com/rdeioris/LuaMachine">GitHub - rdeioris/LuaMachine: Unreal Engine 4 Plugin for Lua APIs implementation</a></li>

<li><a href="https://www.unrealengine.com/marketplace/en-US/product/luamachine">LuaMachine by Roberto De Ioris in Code Plugins - UE4 Marketplace</a>
<ul class="org-ul">
<li>"Unreal Engine 4 Plugin for adding Lua scripting to your
projects: If you want modders to customize your game/project, or
you need to allow game designers to script parts of the logic,
this plugin is for you; Contrary to the other Unreal Engine 4
Lua plugins, this one does not try to expose the Unreal Engine 4
api, but completely hides it exposing to the user/scripter only
the features the developer decided to include (via Blueprints or
C++); Currently Windows 64bit, Mac, Linux x86_64 (both Runtime
and Editor), Linux AArch64, Android 32bit, Android 64bit, iOS
(Runtime only) are supported."</li>
</ul></li>
</ul>

<p>
<b>Lua for DSL - Domain Specific Language</b>  
</p>

<ul class="org-ul">
<li><a href="http://lua-users.org/wiki/LuaDataFormats">lua-users wiki: Lua Data Formats</a>
<ul class="org-ul">
<li>"Lua can be used as a language to represent data, not just as a
general programming language.  Different languages have been
devised for different types of data representation in text
format."</li>
</ul></li>

<li><a href="https://leafo.net/guides/dsl-in-lua.html">Writing a DSL in Lua</a></li>

<li><a href="https://www.slideshare.net/agladysh/luaws13-ag">A visual DSL toolkit in Lua: Past, present and future</a></li>

<li><a href="https://dnaeon.github.io/choosing-lua-as-the-ddl-and-config-language/">Choosing Lua as the data description and configuration language</a></li>

<li><a href="https://www.lua.org/wshop11/luaws11_ag.pdf">Declarative Internal DSLs in Lua / A Game-Changing Experience</a></li>

<li><a href="https://en.m.wikibooks.org/wiki/Lua_Programming/Tables">Lua Programming/Tables - Wikibooks, open books for an open world</a></li>

<li><a href="https://en.m.wikiversity.org/wiki/Lua/Tables">Lua/Tables - Wikiversity</a></li>

<li><a href="https://sudonull.com/post/184529-Lua-declarative-programming-basics">Lua declarative programming basics / Sudo Null IT News</a></li>

<li><a href="https://www.slideshare.net/ShuaiYuan/the-basics-and-design-of-lua-table">The basics and design of lua table</a></li>
</ul>

<p>
<b>Videos</b>
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=pfwHCiP1HFM">CppCon 2017: Andreas Weis "Howling at the Moon: Lua for C++ Programmers"</a>
<ul class="org-ul">
<li>"C++ is a great tool for solving complex problems in a thorough
way. But every once in a while, the desire for a simpler
language emerges. For those parts of our code where performance
is of secondary concern, but the ability to perform rapid
iterations over the code is paramount, a scripting language
might be a tempting choice. But integrating a second language
besides C++ and managing the interaction between the two is also
scary. Lua is a lightweight, dynamic language that was designed
to be used as an embedded language within existing
applications. It is easy to learn, has very reasonable runtime
performance, and a memory footprint small enough that it is
usable even on embedded systems. Furthermore, it is almost
trivial to integrate with C++. This talk will give a brief
introduction to the Lua scripting language, highlighting
specifically how it can complement C++'s language features to
enrich a developer's toolbox. In the second part of the talk, we
will look at Lua's C API and give suggestions how to integrate
it with a modern C++17 codebase. In particular we will focus on
how to interface with the dynamic language Lua without
compromising the benefits of C++'s strong type system."</li>
</ul></li>

<li><a href="https://www.youtube.com/watch?v=xQAmGBfKnas">CppCon 2018: JeanHeyd Meneide Scripting at the Speed of Thought: Lua and C++ with sol3</a>
<ul class="org-ul">
<li>"A big part of accelerating development and promoting
collaboration often translates to deferring a lot of the typical
programmer work to a scripting language, to allow for those with
more design-oriented ideas and experience to handle some of the
workload. What happens, then, when you have to bind a scripting
language like Lua into C++ to allow for this workflow? This
session is going to be all about how you enable non-developers
and developers alike to rapidly increase their development
productivity by turning routines and algorithms into data that
can be shipped alongside your product in Lua. We will talk
primarily how you can use the library sol2 to abstract away the
muck of working with the Lua C API and instead focus on using
and describing both Lua and C++ with each other in a simple
manner. We will demonstrate some of the more interesting
properties of sol such as Overloading Support, Container
Support, Usertypes &#x2013; C++ classes made available with automatic
support for unique/shared pointers &#x2013; and Tables. By the time
this session is over, you will have a firm grasp over what a
good Lua Binding can offer you, and how you can accelerate your
C++ development with it."</li>
</ul></li>
</ul>

<p>
<b>General</b> 
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/List_of_applications_using_Lua">List of applications using Lua - Wikipedia</a></li>

<li><a href="https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games">Category:Lua-scripted video games - Wikipedia</a></li>

<li><a href="http://www.godpatterns.com/2005/07/using-lua-scripting-for-games.html">Godpatterns: Using Lua Scripting For Games</a></li>

<li><a href="https://gamedev.stackexchange.com/questions/73728/how-does-lua-work-as-a-scripting-language-in-games">c++ - How does Lua work as a scripting language in games? - Game Development Stack Exchange</a></li>

<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=398177770">Steam Community - Guide - GameGuru LUA scripting summary and guide.</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4178e7b" class="outline-4">
<h4 id="org4178e7b"><span class="section-number-4">1.5.3</span> Example project with Sol2 C++ binding library</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
This sample project builds a C++ statically linked executable
embedding the Lua scripting engine using the Sol2 binding library,
which is header only. Neither Sol2 nor Lua libraries need to be
installed before building this sample project as the CMake scripts
take care of downloading and building all dependencies.
</p>

<p>
Lua repostiory mirror: 
</p>

<ul class="org-ul">
<li><a href="https://github.com/lua/lua">https://github.com/lua/lua</a></li>
</ul>

<p>
Sol2 library repository: 
</p>

<ul class="org-ul">
<li><a href="https://github.com/ThePhD/sol2">https://github.com/ThePhD/sol2</a></li>
</ul>

<p>
Sol2 library documentation: 
</p>

<ul class="org-ul">
<li><a href="https://sol2.readthedocs.io/en/latest/">https://sol2.readthedocs.io/en/latest/</a></li>
</ul>


<p>
<b>Sample Project</b> 
</p>

<p>
GIST: 
</p>
<ul class="org-ul">
<li><a href="https://gist.github.com/17a37d905d3d71c0ae66661a189481b5">https://gist.github.com/17a37d905d3d71c0ae66661a189481b5</a></li>
</ul>


<p>
File: <span class="underline">CMakeLists.txt</span>
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.0)
<span class="org-function-name">project</span>(duktape-cc-trial)

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)

<span class="org-function-name">include</span>(lua-lib.cmake)

<span class="org-comment">#-----  Target Definitions ----------------------------#</span>

       <span class="org-function-name">add_executable</span>( embed-lua-sol embed-lua-sol.cpp)
<span class="org-function-name">target_link_libraries</span>( embed-lua-sol lua::lualib )

<span class="org-comment"># Lua REPL executable built from static library liblua.a (Linux)</span>
<span class="org-comment"># Note: the main() function is in the file main.c in the lua sources directory</span>
       <span class="org-function-name">add_executable</span>( lua-repl $&lt;TARGET_OBJECTS:lua::lualib&gt; )
<span class="org-function-name">target_link_libraries</span>( lua-repl m pthread )
</pre>
</div>


<p>
File: <span class="underline">lua-lib.cmake</span>
</p>

<ul class="org-ul">
<li>CMake Script for downloading sol2 binding library and lua library
sources.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">include</span>(FetchContent)

<span class="org-comment"># Note: the 'add_subriectory' line was commented becuyase </span>
<span class="org-comment">#       library that will be downloaded does not have </span>
<span class="org-comment">#       a CMakeListst.txt file at the root directory. </span>
<span class="org-keyword">macro</span>(Download_Library_Git  NAME TAG REPOSITORY_URL)
    <span class="org-function-name">FetchContent_Declare</span>(
        ${<span class="org-variable-name">NAME</span>}
        GIT_REPOSITORY  ${<span class="org-variable-name">REPOSITORY_URL</span>}
        GIT_TAG         ${<span class="org-variable-name">TAG</span>}
    )
    <span class="org-function-name">FetchContent_GetProperties</span>(${<span class="org-variable-name">NAME</span>})
    <span class="org-keyword">if</span>(NOT cpputest_POPULATED)
        <span class="org-function-name">FetchContent_Populate</span>(${<span class="org-variable-name">NAME</span>})
        <span class="org-function-name">message</span>(<span class="org-string">"${</span><span class="org-variable-name">NAME</span><span class="org-string">}_SOURCE_DIR} = ${${</span><span class="org-variable-name">NAME</span><span class="org-string">}_SOURCE_DIR}"</span>)        

        <span class="org-comment"># =&gt; Disable following line: the library does not have a CMakeLists.txt</span>
        <span class="org-comment">#    at the root directory.</span>
        <span class="org-comment"># add_subdirectory(${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_SOURCE_DIR} ${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_BINARY_DIR})</span>
    <span class="org-keyword">endif</span>()
<span class="org-keyword">endmacro</span>()


<span class="org-comment"># ====&gt;&gt; Download Lua library &lt;&lt;==========================#</span>

<span class="org-function-name">Download_Library_Git</span>( lua                       
                      v5.3.5
                      https://github.com/lua/lua
                    )

<span class="org-function-name">file</span>(GLOB_RECURSE lua_sources <span class="org-string">"${</span><span class="org-variable-name">lua_SOURCE_DIR</span><span class="org-string">}/*.c"</span>)
<span class="org-function-name">file</span>(GLOB_RECURSE lua_headers<span class="org-string">" ${</span><span class="org-variable-name">lua_SOURCE_DIR</span><span class="org-string">}/*.h"</span>)

<span class="org-function-name">message</span>( [TRACE] <span class="org-string">" lua_SOURCE_DIR = ${</span><span class="org-variable-name">lua_SOURCE_DIR</span><span class="org-string">} "</span>)

               <span class="org-function-name">add_library</span>( lua STATIC ${<span class="org-variable-name">lua_sources</span>} ${<span class="org-variable-name">lua_headers</span>} )
<span class="org-function-name">target_include_directories</span>( lua PUBLIC ${<span class="org-variable-name">lua_SOURCE_DIR</span>} )

<span class="org-function-name">add_library</span>( lua::lualib  ALIAS lua)

<span class="org-comment"># ====&gt;&gt; Download Sol C++ binding library &lt;&lt;====================#</span>

<span class="org-function-name">FetchContent_Declare</span>( sol2 
                      GIT_REPOSITORY  https://github.com/ThePhD/sol2
                      GIT_TAG         v3.2.0
                    )

<span class="org-function-name">FetchContent_MakeAvailable</span>( sol2 )
<span class="org-function-name">include_directories</span>( ${<span class="org-variable-name">sol2_SOURCE_DIR</span>}/include )

</pre>
</div>

<p>
File: <span class="underline">xmake.lua</span>  
</p>

<ul class="org-ul">
<li>Building script for <a href="https://xmake.io">XMake</a> building system, which uses lua as
embedded scripting language and as a building system DSL (Domain
Specific Language) .</li>
<li>Xmake packages: <a href="https://github.com/xmake-io/xmake-repo/blob/master/packages/s/sol2/xmake.lua">sol2</a>, <a href="https://github.com/xmake-io/xmake-repo/blob/master/packages/l/lua/xmake.lua">lua</a>, <a href="https://github.com/xmake-io/xmake-repo/blob/master/packages/l/luajit/xmake.lua">luajit</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-lua">add_rules(<span class="org-string">"mode.debug"</span>, <span class="org-string">"mode.release"</span>)

includes_lua = <span class="org-constant">false</span> 

add_requires(<span class="org-string">"sol2 v3.2.1"</span>)

target(<span class="org-string">"embed-lua-sol"</span>)
  set_kind(<span class="org-string">"binary"</span>)
  set_languages(<span class="org-string">"c++17"</span>)
  add_files(<span class="org-string">"./embed-lua-sol.cpp"</span>)
  add_packages(<span class="org-string">"sol2"</span>)  
</pre>
</div>


<p>
File: <span class="underline">embed-lua-sol.cpp</span> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sol/sol.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>


<span class="org-keyword">class</span> <span class="org-type">Counter</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>: 
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
    <span class="org-type">int</span>         <span class="org-variable-name">m_counter</span>;

<span class="org-function-name">public</span>: 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Ctor [1] =&gt; Default ctor </span>
    <span class="org-function-name">Counter</span><span class="org-rainbow-delimiters-depth-2">()</span>: Counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"untitled"</span>, 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Ctor [2]</span>
    <span class="org-function-name">Counter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">counter</span><span class="org-rainbow-delimiters-depth-2">)</span>
      : m_name<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>, m_counter<span class="org-rainbow-delimiters-depth-2">{</span>counter<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Counter created with =&gt;  { "</span> 
                  &lt;&lt;   <span class="org-string">" name = "</span> &lt;&lt; m_name 
                  &lt;&lt; <span class="org-string">" ; counter = "</span> &lt;&lt; m_counter 
                  &lt;&lt; <span class="org-string">" } \n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">int</span> <span class="org-function-name">getCounter</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_counter; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setCounter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>       
      m_counter = n; 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] I was set to value "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">increment</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>       
      m_counter++; 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] increment event =&gt;&gt; counter = {  "</span> 
                &lt;&lt; m_name &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; m_counter 
                &lt;&lt; <span class="org-string">" } "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>    
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">double</span> <span class="org-function-name">add_fun</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] addfun() =&gt; a = "</span> &lt;&lt; a 
              &lt;&lt; <span class="org-string">" ; b = "</span> &lt;&lt; b &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> a + b;             
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">sol_eval</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">sol</span>::<span class="org-type">state</span>&amp; <span class="org-variable-name">ctx</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        ctx.script<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-4">(</span>code<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;        
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">sol</span>::<span class="org-type">error</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [SOL ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Create an instance of lua Engine (aka virtual Machine)</span>
    <span class="org-constant">sol</span>::<span class="org-type">state</span> <span class="org-variable-name">ctx</span><span class="org-rainbow-delimiters-depth-2">{}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Load basic libraries (such as print)</span>
    ctx.open_libraries<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">sol</span>::<span class="org-constant">lib</span>::base, <span class="org-constant">sol</span>::<span class="org-constant">lib</span>::coroutine, <span class="org-constant">sol</span>::<span class="org-constant">lib</span>::string, <span class="org-constant">sol</span>::<span class="org-constant">lib</span>::io<span class="org-rainbow-delimiters-depth-2">)</span>;    

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register function pointer </span>
    ctx.set_function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"add_fun"</span>, &amp;add_fun<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register lambda object </span>
    ctx.set_function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"make_vector"</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span> <span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">vec</span> = <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>n<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++ <span class="org-rainbow-delimiters-depth-4">)</span> vec<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span>= i * 3;
        <span class="org-keyword">return</span> vec;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Set variables in the Lua engine </span>
    ctx<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"points"</span><span class="org-rainbow-delimiters-depth-2">]</span>    = 2000;
    ctx.set<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"character"</span>, <span class="org-string">"&lt;Marcus Tulius Cicero&gt;"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">===========&gt;&gt;&gt; E X P E  R I M E N T / 1  &lt;&lt;=========*/</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [EXPERIMENT 1] ==&gt;&gt; Evaluating string as code "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt;&gt;&gt; Eval code as string &lt;&lt;=== </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Throws exception sol::error </span>
        ctx.script<span class="org-rainbow-delimiters-depth-3">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">            print(" [LUA] Hello world lua "); </span>

<span class="org-string">            x = add_fun(10, 20);</span>
<span class="org-string">            print("\n  [LUA] result =  " .. x);</span>

<span class="org-string">            v = make_vector(5);</span>
<span class="org-string">            print("\n  [LUA] Printing a vector ");</span>

<span class="org-string">            for i = 1, 5 do </span>
<span class="org-string">                print("   -&gt; v[" .. i .. " ] = " .. v[i] );</span>
<span class="org-string">            end </span>

<span class="org-string">            print("  [LUA] VAR points    = " .. points );</span>
<span class="org-string">            print("  [LUA] VAR character = " .. character );</span>
<span class="org-string">        )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">/* </span><span class="org-comment">===========&gt;&gt;&gt; E X P E  R I M E N T / 2  &lt;&lt;=========*/</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n [EXPERIMENT 2] ==&gt;&gt; Reading configuration "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        ctx.script<span class="org-rainbow-delimiters-depth-3">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">            -- Simulation of user configuration from script     </span>
<span class="org-string">            asset_path   = "C:\\\\Users\\myuser\\data\\files\\";</span>
<span class="org-string">            user_credits = 2000;</span>
<span class="org-string">            width        = 200.561;        </span>
<span class="org-string">        )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">auto</span> <span class="org-variable-name">asset_path</span> = ctx.get<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"asset_path"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">int</span> <span class="org-variable-name">user_credits</span> = ctx<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"user_credits"</span><span class="org-rainbow-delimiters-depth-3">]</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] =&gt; asset_path = "</span> &lt;&lt; asset_path &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] =&gt; user_credits = "</span> &lt;&lt; user_credits &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">/* </span><span class="org-comment">===========&gt;&gt;&gt; E X P E  R I M E N T / 3  &lt;&lt;=========*/</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n [EXPERIMENT 3] ==&gt;&gt; Register C++ classes "</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">struct</span> <span class="org-type">StatefulFunctor</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">int</span> <span class="org-variable-name">state</span> = 0;
        <span class="org-function-name">StatefulFunctor</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">state</span><span class="org-rainbow-delimiters-depth-3">)</span>: <span class="org-function-name">state</span><span class="org-rainbow-delimiters-depth-3">(</span>state<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-rainbow-delimiters-depth-3">(){</span> 

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  *=&gt;&gt; [StatefulFunctor] My new state is = "</span> 
                      &lt;&lt; <span class="org-keyword">this</span>-&gt;state &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-keyword">return</span> state++; 
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">stateful</span> = StatefulFunctor<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span>;
    ctx.set_function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"stateful"</span>, stateful<span class="org-rainbow-delimiters-depth-2">)</span>;

    ctx.script<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        stateful();</span>
<span class="org-string">        stateful();</span>
<span class="org-string">        stateful();</span>
<span class="org-string">    )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;


    ctx.new_usertype<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Counter</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Class name </span>
         <span class="org-string">"Counter"</span>          

        <span class="org-comment-delimiter">//  </span><span class="org-comment">--- Register methods  ------ //</span>
        ,<span class="org-string">"getCounter"</span>, &amp;<span class="org-constant">Counter</span>::getCounter
        ,<span class="org-string">"setCounter"</span>, &amp;<span class="org-constant">Counter</span>::setCounter
        ,<span class="org-string">"increment"</span>,  &amp;<span class="org-constant">Counter</span>::increment

        <span class="org-comment-delimiter">// </span><span class="org-comment">--- Register properties  ---- //</span>
        , <span class="org-string">"value"</span>,     <span class="org-constant">sol</span>::property<span class="org-rainbow-delimiters-depth-3">(</span> &amp;<span class="org-constant">Counter</span>::getCounter
                                    , &amp;<span class="org-constant">Counter</span>::setCounter<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">)</span>;


    sol_eval<span class="org-rainbow-delimiters-depth-2">(</span>ctx, R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        print("\n -----&gt;&gt;&gt; Calling C++ classes from Lua &lt;----- ");</span>

<span class="org-string">        -- Create new instance (object) of C++ class Counter </span>
<span class="org-string">        counter = Counter.new();</span>
<span class="org-string">        counter:increment();</span>
<span class="org-string">        counter:increment(); </span>
<span class="org-string">        counter:increment();</span>

<span class="org-string">        x = counter:getCounter(); </span>
<span class="org-string">        print("  [*] value of counter is equal to = " .. x);</span>

<span class="org-string">        counter.value = 2000;</span>
<span class="org-string">        print(" [*] Counter value is equal to = " .. counter.value );</span>
<span class="org-string">    )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">Counter</span>* <span class="org-variable-name">ptr</span> = ctx.get<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Counter</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"counter"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [FROM C++] counter value = "</span> 
              &lt;&lt; ptr-&gt;getCounter<span class="org-rainbow-delimiters-depth-2">()</span> 
              &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Building =&gt; Debug build: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git clone https://gist.github.com/17a37d905d3d71c0ae66661a189481b5 lua-sol &amp;&amp; <span class="org-builtin">cd</span> lua-sol 
$ cmake --config Debug -H. -B_build 
$ cmake --build _build --target 
</pre>
</div>

<p>
Building =&gt; Release build: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git clone https://gist.github.com/17a37d905d3d71c0ae66661a189481b5 lua-sol &amp;&amp; <span class="org-builtin">cd</span> lua-sol 
$ cmake --config Release -H. -B_build 
$ cmake --build _build --target 
</pre>
</div>

<p>
Check executable: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Confirm whether the executable is statically linked against LuaLib </span>
$ ldd _build/embed-lua-sol 
       linux-vdso.so.1 (0x00007ffdf0fc4000)
       libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fe4490e6000)
       libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fe448fa0000)
       libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fe448f85000)
       libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe448dbb000)
       /lib64/ld-linux-x86-64.so.2 (0x00007fe4492fa000)

  <span class="org-comment-delimiter"># </span><span class="org-comment">Static library </span>
  $ file _build/liblua.a 
 _build/liblua.a: current ar archive
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ _build/embed-lua-sol 

[EXPERIMENT 1] ==&gt;&gt; Evaluating string as code 
[LUA] Hello world lua 
[TRACE] addfun() =&gt; a = 10 ; b = 20

 [LUA] result =  30.0

 [LUA] Printing a vector 
  -&gt; v[1 ] = 0
  -&gt; v[2 ] = 3
  -&gt; v[3 ] = 6
  -&gt; v[4 ] = 9
  -&gt; v[5 ] = 12
 [LUA] VAR points    = 2000
 [LUA] VAR character = &lt;Marcus Tulius Cicero&gt;


[EXPERIMENT 2] ==&gt;&gt; Reading configuration 
 [*] =&gt; asset_path = C:<span class="org-string">\\</span>Users\myuser\data\files<span class="org-sh-escaped-newline">\</span>
 [*] =&gt; user_credits = 2000


[EXPERIMENT 3] ==&gt;&gt; Register C++ classes 
 *=&gt;&gt; [StatefulFunctor] My new state is = 10
 *=&gt;&gt; [StatefulFunctor] My new state is = 11
 *=&gt;&gt; [StatefulFunctor] My new state is = 12

-----&gt;&gt;&gt; Calling C++ classes from Lua &lt;----- 
[TRACE] Counter created with =&gt;  {  name = untitled ; counter = 0 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 1 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 2 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 3 } 
 [*] value of counter is equal to = 3
[TRACE] I was set to value 2000
[*] Counter value is equal to = 2000
[FROM C++] counter value = 2000

</pre>
</div>

<p>
Run Lua repl executable (defined in CMake): 
</p>

<div class="org-src-container">
<pre class="src src-js">$ rlwrap  _build/lua-repl 
Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio
&gt; 
&gt; 

&gt; print(<span class="org-string">" Hello world Lua / Luna / Moon REPL "</span>)
 Hello world Lua / Luna / Moon REPL 

&gt; <span class="org-keyword">for</span> i = 1, 5 <span class="org-keyword">do</span> print(<span class="org-string">" i = "</span> .. i ) end
 i = 1
 i = 2
 i = 3
 i = 4
 i = 5


<span class="org-keyword">function</span> <span class="org-function-name">myfunction</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>) 
  <span class="org-keyword">return</span> math.sin(a) * math.exp(b) / a - a * b 
end 

&gt; myfunction(3.5, 2.0)
-7.7405591279893

<span class="org-keyword">function</span> <span class="org-function-name">add</span> (<span class="org-variable-name">a</span>)
   local sum = 0
   <span class="org-keyword">for</span> i,v <span class="org-keyword">in</span> ipairs(a) <span class="org-keyword">do</span>
      sum = sum + v
   end
   <span class="org-keyword">return</span> sum
end

&gt; add({ 2.5, 10.2, -2.51, 8.251, 10.56})
29.001

<span class="org-keyword">function</span> <span class="org-function-name">add</span> (<span class="org-variable-name">a</span>)
      local sum = 0
      <span class="org-keyword">for</span> i,v <span class="org-keyword">in</span> ipairs(a) <span class="org-keyword">do</span>
        sum = sum + v
      end
<span class="org-keyword">return</span> su
</pre>
</div>

<p>
<b>Building and running with Xmake</b>
</p>

<p>
Building with Xmake: 
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ &gt;&gt; xmake build -P . -v 

[ 25%]: ccache compiling.release embed-lua-sol.cpp
/usr/bin/gcc -c -m64 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -std=c++17 <span class="org-sh-escaped-newline">\</span>
        -isystem /home/user/.xmake/packages/s/sol2/v3.2.1/5fa1980e381b40ed942748bdef09488a/include <span class="org-sh-escaped-newline">\</span>
        -isystem /home/user/.xmake/packages/l/lua/v5.4.4/4de5c31814a64c0d9242d1e524082873/include/lua <span class="org-sh-escaped-newline">\</span>
         -DNDEBUG -o <span class="org-keyword">build/.objs/embed-lua-sol/linux/x86_64/release/embed-lua-sol.cpp.o</span> embed-lua-sol.cpp

[ 50%]: linking.release embed-lua-sol
/usr/bin/g++ -o <span class="org-keyword">build/linux/x86_64/release/embed-lua-sol</span> build/.objs/embed-lua-sol/linux/x86_64/release/embed-lua-sol.cpp.o <span class="org-sh-escaped-newline">\</span>
     -m64 -L/home/user/.xmake/packages/l/lua/v5.4.4/4de5c31814a64c0d9242d1e524082873/lib -s -llua -ldl -lm
[100%]: build ok!
</pre>
</div>

<p>
Generating a CMakeLists.txt file:
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ &gt;&gt; xmake project -v -k cmake -P . <span class="org-comment-delimiter"># </span><span class="org-comment">Overrides CMakeLists.txt if it already exists</span>

configure
{
    plat = linux
    buildir = build
    arch = x86_64
    mode = release
    ccache = true
    ndk_stdcxx = true
    host = linux
    kind = static
}
create ok!


</pre>
</div>

<p>
Running the application: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ &gt;&gt; xmake run -P .

[EXPERIMENT 1] ==&gt;&gt; Evaluating string as code 
[LUA] Hello world lua 
[TRACE] addfun() =&gt; a = 10 ; b = 20

 [LUA] result =  30.0

 [LUA] Printing a vector 
  -&gt; v[1 ] = 0
  -&gt; v[2 ] = 3
  -&gt; v[3 ] = 6
  -&gt; v[4 ] = 9
  -&gt; v[5 ] = 12
 [LUA] VAR points    = 2000
 [LUA] VAR character = &lt;Marcus Tulius Cicero&gt;


[EXPERIMENT 2] ==&gt;&gt; Reading configuration 
 [*] =&gt; asset_path = C:<span class="org-string">\\</span>Users\myuser\data\files<span class="org-sh-escaped-newline">\</span>
 [*] =&gt; user_credits = 2000


[EXPERIMENT 3] ==&gt;&gt; Register C++ classes 
 *=&gt;&gt; [StatefulFunctor] My new state is = 10
 *=&gt;&gt; [StatefulFunctor] My new state is = 11
 *=&gt;&gt; [StatefulFunctor] My new state is = 12

-----&gt;&gt;&gt; Calling C++ classes from Lua &lt;----- 
[TRACE] Counter created with =&gt;  {  name = untitled ; counter = 0 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 1 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 2 } 
[TRACE] increment event =&gt;&gt; counter = {  untitled ; 3 } 
 [*] value of counter is equal to = 3
[TRACE] I was set to value 2000
[*] Counter value is equal to = 2000
[FROM C++] counter value = 2000
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab47671" class="outline-3">
<h3 id="orgab47671"><span class="section-number-3">1.6</span> Squirrel Scripting Language</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orga6572d4" class="outline-4">
<h4 id="orga6572d4"><span class="section-number-4">1.6.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>Squirrel is a embedded scripting language, similar to Lua, but with
C-like syntax, designed to be embedded in larger C or C++
applications such as game engines. Squirrel is written in C++, but
it only exposes a C API, which makes binding C++ code
cumbersome. However, there are many libraries which simplifies the
embedding of squirrel in C++ codebases.</li>
</ul>

<p>
<b>Official Web Site</b>
</p>

<ul class="org-ul">
<li><a href="http://www.squirrel-lang.org/">http://www.squirrel-lang.org/</a></li>
</ul>

<p>
<b>Official Repository</b> 
</p>

<ul class="org-ul">
<li><a href="https://github.com/albertodemichelis/squirrel">https://github.com/albertodemichelis/squirrel</a></li>
</ul>

<p>
<b>Squirrel fork with a more C++-like syntax</b>
</p>

<ul class="org-ul">
<li><a href="https://github.com/mingodad/squilu">https://github.com/mingodad/squilu</a></li>
</ul>

<p>
<b>Articles about squirrel language</b>
</p>

<ul class="org-ul">
<li><a href="https://developer.electricimp.com/squirrel/squirrelcrib">Squirrel Programming Guide | Dev Center</a></li>

<li><a href="https://www.ibm.com/developerworks/aix/library/au-spunix_squirrel/index.html">Speaking UNIX: The Squirrel portable shell and scripting language</a></li>

<li><a href="http://wiki.ogre3d.org/Squirrel+Scripting+Language">http://wiki.ogre3d.org/Squirrel+Scripting+Language</a></li>
</ul>

<p>
<b>Applications using Squirrel</b>
</p>

<ul class="org-ul">
<li>CodeBlocks IDE for C and C++</li>

<li>OpenTTD Game - <a href="http://www.openttd.org/en/">http://www.openttd.org/en/</a></li>
</ul>


<p>
<b>Libraries for simplifying embedding squirrel in C++ code</b> 
</p>

<p>
Libraries for simplifying squirrel embedding in C++ code (binding
C++ code):
</p>

<ul class="org-ul">
<li><b>SQPlus</b>
<ul class="org-ul">
<li><a href="http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SqPlus.html">http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SqPlus.html</a></li>
</ul></li>

<li><b>SQrat</b>
<ul class="org-ul">
<li><a href="http://scrat.sourceforge.net/">http://scrat.sourceforge.net/</a></li>
</ul></li>

<li><b>Squal</b>
<ul class="org-ul">
<li><a href="https://github.com/jonigata/squall">https://github.com/jonigata/squall</a></li>
</ul></li>

<li><b>SimpleSquirrel</b>
<ul class="org-ul">
<li><a href="https://github.com/matusnovak/simplesquirrel">https://github.com/matusnovak/simplesquirrel</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf0eeec3" class="outline-4">
<h4 id="orgf0eeec3"><span class="section-number-4">1.6.2</span> Building Squirrel standalone REPL interpreter</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
Download and build: 
</p>


<div class="org-src-container">
<pre class="src src-sh">$ mkdir ~/build &amp;&amp; <span class="org-builtin">cd</span> build 
$ git clone https://github.com/albertodemichelis/squirrel
$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
$ cmake --build _build --target
</pre>
</div>

<p>
Play with squirrel interactive shell (REPL):
</p>

<div class="org-src-container">
<pre class="src src-sh">$ _build/bin/sq
Squirrel 3.1 stable Copyright (C) 2003-2017 Alberto Demichelis (64 bits)

sq&gt; print(<span class="org-string">" === Hello world Squirrel === "</span>)
 === Hello world Squirrel === 

sq&gt; <span class="org-keyword">function</span> <span class="org-function-name">add_to_10</span>(x){ <span class="org-keyword">return</span> x + 10; }

sq&gt;print(add_to_10(25))
35

sq&gt; x &lt;- cos(3.1415 / 2) + 10 

sq&gt;print(<span class="org-string">" x = "</span> + x.tostring())
 x = 10

sq&gt; for(<span class="org-builtin">local</span> i = 0; i &lt; 5; i++) print(<span class="org-string">" \n [TRACE] i = "</span> + i.tostring());

 [TRACE] i = 0 
 [TRACE] i = 1 
 [TRACE] i = 2 
 [TRACE] i = 3 
 [TRACE] i = 4
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5e014c" class="outline-4">
<h4 id="orgf5e014c"><span class="section-number-4">1.6.3</span> Example - embedding Squirrel with Squall Library</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
This example demonstrates how to embed the Squirrel programming
language in a C++ application using the Squall header-only library. 
</p>

<ul class="org-ul">
<li>Squal Repository: <a href="https://github.com/jonigata/squall">https://github.com/jonigata/squall</a></li>

<li>Note: This project is self-contained, no library needs to be
installed on the system as Squall automatically fetches Squirrel
sources using Cmake FetchContent.</li>
</ul>

<p>
<b>Sample Project</b> 
</p>

<p>
File: CMakeLists.txt 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span> (VERSION 3.11)
<span class="org-function-name">project</span>(squirrel_squall_test)

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD_REQUIRED on)
<span class="org-function-name">set</span>(BUILD_EXAMPLES off)

<span class="org-comment"># -----------------------------------------------#</span>
<span class="org-function-name">include</span>(FetchContent)

<span class="org-function-name">FetchContent_Declare</span>(
  squall 
  URL      https://github.com/jonigata/squall/archive/master.zip
  )

<span class="org-function-name">FetchContent_MakeAvailable</span>(squall)

<span class="org-comment">#-------- TARGET DEFINITIONS --------------------#</span>
<span class="org-function-name">message</span>([TRACE] <span class="org-string">" squall_SOURCE_DIR = ${</span><span class="org-variable-name">squall_SOURCE_DIR</span><span class="org-string">}/squall  "</span>)

            <span class="org-function-name">add_executable</span> ( squirrel-test squirrel_test.cpp)
     <span class="org-function-name">target_link_libraries</span> ( squirrel-test squirrel_static sqstdlib_static)
<span class="org-function-name">target_include_directories</span> ( squirrel-test PUBLIC
                               ${<span class="org-variable-name">squirrel_SOURCE_DIR</span>}/include
                               ${<span class="org-variable-name">squall_SOURCE_DIR</span>}
                               )
</pre>
</div>

<p>
File: squirrel_test.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">squall/squall_vmstd.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">squall/squall_klass.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">some_cpp_fun</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span> <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n   [some_cpp_function] =&gt; i = %d "</span>, i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">ChartXY</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">m_width</span>; 
    <span class="org-type">int</span> <span class="org-variable-name">m_height</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">ChartXY</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_width<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>, m_height<span class="org-rainbow-delimiters-depth-2">(</span>50<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ChartXY] Ctor() - I was created!. OK. "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">set_width</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> m_width = x; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">set_height</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> m_height = x; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">draw</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [ChartXY] draw() =&gt; Draw chart with: width = %d ; height = %d"</span>
                    , m_width, m_height<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Create a virtual-machine object for Squirrel language </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: throws squall::squirrel_error</span>
    <span class="org-constant">squall</span>::<span class="org-type">VMStd</span> <span class="org-variable-name">vm</span>; 

    <span class="org-comment-delimiter">// </span><span class="org-comment">------------------------------------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">[EXPERIMENT 1] Evaluate scripts provided as strings                     //</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------------------------------//</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt;&gt; [EXPERIMENT] 1 - Evaluating code as string. "</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ---------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>

        vm.dostring<span class="org-rainbow-delimiters-depth-3">(</span>R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">            // --- Squirrel Comment ----- // </span>
<span class="org-string">            print(" &lt;SQUIRREL&gt;  =&gt;&gt; Hello world squirrel!");</span>

<span class="org-string">            function myfunc(x) {  </span>
<span class="org-string">                local a = x + 5;</span>
<span class="org-string">                local b = 7 * a + x;</span>
<span class="org-string">                return b - a + 10;  </span>
<span class="org-string">            }</span>

<span class="org-string">            function myfunc2() {</span>
<span class="org-string">                print(" \n  &lt;SQUIRREL&gt; I was called by the C++ code ");</span>
<span class="org-string">            }</span>

<span class="org-string">            print("\n &lt;SQUIRREL&gt; =&gt;&gt; myfunc(4) = " + myfunc(4).tostring() );</span>

<span class="org-string">            print("\n\n &lt;SQUIRREL&gt; --- For Loop test ---- ");</span>
<span class="org-string">            for(local i = 0; i &lt; 5; i++) { </span>
<span class="org-string">                 print("\n   i = " + i.tostring() );  </span>
<span class="org-string">            }</span>
<span class="org-string">        )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">squall</span>::<span class="org-type">squirrel_error</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span> <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n [SQUIRREL ERROR] Error =&gt;  "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;        
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">------------------------------------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">[EXPERIMENT 2] Evaluate scripts provided as strings                     //</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------------------------------//</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n =&gt;&gt; [EXPERIMENT] 2 - Getting variables defined in the code."</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" -----------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-rainbow-delimiters-depth-2">{</span>
        vm.dostring<span class="org-rainbow-delimiters-depth-3">(</span>R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">            // ---- Global varibles for configuration ------ // </span>
<span class="org-string">            ::myvar_width &lt;- 100;</span>
<span class="org-string">            ::myvar_float &lt;- 122.56161;</span>
<span class="org-string">            ::myvar_string &lt;- "/path/to/interpreter.exe"; </span>
<span class="org-string">        )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-constant">squall</span>::<span class="org-type">TableBase</span> <span class="org-variable-name">table</span> = vm.root_table<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">myvar_float</span> = table.get<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"myvar_float"</span><span class="org-rainbow-delimiters-depth-3">)</span>;       
        <span class="org-keyword">auto</span> <span class="org-variable-name">myvar_width</span> = table.get<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"myvar_width"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">myvar_string</span> = table.get<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"myvar_string"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  =&gt;&gt;  myvar_width = "</span> &lt;&lt; myvar_width &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  =&gt;&gt;  myvar_float = "</span> &lt;&lt; myvar_float &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  =&gt;&gt; myvar_string = "</span> &lt;&lt; myvar_string &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-comment-delimiter">// </span><span class="org-comment">------------------------------------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">[EXPERIMENT 3] Call functions defined in the script (Virtual Machine )  //</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------------------------------//    </span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n =&gt;&gt; [EXPERIMENT] 3 - Calling functions defined in the script (VM)"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ------------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;    
    <span class="org-comment-delimiter">// </span><span class="org-comment">Throws: 'squall::squirrel_error' </span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = vm.call<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"myfunc"</span>, 10<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"   =&gt;&gt;&gt; myfunc(4) = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;

    vm.call<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"myfunc2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">------------------------------------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">[EXPERIMENT 4] Call C++ functions from the script                       //</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------------------------------//    </span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n =&gt;&gt; [EXPERIMENT] 4 - Calling functions defined in the script (VM)"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ------------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register C++ function pointer </span>
    vm.defun<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"some_cpp_fun"</span>, &amp;some_cpp_fun<span class="org-rainbow-delimiters-depth-2">)</span>;

    vm.dostring<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        print(" \n [SQUIRREL] =&gt; Call C++ function some_cpp_fun() ");</span>
<span class="org-string">        some_cpp_fun(5);</span>
<span class="org-string">     )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;


    <span class="org-comment-delimiter">// </span><span class="org-comment">Register C++ lambda object </span>
    vm.defun<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"call_me"</span>, <span class="org-rainbow-delimiters-depth-3">[</span>=<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">param</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [TRACE] call_me() Parameter = "</span> &lt;&lt; param &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span>  <span class="org-string">" name = "</span> + param;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    vm.dostring<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        local x = call_me("&lt;SQUIRREL-INTERPRETER&gt;");</span>
<span class="org-string">        print(" [SQUIRREL] \n x &lt;- " + x);</span>
<span class="org-string">     )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">------------------------------------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">[EXPERIMENT 5] Call C++ classes from Squirrel-side                     //</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------------------------------//    </span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n =&gt;&gt; [EXPERIMENT] 5 - Calling C++ classes from Squirrel        "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ------------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Create metaobject 'k' that describes ChartXY class </span>
    <span class="org-constant">squall</span>::<span class="org-type">Klass</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ChartXY</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-2">(</span>vm, <span class="org-string">"ChartXY"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    k.func<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"set_width"</span>,  &amp;<span class="org-constant">ChartXY</span>::set_width<span class="org-rainbow-delimiters-depth-2">)</span>;
    k.func<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"set_height"</span>, &amp;<span class="org-constant">ChartXY</span>::set_height<span class="org-rainbow-delimiters-depth-2">)</span>;
    k.func<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"draw"</span>,       &amp;<span class="org-constant">ChartXY</span>::draw<span class="org-rainbow-delimiters-depth-2">)</span>;

    vm.dostring<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">        function manipulate_chart(ch){           </span>
<span class="org-string">            ch.set_width(25);</span>
<span class="org-string">            ch.set_height(10);</span>
<span class="org-string">            ch.draw();</span>
<span class="org-string">        }</span>

<span class="org-string">        function draw_with(ch, w, h)</span>
<span class="org-string">        {</span>
<span class="org-string">            print(" \n [SQUIRREL LOG] Function draw_with called. OK. \n");</span>
<span class="org-string">            ch.set_width(w);</span>
<span class="org-string">            ch.set_height(h);</span>
<span class="org-string">            ch.draw();</span>
<span class="org-string">        }</span>
<span class="org-string">     )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">ChartXY</span> <span class="org-variable-name">mychart</span>;
    vm.call<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"manipulate_chart"</span>, &amp;mychart<span class="org-rainbow-delimiters-depth-2">)</span>;
    vm.call<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"draw_with"</span>, &amp;mychart, 100, 200<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n\n"</span>;

    <span class="org-constant">squall</span>::<span class="org-type">TableBase</span> <span class="org-variable-name">table</span> = vm.root_table<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Pass object to Squirrel side </span>
    table.set<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"mychart"</span>, mychart<span class="org-rainbow-delimiters-depth-2">)</span>;

    vm.dostring<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        mychart.set_width(250);</span>
<span class="org-string">        mychart.set_width(600);</span>
<span class="org-string">        mychart.draw();</span>
<span class="org-string">    )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;


<span class="org-preprocessor">#if</span> 0  
    <span class="org-comment-delimiter">// </span><span class="org-comment">Segmentation Falt Coredump if the C++ object </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">is created on the Squirrel-side.</span>
    vm.dostring<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        local c = ChartXY();</span>
<span class="org-string">        c.set_width(150);</span>
<span class="org-string">        c.set_height(175);</span>
<span class="org-string">        c.draw();</span>
<span class="org-string">    )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-preprocessor">#endif</span> 

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Build: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
$ cmake --build _build --target 
</pre>
</div>

<p>
Check executable dependencies: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ldd _build/squirrel-test 
       linux-vdso.so.1 (0x00007ffe34dd6000)
       libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007fd3ebd2a000)
       libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fd3ebbe4000)
       libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fd3ebbc9000)
       libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fd3eb9ff000)
       /lib64/ld-linux-x86-64.so.2 (0x00007fd3ebf3e000)
</pre>
</div>

<p>
Run application: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ _build/squirrel-test 

=&gt;&gt; [EXPERIMENT] 1 - Evaluating code as string. 
---------------------------------------------

&lt;SQUIRREL&gt;  =&gt;&gt; Hello world squirrel!
&lt;SQUIRREL&gt; =&gt;&gt; myfunc(4) = 68

&lt;SQUIRREL&gt; --- For Loop test ---- 
  i = 0
  i = 1
  i = 2
  i = 3
  i = 4
=&gt;&gt; [EXPERIMENT] 2 - Getting variables defined<span class="org-keyword"> in</span> the code.
-----------------------------------------------------------

 =&gt;&gt;  myvar_width = 100
 =&gt;&gt;  myvar_float = 122.562
 =&gt;&gt; myvar_string = /path/to/interpreter.exe


=&gt;&gt; [EXPERIMENT] 3 - Calling functions defined<span class="org-keyword"> in</span> the script (VM)
------------------------------------------------------------------

  =&gt;&gt;&gt; myfunc(4) = 110

 &lt;SQUIRREL&gt; I was called by the C++ code 

=&gt;&gt; [EXPERIMENT] 4 - Calling functions defined<span class="org-keyword"> in</span> the script (VM)
------------------------------------------------------------------


[SQUIRREL] =&gt; Call C++ <span class="org-keyword">function</span> <span class="org-function-name">some_cpp_fun</span>() 
  [some_cpp_function] =&gt; i = 0 
  [some_cpp_function] =&gt; i = 1 
  [some_cpp_function] =&gt; i = 2 
  [some_cpp_function] =&gt; i = 3 
  [some_cpp_function] =&gt; i = 4 
[TRACE] call_me() Parameter = &lt;SQUIRREL-INTERPRETER&gt;
[SQUIRREL] 
x &lt;-  name = &lt;SQUIRREL-INTERPRETER&gt;

=&gt;&gt; [EXPERIMENT] 5 - Calling C++ classes from Squirrel        
------------------------------------------------------------------

[ChartXY] Ctor() - I was created!. OK. 
[ChartXY] draw() =&gt; Draw chart with: width = 25 ; height = 10 
[SQUIRREL LOG] Function draw_with called. OK. 
[ChartXY] draw() =&gt; Draw chart with: width = 100 ; height = 200

[ChartXY] draw() =&gt; Draw chart with: width = 600 ; height = 200


</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5698bba" class="outline-3">
<h3 id="org5698bba"><span class="section-number-3">1.7</span> Duktape - Embeddable Javascript Engine</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org0c49fad" class="outline-4">
<h4 id="org0c49fad"><span class="section-number-4">1.7.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>Duktape is a small footprint embeddable Javascript (ECMAScript)
engine, written in C, which can be used for providing scripting
capabilities for C or C++ applications.</li>

<li>License: MIT</li>

<li>Possible Use Cases:
<ul class="org-ul">
<li>Configuration</li>
<li>Data description language</li>
<li>User plugins</li>
<li>User extensions</li>
<li>Scripting for games</li>
</ul></li>

<li>Features:
<ul class="org-ul">
<li>Embeddable, portable, compact: can run on platforms with 160kB
flash and 64kB RAM</li>
<li>Built-in debugger</li>
<li>Built-in regular expression engine</li>
<li>Minimal, retargetable platform dependencies</li>
<li>Combined reference counting and mark-and-sweep garbage
collection with finalization</li>
<li>Bytecode dump/load for caching compiled functions</li>
<li>Distributable includes an optional logging framework,
CommonJS-based module loading implementations, etc</li>
</ul></li>
</ul>

<p>
<b>Official Website</b> 
</p>

<ul class="org-ul">
<li><a href="https://duktape.org/">https://duktape.org/</a></li>

<li><a href="https://duktape.org/download.html">https://duktape.org/download.html</a></li>
</ul>

<p>
<b>Official Repository</b> 
</p>

<ul class="org-ul">
<li><a href="https://github.com/svaarala/duktape">https://github.com/svaarala/duktape</a></li>
</ul>

<p>
<b>C++ Binding Libraries</b>  
</p>

<ul class="org-ul">
<li><a href="https://github.com/Aloshi/dukglue/">https://github.com/Aloshi/dukglue/</a></li>

<li><a href="https://github.com/stfwi/duktape-cc">https://github.com/stfwi/duktape-cc</a></li>
</ul>
</div>
</div>
<div id="outline-container-org88125a9" class="outline-4">
<h4 id="org88125a9"><span class="section-number-4">1.7.2</span> Example project with DukGlue C++ binding library</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
This following project CMakeLists.txt automatically downloads <span class="underline">dukglue</span>
binding library and <span class="underline">duktape</span> engine sources and builds a C++ demonstration
code embedding duktape JavaScript engine. 
</p>

<ul class="org-ul">
<li>DukGlue Binding Library: <a href="https://github.com/Aloshi/dukglue">https://github.com/Aloshi/dukglue</a>
<ul class="org-ul">
<li>Advantage:
<ul class="org-ul">
<li>Easy to use and lots of examples.</li>
</ul></li>
<li>Drawbacks:
<ul class="org-ul">
<li>Lack of namespaces which enhances API discoverability</li>
<li>Lack of C++ wrappers to some Duktape C-types</li>
<li>Lack of a CMakeLists.txt at the top directory.</li>
</ul></li>
</ul></li>
</ul>

<p>
File: CMakeLists.txt 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.0)
<span class="org-function-name">project</span>(duktap-embed)

<span class="org-function-name">include</span>(FetchContent)

<span class="org-comment"># Download library archive (zip, *.tar.gz, ...) from URL</span>
<span class="org-keyword">macro</span>(Download_Library_Url NAME URL)
  <span class="org-function-name">FetchContent_Declare</span>(${<span class="org-variable-name">NAME</span>} URL  ${<span class="org-variable-name">URL</span>})
  <span class="org-function-name">FetchContent_GetProperties</span>(${<span class="org-variable-name">NAME</span>})
  <span class="org-keyword">if</span>(NOT ${<span class="org-variable-name">NAME</span>}_POPULATED)
    <span class="org-function-name">FetchContent_Populate</span>(${<span class="org-variable-name">NAME</span>})
   <span class="org-comment"># add_subdirectory(${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_SOURCE_DIR} ${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_BINARY_DIR})</span>
  <span class="org-keyword">endif</span>()
<span class="org-keyword">endmacro</span>()


<span class="org-comment"># ====&gt;&gt; Duktape JavaScript Engine Configuration &lt;&lt;===========#</span>

<span class="org-function-name">Download_Library_Url</span>(duktape
  <span class="org-string">"https://duktape.org/duktape-2.5.0.tar.xz"</span>
  )

<span class="org-comment"># FetchContent_MakeAvailable(duktape)</span>

<span class="org-function-name">message</span>( [TRACE] <span class="org-string">" =&gt;&gt; duktape_SOURCE_DIR = ${</span><span class="org-variable-name">duktape_SOURCE_DIR</span><span class="org-string">} "</span>)


<span class="org-function-name">file</span>(GLOB_RECURSE duktape_sources <span class="org-string">"${</span><span class="org-variable-name">duktape_SOURCE_DIR</span><span class="org-string">}/src/*.c"</span>)
<span class="org-function-name">file</span>(GLOB_RECURSE duktape_headers <span class="org-string">"${</span><span class="org-variable-name">duktape_SOURCE_DIR</span><span class="org-string">}/src/*.h"</span>)

<span class="org-function-name">message</span>( [TRACE] <span class="org-string">" duktape_sources = ${</span><span class="org-variable-name">duktape_sources</span><span class="org-string">} "</span>)

              <span class="org-function-name">add_library</span> (duktape ${<span class="org-variable-name">duktape_sources</span>} ${<span class="org-variable-name">duktape_headers</span>} )
<span class="org-function-name">target_include_directories</span>(duktape PUBLIC ${<span class="org-variable-name">duktape_SOURCE_DIR</span>}/src  )

<span class="org-comment"># ----------- DukGlue Library ----------------------------#</span>

<span class="org-function-name">FetchContent_Declare</span>(
  dukglue 
  URL       https://github.com/Aloshi/dukglue/archive/master.zip
  )

<span class="org-function-name">FetchContent_MakeAvailable</span>(dukglue)

<span class="org-comment">#----- Main Target Definition ----------------------------#</span>
<span class="org-function-name">add_executable</span>(duktape-embed duktape-embed.cpp)
<span class="org-function-name">target_link_libraries</span>(duktape-embed duktape dukglue)

</pre>
</div>

<p>
File: duktape-embed.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Repository: https://github.com/Aloshi/dukglue</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">dukglue/dukglue.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">print_number</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] number passed is = "</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">log_text</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt;  <span class="org-string">" =&gt;&gt; [C++-LOG] - "</span> &lt;&lt; text &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">eval_code</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">duk_context</span>* <span class="org-variable-name">ctx</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> duk_peval_string<span class="org-rainbow-delimiters-depth-2">(</span>ctx, code.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">plot_points</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">points</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  =&gt;&gt; [TRACE] Plot points  =&gt;&gt; "</span>;
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">x</span>: points<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" \n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Counter</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>: 
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
    <span class="org-type">int</span>         <span class="org-variable-name">m_counter</span>;

<span class="org-function-name">public</span>: 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Ctor [1] =&gt; Default ctor </span>
    <span class="org-function-name">Counter</span><span class="org-rainbow-delimiters-depth-2">()</span>: Counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"untitled"</span>, 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Ctor [2]</span>
    <span class="org-function-name">Counter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">counter</span><span class="org-rainbow-delimiters-depth-2">)</span>
      : m_name<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>, m_counter<span class="org-rainbow-delimiters-depth-2">{</span>counter<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Counter created with =&gt;  { "</span> 
                  &lt;&lt;   <span class="org-string">" name = "</span> &lt;&lt; m_name 
                  &lt;&lt; <span class="org-string">" ; counter = "</span> &lt;&lt; m_counter 
                  &lt;&lt; <span class="org-string">" } \n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">int</span> <span class="org-function-name">getCounter</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_counter; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setCounter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>       
      m_counter = n; 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] I was set to value "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">increment</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>       
      m_counter++; 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] increment event =&gt;&gt; counter = {  "</span> 
                &lt;&lt; m_name &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; m_counter 
                &lt;&lt; <span class="org-string">" } "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>    

<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Create Duktape Virtual machine </span>
      <span class="org-type">duk_context</span>* <span class="org-variable-name">ctx</span> = duk_create_heap_default<span class="org-rainbow-delimiters-depth-2">()</span>;

      <span class="org-comment-delimiter">/* </span><span class="org-comment">========================== EXPERIMENT 1 =============*/</span>
      <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n === [EXPERIMENT 1] ==&gt;&gt; Register and call C++ functions &lt;&lt;===== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
      <span class="org-rainbow-delimiters-depth-2">{</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Register pointer to functions function (function pointer) in </span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">the JS engine (aka virtual machine)</span>
          dukglue_register_function<span class="org-rainbow-delimiters-depth-3">(</span>ctx, &amp;print_number, <span class="org-string">"print_number"</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
          dukglue_register_function<span class="org-rainbow-delimiters-depth-3">(</span>ctx, log_text, <span class="org-string">"log_text"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          dukglue_register_function<span class="org-rainbow-delimiters-depth-3">(</span>ctx, plot_points, <span class="org-string">"plot_points"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

          <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">code1</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">              print_number(10);</span>
<span class="org-string">              log_text(" Hello world from Javascript" ); </span>
<span class="org-string">              log_text(" Toke is equal to " + 100 ); </span>
<span class="org-string">              log_text( " " + 1000 );      </span>

<span class="org-string">              plot_points( [ 20.5, 100.23, -125.254, 8.251, 100.0 ]);</span>
<span class="org-string">          )</span><span class="org-default">"</span>;

          <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate code, returns false on error </span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = eval_code<span class="org-rainbow-delimiters-depth-3">(</span>ctx, code1<span class="org-rainbow-delimiters-depth-3">)</span>;

          <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] A duktape evaluation error has happened. "</span>  &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-3">}</span>

      <span class="org-rainbow-delimiters-depth-2">}</span>

      <span class="org-comment-delimiter">/* </span><span class="org-comment">========================== EXPERIMENT 2 ====================*/</span>
      <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n === [EXPERIMENT 2] ==&gt;&gt; Register and call C++ classes &lt;&lt;===== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
      <span class="org-rainbow-delimiters-depth-2">{</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Register class counter </span>
          dukglue_register_constructor<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Counter</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, <span class="org-string">"Counter"</span><span class="org-rainbow-delimiters-depth-3">)</span>;      
          dukglue_register_constructor<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Counter</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx,  <span class="org-string">"Counter"</span><span class="org-rainbow-delimiters-depth-3">)</span>;     
          dukglue_register_method<span class="org-rainbow-delimiters-depth-3">(</span>ctx, &amp;<span class="org-constant">Counter</span>::getCounter , <span class="org-string">"getCounter"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          dukglue_register_method<span class="org-rainbow-delimiters-depth-3">(</span>ctx, &amp;<span class="org-constant">Counter</span>::setCounter , <span class="org-string">"setCounter"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          dukglue_register_method<span class="org-rainbow-delimiters-depth-3">(</span>ctx, &amp;<span class="org-constant">Counter</span>::increment , <span class="org-string">"increment"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

          dukglue_register_property<span class="org-rainbow-delimiters-depth-3">(</span>ctx                   <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to engine (VM)</span>
                                  , &amp;<span class="org-constant">Counter</span>::getCounter  <span class="org-comment-delimiter">// </span><span class="org-comment">Getter </span>
                                  , &amp;<span class="org-constant">Counter</span>::setCounter  <span class="org-comment-delimiter">// </span><span class="org-comment">Setter </span>
                                  , <span class="org-string">"number"</span>              <span class="org-comment-delimiter">// </span><span class="org-comment">Property name </span>
                                  <span class="org-rainbow-delimiters-depth-3">)</span>;

          <span class="org-type">int</span> <span class="org-variable-name">ret</span> = eval_code<span class="org-rainbow-delimiters-depth-3">(</span>ctx, R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">              var counter = new Counter("mycounter", 10); </span>

<span class="org-string">              for(i = 0 ; i &lt; 5; i++) { counter.increment(); }</span>

<span class="org-string">              var n = counter.getCounter(); </span>
<span class="org-string">              log_text(" [BEFORE] Counter value = " + n );</span>

<span class="org-string">              counter.setCounter(100);</span>
<span class="org-string">              log_text(" [AFTER 1 ] Counter value = " + counter.getCounter() );</span>

<span class="org-string">              counter.number = 400;</span>
<span class="org-string">              log_text(" [AFTER 2] Counter value = " + counter.number );</span>
<span class="org-string">          )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          assert<span class="org-rainbow-delimiters-depth-3">(</span> ret == 0 <span class="org-rainbow-delimiters-depth-3">)</span>;

      <span class="org-rainbow-delimiters-depth-2">}</span>

      <span class="org-comment-delimiter">/* </span><span class="org-comment">======= Calling Javascript Engine from C++ ====================*/</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It is useful for reading data or user configuration </span>
      <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n === [EXPERIMENT 3] ==&gt;&gt; Calling engine objects from C++ &lt;&lt;===== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
      <span class="org-rainbow-delimiters-depth-2">{</span>
          <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">code</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">            // Global variables for configuration </span>
<span class="org-string">            points = 200; </span>
<span class="org-string">            asset_path = "C:\\\\Users\\dummy\\data\\graphics";</span>

<span class="org-string">            function my_js_function(n){</span>
<span class="org-string">                log_text( " &lt;my_js_function&gt; =&gt;&gt; n = " + n );</span>
<span class="org-string">                var k = 20 * n + 100;</span>
<span class="org-string">                return k; </span>
<span class="org-string">            }</span>

<span class="org-string">          )</span><span class="org-default">"</span>;
          eval_code<span class="org-rainbow-delimiters-depth-3">(</span>ctx, code<span class="org-rainbow-delimiters-depth-3">)</span>;

          <span class="org-comment-delimiter">// </span><span class="org-comment">Throws error: DukErrorException</span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">points</span> = dukglue_peval<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, <span class="org-string">"points"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] =&gt;&gt; points = "</span> &lt;&lt; points &lt;&lt; <span class="org-constant">std</span>::endl;

          <span class="org-comment-delimiter">// </span><span class="org-comment">Throws error: DukErrorException</span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">asset_path</span> = dukglue_peval<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, <span class="org-string">"asset_path"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] =&gt;&gt; asset_path = "</span> &lt;&lt; asset_path &lt;&lt; <span class="org-constant">std</span>::endl;

          <span class="org-keyword">auto</span> <span class="org-variable-name">jsexpr</span> = dukglue_peval<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, <span class="org-string">"3.51 * 10.52 - 8.251 / 100"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] jsexpr = "</span> &lt;&lt; jsexpr &lt;&lt; <span class="org-constant">std</span>::endl;

          <span class="org-comment-delimiter">// </span><span class="org-comment">Call Javascript function from C++ </span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = dukglue_peval<span class="org-rainbow-delimiters-depth-3">&lt;</span>DukValue<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, <span class="org-string">"my_js_function"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-type">int</span> <span class="org-variable-name">res</span> = dukglue_pcall<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ctx, func, 20<span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  [*] res = "</span> &lt;&lt; res &lt;&lt; <span class="org-constant">std</span>::endl;

      <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Release Javascript engine object (aka virtual machine)</span>
    ::duk_destroy_heap<span class="org-rainbow-delimiters-depth-2">(</span>ctx<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Build: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
$ cmake --build _build --target 
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./build/duktape-embed 

=== [EXPERIMENT 1] ==&gt;&gt; Register and call C++ functions &lt;&lt;===== 
[TRACE] number passed is = 10
=&gt;&gt; [C++-LOG] -  Hello world from Javascript
=&gt;&gt; [C++-LOG] -  Toke is equal to 100
=&gt;&gt; [C++-LOG] -  1000
 =&gt;&gt; [TRACE] Plot points  =&gt;&gt;  x = 20.5 x = 100.23 x = -125.254 x = 8.251 x = 100 

=== [EXPERIMENT 2] ==&gt;&gt; Register and call C++ classes &lt;&lt;===== 

[TRACE] Counter created with =&gt;  {  name = mycounter ; counter = 10 } 
[TRACE] increment event =&gt;&gt; counter = {  mycounter ; 11 } 
[TRACE] increment event =&gt;&gt; counter = {  mycounter ; 12 } 
[TRACE] increment event =&gt;&gt; counter = {  mycounter ; 13 } 
[TRACE] increment event =&gt;&gt; counter = {  mycounter ; 14 } 
[TRACE] increment event =&gt;&gt; counter = {  mycounter ; 15 } 
=&gt;&gt; [C++-LOG] -  [BEFORE] Counter value = 15
[TRACE] I was set to value 100
=&gt;&gt; [C++-LOG] -  [AFTER 1 ] Counter value = 100
[TRACE] I was set to value 400
=&gt;&gt; [C++-LOG] -  [AFTER 2] Counter value = 400

=== [EXPERIMENT 3] ==&gt;&gt; Calling engine objects from C++ &lt;&lt;===== 

 [*] =&gt;&gt; points = 200
 [*] =&gt;&gt; asset_path = C:<span class="org-string">\\</span>Users\dummy\data\graphics
 [*] jsexpr = 36.8427
=&gt;&gt; [C++-LOG] -  &lt;my_js_function&gt; =&gt;&gt; n = 20
 [*] res = 500


</pre>
</div>
</div>
</div>
<div id="outline-container-org794a4a1" class="outline-4">
<h4 id="org794a4a1"><span class="section-number-4">1.7.3</span> Example project with Duktape-CC binding library</h4>
<div class="outline-text-4" id="text-1-7-3">
<ul class="org-ul">
<li>Duktape-CC binding library: <a href="https://github.com/stfwi/duktape-cc/">https://github.com/stfwi/duktape-cc/</a>
<ul class="org-ul">
<li>Benefits 
<ul class="org-ul">
<li>Namespace</li>
<li>RAII for duktape C-API</li>
<li>Javascript common known APIs such as console.log()</li>
</ul></li>
<li>Disadvantage:
<ul class="org-ul">
<li>No possible to bind lambda function.</li>
<li>No possible to bind C++ classes or objects</li>
<li>No CMakeLists.txt at top directory, which makes the library
usage easier, but the following cmake scripts solves this
problem.</li>
</ul></li>
</ul></li>
</ul>


<p>
File: CMakeLists.txt 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.0)
<span class="org-function-name">project</span>(duktape-cc-trial)

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)

<span class="org-function-name">include</span>(duktape.cmake)

<span class="org-comment">#----- Main Target Definition ----------------------------#</span>
       <span class="org-function-name">add_executable</span>( duktape-script duktape-script.cpp)
<span class="org-function-name">target_link_libraries</span>( duktape-script duktape-cc )
</pre>
</div>

<p>
File: duktape.cmake 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">include</span>(FetchContent)

<span class="org-comment"># Note: the 'add_subriectory' line was commented becuyase </span>
<span class="org-comment">#       library that will be downloaded does not have </span>
<span class="org-comment">#       a CMakeListst.txt file at the root directory. </span>
<span class="org-keyword">macro</span>(Download_Library_Git  NAME TAG REPOSITORY_URL)
    <span class="org-function-name">FetchContent_Declare</span>(
        ${<span class="org-variable-name">NAME</span>}
        GIT_REPOSITORY  ${<span class="org-variable-name">REPOSITORY_URL</span>}
        GIT_TAG         ${<span class="org-variable-name">TAG</span>}
    )
    <span class="org-function-name">FetchContent_GetProperties</span>(${<span class="org-variable-name">NAME</span>})
    <span class="org-keyword">if</span>(NOT cpputest_POPULATED)
        <span class="org-function-name">FetchContent_Populate</span>(${<span class="org-variable-name">NAME</span>})
        <span class="org-function-name">message</span>(<span class="org-string">"${</span><span class="org-variable-name">NAME</span><span class="org-string">}_SOURCE_DIR} = ${${</span><span class="org-variable-name">NAME</span><span class="org-string">}_SOURCE_DIR}"</span>)        

        <span class="org-comment"># =&gt; Disable following line: the library does not have a CMakeLists.txt</span>
        <span class="org-comment">#    at the root directory.</span>
        <span class="org-comment"># add_subdirectory(${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_SOURCE_DIR} ${${</span><span class="org-variable-name">NAME</span><span class="org-comment">}_BINARY_DIR})</span>
    <span class="org-keyword">endif</span>()
<span class="org-keyword">endmacro</span>()


<span class="org-comment"># ====&gt;&gt; Duktape JavaScript Engine Configuration &lt;&lt;===========#</span>

<span class="org-function-name">Download_Library_Git</span>( duktape-cc 
                      51fed200b0c3353a60fa560aa8a13a480f0ec0c7
                      https://github.com/stfwi/duktape-cc/
                    )

<span class="org-function-name">file</span>(GLOB_RECURSE duktape_sources <span class="org-string">"${</span><span class="org-variable-name">duktape-cc_SOURCE_DIR</span><span class="org-string">}/duktape/*.c"</span>)
<span class="org-function-name">file</span>(GLOB_RECURSE duktape_headers1 <span class="org-string">"${</span><span class="org-variable-name">duktape-cc_SOURCE_DIR</span><span class="org-string">}/duktape/*.hh"</span>)
<span class="org-function-name">file</span>(GLOB_RECURSE duktape_headers2 <span class="org-string">"${</span><span class="org-variable-name">duktape-cc_SOURCE_DIR</span><span class="org-string">}/duktape/*.h"</span>)

               <span class="org-function-name">add_library</span>( duktape-cc ${<span class="org-variable-name">duktape_sources</span>} ${<span class="org-variable-name">duktape_headers1</span>} ${<span class="org-variable-name">duktape_headers2</span>} )
<span class="org-function-name">target_include_directories</span>( duktape-cc PUBLIC ${<span class="org-variable-name">duktape-cc_SOURCE_DIR</span>} )

</pre>
</div>

<p>
File: duktape-script.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">duktape/duktape.hh</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">duktape/mod/mod.stdio.hh</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Program started Ok. "</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Create Duktape Engine object (Virtual Machine)</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">ctx</span> = <span class="org-constant">duktape</span>::engine<span class="org-rainbow-delimiters-depth-2">{}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Load all functions from stdio module </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">==&gt; Note: It is necessary for console.log() work </span>
    <span class="org-constant">duktape</span>::<span class="org-constant">mod</span>::<span class="org-constant">stdio</span>::define_in<span class="org-rainbow-delimiters-depth-2">(</span>ctx<span class="org-rainbow-delimiters-depth-2">)</span>;   


    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [EXPERIMENT 1] ======= Evaluate string as code ========"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    ctx.eval<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">        console.log(" [INFO] Hello world Javascript Engine ");</span>

<span class="org-string">        var i = 0;</span>
<span class="org-string">        while(i &lt; 5) {</span>
<span class="org-string">            console.log(" [TRACE] &lt;ducktape&gt;  i = " + i);</span>
<span class="org-string">            i++;</span>
<span class="org-string">        }</span>
<span class="org-string">    )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [EXPERIMENT 2] == Read/write values to the engine the engine ="</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Write or pass values to the engine. </span>
    ctx.define<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"app.version"</span>, <span class="org-string">"0.251"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    ctx.define<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"user.points"</span>, 1000<span class="org-rainbow-delimiters-depth-2">)</span>;
    ctx.define<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"array1"</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span> 4.51, 9.25, -25.154, 205.2 <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    ctx.define<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"array2"</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">&gt;{</span> <span class="org-string">"C++"</span>, <span class="org-string">"ADA-Spark"</span>, <span class="org-string">"Rust"</span>, <span class="org-string">"Dlang"</span>, <span class="org-string">"OCaml"</span> <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">script_file</span> = <span class="org-string">"/tmp/myscript.js"</span>;

    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">script_code</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        console.log("  =&gt; app.version = " + app.version );</span>
<span class="org-string">        console.log("  =&gt; user.points = " + user.points );</span>
<span class="org-string">        console.log("  =&gt; array1 = " + array1);</span>
<span class="org-string">        console.log("  =&gt; array2 = " + array2);</span>

<span class="org-string">        myconfig_path = "/Users/data/osx/config";</span>
<span class="org-string">        user_credits = 1020; </span>
<span class="org-string">        vector = [100.25, 90.251, -120.5150];</span>
<span class="org-string">    )</span><span class="org-default">"</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Write script code to file     </span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">fs</span> = <span class="org-constant">std</span>::ofstream<span class="org-rainbow-delimiters-depth-2">(</span>script_file<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Flush forces writing to the IO</span>
    fs &lt;&lt; script_code &lt;&lt; <span class="org-constant">std</span>::flush;          
    <span class="org-comment-delimiter">// </span><span class="org-comment">Execute script from file </span>
    ctx.include<span class="org-rainbow-delimiters-depth-2">(</span>script_file<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ---- Read configuration from file "</span> &lt;&lt; <span class="org-constant">std</span>::endl; 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Throws exception: duktape::detail::basic_script_error&lt;void&gt;</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">myconfig_path</span> = ctx.eval<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"myconfig_path"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">credits</span>       = ctx.eval<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"user_credits"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">vec</span>           = ctx.eval<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"vector"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n\n[*] my_config_path = "</span> &lt;&lt; myconfig_path &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[*]   user_credits = "</span> &lt;&lt; credits &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[*] vec[0] = "</span> &lt;&lt; vec<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">" ; vec[1] = "</span> &lt;&lt; vec<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">"\n"</span>;    

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Build: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
$ cmake --build _build --target 
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ _build/duktape-script 
 [TRACE] Program started Ok. 

 [EXPERIMENT 1] ======= Evaluate string as code ========

 [EXPERIMENT 2] == Read/write values to the engine the engine =
 [INFO] Hello world Javascript Engine 
 [TRACE] &lt;ducktape&gt;  i = 0
 [TRACE] &lt;ducktape&gt;  i = 1
 [TRACE] &lt;ducktape&gt;  i = 2
 [TRACE] &lt;ducktape&gt;  i = 3
 [TRACE] &lt;ducktape&gt;  i = 4
  =&gt; app.version = 0.251
  =&gt; user.points = 1000
  =&gt; array1 = 4.51,9.25,-25.154,205.2
  =&gt; array2 = C++,ADA-Spark,Rust,Dlang,OCaml
 ---- Read configuration from file 


[*] my_config_path = /Users/data/osx/config
[*]   user_credits = 1020
[*] vec[0] = 100.25 ; vec[1] = 90.251

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0b113cb" class="outline-3">
<h3 id="org0b113cb"><span class="section-number-3">1.8</span> QuickJS - ES20 Javascript Engine</h3>
<div class="outline-text-3" id="text-1-8">
<p>
QuickJS is small and lightweight embeddable Javascript engine, written
in C, which supports ES2020 technical specification. This engine was
created by Fabrice Bellard, creator of many widely used open source
projects, namely, QEMU emulator used for emulation of operating
systems and embedded systems hardware; FFmpeg tool for video and audio
conversion; TCC (Tiny C Compiler). Some features supported by the
engine are: modules, proxies, BigInt and asynchronous generators.
</p>

<ul class="org-ul">
<li>QuickJS Web Site:
<ul class="org-ul">
<li><a href="https://bellard.org/quickjs/quickjs.html">https://bellard.org/quickjs/quickjs.html</a></li>
</ul></li>

<li>QuickJS Repository:
<ul class="org-ul">
<li><a href="https://github.com/bellard/quickjs">https://github.com/bellard/quickjs</a></li>
</ul></li>

<li>QuickJSpp C++ Wrapper Repository (License: CC0)
<ul class="org-ul">
<li><a href="https://github.com/ftk/quickjspp">https://github.com/ftk/quickjspp</a></li>
</ul></li>
</ul>

<p>
See also: 
</p>

<ul class="org-ul">
<li><a href="https://dev.to/carlillo/es2020-features-in-simple-examples-1513">ES2020 Features in simple examples - DEV</a></li>

<li><a href="https://gist.github.com/revolunet/537a3448cff850231a74">Python VS JavaScript ES6 syntax comparison  GitHub</a></li>
</ul>

<p>
<b>Sample CMake project</b> 
</p>

<p>
The following sample CMake projects demonstrates how to embed QuickJS
engine in a C++ code by using the QuickJSpp C++ wrapper. The CMake
script (CMakeLists.txt) downloads the QuickJS source code from its
repository and creates static library target for the JavaScript engine
which is then linked against the sample application embedding
QuickJS. This CMakeLists.txt script fully automates all steps, which relieves
the library user from installing QuickJS manually by using GNU make,
which is the original building system used by the engine. 
</p>

<p>
GIST Containing all sources: 
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/1abdd1d36cd3e973cd1f11f5c20ef7eb">https://gist.github.com/1abdd1d36cd3e973cd1f11f5c20ef7eb</a></li>
</ul>

<p>
File: <span class="underline">CMakeLists.txt</span> 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.9)
<span class="org-function-name">project</span>(QuickJS-Experiment)

<span class="org-comment">#========== Global Configurations =============#</span>
<span class="org-comment">#----------------------------------------------#</span>

<span class="org-function-name">set</span>( CMAKE_CXX_STANDARD     17 )
<span class="org-function-name">set</span>( CMAKE_VERBOSE_MAKEFILE ON )
<span class="org-function-name">set</span>( CMAKE_CXX_EXTENSIONS   OFF)

<span class="org-comment"># ------------ Download CPM CMake Script ----------------#</span>

<span class="org-comment">## Automatically donwload and use module CPM.cmake</span>
<span class="org-function-name">file</span>(DOWNLOAD https://raw.githubusercontent.com/TheLartians/CPM.cmake/v0.26.2/cmake/CPM.cmake
                 <span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/CPM.cmake"</span>)
<span class="org-function-name">include</span>(<span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/CPM.cmake"</span>)

<span class="org-comment">#----------- Add dependencies --------------------------#</span>

<span class="org-function-name">CPMAddPackage</span>(
    NAME               quickjs 
    GITHUB_REPOSITORY  bellard/quickjs
    GIT_TAG            204682fb87ab9312f0cf81f959ecd181180457bc
    <span class="org-comment"># DOWNLOAD_ONLY YES</span>
    )


<span class="org-comment"># Add this directory where is this file (CMakeLists.txt) to include path. </span>
<span class="org-function-name">include_directories</span>( ${<span class="org-variable-name">CMAKE_CURRENT_LIST_DIR</span>} )

<span class="org-comment"># =============== QuickJS settings ====================================#</span>

<span class="org-function-name">include_directories</span>( ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/ )
<span class="org-function-name">message</span>([TRACE] <span class="org-string">" quickjs source = ${</span><span class="org-variable-name">quickjs_SOURCE_DIR</span><span class="org-string">} "</span>)

<span class="org-function-name">file</span>(GLOB quickjs_hpp ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/*.h )

<span class="org-function-name">file</span>(GLOB quickjs_src ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/quickjs.c 
                      ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/libregexp.c 
                      ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/libunicode.c  
                      ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/cutils.c 
                      ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/quickjs-libc.c 
                      ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/libbf.c 
                      )


               <span class="org-function-name">add_library</span>( qjs-engine ${<span class="org-variable-name">quickjs_src</span>} ${<span class="org-variable-name">quickjs_hpp</span>} )
    <span class="org-function-name">target_compile_options</span>( qjs-engine PRIVATE
                                -MMD -MF
                                -Wno-sign-compare 
                                -Wno-missing-field-initializers 
                                -Wundef -Wuninitialized 
                                -Wundef -Wuninitialized -Wwrite-strings -Wchar-subscripts
                          )
<span class="org-function-name">target_compile_definitions</span>( qjs-engine PUBLIC 
                                       CONFIG_BIGNUM=y
                                       CONFIG_VERSION=<span class="org-string">"2020-11-08"</span>
                                       _GNU_SOURCE
                           )

<span class="org-keyword">if</span>(UNIX)
    <span class="org-function-name">target_link_libraries</span>( qjs-engine PRIVATE m pthread dl)
<span class="org-keyword">endif</span>()

<span class="org-comment"># =========== Target Settings =========================================#</span>

            <span class="org-comment"># QuickJS compiler. </span>
            <span class="org-function-name">add_executable</span>( qjsc ${<span class="org-variable-name">quickjs_SOURCE_DIR</span>}/qjsc.c )
<span class="org-function-name">target_compile_definitions</span>( qjsc  PUBLIC  CONFIG_BIGNUM=y  CONFIG_VERSION=<span class="org-string">"2020-11-08"</span>  _GNU_SOURCE )            
     <span class="org-function-name">target_link_libraries</span>( qjsc  qjs-engine )

            <span class="org-comment"># Sample application that embeds the quickJS Javascript engine. </span>
       <span class="org-function-name">add_executable</span>( main main.cpp   )
<span class="org-function-name">target_link_libraries</span>( main qjs-engine )
</pre>
</div>

<p>
File: <span class="underline">main.cpp</span> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">quickjspp.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">ChartXY</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">double</span> <span class="org-variable-name">x</span> = 0.0, <span class="org-variable-name">y</span> = 0.0;
    <span class="org-type">double</span> <span class="org-variable-name">width</span> = 100.0, <span class="org-variable-name">height</span> = 100.0;
<span class="org-function-name">public</span>:
    <span class="org-function-name">ChartXY</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">ChartXY</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">w</span>, <span class="org-type">double</span> <span class="org-variable-name">h</span><span class="org-rainbow-delimiters-depth-2">)</span>: width<span class="org-rainbow-delimiters-depth-2">(</span>w<span class="org-rainbow-delimiters-depth-2">)</span>, height<span class="org-rainbow-delimiters-depth-2">(</span>h<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [&#262;hartXY Object] x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">" ; y = "</span> &lt;&lt; y 
                &lt;&lt; <span class="org-string">" ; width = "</span> &lt;&lt; width &lt;&lt; <span class="org-string">" height = "</span> &lt;&lt; height 
                &lt;&lt; <span class="org-string">'\n'</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">set_width</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">width</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>  
        <span class="org-keyword">this</span>-&gt;width = width; 
        <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-3">(</span>stdout, <span class="org-string">" [ChartXY] Width set to %f \n"</span>, width<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">set_height</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">height</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-keyword">this</span>-&gt;height = height; 
        <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-3">(</span>stdout, <span class="org-string">" [ChartXY] Height set to %f \n"</span>, height<span class="org-rainbow-delimiters-depth-3">)</span>;        
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">double</span> <span class="org-function-name">get_height</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;height; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span> <span class="org-function-name">get_width</span> <span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;width; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">plot_points</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">points</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ChartXY] Plotting points =&gt;&gt; "</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span> : points<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; p; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">qjs</span>::Value
try_eval_module<span class="org-rainbow-delimiters-depth-1">(</span>
             <span class="org-constant">qjs</span>::<span class="org-type">Context</span>&amp; <span class="org-variable-name">context</span>
           , <span class="org-constant">qjs</span>::<span class="org-type">Runtime</span>&amp; <span class="org-variable-name">runtime</span>
           , <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-keyword">try</span>
      <span class="org-rainbow-delimiters-depth-2">{</span>
          <span class="org-keyword">return</span> context.eval<span class="org-rainbow-delimiters-depth-3">(</span>code, <span class="org-string">"&lt;eval&gt;"</span>, JS_EVAL_TYPE_MODULE<span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-keyword">const</span> <span class="org-constant">qjs</span>::<span class="org-type">exception</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">js_std_dump_error(ctx);</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">exc</span> = context.getException<span class="org-rainbow-delimiters-depth-3">()</span>;
            <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>exc.isError<span class="org-rainbow-delimiters-depth-4">()</span> ? <span class="org-string">"Error: "</span> : <span class="org-string">"Throw: "</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">)</span>exc &lt;&lt; <span class="org-constant">std</span>::endl;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-4">)</span>exc<span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">"stack"</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">)</span>exc<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"stack"</span><span class="org-rainbow-delimiters-depth-3">]</span> &lt;&lt; <span class="org-constant">std</span>::endl;

            js_std_free_handlers<span class="org-rainbow-delimiters-depth-3">(</span>runtime.rt<span class="org-rainbow-delimiters-depth-3">)</span>;
            <span class="org-keyword">return</span> context.newObject<span class="org-rainbow-delimiters-depth-3">()</span>;
      <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Started Ok"</span> &lt;&lt; <span class="org-constant">std</span>::endl; 

    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">qjs</span>;

    <span class="org-type">Runtime</span> <span class="org-variable-name">runtime</span>;
    <span class="org-comment-delimiter">//</span><span class="org-comment">JSRuntime* rt = runtime.rt;</span>

    <span class="org-type">Context</span> <span class="org-variable-name">context</span><span class="org-rainbow-delimiters-depth-2">(</span>runtime<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">//</span><span class="org-comment">JSContext* ctx = context.ctx;</span>

    js_std_init_handlers<span class="org-rainbow-delimiters-depth-2">(</span>runtime.rt<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">loader for ES6 modules */</span>
    JS_SetModuleLoaderFunc<span class="org-rainbow-delimiters-depth-2">(</span>runtime.rt, <span class="org-constant">nullptr</span>, js_module_loader, <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    js_std_add_helpers<span class="org-rainbow-delimiters-depth-2">(</span>context.ctx, argc - 1, argv + 1<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">system modules */</span>
    js_init_module_std<span class="org-rainbow-delimiters-depth-2">(</span>context.ctx, <span class="org-string">"std"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    js_init_module_os<span class="org-rainbow-delimiters-depth-2">(</span>context.ctx, <span class="org-string">"os"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-2">(</span>stderr, <span class="org-string">" [TRACE] Before loading code. \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">            /*</span>
<span class="org-string">            import * as std from 'std';</span>
<span class="org-string">            import * as os from 'os';</span>
<span class="org-string">            globalThis.std = std;</span>
<span class="org-string">            globalThis.os = os;</span>
<span class="org-string">            */</span>

<span class="org-string">            console.log(" [QUICJS] =&gt; =&gt;&gt; Script loaded. Ok. \n");</span>

<span class="org-string">            for(n = 1; n &lt;= 5; n++){</span>
<span class="org-string">                console.log(` [QUICKJS-TRACE] n = ${n}/5 `);</span>
<span class="org-string">            }</span>

<span class="org-string">            // ----- Define user variables here ----</span>

<span class="org-string">            asset_path = "/Users/mydir-macosx/data/blackjack.txt";</span>
<span class="org-string">            game_score = 0.25156;</span>

<span class="org-string">            let x = 10.352;</span>
<span class="org-string">            datapoints = [ 0.251, 19.2363, 9.262, 100.125 ];</span>

<span class="org-string">            console.log(`\n  [QUICKJS] asset_path = ${asset_path}` );</span>
<span class="org-string">            console.log(`   [QUICKJS] score = ${100.0 * game_score} (in percent) \n`);</span>
<span class="org-string">            console.log(`   [QUICKJS] data points = ${datapoints} `)</span>
<span class="org-string">      )</span><span class="org-default">"</span>;

    <span class="org-keyword">try</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
         context.eval<span class="org-rainbow-delimiters-depth-3">(</span>str<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">, "", JS_EVAL_TYPE_MODULE);</span>
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-keyword">const</span> <span class="org-constant">qjs</span>::<span class="org-type">exception</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
          <span class="org-comment-delimiter">//</span><span class="org-comment">js_std_dump_error(ctx);</span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">exc</span> = context.getException<span class="org-rainbow-delimiters-depth-3">()</span>;
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>exc.isError<span class="org-rainbow-delimiters-depth-4">()</span> ? <span class="org-string">"Error: "</span> : <span class="org-string">"Throw: "</span><span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">)</span>exc &lt;&lt; <span class="org-constant">std</span>::endl;
          <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-4">)</span>exc<span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">"stack"</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>
              <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">)</span>exc<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"stack"</span><span class="org-rainbow-delimiters-depth-3">]</span> &lt;&lt; <span class="org-constant">std</span>::endl;

          js_std_free_handlers<span class="org-rainbow-delimiters-depth-3">(</span>runtime.rt<span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-keyword">return</span> 1;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-2">(</span>stderr, <span class="org-string">" [TRACE] After loading code. \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;


    <span class="org-type">int</span> <span class="org-variable-name">number</span> = <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> context.eval<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" 10 * (3 + 1 + 10 ) - 1000 * 2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;                               
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [RESULT] number = "</span> &lt;&lt; number &lt;&lt; <span class="org-string">'\n'</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [*] ===== Read configuration variables defined in the js code. ====\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;    
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">var_asset_path</span> = context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"asset_path"</span><span class="org-rainbow-delimiters-depth-3">]</span>.as<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"    =&gt;&gt; asset_path = "</span> &lt;&lt; var_asset_path &lt;&lt; <span class="org-string">'\n'</span>;

        <span class="org-keyword">auto</span> <span class="org-variable-name">score</span> = context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"game_score"</span><span class="org-rainbow-delimiters-depth-3">]</span>.as<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"    =&gt;&gt; game_score (%) = "</span> &lt;&lt; 100.0 * score &lt;&lt; <span class="org-string">'\n'</span>;

        <span class="org-keyword">auto</span> <span class="org-variable-name">points</span> = context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"datapoints"</span><span class="org-rainbow-delimiters-depth-3">]</span>.as<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"    ==&gt;&gt; datapoints = ["</span> &lt;&lt; points.size<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"]( "</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span> : points<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>  <span class="org-constant">std</span>::cout &lt;&lt; p &lt;&lt; <span class="org-string">' '</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ) \n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [*] ===== Define variables in C++-side  ====\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;    
    <span class="org-rainbow-delimiters-depth-2">{</span> 

        context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"user_name"</span><span class="org-rainbow-delimiters-depth-3">]</span>   = context.newValue<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Gaius Julius Caesar"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"user_points"</span><span class="org-rainbow-delimiters-depth-3">]</span> = context.newValue<span class="org-rainbow-delimiters-depth-3">(</span>101235<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">auto</span> <span class="org-variable-name">data</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span> <span class="org-string">"ADA"</span>, <span class="org-string">"RUST"</span>, <span class="org-string">"C++11"</span>, <span class="org-string">"C++17"</span>, <span class="org-string">"C++20"</span>
                                            , <span class="org-string">"Dlang"</span>, <span class="org-string">"OCaml"</span>, <span class="org-string">"C#(Csharp)"</span> <span class="org-rainbow-delimiters-depth-3">}</span>;

        context.global<span class="org-rainbow-delimiters-depth-3">()[</span><span class="org-string">"user_data"</span><span class="org-rainbow-delimiters-depth-3">]</span> = context.newValue<span class="org-rainbow-delimiters-depth-3">(</span>data<span class="org-rainbow-delimiters-depth-3">)</span>;         

        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: This code should be within an exception handler. </span>
        context.eval<span class="org-rainbow-delimiters-depth-3">(</span>R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">            console.log(` [STEP 2] user_name = ${user_name} ; points = ${user_points} `);</span>
<span class="org-string">            console.log(` [STEP 2] user_data = ${user_data} ; type = ${ typeof(user_data) } `);</span>
<span class="org-string">            console.log(` [STEP 2] user_data[5] = ${ user_data[5] } `)</span>

<span class="org-string">            // Iterate over the array </span>
<span class="org-string">            for(let x in user_data){ console.log(user_data[x]); }</span>
<span class="org-string">        )</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-3">)</span>;          

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [*] ===== Register class ChartXY   ====\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;    

    <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">module</span> = context.addModule<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"chart"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    module.class_<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ChartXY</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"ChartXY"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      .constructor<span class="org-rainbow-delimiters-depth-2">()</span> 
      .constructor<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
      .fun<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::show<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"show"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      .fun<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::set_height<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"set_height"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      .fun<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::set_width<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"set_width"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      .fun<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::plot_points<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"plot_points"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      .property<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::get_width,  &amp;<span class="org-constant">ChartXY</span>::set_width<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"width"</span><span class="org-rainbow-delimiters-depth-2">)</span>      
      .property<span class="org-rainbow-delimiters-depth-2">&lt;</span>&amp;<span class="org-constant">ChartXY</span>::get_height, &amp;<span class="org-constant">ChartXY</span>::set_height<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"height"</span><span class="org-rainbow-delimiters-depth-2">)</span>      
      ;  

    module.add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"user_path"</span>, <span class="org-string">"/Users/data/assets/game/score/marks"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    module.add<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"user_points"</span>, 1023523<span class="org-rainbow-delimiters-depth-2">)</span>;

    module.function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"myfunc"</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> 4.61 * x + 10 * y * y; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">module_code</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        import { ChartXY } from "chart";</span>

<span class="org-string">        import * as chart from "chart"</span>

<span class="org-string">        console.log(` [SCRIPT] chart.user_path = ${chart.user_path} \n\n`);</span>
<span class="org-string">        console.log(` [SCRIPT] chart.user_points = ${chart.user_points} \n\n`);</span>

<span class="org-string">        console.log(` [SCRIPT] Result = ${ chart.myfunc(5.61, 9.821) } \n`);</span>

<span class="org-string">        let ch = new ChartXY(200, 600);</span>
<span class="org-string">        ch.show();</span>

<span class="org-string">        ch.set_width(800.0);</span>
<span class="org-string">        ch.set_height(700.0)</span>
<span class="org-string">        ch.show();</span>

<span class="org-string">        console.log("   [QUICKJS] Change chart dimensions using properties ");</span>
<span class="org-string">        ch.width = 500;</span>
<span class="org-string">        ch.height = 660;</span>

<span class="org-string">        console.log(`\n   &lt;QUICKJS&gt; Chart width = ${ch.width} ; Chart height = ${ch.height} \n`);</span>

<span class="org-string">        ch.plot_points( [ 10.522, 8.261, -100.24, 7.2532, 56.123, 89.23 ] );</span>
<span class="org-string">    )</span><span class="org-default">"</span>;

    try_eval_module<span class="org-rainbow-delimiters-depth-2">(</span>context, runtime, module_code<span class="org-rainbow-delimiters-depth-2">)</span>;

    js_std_loop<span class="org-rainbow-delimiters-depth-2">(</span>context.ctx<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">----- Shutdown virtual machine ---------------// </span>
    js_std_free_handlers<span class="org-rainbow-delimiters-depth-2">(</span>runtime.rt<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Building and Running</b> 
</p>

<p>
Download sources: 
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ git clone https://gist.github.com/1abdd1d36cd3e973cd1f11f5c20ef7eb qqjs &amp;&amp; <span class="org-builtin">cd</span> qqjs 

 $ ls
CMakeLists.txt  main.cpp  quickjspp.hpp
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
$ cmake --build _build --target
</pre>
</div>

<p>
Running qjsc (QuickJS - transpiler or C code generator)
</p>

<div class="org-src-container">
<pre class="src src-text"> $ _build/qjsc 
QuickJS Compiler version 2020-11-08
usage: qjsc [options] [files]

options are:
-c          only output bytecode in a C file
-e          output main() and bytecode in a C file (default = executable output)
-o output   set the output filename
-N cname    set the C name of the generated data
-m          compile as Javascript module (default=autodetect)
-D module_name         compile a dynamically loaded module or worker
-M module_name[,cname] add initialization code for an external C module
-x          byte swapped output
-p prefix   set the prefix of the generated C names
-S n        set the maximum stack size to 'n' bytes (default=262144)
</pre>
</div>

<p>
Running <span class="underline">main</span> application, which embeds QuickJS JS engine:  
</p>

<div class="org-src-container">
<pre class="src src-text"> $ &gt;&gt; _build/main 
 [INFO] Started Ok
 [TRACE] Before loading code. 
 [QUICJS] =&gt; =&gt;&gt; Script loaded. Ok. 

 [QUICKJS-TRACE] n = 1/5 
 [QUICKJS-TRACE] n = 2/5 
 [QUICKJS-TRACE] n = 3/5 
 [QUICKJS-TRACE] n = 4/5 
 [QUICKJS-TRACE] n = 5/5 

  [QUICKJS] asset_path = /Users/mydir-macosx/data/blackjack.txt
   [QUICKJS] score = 25.156 (in percent) 

   [QUICKJS] data points = 0.251,19.2363,9.262,100.125 
 [TRACE] After loading code. 
 [RESULT] number = -1860

 [*] ===== Read configuration variables defined in the js code. ====

    =&gt;&gt; asset_path = /Users/mydir-macosx/data/blackjack.txt
    =&gt;&gt; game_score (%) = 25.156
    ==&gt;&gt; datapoints = [4]( 0.251 19.2363 9.262 100.125  ) 

 [*] ===== Define variables in C++-side  ====

 [STEP 2] user_name = Gaius Julius Caesar ; points = 101235 
 [STEP 2] user_data = ADA,RUST,C++11,C++17,C++20,Dlang,OCaml,C#(Csharp) ; type = object 
 [STEP 2] user_data[5] = Dlang 
ADA
RUST
C++11
C++17
C++20
Dlang
OCaml
C#(Csharp)

 [*] ===== Register class ChartXY   ====

 [SCRIPT] chart.user_path = /Users/data/assets/game/score/marks 


 [SCRIPT] chart.user_points = 1023523 


 [SCRIPT] Result = 990.3825099999999 

 [&#262;hartXY Object] x = 0 ; y = 0 ; width = 200 height = 600
 [ChartXY] Width set to 800.000000 
 [ChartXY] Height set to 700.000000 
 [&#262;hartXY Object] x = 0 ; y = 0 ; width = 800 height = 700
   [QUICKJS] Change chart dimensions using properties 
 [ChartXY] Width set to 500.000000 
 [ChartXY] Height set to 660.000000 

   &lt;QUICKJS&gt; Chart width = 500 ; Chart height = 660 

 [ChartXY] Plotting points =&gt;&gt;  10.522 8.261 -100.24 7.2532 56.123 89.23

</pre>
</div>
</div>
</div>

<div id="outline-container-org098b4dc" class="outline-3">
<h3 id="org098b4dc"><span class="section-number-3">1.9</span> Chaiscript</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Scripting engine available as a header-only library that has
Javascript-like syntax and easy integration to C++ codebases.
</p>

<p>
Drawbacks: 
</p>
<ul class="org-ul">
<li>Header-only =&gt; Slow compile-time and large executable size due to
the intesive use of templates. <a href="https://arne-mertz.de/2019/02/extern-template-reduce-compile-times/">Extern templates</a> C++ language
feature could reduce the compile time.</li>
</ul>

<p>
Repository: 
</p>
<ul class="org-ul">
<li><a href="https://github.com/ChaiScript/ChaiScript">https://github.com/ChaiScript/ChaiScript</a></li>
</ul>

<p>
Web site: 
</p>
<ul class="org-ul">
<li><a href="https://chaiscript.com/examples.html">https://chaiscript.com/examples.html</a></li>
</ul>


<p>
<b>Files</b> 
</p>

<p>
File: <span class="underline">CMakeLists.txt</span> 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.0)
<span class="org-function-name">project</span>(chaiscript-eval)

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)

<span class="org-function-name">include</span>( FetchContent )

<span class="org-function-name">set</span>( BUILD_SAMPLES  OFF CACHE BOOL  <span class="org-string">""</span>) 
<span class="org-function-name">set</span>( BUILD_SAMPLES  OFF CACHE BOOL  <span class="org-string">""</span>) 
<span class="org-function-name">set</span>( RUN_FUZZY_TESTS OFF CACHE BOOL <span class="org-string">""</span>)
<span class="org-function-name">set</span>( RUN_PERFORMANCE_TESTS  OFF CACHE BOOL <span class="org-string">""</span>)

<span class="org-function-name">FetchContent_Declare</span>(
     chaiscript 
     GIT_REPOSITORY  https://github.com/ChaiScript/ChaiScript/
     GIT_TAG         v6.1.0     
)
<span class="org-function-name">FetchContent_MakeAvailable</span>(chaiscript)
<span class="org-function-name">include_directories</span>( chaiscript-runtime PUBLIC ${<span class="org-variable-name">chaiscript_SOURCE_DIR</span>}/include )    

<span class="org-function-name">add_executable</span>( runner chaiscript-eval.cpp)

<span class="org-keyword">if</span>(UNIX)
    <span class="org-function-name">target_link_libraries</span>( runner PUBLIC pthread dl )
<span class="org-keyword">endif</span>()
</pre>
</div>

<p>
File: <span class="underline">chaiscript-eval.cpp</span> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chaiscript/chaiscript.hpp</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">void</span> <span class="org-function-name">scriptable_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">label</span>, <span class="org-type">int</span> <span class="org-variable-name">w</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [CALLED] label = "</span> &lt;&lt; label &lt;&lt; <span class="org-string">" ; w = "</span> &lt;&lt; w &lt;&lt; <span class="org-string">'\n'</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Robot</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-type">float</span> <span class="org-variable-name">x</span> = 0, <span class="org-variable-name">y</span> = 0;
<span class="org-function-name">public</span>:

    <span class="org-function-name">Robot</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">Robot</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">float</span> <span class="org-variable-name">x</span>, <span class="org-type">float</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){}</span>

    <span class="org-type">void</span> <span class="org-function-name">setPosition</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">float</span> <span class="org-variable-name">x</span>, <span class="org-type">float</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">this</span>-&gt;x = x;
        <span class="org-keyword">this</span>-&gt;y = y;
        <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-3">(</span>stderr, <span class="org-string">" [INFO] Robot moved to x = %f ; y = %f \n"</span>, x, y<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   

    <span class="org-type">void</span> <span class="org-function-name">showPosition</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-3">(</span>stderr, <span class="org-string">" [INFO] Robot position (x = %f, y = %f ) \n"</span>, x, y<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create script engine object </span>
  <span class="org-constant">chaiscript</span>::<span class="org-type">ChaiScript</span> <span class="org-variable-name">chai</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Register user function   </span>
  chai.add<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">chaiscript</span>::fun<span class="org-rainbow-delimiters-depth-3">(</span>&amp;scriptable_function<span class="org-rainbow-delimiters-depth-3">)</span>
          , <span class="org-string">"scriptable_function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  chai.add<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">chaiscript</span>::constructor<span class="org-rainbow-delimiters-depth-3">&lt;</span>Robot<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>, <span class="org-string">"Robot"</span> <span class="org-rainbow-delimiters-depth-2">)</span>;
  chai.add<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">chaiscript</span>::fun<span class="org-rainbow-delimiters-depth-3">(</span>&amp;<span class="org-constant">Robot</span>::showPosition<span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-string">"showPosition"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  chai.add<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">chaiscript</span>::fun<span class="org-rainbow-delimiters-depth-3">(</span>&amp;<span class="org-constant">Robot</span>::setPosition<span class="org-rainbow-delimiters-depth-3">)</span>,  <span class="org-string">"setPosition"</span> <span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">code</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">        // It supports C++-like syntax </span>
<span class="org-string">        for(var i = 0; i &lt; 5; ++i)</span>
<span class="org-string">        { </span>
<span class="org-string">            print(i);</span>
<span class="org-string">        }</span>

<span class="org-string">        puts(" ========= Line ================= \n");</span>
<span class="org-string">        scriptable_function("Moon", 200);</span>
<span class="org-string">        scriptable_function("Mars", 500);</span>

<span class="org-string">        var robot = Robot();</span>
<span class="org-string">        robot.setPosition(200, 400);</span>
<span class="org-string">        robot.showPosition();</span>

<span class="org-string">        // User configuration function will be called </span>
<span class="org-string">        // by the script engine. </span>

<span class="org-string">        def on_init_hook()</span>
<span class="org-string">        {</span>
<span class="org-string">            puts("\n [TRACE] User function called. Ok.");</span>
<span class="org-string">        }</span>

<span class="org-string">    )</span><span class="org-default">"</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to evaluate code </span>
  <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      chai.eval<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">chaiscript</span>::<span class="org-constant">exception</span>::<span class="org-type">eval_error</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Exception = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ==== Get robot object from script ========="</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-keyword">auto</span> <span class="org-variable-name">robot</span> = chai.eval<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Robot</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"robot"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  robot-&gt;showPosition<span class="org-rainbow-delimiters-depth-2">()</span>;
  robot-&gt;setPosition<span class="org-rainbow-delimiters-depth-2">(</span>400, 1000<span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">---- End of main() ----------// </span>
</pre>
</div>

<p>
<b>Check Executable</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ du -h build/runner
23M     build/runner

<span class="org-comment-delimiter"># </span><span class="org-comment">Remove debugging symbols </span>
$ strip build/runner
$ du -h build/runner
7.6M    build/runner

$ file build/runner
<span class="org-function-name">build/runner</span>: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2
</pre>
</div>

<p>
<b>Running</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./runner 
0
1
2
3
4
 ========= Line ================= 

 [CALLED] label = Moon ; w = 200

 [CALLED] label = Mars ; w = 500
 [INFO] Robot moved to x = 200.000000 ; y = 400.000000 
 [INFO] Robot position (x = 200.000000, y = 400.000000 ) 
 ==== Get robot object from script =========
 [INFO] Robot position (x = 200.000000, y = 400.000000 ) 
 [INFO] Robot moved to x = 400.000000 ; y = 1000.000000 
</pre>
</div>
</div>
</div>
<div id="outline-container-org6f474af" class="outline-3">
<h3 id="org6f474af"><span class="section-number-3">1.10</span> Python Engine via Pybind11</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://pybind11.readthedocs.io/en/stable/advanced/embedding.html">Pybind11 Embedding</a></li>
</ul>

<p>
Advantages: 
</p>
<ul class="org-ul">
<li>High popularity</li>
<li>Lost of libraries</li>
<li>Easy usage</li>
</ul>

<p>
Drawbacks: 
</p>
<ul class="org-ul">
<li>Hard to static link</li>
<li>Not ligthweight and designed to be embedded as Lua.</li>
<li>It is not possible to run multiple instances of the Python
interpreter.</li>
<li>It is not possible to sandbox the interpreter and restrict
accessing files or process manipulation APIs.</li>
<li>Requires pre-installation of Python development headers. But, it
can be mitigated by using Anaconda or miniconda Python distributions.</li>
</ul>

<p>
Known Cases: 
</p>
<ul class="org-ul">
<li>GDB - GNU Debugger</li>
<li>IDA Debugger</li>
<li>Sublime Text Editor</li>
</ul>

<p>
<b>Sample Project</b> 
</p>

<p>
GIST containing the sources: 
</p>
<ul class="org-ul">
<li><a href="https://gist.github.com/d7fda02034757374a0b0114e54c7daff">https://gist.github.com/d7fda02034757374a0b0114e54c7daff</a></li>
</ul>

<p>
File: CMakeLists.txt 
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.9)
<span class="org-function-name">project</span>(embed-python-scripting)

<span class="org-comment">#========== Global Configurations =============#</span>
<span class="org-comment">#----------------------------------------------#</span>

<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)     
<span class="org-function-name">set</span>(CMAKE_VERBOSE_MAKEFILE ON)
<span class="org-function-name">set</span>(CMAKE_CXX_EXTENSIONS OFF)

<span class="org-comment"># ------------ Download CPM CMake Script ----------------#</span>

<span class="org-comment">## Automatically donwload and use module CPM.cmake</span>
<span class="org-function-name">file</span>(DOWNLOAD https://raw.githubusercontent.com/TheLartians/CPM.cmake/v0.26.2/cmake/CPM.cmake
                 <span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/CPM.cmake"</span>)
<span class="org-function-name">include</span>(<span class="org-string">"${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">}/CPM.cmake"</span>)

<span class="org-comment">#----------- Add dependencies --------------------------#</span>

<span class="org-function-name">find_package</span>(PythonLibs REQUIRED)

<span class="org-function-name">CPMAddPackage</span>(
    NAME pybind11 
    URL  https://github.com/pybind/pybind11/archive/v2.5.zip    
    DOWNLOAD_ONLY true  
)

<span class="org-comment"># add_subdirectory( {pybind11_SOURCE_DIR} )</span>
<span class="org-function-name">include_directories</span>( ${<span class="org-variable-name">pybind11_SOURCE_DIR</span>}/include
                     ${<span class="org-variable-name">PYTHON_INCLUDE_PATH</span>} )

<span class="org-function-name">message</span>( [TRACE] <span class="org-string">"  pybind11_SOURCE_DIR = ${</span><span class="org-variable-name">pybind11_SOURCE_DIR</span><span class="org-string">} "</span>)

<span class="org-comment"># configure_file(script.py ${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-comment">} COPYONLY )</span>

<span class="org-comment">#----------- Set targets -------------------------------#</span>

<span class="org-function-name">add_executable</span>(app1 app1.cpp)
<span class="org-function-name">target_link_libraries</span>( app1 ${<span class="org-variable-name">PYTHON_LIBRARIES</span>} )

<span class="org-function-name">add_custom_command</span>(
        TARGET app1 POST_BUILD
        COMMAND ${<span class="org-variable-name">CMAKE_COMMAND</span>} -E copy
                ${<span class="org-variable-name">CMAKE_SOURCE_DIR</span>}/script.py 
                ${<span class="org-variable-name">CMAKE_CURRENT_BINARY_DIR</span>}/script.py)

</pre>
</div>

<p>
File: app.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">pybind11/embed.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">py</span> = pybind11;

<span class="org-comment-delimiter">// </span><span class="org-comment">Requires: &lt;string&gt;, &lt;stream&gt;, &lt;sstream&gt;</span>
<span class="org-function-name">std</span>::string readFile<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">file</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">is</span> = <span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-2">(</span>file<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-negation-char">!</span>is.good<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: stream has errors."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
    ss &lt;&lt; is.rdbuf<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> ss.str<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">extern</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">pycode</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">py</span>::scoped_interpreter<span class="org-rainbow-delimiters-depth-2">{}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">------ EXPERIMENT 1 ------------------------------------// </span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [EXPERIMENT 1] ===== Execute Python code ======================\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">code</span> = readFile<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"./script.py"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; " code = " &lt;&lt; code &lt;&lt; "\n";</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = <span class="org-constant">py</span>::globals<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Define global variables for the interpreter global scope </span>
    g<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"game_assets"</span><span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"/Users/myuser/game_assets"</span>;
    g<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"speed"</span><span class="org-rainbow-delimiters-depth-2">]</span>       = 20.151;
    g<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"z_value"</span><span class="org-rainbow-delimiters-depth-2">]</span>     = 100;    

    <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate Python code</span>
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>        
        <span class="org-constant">py</span>::exec<span class="org-rainbow-delimiters-depth-3">(</span> code, g <span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">pybind11</span>::<span class="org-type">error_already_set</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [PYBIND11 ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-keyword">return</span> EXIT_FAILURE;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">------ EXPERIMENT 2 ------------------------------------// </span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n [EXPERIMENT 2] == Read user defined configuration variables ===\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">v_x</span>    = g<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"x"</span><span class="org-rainbow-delimiters-depth-2">]</span>.cast<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">v_path</span> = g<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"path"</span><span class="org-rainbow-delimiters-depth-2">]</span>.cast<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*]    v_x = "</span> &lt;&lt; v_x &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] v_path = "</span> &lt;&lt; v_path &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">return</span> EXIT_SUCCESS;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">----- Internal Python Embedded Module ---------------------------// </span>


<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">version</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"SampleModule Version 3.451-ZETA"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Sample "function-object class"</span>
<span class="org-keyword">class</span> <span class="org-type">LinearFunctor</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-type">double</span> <span class="org-variable-name">A</span> = 0, <span class="org-variable-name">B</span> = 0;

    <span class="org-function-name">LinearFunctor</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-function-name">LinearFunctor</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span>: A<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, B<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">double</span> <span class="org-function-name">GetA</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> A; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">SetA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> A = a; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span> <span class="org-function-name">GetB</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> B; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">SetB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> B = b; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" LinearFunction: y(x) = A * x + B"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; A = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;A &lt;&lt; <span class="org-string">" ; B = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;B &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">toString</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
        ss &lt;&lt; <span class="org-string">" LinearFunction: y(x) = A * x + B"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        ss &lt;&lt; <span class="org-string">" =&gt; A = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;A &lt;&lt; <span class="org-string">" ; B = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;B &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-keyword">return</span> ss.str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator</span>
    <span class="org-type">double</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> A * x + B;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">---- Internal Module -----------------------// </span>

<span class="org-function-name">PYBIND11_EMBEDDED_MODULE</span><span class="org-rainbow-delimiters-depth-1">(</span>SampleModule, m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">optional module docstring</span>
    m.doc<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-string">"Sample Python built with C++ CeePlusPlus "</span>;
    m.def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"version"</span>, &amp;version, <span class="org-string">"Show Library Version"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    m.def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"cppLambda"</span>
          ,<span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> 3.0 * x + y;<span class="org-rainbow-delimiters-depth-3">}</span>
          ,<span class="org-string">"A C++ lambda object or functor"</span>
          <span class="org-comment-delimiter">//</span><span class="org-comment">,py::arg("x"), py::args("y") = 15</span>
    <span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register LinearFunction</span>
    <span class="org-constant">py</span>::class_<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">LinearFunctor</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>m, <span class="org-string">"LinearFunctor"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">py</span>::init<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span>             <span class="org-comment-delimiter">// </span><span class="org-comment">Register overloaded consructor</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"GetA"</span>, &amp;<span class="org-constant">LinearFunctor</span>::GetA<span class="org-rainbow-delimiters-depth-2">)</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">Reister method GetA()</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"GetB"</span>, &amp;<span class="org-constant">LinearFunctor</span>::GetB<span class="org-rainbow-delimiters-depth-2">)</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">Register method GetB()</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"SetA"</span>, &amp;<span class="org-constant">LinearFunctor</span>::SetA<span class="org-rainbow-delimiters-depth-2">)</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">Reister method GetA()</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"SetB"</span>, &amp;<span class="org-constant">LinearFunctor</span>::SetB<span class="org-rainbow-delimiters-depth-2">)</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">Register method GetB()</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"show"</span>, &amp;<span class="org-constant">LinearFunctor</span>::show<span class="org-rainbow-delimiters-depth-2">)</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">Register method show</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"call"</span>, &amp;<span class="org-constant">LinearFunctor</span>::<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>      <span class="org-comment-delimiter">// </span><span class="org-comment">Register function-call operator with name 'call'</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"__call__"</span>, &amp;<span class="org-constant">LinearFunctor</span>::<span class="org-keyword">operator</span> <span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Register fun-call operator</span>
            .def<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"__repr__"</span>, &amp;<span class="org-constant">LinearFunctor</span>::toString<span class="org-rainbow-delimiters-depth-2">)</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Register strin representation</span>
            .def_readwrite<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A"</span>, &amp;<span class="org-constant">LinearFunctor</span>::A<span class="org-rainbow-delimiters-depth-2">)</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Register field A</span>
            .def_readwrite<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"B"</span>, &amp;<span class="org-constant">LinearFunctor</span>::B<span class="org-rainbow-delimiters-depth-2">)</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">Register field B</span>

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">/** </span><span class="org-comment">--- End of PYBIND11_MODULE registration --- */</span>

</pre>
</div>

<p>
File: script.py 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">"   =&gt; game_assets = "</span>, game_assets)
<span class="org-keyword">print</span>(<span class="org-string">"   =&gt;       speed = "</span>, speed)
<span class="org-keyword">print</span>(<span class="org-string">"   =&gt;     z_value = "</span>, z_value)

<span class="org-function-name">x</span>: <span class="org-builtin">float</span> = 10.0 * 20.51 / 200

<span class="org-variable-name">path</span> = <span class="org-string">"C:\\\\Users\\dummy\\Documents\\data"</span>

<span class="org-keyword">print</span>(<span class="org-string">" [PYTHON] The value of x = "</span>, x)

<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(5):
    <span class="org-keyword">print</span>(<span class="org-string">"   [PYTHON] i = "</span>, i)

<span class="org-comment-delimiter"># </span><span class="org-comment">It is not possible to restrict the interpreter!</span>
<span class="org-keyword">import</span> os 
<span class="org-keyword">print</span>(<span class="org-string">" [*] Current path = "</span>, os.getcwd() )

<span class="org-keyword">print</span>(<span class="org-string">"\n ------------------------------------------"</span>)
<span class="org-keyword">print</span>(<span class="org-string">"\n =&gt;&gt;&gt; Test Python Internal Module (C++) &lt;&lt;=\n"</span>)

<span class="org-keyword">import</span> SampleModule <span class="org-keyword">as</span> m 
<span class="org-keyword">from</span> SampleModule <span class="org-keyword">import</span> LinearFunctor 

<span class="org-keyword">print</span>(f<span class="org-string">"    -&gt;   Module Information = [{m.__doc__}] "</span>)
<span class="org-keyword">print</span>( <span class="org-string">"    -&gt;       Module Version = "</span>, m.version())
<span class="org-keyword">print</span>( <span class="org-string">"    -&gt; m.cppLambda(100, 25) = "</span>, m.cppLambda(100, 25) )

<span class="org-variable-name">functor</span> = LinearFunctor(8.0, -10.0)
<span class="org-keyword">print</span>(f<span class="org-string">"\n C++ Functor -&gt; ${functor} "</span>)

<span class="org-keyword">print</span>(<span class="org-string">" functor(5.0) = "</span>, functor(5.0))
<span class="org-keyword">print</span>(<span class="org-string">" functor(8.0) = "</span>, functor(8.0))

</pre>
</div>

<p>
Build and running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cd /tmp 
$ git clone https://gist.github.com/d7fda02034757374a0b0114e54c7daff python-embed-script 
$ cd python-embed-script

$ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
$ cmake --build _build --target 
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ _build/app1 

 [EXPERIMENT 1] ===== Execute Python code ======================

   =&gt; game_assets =  /Users/myuser/game_assets
   =&gt;       speed =  20.151
   =&gt;     z_value =  100
 [PYTHON] The value of x =  1.0255
   [PYTHON] i =  0
   [PYTHON] i =  1
   [PYTHON] i =  2
   [PYTHON] i =  3
   [PYTHON] i =  4
 [*] Current path =  /home/mxpkf8/temp-projects/python-embed-script

 ------------------------------------------

 =&gt;&gt;&gt; Test Python Internal Module (C++) &lt;&lt;=

    -&gt;   Module Information = [Sample Python built with C++ CeePlusPlus ] 
    -&gt;       Module Version =  SampleModule Version 3.451-ZETA
    -&gt; m.cppLambda(100, 25) =  325.0

 C++ Functor -&gt; $ LinearFunction: y(x) = A * x + B
 =&gt; A = 8 ; B = -10

 functor(5.0) =  30.0
 functor(8.0) =  54.0

 [EXPERIMENT 2] == Read user defined configuration variables ===

 [*]    v_x = 1.0255
 [*] v_path = C:<span class="org-string">\\</span>Users\dummy\Documents\data

</pre>
</div>
</div>
</div>
<div id="outline-container-orgd967991" class="outline-3">
<h3 id="orgd967991"><span class="section-number-3">1.11</span> Scheme-like lisp interpreter</h3>
<div class="outline-text-3" id="text-1-11">
</div>
<div id="outline-container-orgfbc8fb1" class="outline-4">
<h4 id="orgfbc8fb1"><span class="section-number-4">1.11.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
Scheme is a simple dialect of lisp with several functional-programming
features. Functions are first class citizens, they can be passed as
argument to other functions and returned from functions. Everything is
an expression and evaluates to something, even assignments and if-else
statements. Some versions of scheme also feature tail-call
optimization that allow writing tail-recursive functions to be
converted to loop without creating excessive stack frames.
</p>

<p>
This section presents a lisp-like interpreter based on <span class="underline">Scheme</span>,
implemented using modern C++ features and object oriented design
patterns with a handwritten parser and lexer. This lisp interpreter is
based on <a href="https://norvig.com/lispy.html">lispy</a>, a lisp interpreter written in Python. Just like lispy,
this implementation is easy to understand and can be easily be embedded in
C++ applications for adding scripting capabilities or ursing
S-expressions as a DSL (Domain-Specific Language) or data description
language. 
</p>


<p>
Techniques used in this implementation: 
</p>

<ul class="org-ul">
<li>Smart pointers are used for memory managment.</li>

<li><span class="underline">Composite design pattern</span> for representing the AST</li>

<li>Visitor design pattern is used for traversing the AST and
implementing AST printing. In a functional programming language
with proper sum types (also known as variants or discriminated
unions), the visitor could be replaced by <span class="underline">pattern matching</span>.</li>

<li>Inheritance is used for representing <span class="underline">sum types</span> or <span class="underline">discriminated</span>
<span class="underline">unitons</span>, common in functional programming languages.  The AST
(Abstract Syntax Tree) nodes, including atoms and lists, are
represented by classes inheriting from <span class="underline">IEXpr</span> abstract class.</li>

<li>The interpreter uses direct recursive evaluation of the AST just
like the inspiration <a href="https://norvig.com/lispy.html">lispy</a>.</li>

<li>Lists are not implemented using linked lists, instead they are
implemented using std::vector container.</li>

<li>Besides the recursive abstract syntax tree evaluation
implementation, the interpreter could also be implemented using a
SECD (stack-environment-control-dump) virtual machine.</li>

<li>This implementation uses the <span class="underline">fn</span> keyword instead of <span class="underline">lambda</span>; <span class="underline">def</span>
instead of <span class="underline">define</span> for creating named functions; and <span class="underline">set</span> instead of
<span class="underline">define</span> for defining variables.</li>
</ul>


<p>
Possible implementation techniques of Lisp-like languages: 
</p>

<ul class="org-ul">
<li>Recursive AST (Abstract Syntax Tree) evaluation</li>

<li>SECD (stack-environment-control-dump) virtual/abstract machine</li>

<li><span class="underline">Meta-circular evaluator</span> =&gt; Implement lisp-like dialects on top of
an existing lisp implementation such as Common Lisp.</li>

<li>Compile lisp dialect to bytecodes of an existing virtual machine
including, JVM (Java Virtual Machine); CLR (Common Language
Runtime) - .NET virtual machine; parrot virtual machine or WASM -
Web Assembly.</li>

<li>JIT (Just-In-Time) compiler =&gt; Compile itself to machine code at
runtime for improving performance and speed. This technique is
used by several common lisp implementations.</li>

<li>Transpile S-expressions to another language, including C or C++.</li>
</ul>

<p>
Lisp terminology:
</p>

<ul class="org-ul">
<li>Sexp - S-Expression  
<ul class="org-ul">
<li>Stands for symbolic expressions</li>
</ul></li>

<li>Homoiconicity
<ul class="org-ul">
<li>Code is data. The lisp code represents the AST (Abstract Syntax
Tree) that is just nested lists of lists or atoms.</li>
</ul></li>

<li>atoms
<ul class="org-ul">
<li>Everything that is not a list is an atom. An indivisible value,
including strings, symbols, keywords, numbers and so on.</li>
</ul></li>

<li>car - comes from 'Contents of the Address part of the Register'</li>

<li>cdr - comes from 'Contents of the Decrement part of the Register'</li>

<li>cons -  abbreviation of the word 'construct'</li>

<li>Lisp 1 =&gt;&gt; There is a single namespace for variables and
functions. Example: Scheme variants.</li>

<li>Lisp 2 =&gt;&gt; There are separate namespaces for variables and
functions. Example: Common Lisp and Elisp - Emacs' lisp.</li>

<li>Special forms
<ul class="org-ul">
<li>They are forms or primitives not evaluated as functions, instead
arguments may not be evaluated at all. Most special forms are
primitives or control structures such as 'if', 'set', 'define', 'lambda'
and so on. For instance the 'if' special form, that has three
arguments, the first argument is a predicate, the second
argument is the action that happens when the predicate is true
and  the third argument is the action that happens when the
predicate is false. If the predicate is true, the second
argument is not evaluated and the if expression is evaluated to
the value of the first argument. If the predicate is false, the
first argument is not evaluated and the if expression is
evaluated to the value of the second argument.</li>
</ul></li>

<li>DSL - Domain Specific Lanaguage</li>

<li>(if &lt;PREDICATE&gt; &lt;THEN-EXPR&gt; &lt;ELSE-EXPR&gt; )
<ul class="org-ul">
<li>The &lt;THEN-EXPR&gt; or then-expression is evaluated if the predicate
evaulates to true that happens when the predicate does not
evaluate to #f or nil. If the predicate is evaluated to any
other value, the else-expression is evaluated.</li>
</ul></li>

<li>User-defined procedures
<ul class="org-ul">
<li>User-defined functions using the keyword <span class="underline">fn</span> (equivalent to
lambda) or <span class="underline">def</span> equivalent to Scheme's define keyword.</li>
</ul></li>

<li>Primitive procedures 
<ul class="org-ul">
<li>Built-in functions or procedures, for instance (+), (*), apply,
map, list and so on.</li>
</ul></li>

<li>Literals
<ul class="org-ul">
<li>Boolean literals =&gt; #t or #f - in this implementation</li>
<li>nil literal: nil =&gt; For designating empty return value.</li>
<li>symbol literal: 'a-symbol</li>
<li>keyword literal: :keyword1, :keyword2</li>
<li>String literal - between quotes:  "my string"</li>
</ul></li>
</ul>


<p>
Known uses of Lisp-like languages as <span class="underline">configuration language</span>, <span class="underline">scripting</span>
<span class="underline">language</span>, <span class="underline">embedded scripting language</span> or <span class="underline">extension language</span>:
</p>

<ol class="org-ol">
<li><span class="underline">Emacs text editor</span> - uses its own Lisp dialect ELisp as a
configuration language and scripting language. Note: Elisp is
older than Scheme and Common Lisp.</li>

<li><a href="https://guix.gnu.org/">GNU Guix</a> functional package manager that uses <a href="https://www.gnu.org/software/guile/">GNU GUile</a> as a
configuration and scripting language. GNU Guix solves the Linux
dependency hell problem by allowing reproducible installation of
any package. This package manager also allows multiple versions
of the same software to cohexis.</li>

<li><span class="underline">Autocad</span> from Autodesk - CAD (Computer Aided Design) software for
engineering drawing that uses Autolisp, its own lisp dialect based
on common lisp, as an embedded scripting language.</li>

<li><a href="https://www.gimp.org/tutorials/Basic_Scheme2/">GNU Gimp</a> - Image editor that uses <a href="https://tinyscheme.sourceforge.net/home.html">TinyScheme</a> as embedded
scripting language.</li>

<li><a href="https://ubrigens.com/posts/sandbox_tour.html">Apple Sandbox</a> - Uses TinyScheme as configuration language.</li>
</ol>


<p>
C++ Features useful for implementation of lexers, AST (Abstract Syntax
Trees) and interpreters:
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a></li>

<li><a href="https://en.cppreference.com/w/cpp/io/basic_istream">std::basic_istream and std::istream</a></li>

<li><a href="https://en.cppreference.com/w/cpp/io/basic_istream/getline">std::getline()</a></li>

<li><a href="https://en.cppreference.com/w/cpp/container/vector">std::vector container</a></li>

<li><a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string container</a></li>

<li><a href="https://en.cppreference.com/w/cpp/container/map">std::map container</a></li>

<li><a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function container</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/enum">Enum class (scoped enumeration)</a></li>

<li><a href="https://www.modernescpp.com/index.php/c-core-guidelines-rules-for-enumerations">C++ Core Guidelines: Rules for Enumerations - ModernesCpp.com</a></li>

<li><a href="https://stackoverflow.com/questions/18335861/why-is-enum-class-preferred-over-plain-enum">c++ - Why is enum class preferred over plain enum? - Stack Overflow</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast">std::static_pointer_cast</a>  (downcasting shared pointers)</li>

<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">std::make_shared()</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this - cppreference.com</a></li>

<li><a href="https://www.codeproject.com/Articles/286304/Solution-for-multiple-enable-shared-from-this-in-i">Solution for Multiple enable_shared_from_this in Inheritance Tree - CodeProject</a></li>

<li><a href="https://medium.com/@hmminto/using-enabled-shared-from-this-aa84c2b283c3">Using enabled_shared_from_this. enable_shared_from_this allows to</a></li>

<li><a href="https://www.caichinger.com/blog/2016/05/21/enable_shared_from_this/">Remarks on enable_shared_from_this - Christian Aichinger's posts</a></li>
</ul>


<p>
Typical AST - Abstract Syntax Tree of Lisp/Scheme implementations:
</p>

<div class="org-src-container">
<pre class="src src-text">                 Expr - Expression 
                     |
                     |
      +--------------+-------------------------+
      |                                        |  
  Cons(Expr, Expr)                           Atom - anything that is not a pair (cons cell)
(cons pair,                                    |
 cons linked list         +--------+--------+---+------+-----------+---------+--------------+
 or cons cell   )         |        |        |          |           |         |              |
                        Nil     Number    String    Boolean     Symbol    Keyword       Function 
                      literal   literal   Literal   Literal                                 |
                                                                               -------------+-------------
                                                                               |                         |
                                                                            Native                  Lisp Function
                                                                           Function              implemented in Lisp 

    data Expr =  -- Cons cell  
                 Cons Expr, Expr                      
                 -- Nil literal - represents an empty value 
               | Nil                             
                 -- Boolean literal 
               | Bool Bool                       
                 -- Number literal 
               | Num  Double                     
                 -- String literal 
               | Str  String                     
                 -- Symbol 
               | Sym  String                     
                 -- keyword 
               | Key  String                     
                 -- Native function written in the hosting language 
               | NativeFun ([Expr] -&gt; Expr)     
                  -- Function written in Lisp 
               | LispFunc (environment: Dict&lt;String,Expr&gt;, args: &lt;String&gt;, name: &lt;String&gt;, call:  [Expr] -&gt; Expr)


 Example =&gt;&gt; The pair or cons cell '( hello . 100) is reprented as:

      Cons( Sym("hello"), Num(100))

   Example -&gt;&gt; The list (1 hello "world") is represented as a linked list in the following format:

      Cons( Num(1), Cons( Sym("Hello"), Cons( Str("hello"), Nil )))
</pre>
</div>


<p>
AST - Abstract Syntax Tree used in this implementation: 
</p>

<div class="org-src-container">
<pre class="src src-text">           Expression  
               |
               |
   +-----------+------------------------+
   |                                    |
   |                                    |
List of Expr                          Atom - anything that is not a list 
                                        |
               +-------+---------+------+--+---+--------------+----------+
               |       |         |         |        |         |          |
              Nil    Number    String   Boolean   Symbol   Keyword   Function 
            Literal  Literal   Literal   Literal          :keyword    object 
                                        #t (true)                       |
                                        #f (false)           +----------+---------------+
                                                             |                          |
                                                      Native Function            Lisp Function 
                                                    written in C or C++         written in Lisp 
                                                    or in the hosting 
                                                       language 

Haskell-like notation:

   data Expr =  -- List data structure - can be represented by a linked list or vector  
                List [Expr]                     
                -- Nil literal - represents an empty value 
              | Nil                             
                -- Boolean literal 
              | Bool Bool                       
                -- Number literal 
              | Num  Double                     
                -- String literal 
              | Str  String                     
                -- Symbol 
              | Sym  String                     
                -- keyword 
              | Key  String                     
                -- Native function written in the hosting language 
              | NativeFun ([Expr] -&gt; Expr)     
                 -- Function written in Lisp 
              | LispFunc (environment: Dict&lt;String,Expr&gt;, args: &lt;String&gt;, name: &lt;String&gt;, call:  [Expr] -&gt; Expr)
</pre>
</div>

<p>
EBNF Grammar: 
</p>

<div class="org-src-container">
<pre class="src src-text"> sexp:  atom | list ; 

 list: "(" sexp* ")" ;

 atom:  SYMBOL 
      | KEYWORD  // Example: :x, :keyword 
      | NUMBER  
      | STRING 
      | BOOLEAN 
      | NIL 
      ; 

NIL: "nil"; 
BOOLEAN: "true" | "false";  
</pre>
</div>
</div>
</div>

<div id="outline-container-org8de5ddf" class="outline-4">
<h4 id="org8de5ddf"><span class="section-number-4">1.11.2</span> Code</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
File: <span class="underline">code.lisp</span>  - Sample Lisp scripting code 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-comment-delimiter">; </span><span class="org-comment">Lisp test code </span>
<span class="org-comment-delimiter">;</span><span class="org-comment">--------------------------------</span>

(comment <span class="org-string">"Comment special form is evaluated to nil and discarded."</span>)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Create a sample list </span>
(set mylist (list 10 #t #f <span class="org-string">"hello world"</span> 
              'hello 'world
              <span class="org-comment">; Operation 1</span>
              <span class="org-builtin">:keyword1</span> (+ 10 25 6) '(+ 10 25 6) 
              <span class="org-comment">; Operation 2</span>
              <span class="org-builtin">:keyword2</span> (* 4 2 6)  '(* 4 2 6) 

              ))

<span class="org-comment-delimiter">; </span><span class="org-comment">Factorial function </span>
(set code-fact <span class="org-string">"</span>
<span class="org-string">      ; Factorial function </span>
<span class="org-string">      (def fact (n)</span>
<span class="org-string">          (if (= n 1)</span>
<span class="org-string">              1                    ;; Base case </span>
<span class="org-string">              (* n (fact (- n 1))) ;; Recursion case </span>
<span class="org-string">           )) </span>
<span class="org-string">    "</span>)

<span class="org-comment-delimiter">;; </span><span class="org-comment">S-expression for fibbonaci function</span>
(def fib(n)
   (<span class="org-keyword">if</span> (&lt; n 2)
     n 
     (+ (fib (- n 1))  (fib (- n 2)) )
    ))

(def make-adder (k)
    (fn (x) (+ k x)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Define a function that adds 10 to a number </span>
(set add10 (make-adder 10))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Defines a function that adds 10 to a number </span>
(set add50 (make-adder 50))


(set func 
  (<span class="org-keyword">let</span> (
          (a (sqrt 125))
          (b (+ 20 a))
          (c (* a b))
        )
        (comment <span class="org-string">"Create  a function using lexical scope. </span>
<span class="org-string">                  The variable (a, b and c) are not visible outside the function. </span>
<span class="org-string">                  "</span>)
        (fn (x) (/ (+ a b x) c))
   )
 )

<span class="org-comment-delimiter">;; </span><span class="org-comment">Compute many trigonometric properties of an angle </span>
(def compute-trig (angle-degrees)
    (<span class="org-keyword">let</span> (
          (angle (/ (* angle-degrees PI) 180) )
         )
        (list <span class="org-builtin">:angle</span> angle-degrees <span class="org-builtin">:cos</span> (cos angle) <span class="org-builtin">:sin</span> (sin angle) <span class="org-builtin">:tan</span> (tan angle))
     )
 )

</pre>
</div>

<p>
File: <span class="underline">gui-dsl.lisp</span> - Hypothetical configuration file written in Lisp
that represents a html-like user interface.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">Theoretical GUI DSL (Domain Specific Language)</span>

(div <span class="org-builtin">:class</span> <span class="org-string">"myclass-csss-style"</span>
          <span class="org-builtin">:bgcolor</span> <span class="org-string">"#ff81a"</span> 
          <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;p&gt;Paragraph 1&lt;/p&gt;</span>
          (p <span class="org-string">"Paragraph 1 "</span>)
          <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;img  src="http://..../myimage.png" /&gt; </span>
          (img <span class="org-builtin">:src</span> <span class="org-string">"http://www.mydomain/images/myimage.png"</span> <span class="org-builtin">:caption</span> <span class="org-string">"Image 1 data"</span>)
          <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;button id="btn-submit" class="my-style-button" &gt;Submit&lt;/button&gt;</span>
          (button <span class="org-builtin">:label</span> <span class="org-string">"Submit"</span> <span class="org-builtin">:id</span> <span class="org-string">"btn-submit"</span> <span class="org-builtin">:class</span> <span class="org-string">"my-style-button"</span>
                  <span class="org-builtin">:onclick</span> (fn (event) (display <span class="org-string">"Button was clicked"</span>) ))
       )

</pre>
</div>


<p>
File: <span class="underline">cpplisp.cpp</span> (Lisp-like interpreter) - about 1600 lines of code.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cctype</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">optional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">stack</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">TokenType</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-variable-name">SYM</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol </span>
    , <span class="org-variable-name">KEYW</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Keyword  Examples =&gt; :keyword, :x</span>
    , <span class="org-variable-name">STR</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">String literal </span>
    , <span class="org-variable-name">NUM</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Number literal </span>
    , <span class="org-variable-name">BOOL</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean </span>
    , <span class="org-variable-name">QUOTE</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Quote  </span>
    , <span class="org-variable-name">RPAREN</span> <span class="org-comment-delimiter">// </span><span class="org-comment">'(' Right parenthesis  </span>
    , <span class="org-variable-name">LPAREN</span> <span class="org-comment-delimiter">// </span><span class="org-comment">')' Left parenthesis </span>
    , <span class="org-variable-name">EOFF</span>   <span class="org-comment-delimiter">//  </span><span class="org-comment">End of File (It was named 'EOFF' since it conflicts with #define 'EOF')</span>
    , <span class="org-variable-name">ERR</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates error </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">Token</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">TokenType</span>   <span class="org-variable-name">type</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span>;
    <span class="org-type">int</span> <span class="org-variable-name">pos</span>;
    <span class="org-type">int</span> <span class="org-variable-name">lin</span>;
    <span class="org-type">int</span> <span class="org-variable-name">col</span>;

    <span class="org-function-name">Token</span><span class="org-rainbow-delimiters-depth-2">()</span>: 
     type<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">TokenType</span>::ERR<span class="org-rainbow-delimiters-depth-2">)</span>, text<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-2">)</span>, pos<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>, lin<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>, col<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{}</span>

    <span class="org-function-name">Token</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">TokenType</span> <span class="org-variable-name">type_</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">text_</span>, <span class="org-type">int</span> <span class="org-variable-name">pos_</span>, <span class="org-type">int</span> <span class="org-variable-name">lin_</span>, <span class="org-type">int</span> <span class="org-variable-name">col_</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        type<span class="org-rainbow-delimiters-depth-2">(</span>type_<span class="org-rainbow-delimiters-depth-2">)</span>, text<span class="org-rainbow-delimiters-depth-2">(</span>text_<span class="org-rainbow-delimiters-depth-2">)</span>, pos<span class="org-rainbow-delimiters-depth-2">(</span>pos_<span class="org-rainbow-delimiters-depth-2">)</span>, lin<span class="org-rainbow-delimiters-depth-2">(</span>lin_<span class="org-rainbow-delimiters-depth-2">)</span>, col<span class="org-rainbow-delimiters-depth-2">(</span>col_<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">isEOF</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> type == <span class="org-constant">TokenType</span>::EOFF; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">bool</span> <span class="org-function-name">isNumber</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> text<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> != <span class="org-string">'-'</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-3">(</span>text<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = text.length<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">k</span> = 1; k &lt; n; k++<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-4">(</span> text<span class="org-rainbow-delimiters-depth-5">[</span>k<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;<span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Tokenizer</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">_is</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Position of cursor in the inout stream </span>
    <span class="org-type">int</span> <span class="org-variable-name">_pos</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Current line in the input stream </span>
    <span class="org-type">int</span> <span class="org-variable-name">_lin</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Column in the input stream </span>
    <span class="org-type">int</span> <span class="org-variable-name">_col</span> = 0; 
<span class="org-function-name">public</span>:
    <span class="org-function-name">Tokenizer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_is</span><span class="org-rainbow-delimiters-depth-2">(</span>is<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Read a single character and consumes it from the stream  </span>
    <span class="org-type">char</span> <span class="org-function-name">next</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
        <span class="org-type">char</span> <span class="org-variable-name">chr</span> = _is.get<span class="org-rainbow-delimiters-depth-3">()</span>; 
        _pos++;
        _col++;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Assumes that the new line character is just '\n'</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> chr == <span class="org-string">'\n'</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            _col = 0;
            _lin++;    
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> chr;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Read next character from input string without reading it </span>
    <span class="org-type">char</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">(){</span> 
        <span class="org-keyword">return</span> _is.peek<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-type">bool</span> <span class="org-function-name">isBlankChar</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> ch == <span class="org-string">' '</span> || ch == <span class="org-string">'\t'</span> || ch == <span class="org-string">'\r'</span> || ch == <span class="org-string">'\n'</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">isParenthesis</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> ch == <span class="org-string">'('</span> || ch == <span class="org-string">')'</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Is end of line     </span>
    <span class="org-type">bool</span> <span class="org-function-name">isEOL</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> peek<span class="org-rainbow-delimiters-depth-3">()</span> == <span class="org-string">'\n'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">isEOF</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _is.eof<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">skipBlankChars</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> isBlankChar<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> next<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">skipLineComment</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> ch != <span class="org-string">'\n'</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>-&gt;isEOF<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> ch = next<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Consume stream until a blank character is found </span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">consumeUntilBlank</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Consuming until blank \n");</span>
        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span>;
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-keyword">this</span>-&gt;isBlankChar<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>-&gt;isParenthesis<span class="org-rainbow-delimiters-depth-4">()</span>  &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>-&gt;isEOF<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            ch = <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">fprintf(stderr, " [TRACE] ConsumeUntilBlank ch = %d \n", ch);</span>
            text = text + ch;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] consumeUntilBlank = %s \n", text.c_str());</span>
        <span class="org-keyword">return</span> text;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">readTokens</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">out</span><span class="org-rainbow-delimiters-depth-3">{}</span>;
        <span class="org-type">Token</span> <span class="org-variable-name">tok</span>; 
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>tok.isEOF<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            tok = <span class="org-keyword">this</span>-&gt;nextToken<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>tok.isEOF<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> out.push_back<span class="org-rainbow-delimiters-depth-5">(</span>tok<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">stack</span> = <span class="org-constant">std</span>::<span class="org-type">stack</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Check if parentheses are balanced </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tok</span>: out<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Push left parentheses to the stack </span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>tok.type == <span class="org-constant">TokenType</span>::LPAREN<span class="org-rainbow-delimiters-depth-4">){</span> stack.push<span class="org-rainbow-delimiters-depth-5">(</span>tok<span class="org-rainbow-delimiters-depth-5">)</span>;  <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">If the stack is not empty and current parenthesis is a </span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">right parentheses, if the top of stack is left parentheses </span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">then pop the stack.</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>tok.type == <span class="org-constant">TokenType</span>::RPAREN <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>stack.empty<span class="org-rainbow-delimiters-depth-6">()</span> &amp;&amp; stack.top<span class="org-rainbow-delimiters-depth-6">()</span>.type == <span class="org-constant">TokenType</span>::LPAREN <span class="org-rainbow-delimiters-depth-5">)</span>
                     <span class="org-rainbow-delimiters-depth-5">{</span> stack.pop<span class="org-rainbow-delimiters-depth-6">()</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: unbalanced parentheses."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>stack.empty<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = stack.top<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-4">(</span>stderr, <span class="org-string">" [ERROR] Unbalanced parentheses at line %d and column %d \n"</span>, tok.lin, tok.col<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: unbalanced parentheses."</span><span class="org-rainbow-delimiters-depth-4">)</span>; 
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">return</span> out;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">Token</span> <span class="org-function-name">nextToken</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Removing blank characters \n");</span>
        skipBlankChars<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = next<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] nextChar = %c \n", ch);</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">this</span>-&gt;isEOF<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::EOFF, <span class="org-string">""</span>, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Skip comments </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">';'</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Skiping comment \n");</span>
            skipLineComment<span class="org-rainbow-delimiters-depth-4">()</span>; 

            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Skiping comment 2 \n");</span>
            <span class="org-keyword">return</span> nextToken<span class="org-rainbow-delimiters-depth-4">()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">'('</span><span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::LPAREN, <span class="org-string">"("</span>, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">')'</span><span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::RPAREN, <span class="org-string">")"</span>, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">'\''</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::QUOTE, <span class="org-string">"'"</span>,  _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean value </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">'#'</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">c</span> = <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">text</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"#"</span><span class="org-rainbow-delimiters-depth-4">)</span> + c;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> c!= <span class="org-string">'f'</span> &amp;&amp; c !=<span class="org-string">'t'</span> <span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::ERR, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error - invalid boolean literal =&gt; "</span><span class="org-rainbow-delimiters-depth-6">)</span> + text, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; 
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::BOOL, text,  _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">String literal </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ch == <span class="org-string">'"'</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Reading string literal \n");</span>
            <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span> = <span class="org-string">""</span>;
            <span class="org-type">int</span> <span class="org-variable-name">col</span> = _col;
            <span class="org-type">int</span> <span class="org-variable-name">pos</span> = _pos;
            <span class="org-type">int</span> <span class="org-variable-name">lin</span> = _lin;
            <span class="org-type">char</span> <span class="org-variable-name">c</span> = <span class="org-string">'x'</span>;
            <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span> c != <span class="org-string">'"'</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>-&gt;isEOF<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                c  = <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-5">()</span>;
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>c == <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
                out = out + c;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> c!= <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::ERR, <span class="org-string">"Error - non closed quote."</span>, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span>        <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::STR, out, pos, lin, col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">assert(  )</span>

        <span class="org-type">int</span> <span class="org-variable-name">col</span> = _col;
        <span class="org-type">int</span> <span class="org-variable-name">pos</span> = _pos;
        <span class="org-type">int</span> <span class="org-variable-name">lin</span> = _lin;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> = ch + <span class="org-keyword">this</span>-&gt;consumeUntilBlank<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> text == <span class="org-string">":"</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::ERR, <span class="org-string">"illegal terminating character after a colon:"</span> ,pos, lin, col<span class="org-rainbow-delimiters-depth-4">)</span>; 
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Keyworkd </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> text<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">':'</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Tokenizer =&gt;&gt; keyword = %s \n", text.c_str() );</span>
            <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::KEYW, text, pos, lin, col<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> text == <span class="org-string">"-"</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">TokenType</span>::SYM, text, pos, lin, col<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">text</span><span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> isNumber<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">text</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
                 <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::NUM, <span class="org-type">text</span>, pos, lin, col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::ERR, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error - invalid number =&gt; "</span><span class="org-rainbow-delimiters-depth-6">)</span> + text, pos, lin, col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> text<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">'-'</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> isNumber<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">text</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
                 <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::NUM, <span class="org-type">text</span>, pos, lin, col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">TokenType</span>::ERR, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error - invalid number =&gt; "</span><span class="org-rainbow-delimiters-depth-6">)</span> + text, pos, lin, col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Anything else is a symbpl </span>
        <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">TokenType</span>::SYM, <span class="org-type">text</span>, pos, lin, col<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-variable-name">TokenType</span> type<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::BOOL<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[BOOL]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::EOFF<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[EOF]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::STR<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[STR]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::LPAREN<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[LPAREN]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::RPAREN<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[RPAREN]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::NUM<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[NUM]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::SYM<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[SYM]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-constant">TokenType</span>::ERR<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"[ERR]"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> os;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">ExprType</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-variable-name">ERR</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Error  </span>
    , <span class="org-variable-name">NUM</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Number literal </span>
    , <span class="org-variable-name">STR</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">String literal </span>
    , <span class="org-variable-name">BOOL</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean literal </span>
    , <span class="org-variable-name">SYM</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol </span>
    , <span class="org-variable-name">KEY</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Keyword </span>
    , <span class="org-variable-name">NIL</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Nil or Null value </span>
    , <span class="org-variable-name">FUN</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Function  </span>
    , <span class="org-variable-name">LST</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">List literal </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Forward declaration </span>
<span class="org-keyword">struct</span> <span class="org-type">ExprNil</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprStr</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprNum</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprSym</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprKey</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprErr</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprBool</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprFun</span>;
<span class="org-keyword">struct</span> <span class="org-type">ExprLst</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Visitor design pattern </span>
<span class="org-keyword">struct</span> <span class="org-type">IVisitor</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">IVisitor</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNil</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprStr</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNum</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprSym</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprKey</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprBool</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprErr</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprFun</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprLst</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Lisp-like AST - Abstract syntax tree </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">IEXpr stands for Interface Expression </span>
<span class="org-keyword">struct</span> <span class="org-type">IExpr</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">IExpr</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-keyword">virtual</span> <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span>   <span class="org-keyword">const</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is ATOM</span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is list  </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isList</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is error  </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isErr</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is symbol </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isSym</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is string</span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isStr</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is keyword</span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isKey</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is number  </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isNum</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is boolean </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isBool</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is nil   </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isNil</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if AST node is function </span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>     <span class="org-function-name">isFun</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Returns the string value of a node </span>
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluates to false if nil or #f and evaluates to true if it is anything else.</span>
    <span class="org-keyword">virtual</span> <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Method for accepting visitor (Related to visitor design pattern)</span>
    <span class="org-keyword">virtual</span> <span class="org-type">void</span>     <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0; 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate AST node and return a value (AST Node) </span>
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a null value (empty value) equivalent to void </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">In Lisp just as other functional-like programming languages</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">everything is evaluated to something and can be replaced be a value.</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprNil</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-function-name">ExprNil</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::NIL; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isNil</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 0;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;<span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a string literal </span>
<span class="org-keyword">struct</span> <span class="org-type">ExprStr</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
    <span class="org-function-name">ExprStr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::STR; <span class="org-rainbow-delimiters-depth-2">}</span> 


    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>        <span class="org-function-name">isStr</span><span class="org-rainbow-delimiters-depth-2">()</span>      <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprStr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-keyword">this</span>-&gt;value<span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a number </span>
<span class="org-keyword">struct</span> <span class="org-type">ExprNum</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">double</span> <span class="org-variable-name">value</span>;
    <span class="org-function-name">ExprNum</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">value_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::NUM; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isNum</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-keyword">this</span>-&gt;value<span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a boolean literal (logical value)</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprBool</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>  
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">bool</span> <span class="org-variable-name">value</span>;
    <span class="org-function-name">ExprBool</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span> <span class="org-variable-name">value_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::BOOL; <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-type">bool</span> <span class="org-function-name">isBool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-keyword">this</span>-&gt;value<span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a lisp symbol</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprSym</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>  
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
    <span class="org-function-name">ExprSym</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::SYM; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isSym</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = env.find<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>it == env.end<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [ERROR] Unbound variable "</span> + value<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-comment-delimiter">//</span><span class="org-comment">return std::make_shared&lt;ExprErr&gt;(10, "Error - unbound variable " + value);</span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">return nullptr;</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> it-&gt;second;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a lisp keyword such as :x, :y, :keyword1</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprKey</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>  
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
    <span class="org-function-name">ExprKey</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::KEY; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isKey</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprKey</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-keyword">this</span>-&gt;value<span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-comment-delimiter">// </span><span class="org-comment">Represents an Error (Reserved for future use)</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprErr</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>  
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>         <span class="org-variable-name">code</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">info</span>;

    <span class="org-function-name">ExprErr</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
    <span class="org-function-name">ExprErr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">code_</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">info_</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : code<span class="org-rainbow-delimiters-depth-2">(</span>code_<span class="org-rainbow-delimiters-depth-2">)</span>, info<span class="org-rainbow-delimiters-depth-2">(</span>info_<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::ERR; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isErr</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> info;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;<span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprErr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>code, info<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-keyword">using</span> <span class="org-type">LispFunc</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-keyword">using</span> <span class="org-type">LispEnv</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>; 


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a function</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprFun</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">doc</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::vector&lt;std::string&gt; args;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::shared_ptr&lt;IExpr&gt;   body;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">ExprFun(std::vector&lt;std::string&gt; const&amp; args_): args(args_) { }</span>
    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::FUN; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span> <span class="org-function-name">isFun</span><span class="org-rainbow-delimiters-depth-2">()</span>    <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">isNativeFun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;

    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>  <span class="org-function-name">call</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">params</span>
                                        , <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env_</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;

    ~<span class="org-function-name">ExprFun</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Non-native lisp function implemented in lisp </span>
<span class="org-keyword">struct</span> <span class="org-type">ExprFunLisp</span>: <span class="org-keyword">public</span> <span class="org-type">ExprFun</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">args</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>  <span class="org-variable-name">body</span>;
    <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">env</span>;

    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"(function) "</span> + <span class="org-keyword">this</span>-&gt;name;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span> <span class="org-function-name">isNativeFun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
    <span class="org-function-name">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args_</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">body_</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : args<span class="org-rainbow-delimiters-depth-2">(</span>args_<span class="org-rainbow-delimiters-depth-2">)</span>, body<span class="org-rainbow-delimiters-depth-2">(</span>body_<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>

         <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Invoke copy constructor </span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
    <span class="org-function-name">call</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">params</span>
         ,<span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env_</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> params.size<span class="org-rainbow-delimiters-depth-4">()</span> != args.size<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: Function call error. "</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Create local environment </span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">envv</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Copy global environment to temporary environment </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">k</span> : env_<span class="org-rainbow-delimiters-depth-3">){</span> envv<span class="org-rainbow-delimiters-depth-4">[</span>k.first<span class="org-rainbow-delimiters-depth-4">]</span> = k.second; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Copy local environment to temporary environment </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">k</span> : env<span class="org-rainbow-delimiters-depth-3">){</span> envv<span class="org-rainbow-delimiters-depth-4">[</span>k.first<span class="org-rainbow-delimiters-depth-4">]</span> = k.second; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Pass parameters to local environment </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; args.size<span class="org-rainbow-delimiters-depth-4">()</span>; n++ <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = args<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>;
            envv<span class="org-rainbow-delimiters-depth-4">[</span>a<span class="org-rainbow-delimiters-depth-4">]</span> = params<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>;   
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">N</span> = body.size<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; N - 1; n ++ <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            body<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>envv<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = body<span class="org-rainbow-delimiters-depth-3">[</span>N - 1<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-3">(</span>envv<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> result-&gt;isFun<span class="org-rainbow-delimiters-depth-4">()</span> 
            &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>result<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;isNativeFun<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>result<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; args.size<span class="org-rainbow-delimiters-depth-5">()</span>; n++ <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>n<span class="org-rainbow-delimiters-depth-5">]</span>;
                func-&gt;env<span class="org-rainbow-delimiters-depth-5">[</span>a<span class="org-rainbow-delimiters-depth-5">]</span> = params<span class="org-rainbow-delimiters-depth-5">[</span>n<span class="org-rainbow-delimiters-depth-5">]</span>;   
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>
                                
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Native function implemented in C or C++</span>
<span class="org-keyword">struct</span> <span class="org-type">ExprFunNative</span>: <span class="org-keyword">public</span> <span class="org-type">ExprFun</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">LispFunc</span> <span class="org-variable-name">func</span>; 
    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"(native function) "</span> + <span class="org-keyword">this</span>-&gt;name;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span> <span class="org-function-name">isNativeFun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ExprFunNative</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">LispFunc</span> <span class="org-variable-name">func_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">func</span><span class="org-rainbow-delimiters-depth-2">(</span>func_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Invoke copy constructor </span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprFunNative</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>func<span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
    <span class="org-function-name">call</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">params</span>
         ,<span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env_</span><span class="org-rainbow-delimiters-depth-2">)</span>

    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Calling native function \n");</span>
        <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;func<span class="org-rainbow-delimiters-depth-3">(</span>params<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a list </span>
<span class="org-keyword">struct</span> <span class="org-type">ExprLst</span>: <span class="org-keyword">public</span> <span class="org-type">IExpr</span>  
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">lst</span>; 

    <span class="org-function-name">ExprLst</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lst_</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : lst<span class="org-rainbow-delimiters-depth-2">(</span>lst_<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-type">ExprType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ExprType</span>::LST; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-2">()</span>   <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">bool</span> <span class="org-function-name">isList</span><span class="org-rainbow-delimiters-depth-2">()</span>   <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-function-name">strValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span>       <span class="org-function-name">numValue</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1;   <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>         <span class="org-function-name">boolValue</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;<span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">type</span> = lst<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> type != <span class="org-constant">ExprType</span>::SYM &amp;&amp; type != <span class="org-constant">ExprType</span>::LST  <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [ERROR] =&gt;&gt; Object is not applicable."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">symbol</span> = lst<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore comment special form</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>symbol == <span class="org-string">"comment"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>symbol == <span class="org-string">"set"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lst.size<span class="org-rainbow-delimiters-depth-5">()</span> != 3<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for SET special form"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::SYM<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for SET special form. Expected symbol. "</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>; 
            <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-4">(</span>stderr, <span class="org-string">" [TRACE] Defining symbol = %s . \n"</span>, name.c_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            env<span class="org-rainbow-delimiters-depth-4">[</span>name<span class="org-rainbow-delimiters-depth-4">]</span> = res; <span class="org-comment-delimiter">//</span><span class="org-comment">;std::make_shared&lt;EnvVal&gt;(res);</span>
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Handle special form (if &lt;cond&gt; &lt;then-expr&gt;) or (if &lt;cond&gt; &lt;then-expr&gt; &lt;else-expr&gt;)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"if"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> != 3 &amp;&amp; lst.size<span class="org-rainbow-delimiters-depth-5">()</span> != 4<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for IF special form"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">auto</span> <span class="org-variable-name">cond</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">cond_result</span> = cond-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> == 3 &amp;&amp; <span class="org-negation-char">!</span>cond_result-&gt;boolValue<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span> 
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-5">&gt;()</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> == 4 &amp;&amp; <span class="org-negation-char">!</span>cond_result-&gt;boolValue<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate the else-expr </span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = lst<span class="org-rainbow-delimiters-depth-5">[</span>3<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>env<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this-&gt;eval( *lst[3] );</span>
                <span class="org-keyword">return</span> res;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            assert<span class="org-rainbow-delimiters-depth-4">(</span> cond_result-&gt;boolValue<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">this-&gt;eval( *lst[2] );</span>
            <span class="org-keyword">return</span> res;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Handle quote special form </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"quote"</span> || symbol == <span class="org-string">"$q"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> != 2 <span class="org-rainbow-delimiters-depth-4">)</span> 
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for QUOTE special form"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">arg</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>;
            <span class="org-keyword">return</span> arg;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to scheme or lisp lambda or scheme lambda </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(fn (a0 a1 ... a[N-1]) (expr1) (expr2) ... (expr[K-1]) )</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"fn"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lst.size<span class="org-rainbow-delimiters-depth-5">()</span> &lt; 3<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for lambda special form"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for lambda. Expected arguments."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">Function/lambda arguments   </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Function/lambda body (list of expressions)</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">body</span> = lst;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element ('lambda' symbol)</span>
            body.erase<span class="org-rainbow-delimiters-depth-4">(</span>body.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Remove frst element - function arguments </span>
            body.erase<span class="org-rainbow-delimiters-depth-4">(</span>body.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; 

            <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-variable-name">_args</span><span class="org-rainbow-delimiters-depth-4">{}</span>;

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">a</span>: args-&gt;lst<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>a-&gt;isSym<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>            
                <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Ill-formed syntax for lamba. Arguments must be strings."</span><span class="org-rainbow-delimiters-depth-6">)</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
                _args.push_back<span class="org-rainbow-delimiters-depth-5">(</span> a-&gt;strValue<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">auto</span> <span class="org-variable-name">fun</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>_args, body<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">return</span> fun;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">/** </span><span class="org-comment">Sepcial form def </span>
<span class="org-comment">         * (def function (a0 a1 ... a[N-1]) (expr1) (expr2) ... (expr[K-1]) )</span>
<span class="org-comment">         * </span>
<span class="org-comment">         *  Example: </span>
<span class="org-comment">         *   (def addxy(x  y )</span>
<span class="org-comment">         *             (disp x) </span>
<span class="org-comment">         *             (disp y)</span>
<span class="org-comment">         *              (+ x y))</span>
<span class="org-comment">         * </span>
<span class="org-comment">         */</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"def"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lst.size<span class="org-rainbow-delimiters-depth-5">()</span> &lt; 4<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for def() special form"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;isSym<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for def(). Expected function name."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>2<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Ill-formed syntax for def(). Expected arguments."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">Function name </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">name</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Function/lambda arguments   </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>2<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Function/lambda body (list of expressions)</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">body</span> = lst;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element ('lambda' symbol)</span>
            body.erase<span class="org-rainbow-delimiters-depth-4">(</span>body.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; 
            body.erase<span class="org-rainbow-delimiters-depth-4">(</span>body.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; 
            body.erase<span class="org-rainbow-delimiters-depth-4">(</span>body.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; 

            <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-4">(</span>stderr, <span class="org-string">" [TRACE] Defining function = %s . \n"</span>, name.c_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;

            <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-variable-name">_args</span><span class="org-rainbow-delimiters-depth-4">{}</span>;

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">a</span>: args-&gt;lst<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>a-&gt;isSym<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>            
                <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Ill-formed syntax for lamba. Arguments must be strings."</span><span class="org-rainbow-delimiters-depth-6">)</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
                _args.push_back<span class="org-rainbow-delimiters-depth-5">(</span> a-&gt;strValue<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">fun</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>_args, body<span class="org-rainbow-delimiters-depth-4">)</span>;
            fun-&gt;name = name;

            env<span class="org-rainbow-delimiters-depth-4">[</span>name<span class="org-rainbow-delimiters-depth-4">]</span> = fun;

            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Handle special form (begin (action1 ....) (action 2) (action N-1)) </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"begin"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">arguments </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = lst;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element </span>
            args.erase<span class="org-rainbow-delimiters-depth-4">(</span>args.begin<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> args.size<span class="org-rainbow-delimiters-depth-5">()</span> == 0<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-5">&gt;()</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; args.size<span class="org-rainbow-delimiters-depth-5">()</span> - 1; n++<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>  args<span class="org-rainbow-delimiters-depth-5">[</span>n<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>env<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Revaluate last element </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = args<span class="org-rainbow-delimiters-depth-4">[</span> args.size<span class="org-rainbow-delimiters-depth-5">()</span> -1 <span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">return</span> result;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        
        <span class="org-comment-delimiter">/** </span><span class="org-comment">(let (binding lists) (exp1) (exp2) .... (expN-1) )</span>
<span class="org-comment">         *     </span>
<span class="org-comment">         *  (let ( (a 20)</span>
<span class="org-comment">         *         (b 30 )) </span>
<span class="org-comment">         *        (display a) (display b) (+ a b) )</span>
<span class="org-comment">         *  </span>
<span class="org-comment">         *  The previous expression evaluates to 30.</span>
<span class="org-comment">         */</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"let"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> &lt; 3 <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: ill-formed sytax for let expression."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: ill-formed sytax for let expression. Expected list of bindings."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">auto</span> <span class="org-variable-name">bindings</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>-&gt;lst;

            <span class="org-comment-delimiter">// </span><span class="org-comment">Create a new temporary environment </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">envv</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-5">&gt;</span><span class="org-rainbow-delimiters-depth-4">&gt;{}</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">envs</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-5">&gt;</span><span class="org-rainbow-delimiters-depth-4">&gt;{}</span>;

            <span class="org-comment-delimiter">// </span><span class="org-comment">Copy environment     </span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">k</span> : env<span class="org-rainbow-delimiters-depth-4">){</span> envv<span class="org-rainbow-delimiters-depth-5">[</span>k.first<span class="org-rainbow-delimiters-depth-5">]</span> = k.second; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">b</span>: bindings<span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>b-&gt;isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
                    <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: ill-formed sytax for let expression. Expected list as binding argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">bb</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>b<span class="org-rainbow-delimiters-depth-5">)</span>-&gt;lst;
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> bb.size<span class="org-rainbow-delimiters-depth-6">()</span> != 2<span class="org-rainbow-delimiters-depth-5">)</span>
                    <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: ill-formed sytax for let expression."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>bb<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isSym<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span> 
                    <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: ill-formed sytax for let expression. Expected symbol."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">sym</span> = bb<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-5">()</span>;
                <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = bb<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>envv<span class="org-rainbow-delimiters-depth-5">)</span>;
                <span class="org-comment-delimiter">// </span><span class="org-comment">Add symbols from let binding to the new temporary environment</span>
                envv<span class="org-rainbow-delimiters-depth-5">[</span>sym<span class="org-rainbow-delimiters-depth-5">]</span> = val;
                envs<span class="org-rainbow-delimiters-depth-5">[</span>sym<span class="org-rainbow-delimiters-depth-5">]</span> = val;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">size_t</span> <span class="org-variable-name">k</span> = 2; k &lt; lst.size<span class="org-rainbow-delimiters-depth-5">()</span> - 1; k ++<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> lst<span class="org-rainbow-delimiters-depth-5">[</span>k<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>envv<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>lst.size<span class="org-rainbow-delimiters-depth-5">()</span> - 1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>envv<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Implement closure - function cature variables from local environment </span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> result-&gt;isFun<span class="org-rainbow-delimiters-depth-5">()</span> 
                &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>-&gt;isNativeFun<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprFunLisp</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>;
                func-&gt;env = envs;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">return</span> result;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">/** </span><span class="org-comment">For-loop similar to common lisp =&gt; (repeat 10 n (action n)) */</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> symbol == <span class="org-string">"repeat"</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lst.size<span class="org-rainbow-delimiters-depth-5">()</span> != 4 <span class="org-rainbow-delimiters-depth-4">)</span> 
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: ill-formed syntax for repeat special form. Expected 4 arguments"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>2<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;isSym<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: ill-formed syntax for repeat special form. Expected symbol."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>n-&gt;isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: expected number as first argument."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">ntimes</span> = <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-4">)</span> n-&gt;numValue<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> ntimes &lt; 0<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: ill-formed syntax for repeat special form . Iterations cannot be negative."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-keyword">auto</span> <span class="org-variable-name">sym</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-4">()</span>;

            <span class="org-keyword">auto</span> <span class="org-variable-name">action</span> = lst<span class="org-rainbow-delimiters-depth-4">[</span>3<span class="org-rainbow-delimiters-depth-4">]</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Copy environment </span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">envv</span> = env;

            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">k</span> = 0; k &lt; ntimes; k++<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                envv<span class="org-rainbow-delimiters-depth-5">[</span>sym<span class="org-rainbow-delimiters-depth-5">]</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>k<span class="org-rainbow-delimiters-depth-5">)</span>;
                action-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>envv<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>


        <span class="org-comment-delimiter">// </span><span class="org-comment">---------- Function Application --------------------//</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = lst<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;eval<span class="org-rainbow-delimiters-depth-3">(</span>env<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>it-&gt;isFun<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error - object not callable."</span><span class="org-rainbow-delimiters-depth-4">)</span>;  <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">function</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>it<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = lst;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element</span>
        args.erase<span class="org-rainbow-delimiters-depth-3">(</span>args.begin<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">evaluatedArgs</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">evaluatedArgs.reserve(args.size());</span>
        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">arg</span> : args<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = arg-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>env<span class="org-rainbow-delimiters-depth-4">)</span>; 
            evaluatedArgs.push_back<span class="org-rainbow-delimiters-depth-4">(</span>res<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = function-&gt;call<span class="org-rainbow-delimiters-depth-3">(</span>evaluatedArgs, env<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Parser </span>
<span class="org-keyword">auto</span> <span class="org-function-name">readTokens</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">tokens</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">auto tokens = tokens_;</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tokens.size<span class="org-rainbow-delimiters-depth-3">()</span> == 0<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: Unexpected EOF - End of File"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = tokens<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>;    
    <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element of vector </span>
    tokens.erase<span class="org-rainbow-delimiters-depth-2">(</span>tokens.begin<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; " [readToken] " &lt;&lt; tok.type &lt;&lt; " ; " &lt;&lt; tok.text </span>
    <span class="org-comment-delimiter">//           </span><span class="org-comment">&lt;&lt; " ; line = " &lt;&lt; tok.lin &lt;&lt; " ; col = " &lt;&lt; tok.col </span>
    <span class="org-comment-delimiter">//           </span><span class="org-comment">&lt;&lt; "\n";</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::ERR <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"[ERROR] "</span> + tok.text<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::QUOTE <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
        lst.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprSym</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"quote"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">next</span> = readTokens<span class="org-rainbow-delimiters-depth-3">(</span>tokens<span class="org-rainbow-delimiters-depth-3">)</span>;
        lst.push_back<span class="org-rainbow-delimiters-depth-3">(</span>next<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::LPAREN  <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;

        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> tokens<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.type != <span class="org-constant">TokenType</span>::RPAREN <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = readTokens<span class="org-rainbow-delimiters-depth-4">(</span>tokens<span class="org-rainbow-delimiters-depth-4">)</span>;
            lst.push_back<span class="org-rainbow-delimiters-depth-4">(</span> expr <span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Drop off ')' right parentheis</span>
        tokens.erase<span class="org-rainbow-delimiters-depth-3">(</span>tokens.begin<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::RPAREN  <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: Unexpected ')' right parenthesis "</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::NUM<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-4">(</span>tok.text<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::SYM &amp;&amp; tok.text == <span class="org-string">"nil"</span> <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::SYM <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprSym</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> tok.text <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::KEYW <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprKey</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> tok.text <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::BOOL <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> tok.text == <span class="org-string">"#t"</span> ? <span class="org-constant">true</span> : <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> tok.type == <span class="org-constant">TokenType</span>::STR <span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprStr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> tok.text <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ExprErr</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>-1, <span class="org-string">"BUG Found =&gt; Edge case found in the parser."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-comment-delimiter">// </span><span class="org-comment">Parse Lisp-like (scheme-like) S-Expression by reading a string source code </span>
<span class="org-keyword">auto</span> <span class="org-function-name">parseSexp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>; 
    ss &lt;&lt; code; 
    <span class="org-type">Tokenizer</span> <span class="org-variable-name">tokenizer</span><span class="org-rainbow-delimiters-depth-2">(</span>ss<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">tokens</span> = tokenizer.readTokens<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = readTokens<span class="org-rainbow-delimiters-depth-2">(</span>tokens<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Parse Lisp-like (scheme-like) S-Expression by reading an input stream </span>
<span class="org-keyword">auto</span> <span class="org-function-name">parseSexp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Tokenizer</span> <span class="org-variable-name">tokenizer</span><span class="org-rainbow-delimiters-depth-2">(</span>is<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">tokens</span> = tokenizer.readTokens<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = readTokens<span class="org-rainbow-delimiters-depth-2">(</span>tokens<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-keyword">class</span> <span class="org-type">PrintVisitor</span>: <span class="org-keyword">public</span> <span class="org-type">IVisitor</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:

    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNil</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"nil"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprStr</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\""</span> &lt;&lt; expr.value &lt;&lt; <span class="org-string">"\""</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNum</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprBool</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>expr.value ? <span class="org-string">"#t"</span> : <span class="org-string">"#f"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprSym</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprKey</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprErr</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"&lt;&lt; [ERROR] "</span> &lt;&lt; expr.info; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprFun</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; expr.strValue<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprLst</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"( "</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">node</span> : expr.lst<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>; node-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" )"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">WriterVisitor</span>: <span class="org-keyword">public</span> <span class="org-type">IVisitor</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">out</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">WriterVisitor</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os_</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">out</span><span class="org-rainbow-delimiters-depth-2">(</span>os_<span class="org-rainbow-delimiters-depth-2">){}</span>

    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNil</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; <span class="org-string">"nil"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprStr</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; <span class="org-string">"\""</span> &lt;&lt; expr.value &lt;&lt; <span class="org-string">"\""</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprNum</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprBool</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>expr.value ? <span class="org-string">"#t"</span> : <span class="org-string">"#f"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprSym</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprKey</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; expr.value; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprErr</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; <span class="org-string">"&lt;&lt; [ERROR] "</span> &lt;&lt; expr.info; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprFun</span>&amp;  <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> out &lt;&lt; expr.strValue<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ExprLst</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">out &lt;&lt; "\n ( ";</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">node</span> : expr.lst<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> 
            out &lt;&lt; <span class="org-string">" "</span>; node-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-comment-delimiter">//</span><span class="org-comment">if( node-&gt;isList() ){ out &lt;&lt; '\n'; }</span>
         <span class="org-rainbow-delimiters-depth-3">}</span>
        out &lt;&lt; <span class="org-string">" )"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Print S-Expression </span>
<span class="org-type">void</span> <span class="org-function-name">printSexp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">IExpr</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">PrintVisitor</span> <span class="org-variable-name">visitor</span>;
    expr.accept<span class="org-rainbow-delimiters-depth-2">(</span>visitor<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-comment-delimiter">/// </span><span class="org-comment">Lisp interpreter's primitive functions </span>
<span class="org-keyword">namespace</span> <span class="org-constant">primitives</span> <span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">All Lisp functions passed to the interpreter must have this type signature </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp function primitive 'list' =&gt; Example: (list 10 20 (+ 1 2 5) "Hello" #f #t nil)</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">list</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>args<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Return the number of elements of alist </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">length</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: length() requires 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: length() expects 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">node</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span> *args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = node.lst;
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>lst.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">//  </span><span class="org-comment">car =&gt; Returns first element of the list or nil </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">car</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: car() requires 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: car() expects 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">node</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span> *args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = node.lst;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0 <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> lst<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">cdr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: cdr() requires 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: cdr() expects 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">node</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span> *args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = node.lst;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0 <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first list argument </span>
        lst.erase<span class="org-rainbow-delimiters-depth-3">(</span>lst.begin<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">cons =&gt; List constructor </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">cons</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 2 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: cons() requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: pairs construction not allowed. Second argument can only be a list or nil."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span>  = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> args<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-4">)</span>-&gt;lst;
            lst.insert<span class="org-rainbow-delimiters-depth-4">(</span>lst.begin<span class="org-rainbow-delimiters-depth-5">()</span>, args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        assert<span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> =  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-3">}</span>;
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>lst<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get the nth element of a list</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">nth</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 2 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: cons() requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: Expected number "</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: Expected list or nil."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">)</span> args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;    
        <span class="org-keyword">auto</span> <span class="org-variable-name">lst</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>-&gt;lst;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n &lt; lst.size<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; n &gt;= 0 <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lst<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">(= 10 20) =&gt; #f ; (= 10 10) =&gt; #t</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">equal_number</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 2 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: = requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: Expected number "</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;    
        <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;    
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>a == b<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">less_than</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 2 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: = requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: Expected number "</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;    
        <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;    
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>a &lt; b<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse a string returning a S-Expression </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">read</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: read() requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> != <span class="org-constant">ExprType</span>::STR <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: read() expects 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span>  = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = parseSexp<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function list? =&gt; Return true if the argument is of type list </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_list</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: list?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function symbol? =&gt; Return true if the argument is of type symbol</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_symbol</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: symbol?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ExprType</span>::SYM <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_keyword</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: keyword?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ExprType</span>::KEY <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function number? =&gt; Return true if the argument is of type number</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_number</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: number?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function boolean? =&gt; Return true if the argument is of type number</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_boolean</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: boolean?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ExprType</span>::BOOL <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function nil? =&gt; Return true if the argument is of type nil</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_nil</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: nil?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate function string? =&gt; Return true if the argument is of type string</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">is_string</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: string?() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprBool</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ExprType</span>::STR <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Display an S-Expression </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">disp</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> != 1 <span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function disp() requires 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-type">PrintVisitor</span> <span class="org-variable-name">visitor</span>;
        args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>visitor<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp function (+) =&gt; Example: (+ 1 2 3 4 5) = 15</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0 <span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: this function requires at least 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span> 
       <span class="org-type">double</span> <span class="org-variable-name">acc</span> = 0.0;
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">a</span>: args<span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">){</span>
               <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid argument. Expected a number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
           <span class="org-rainbow-delimiters-depth-4">}</span>
           acc = acc + a-&gt;numValue<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>acc<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp function (*) =&gt; Example: (* 1 2 3 4 5) = 120</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">mul</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0 <span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: this function requires at least 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span> 
       <span class="org-type">double</span> <span class="org-variable-name">acc</span> = 1.0;
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">a</span>: args<span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">){</span>
               <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid argument. Expected a number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
           <span class="org-rainbow-delimiters-depth-4">}</span>
           acc = acc * a-&gt;numValue<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>acc<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">List function (-) =&gt; Example: (- 100 20 30 ) = 100 - 20 - 30 = 50 </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">sub</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Called Lispfun sub() \n "); </span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: this function requires at least 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: invalid argument type. Expected number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            assert<span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> == <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>-args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: invalid argument type. Expected number"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">double</span> <span class="org-variable-name">acc</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] acc = %f \n", acc);</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">args_</span> = args;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element</span>
        args_.erase<span class="org-rainbow-delimiters-depth-3">(</span>args_.begin<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">a</span> : args_<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid argument. Expected a number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-type">double</span> <span class="org-variable-name">x</span> = a-&gt;numValue<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] x = %f \n", x);</span>
            acc = acc - x; 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>acc<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">div</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Called Lispfun sub() \n "); </span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: this function requires at least 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args.size<span class="org-rainbow-delimiters-depth-4">()</span> == 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: invalid argument type. Expected number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            assert<span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> == <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>1.0 / args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: invalid argument type. Expected number"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">double</span> <span class="org-variable-name">acc</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>-&gt;numValue<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] acc = %f \n", acc);</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">args_</span> = args;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element</span>
        args_.erase<span class="org-rainbow-delimiters-depth-3">(</span>args_.begin<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">a</span> : args_<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid argument. Expected a number"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-type">double</span> <span class="org-variable-name">x</span> = a-&gt;numValue<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] x = %f \n", x);</span>
            acc = acc / x; 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>acc<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Eval</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Reference to itself in oder to provide code completion</span>
    <span class="org-type">Eval</span>&amp; <span class="org-variable-name">self</span> = *<span class="org-keyword">this</span>;

<span class="org-function-name">public</span>:
    <span class="org-keyword">using</span> <span class="org-type">Env</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>; 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp environment </span>
    <span class="org-type">Env</span> <span class="org-variable-name">_env</span>;

    <span class="org-function-name">Eval</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"disp"</span>,    &amp;<span class="org-constant">primitives</span>::disp<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive list functions </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"list"</span>,    &amp;<span class="org-constant">primitives</span>::list<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"length"</span>,  &amp;<span class="org-constant">primitives</span>::length<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"car"</span>,     &amp;<span class="org-constant">primitives</span>::car<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cdr"</span>,     &amp;<span class="org-constant">primitives</span>::cdr<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cons"</span>,    &amp;<span class="org-constant">primitives</span>::cons<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"nth"</span>,     &amp;<span class="org-constant">primitives</span>::nth<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive predicate functions  </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"number?"</span>,  &amp;<span class="org-constant">primitives</span>::is_number<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"boolean?"</span>, &amp;<span class="org-constant">primitives</span>::is_boolean<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"symbol?"</span>,  &amp;<span class="org-constant">primitives</span>::is_symbol<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"nil?"</span>,     &amp;<span class="org-constant">primitives</span>::is_nil<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"keyword?"</span>, &amp;<span class="org-constant">primitives</span>::is_keyword<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"list?"</span>,    &amp;<span class="org-constant">primitives</span>::is_list<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Primtive math functions </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"="</span>,       &amp;<span class="org-constant">primitives</span>::equal_number<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"&lt;"</span>,       &amp;<span class="org-constant">primitives</span>::less_than<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"+"</span>,       &amp;<span class="org-constant">primitives</span>::add<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"*"</span>,       &amp;<span class="org-constant">primitives</span>::mul<span class="org-rainbow-delimiters-depth-3">)</span>; 
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"-"</span>,       &amp;<span class="org-constant">primitives</span>::sub<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"/"</span>,       &amp;<span class="org-constant">primitives</span>::div<span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addMath1ArgFun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"sin"</span>, <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::sin<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addMath1ArgFun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cos"</span>, <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::cos<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addMath1ArgFun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"tan"</span>, <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::tan<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addMath1ArgFun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"sqrt"</span>, <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addMath1ArgFun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"inv"</span>, <span class="org-rainbow-delimiters-depth-4">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> 1.0 / x; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        self.addVariable<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"PI"</span>, 3.1415<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse string into a SExp - S-Expression </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"read"</span>, &amp;<span class="org-constant">primitives</span>::read<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate a List (AST - Abstract Syntax Tree) or SEXP returning a SEXP (S-Expression)</span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"eval"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1 <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: eval(sexp) requires 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: eval(sexpr) expects 1 argument of type list."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-5">&gt;(</span> *args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span> <span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">return</span> expr.eval<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">this</span>-&gt;_env<span class="org-rainbow-delimiters-depth-5">)</span>; 
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">load a file </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"load-file"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1  &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isStr<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: load-file() requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">auto</span> <span class="org-variable-name">file</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-5">()</span>; 
            <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">this</span>-&gt;evalFile<span class="org-rainbow-delimiters-depth-5">(</span>file<span class="org-rainbow-delimiters-depth-5">)</span>; 
            <span class="org-keyword">return</span> expr;
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Read a single S-Expression from file without evaluating it </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"read-file"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1  &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isStr<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: eval(sexp) requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">auto</span> <span class="org-variable-name">file</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-5">()</span>; 
            <span class="org-keyword">auto</span> <span class="org-variable-name">ifs</span>  = <span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-5">(</span>file<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">sexp</span>  = parseSexp<span class="org-rainbow-delimiters-depth-5">(</span>ifs<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">return</span> sexp;
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Write a single S-Expression to a file </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"write-file"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 2  &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isStr<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: eval(sexp) requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">auto</span> <span class="org-variable-name">file</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-5">()</span>; 
            <span class="org-keyword">auto</span> <span class="org-variable-name">ofs</span>  = <span class="org-constant">std</span>::ofstream<span class="org-rainbow-delimiters-depth-5">(</span>file<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-type">WriterVisitor</span> <span class="org-variable-name">visitor</span><span class="org-rainbow-delimiters-depth-5">(</span>ofs<span class="org-rainbow-delimiters-depth-5">)</span>; 
            args<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;accept<span class="org-rainbow-delimiters-depth-5">(</span>visitor<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-5">&gt;()</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Read a multiple S-Expression from file without evaluating it </span>
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"read-file-multiple"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1  &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isStr<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: eval(sexp) requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">auto</span> <span class="org-variable-name">file</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;strValue<span class="org-rainbow-delimiters-depth-5">()</span>; 
            <span class="org-constant">std</span>::<span class="org-type">ifstream</span> <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-5">(</span>file<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>is.good<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: stream has errors."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
            ss &lt;&lt; is.rdbuf<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">code</span> = <span class="org-string">"( \n"</span> +  ss.str<span class="org-rainbow-delimiters-depth-5">()</span> + <span class="org-string">"\n )"</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">sexp</span> = parseSexp<span class="org-rainbow-delimiters-depth-5">(</span>code<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">return</span> sexp;
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;


        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"apply"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 2 <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: apply() requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isFun<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected function as first argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected list as second argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">params</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>; 
            <span class="org-keyword">return</span> func-&gt;call<span class="org-rainbow-delimiters-depth-5">(</span>params-&gt;lst, <span class="org-keyword">this</span>-&gt;_env<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  
        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"map"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 2 <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: apply() requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isFun<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected function as first argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected list as second argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">params</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>; 

            <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;{}</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">args_</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;{</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-6">&gt;()</span> <span class="org-rainbow-delimiters-depth-5">}</span>;
            result.reserve<span class="org-rainbow-delimiters-depth-5">(</span> params-&gt;lst.size<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">p</span>: params-&gt;lst<span class="org-rainbow-delimiters-depth-5">){</span>
                args_<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span> = p; 
                result.push_back<span class="org-rainbow-delimiters-depth-6">(</span> func-&gt;call<span class="org-rainbow-delimiters-depth-7">(</span> args_, <span class="org-keyword">this</span>-&gt;_env <span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-6">)</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>;

        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        self.addFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"for-each"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 2 <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: apply() requires 2 arguments."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isFun<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected function as first argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"Error: expected list as second argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprFun</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">auto</span> <span class="org-variable-name">params</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprLst</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-type">args</span><span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span>; 
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">p</span>: params-&gt;lst<span class="org-rainbow-delimiters-depth-5">){</span> 
                <span class="org-keyword">auto</span> <span class="org-variable-name">args_</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-7">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-7">&gt;</span><span class="org-rainbow-delimiters-depth-6">&gt;{</span> p <span class="org-rainbow-delimiters-depth-6">}</span>;
                func-&gt;call<span class="org-rainbow-delimiters-depth-6">(</span> args_, <span class="org-keyword">this</span>-&gt;_env <span class="org-rainbow-delimiters-depth-6">)</span>; 
            <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ExprNil</span><span class="org-rainbow-delimiters-depth-5">&gt;()</span>;

        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">addVariable</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        _env<span class="org-rainbow-delimiters-depth-3">[</span>name<span class="org-rainbow-delimiters-depth-3">]</span> = expr;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">addVariable</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        _env<span class="org-rainbow-delimiters-depth-3">[</span>name<span class="org-rainbow-delimiters-depth-3">]</span> = expr;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">addFunction</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">LispFunc</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">fn</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprFunNative</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>func<span class="org-rainbow-delimiters-depth-3">)</span>;
        fn-&gt;name = name;
        _env<span class="org-rainbow-delimiters-depth-3">[</span>name<span class="org-rainbow-delimiters-depth-3">]</span> = fn;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Func</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">void</span> <span class="org-function-name">addMath1ArgFun</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">Func</span> <span class="org-variable-name">funcMath</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-rainbow-delimiters-depth-3">[</span>=<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-5">&gt;</span><span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> args.size<span class="org-rainbow-delimiters-depth-5">()</span> != 1<span class="org-rainbow-delimiters-depth-4">){</span>
               <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [ERROR] This function requires exactly one argument."</span><span class="org-rainbow-delimiters-depth-5">)</span>;
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>;
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x-&gt;type<span class="org-rainbow-delimiters-depth-5">()</span> != <span class="org-constant">ExprType</span>::NUM <span class="org-rainbow-delimiters-depth-4">){</span>
               <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [ERROR] Invalid arguument type. Number required. "</span><span class="org-rainbow-delimiters-depth-5">)</span>;
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-type">double</span> <span class="org-variable-name">res</span> = funcMath<span class="org-rainbow-delimiters-depth-4">(</span>x-&gt;numValue<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
           <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ExprNum</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>res<span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>;
       <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ExprFunNative</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>func<span class="org-rainbow-delimiters-depth-3">)</span>;
       val-&gt;name = name;
       _env<span class="org-rainbow-delimiters-depth-3">[</span>name<span class="org-rainbow-delimiters-depth-3">]</span> = val;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IExpr</span>&amp; <span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> expr.eval<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">this</span>-&gt;_env <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Interactive read-print eval loop0 </span>
    <span class="org-type">void</span> <span class="org-function-name">repl</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>; 
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">arg</span>, <span class="org-variable-name">command</span>; 

        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>;;<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" $ lisp&gt;&gt; "</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> line == <span class="org-string">""</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span><span class="org-rainbow-delimiters-depth-4">(</span>line<span class="org-rainbow-delimiters-depth-4">)</span>;
            ss &gt;&gt; command &gt;&gt; arg;
            <span class="org-keyword">try</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> command == <span class="org-string">":file"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-rainbow-delimiters-depth-5">{</span>
                    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>-&gt;evalFile<span class="org-rainbow-delimiters-depth-6">(</span>arg<span class="org-rainbow-delimiters-depth-6">)</span>;
                    <span class="org-keyword">continue</span>;
                <span class="org-rainbow-delimiters-depth-5">}</span>

                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> command == <span class="org-string">":block"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-rainbow-delimiters-depth-5">{</span>
                    <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-6">(</span>stderr, <span class="org-string">" [INFO] Type a multi-line s-expression and type (;;) as the last line when you are done. \n"</span><span class="org-rainbow-delimiters-depth-6">)</span>;
                    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span>;

                    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-6">(</span> line != <span class="org-string">";;"</span> <span class="org-rainbow-delimiters-depth-6">){</span> 
                        <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-7">)</span>;
                        code = code + <span class="org-string">"\n"</span> + line;
                     <span class="org-rainbow-delimiters-depth-6">}</span>
                    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>-&gt;evalCode<span class="org-rainbow-delimiters-depth-6">(</span>code<span class="org-rainbow-delimiters-depth-6">)</span>;
                    self.addVariable<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">"ans"</span>, res<span class="org-rainbow-delimiters-depth-6">)</span>;
                    printSexp<span class="org-rainbow-delimiters-depth-6">(</span>*res<span class="org-rainbow-delimiters-depth-6">)</span>;
                    <span class="org-keyword">continue</span>;

                <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>-&gt;evalCode<span class="org-rainbow-delimiters-depth-5">(</span>line<span class="org-rainbow-delimiters-depth-5">)</span>;
                self.addVariable<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"ans"</span>, res<span class="org-rainbow-delimiters-depth-5">)</span>;
                printSexp<span class="org-rainbow-delimiters-depth-5">(</span>*res<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">exception</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; e.what<span class="org-rainbow-delimiters-depth-5">()</span> &lt;&lt; <span class="org-string">'\n'</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>

        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Eval lisp-like code given as string </span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>  
    <span class="org-function-name">evalCode</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = parseSexp<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = expr-&gt;eval<span class="org-rainbow-delimiters-depth-3">(</span>_env<span class="org-rainbow-delimiters-depth-3">)</span>; 
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IExpr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>  
    <span class="org-function-name">evalFile</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">file</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-type">ifstream</span> <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-3">(</span>file<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>is.good<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: stream has errors."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
        ss &lt;&lt; is.rdbuf<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">code</span> = <span class="org-string">"(begin \n"</span> +  ss.str<span class="org-rainbow-delimiters-depth-3">()</span> + <span class="org-string">"\n )"</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = parseSexp<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = expr-&gt;eval<span class="org-rainbow-delimiters-depth-3">(</span>_env<span class="org-rainbow-delimiters-depth-3">)</span>; 
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Testing "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span> = R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">         ; comment1</span>
<span class="org-string">         ;   comment 2  </span>
<span class="org-string">         ; comment 3 </span>
<span class="org-string">     (  print-&gt;list </span>
<span class="org-string">         ; comment 4</span>
<span class="org-string">          " Hello world" A8 B100</span>
<span class="org-string">          ; Next comment </span>
<span class="org-string">          #t #f </span>
<span class="org-string">             (+  20 30 -200(* 20 -20 x y z 8000)) ) </span>
<span class="org-string">    )</span><span class="org-default">"</span>;

    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
   
<span class="org-preprocessor">    #if</span> 0 
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =========== Tokenizer  ======================== "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    ss &lt;&lt; text; 
    ss &lt;&lt; <span class="org-string">"100"</span>;
    
    <span class="org-type">Tokenizer</span> <span class="org-variable-name">tokenizer</span><span class="org-rainbow-delimiters-depth-2">(</span>ss<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">Token</span> <span class="org-variable-name">tok</span>;
    
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-negation-char">!</span>tok.isEOF<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">){</span>
        tok = tokenizer.nextToken<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; "</span> &lt;&lt; tok.type &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; tok.text 
                  &lt;&lt; <span class="org-string">" ; line = "</span> &lt;&lt; tok.lin &lt;&lt; <span class="org-string">" ; col = "</span> &lt;&lt; tok.col 
                  &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-preprocessor">    #endif</span> 

    <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = parseSexp<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>; 

    <span class="org-constant">std</span>::cout &lt;&lt;  <span class="org-constant">std</span>::boolalpha &lt;&lt; <span class="org-string">" [TRACE] expr-&gt;isList() = "</span> &lt;&lt; expr-&gt;isList<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    printSexp<span class="org-rainbow-delimiters-depth-2">(</span>*expr<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ====== Evaluate Code  ======================== "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">code1</span> = R<span class="org-default">"</span><span class="org-string">( </span>
<span class="org-string">        (list 10 #t #f "hello world" </span>
<span class="org-string">            ; Operation 1</span>
<span class="org-string">            (+ 10 25 6) </span>
<span class="org-string">            ; Operation 2</span>
<span class="org-string">            (* 4 2 6) )</span>
<span class="org-string">     )</span><span class="org-default">"</span>;

    <span class="org-type">Eval</span> <span class="org-variable-name">eval</span>; 

    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = eval.evalCode<span class="org-rainbow-delimiters-depth-2">(</span>code1<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Result = "</span>;
    printSexp<span class="org-rainbow-delimiters-depth-2">(</span>*res<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"============ Start LISP REPL ======================"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    eval.repl<span class="org-rainbow-delimiters-depth-2">()</span>; 


    <span class="org-keyword">return</span> 0;
  <span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>


<p>
Building  the lisp interpreter: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$  g++ cpplisp.cpp -o <span class="org-keyword">cpplisp.bin</span> -g -Wall -Wextra -std=c++1z
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-lisp">$ &gt;&gt; rlwrap ./cpplisp.bin
 [TRACE] Testing 
 [TRACE] expr-&gt;isList() = true
(  print-&gt;list <span class="org-string">" Hello world"</span> A8 B100 #t #f (  + 20 30 -200 (  * 20 -20 x y z 8000 ) ) )
 ====== Evaluate Code  ======================== 
 [TRACE] Result = (  10 #t #f <span class="org-string">"hello world"</span> 41 48 )
============ Start LISP REPL ======================

 $ lisp&gt;&gt; (list '(+ 1 2 3 4 5) (+ 1 2 3 4 5) '(* 4 100) (* 4 100) <span class="org-builtin">:keyword</span> #t #f nil <span class="org-string">"Hello world"</span>)
(  (  + 1 2 3 4 5 ) 15 (  * 4 100 ) 400 <span class="org-builtin">:keyword</span> #t #f nil <span class="org-string">"Hello world"</span> )

 $ lisp&gt;&gt; '(list (+ 1 2 3 4 5) (+ 1 2 3 4 5) '(* 4 100) (* 4 100) <span class="org-builtin">:keyword</span> #t #f nil <span class="org-string">"Hello world"</span>)
(  list (  + 1 2 3 4 5 ) (  + 1 2 3 4 5 ) (  quote (  * 4 100 ) ) (  * 4 100 ) <span class="org-builtin">:keyword</span> #t #f nil <span class="org-string">"Hello world"</span> )

  $ lisp&gt;&gt; (cons 10 20)
<span class="org-function-name">Error</span>: pairs construction not allowed. Second argument can only be a list or nil.

 $ lisp&gt;&gt; (cons 20 nil)
(  20 )

 $ lisp&gt;&gt; (cons 10 (cons 20 nil))
(  10 20 )

 $ lisp&gt;&gt; (cons <span class="org-string">"hello"</span> (cons 10 (cons 20 nil)))
(  <span class="org-string">"hello"</span> 10 20 )
 $ lisp&gt;&gt; 
 $ lisp&gt;&gt; (cons 'world (cons <span class="org-string">"hello"</span> (cons 10 (cons 20 nil))))
(  world <span class="org-string">"hello"</span> 10 20 )

 $ lisp&gt;&gt; (cons <span class="org-builtin">:keyword</span> (cons 'world (cons <span class="org-string">"hello"</span> (cons 10 (cons 20 nil)))))
(  <span class="org-builtin">:keyword</span> world <span class="org-string">"hello"</span> 10 20 )

 $ lisp&gt;&gt; (cons sqrt (cons <span class="org-builtin">:keyword</span> (cons 'world (cons <span class="org-string">"hello"</span> (cons 10 (cons 20 nil))))))
(  (native function) sqrt <span class="org-builtin">:keyword</span> world <span class="org-string">"hello"</span> 10 20 )
 $ lisp&gt;&gt; 

 $ lisp&gt;&gt; (+ 1 2 3 4 5 6)
21
 $ lisp&gt;&gt; (* 1 2 3 4 5 6)
720

 $ lisp&gt;&gt; (list 1 2 3 5 6 7 8)
(  1 2 3 5 6 7 8 )

 $ lisp&gt;&gt; (set x 10)
 [TRACE] Defining symbol = x . 
nil

 $ lisp&gt;&gt; ( (<span class="org-keyword">if</span> (&lt; x  5) + *)  100 20)
2000

 $ lisp&gt;&gt; ( (<span class="org-keyword">if</span> (&lt; x  50) + *)  100 20)
120

$ lisp&gt;&gt; (set code <span class="org-string">"(apply + (list 1 3 4 5 6 7))"</span>)
 [TRACE] Defining symbol = code . 
nil

 $ lisp&gt;&gt; code
<span class="org-string">"(apply + (list 1 3 4 5 6 7))"</span>

 $ lisp&gt;&gt; (set expr (read code))<span class="org-comment">; read SExp - S-Expression from string</span>
 [TRACE] Defining symbol = expr . 
nil
 $ lisp&gt;&gt; expr
(  apply + (  list 1 3 4 5 6 7 ) )

 $ lisp&gt;&gt; (eval expr) <span class="org-comment-delimiter">;; </span><span class="org-comment">Evaluate S-Expression </span>
26

$ lisp&gt;&gt; <span class="org-builtin">:block</span>
 [INFO] Type a multi-line s-expression and type (<span class="org-comment-delimiter">;;</span><span class="org-comment">) as the last line when you are done. </span>
<span class="org-comment-delimiter">; </span><span class="org-comment">Execute a let-binding expression</span>
(<span class="org-keyword">let</span> (
      (a 10)
      (b (+ (* a a) 10))
      (c (sqrt (+ a b)))
     )
   (disp a) (disp b) (disp c)
   (list <span class="org-builtin">:x</span> a <span class="org-builtin">:y</span> b <span class="org-builtin">:result3</span> c <span class="org-builtin">:z</span> (+ a b c)))
<span class="org-comment-delimiter">;;</span>
10
110
10.9545
(  <span class="org-builtin">:x</span> 10 <span class="org-builtin">:y</span> 110 <span class="org-builtin">:result3</span> 10.9545 <span class="org-builtin">:z</span> 130.954 )

 $ lisp&gt;&gt; a
 [ERROR] Unbound variable a

 $ lisp&gt;&gt; b
 [ERROR] Unbound variable b

 $ lisp&gt;&gt; c
 [ERROR] Unbound variable c
 $ lisp&gt;&gt; 

 $ lisp&gt;&gt; (load-file <span class="org-string">"code.lisp"</span>) <span class="org-comment">; Load a lisp file</span>
 [TRACE] Defining symbol = mylist . 
 [TRACE] Defining symbol = code-fact . 
 [TRACE] Defining function = fib . 
 [TRACE] Defining function = make-adder . 
 [TRACE] Defining symbol = add10 . 
 [TRACE] Defining symbol = add50 . 
 [TRACE] Defining symbol = func . 
 [TRACE] Defining function = compute-trig . 
nil
 $ lisp&gt;&gt; 

 $ lisp&gt;&gt; mylist
(  10 #t #f <span class="org-string">"hello world"</span> hello world <span class="org-builtin">:keyword1</span> 41 (  + 10 25 6 ) <span class="org-builtin">:keyword2</span> 48 (  * 4 2 6 ) )

 $ lisp&gt;&gt; (car mylist)
10

 $ lisp&gt;&gt; (cdr mylist)
(  #t #f <span class="org-string">"hello world"</span> hello world <span class="org-builtin">:keyword1</span> 41 (  + 10 25 6 ) <span class="org-builtin">:keyword2</span> 48 (  * 4 2 6 ) )

 $ lisp&gt;&gt; (car (cdr mylist))
#t

$ lisp&gt;&gt; (nth 5 mylist)
world

 $ lisp&gt;&gt; (add10 20)
30

 $ lisp&gt;&gt; (add50 80)
130

 $ lisp&gt;&gt; (map add10 (list 1 2 3 4 5 6 7 ))
(  11 12 13 14 15 16 17 )

 $ lisp&gt;&gt; (map add50 (list 1 2 3 4 5 6 7 ))
(  51 52 53 54 55 56 57 )

 $ lisp&gt;&gt; (map (fn (x) (* x x)) (list 1 2 3 4 5 6 7 )) <span class="org-comment">; Map a lambda</span>
(  1 4 9 16 25 36 49 )

 $ lisp&gt;&gt; (compute-trig 45)
(  <span class="org-builtin">:angle</span> 45 <span class="org-builtin">:cos</span> 0.707123 <span class="org-builtin">:sin</span> 0.70709 <span class="org-builtin">:tan</span> 0.999954 )

 $ lisp&gt;&gt; (compute-trig 90)
(  <span class="org-builtin">:angle</span> 90 <span class="org-builtin">:cos</span> 4.63268e-05 <span class="org-builtin">:sin</span> 1 <span class="org-builtin">:tan</span> 21585.8 )

 $ lisp&gt;&gt; (compute-trig 30)
(  <span class="org-builtin">:angle</span> 30 <span class="org-builtin">:cos</span> 0.866033 <span class="org-builtin">:sin</span> 0.499987 <span class="org-builtin">:tan</span> 0.57733 )

 $ lisp&gt;&gt; (map compute-trig (list 30 90 45))
(  (  <span class="org-builtin">:angle</span> 30 <span class="org-builtin">:cos</span> 0.866033 <span class="org-builtin">:sin</span> 0.499987 <span class="org-builtin">:tan</span> 0.57733 ) (  <span class="org-builtin">:angle</span> 90 <span class="org-builtin">:cos</span> 4.63268e-05 <span class="org-builtin">:sin</span> 1 <span class="org-builtin">:tan</span> 21585.8 ) (  <span class="org-builtin">:angle</span> 45 <span class="org-builtin">:cos</span> 0.707123 <span class="org-builtin">:sin</span> 0.70709 <span class="org-builtin">:tan</span> 0.999954 ) )

 $ lisp&gt;&gt; (func 10)
0.1502

 $ lisp&gt;&gt; (func 1)
0.124383

 $ lisp&gt;&gt; a
 [ERROR] Unbound variable a

 $ lisp&gt;&gt; b
 [ERROR] Unbound variable b

 $ lisp&gt;&gt; c
 [ERROR] Unbound variable c
 $ lisp&gt;&gt; 

 $ lisp&gt;&gt; (for-each disp (list <span class="org-string">"Hello"</span> 'world <span class="org-builtin">:lisp</span> 100 nil #t #f))
<span class="org-string">"Hello"</span>
world
<span class="org-builtin">:lisp</span>
100
nil
#t
#f

$ lisp&gt;&gt; (set make-multiplier-function (fn (mult) (fn (x) (* mult x))))
 [TRACE] Defining symbol = make-multiplier-function . 
nil

 $ lisp&gt;&gt; (set mult-by-10 (make-multiplier-function 10))
 [TRACE] Defining symbol = mult-by-10 . 
nil

 $ lisp&gt;&gt; (set mult-by-6 (make-multiplier-function 6))
 [TRACE] Defining symbol = mult-by-6 . 
nil

 $ lisp&gt;&gt; (map mult-by-10 (list 1 2 3 4 5))
(  10 20 30 40 50 )

 $ lisp&gt;&gt; (map mult-by-6 (list 1 2 3 4 5))
(  6 12 18 24 30 )

 $ lisp&gt;&gt; ( (make-multiplier-functon 4) (list 1 2 3 4 5))
 [ERROR] Unbound variable make-multiplier-functon

 $ lisp&gt;&gt; (map (make-multiplier-function 4) (list 1 2 3 4 5))
(  4 8 12 16 20 )
 $ lisp&gt;&gt; 
</pre>
</div>

<p>
Read file <span class="underline">gui-dsl.lisp</span>: 
</p>

<div class="org-src-container">
<pre class="src src-lisp"> $ lisp&gt;&gt; (set expr (read-file <span class="org-string">"gui-dsl.lisp"</span>))
 [TRACE] Defining symbol = expr . 
nil

 $ lisp&gt;&gt; expr
(  div <span class="org-builtin">:class</span> <span class="org-string">"myclass-csss-style"</span> <span class="org-builtin">:bgcolor</span> <span class="org-string">"#ff81a"</span> (  p <span class="org-string">"Paragraph 1 "</span> ) (  img <span class="org-builtin">:src</span> <span class="org-string">"http://www.mydomain/images/myimage.png"</span> <span class="org-builtin">:caption</span> <span class="org-string">"Image 1 data"</span> ) (  button <span class="org-builtin">:label</span> <span class="org-string">"Submit"</span> <span class="org-builtin">:id</span> <span class="org-string">"btn-submit"</span> <span class="org-builtin">:class</span> <span class="org-string">"my-style-button"</span> <span class="org-builtin">:onclick</span> (  fn (  event ) (  display <span class="org-string">"Button was clicked"</span> ) ) ) )


 $ lisp&gt;&gt; (car expr)
div

 $ lisp&gt;&gt; (car (cdr expr))
<span class="org-builtin">:class</span>

 $ lisp&gt;&gt; (nth 5 expr)
(  p <span class="org-string">"Paragraph 1 "</span> )

 $ lisp&gt;&gt; (car (nth 5 expr))
p

 $ lisp&gt;&gt; (cdr (nth 5 expr))
(  <span class="org-string">"Paragraph 1 "</span> )

 $ lisp&gt;&gt; (car (cdr (nth 5 expr)))
<span class="org-string">"Paragraph 1 "</span>

  $ lisp&gt;&gt; (nth 6 expr)
(  img <span class="org-builtin">:src</span> <span class="org-string">"http://www.mydomain/images/myimage.png"</span> <span class="org-builtin">:caption</span> <span class="org-string">"Image 1 data"</span> )

 $ lisp&gt;&gt; (nth 7 expr)
(  button <span class="org-builtin">:label</span> <span class="org-string">"Submit"</span> <span class="org-builtin">:id</span> <span class="org-string">"btn-submit"</span> <span class="org-builtin">:class</span> <span class="org-string">"my-style-button"</span> <span class="org-builtin">:onclick</span> (  fn (  event ) (  display <span class="org-string">"Button was clicked"</span> ) ) )
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b65050" class="outline-4">
<h4 id="org3b65050"><span class="section-number-4">1.11.3</span> dotted list sexp parser algorithm</h4>
<div class="outline-text-4" id="text-1-11-3">
<p>
In traditional Scheme and Lisp implementations, lists are not
reprsented as vectors or arrays, instead they are represented as
linked list of cons, also called dotted pairs cells. Each cons cell
has two parts.  The first part <span class="underline">car</span> points to another s-expression,
that either can be an atomic element or other cons cell. The second
part of a dotted pair, cons can point to another dotted pair, an empty
list or an atomic element. If the cons of the final dotted pair of a
list points to an empty list (nil in common lisp), the list is said to
be a <span class="underline">proper list</span>. If the dotted pair points to an atomic element, the
list is said to be an <span class="underline">improper list.</span>
</p>


<p>
The terms car, cdr and cons, come from the following abbreviations:
</p>

<ul class="org-ul">
<li>car - comes from 'Contents of the Address part of the Register'</li>

<li>cdr - comes from 'Contents of the Decrement part of the Register'</li>

<li>cons -  abbreviation of the word 'construct'</li>
</ul>

<p>
A single dotted pair (a . b) denoting an association of two atoms
'a' and 'b' can be represented with the following diagram.
</p>

<pre class="example">
(a . b) or (cons a b)

+-----+-----+     
| car | cdr | ---&gt; b
+-----+-----+     
   |              
  \ /             
   a              
</pre>

<p>
According to this dotted-pairs or cons-cell linked lista approach, a
list (a b c) is represented as:
</p>

<pre class="example">
representation 1: (cons a (cons b (cons c nil)))
representation 2: (a . (b . (c . nil)))

+-----+-----+     +-----+-----+     +-----+-----+
| car | cdr | ---&gt;| car | cdr | ---&gt;| car | cdr |---&gt; NIL 
+-----+-----+     +-----+-----|     +-----+-----+     =&gt; Empty list in Scheme '())
   |                 |                 |              =&gt; nil (null pointer) in Common Lisp
  \ /               \ /               \ /
   a                 b                 c

</pre>

<p>
A proper list, such as (a b c d), is terminated in nil as shown in the
following diagram:
</p>

<div class="org-src-container">
<pre class="src src-text">cons(a, cons(b, cons(c, cons(d, nil))) 
(a . (b . (c . (d . nil))))
</pre>
</div>

<p>
An improper list, such as (a b . c), is terminated in a non nil or non
empty-list atom. The next diagram show how this list is represented in
memory.
</p>

<div class="org-src-container">
<pre class="src src-text">cons(a, cons(b, c))
(a . (b . c))

+-----+-----+     +-----+-----+     
| car | cdr | ---&gt;| car | cdr | ---&gt; c
+-----+-----+     +-----+-----|     
   |                 |              
  \ /               \ /             
   a                 b              

</pre>
</div>

<p>
The EBNF grammar of this dotted-pairs linked list can be specified as follow:
</p>

<div class="org-src-container">
<pre class="src src-text">sexp := atom | pair | list 
pair := "(" sexp "." sexp ")"
list := "(" sexp* ")"
atom := NUMBER 
      | SYMBOL 
      | STRING 
      | BOOLEAN 
      | SYMBOL 
      | NULL 
</pre>
</div>

<p>
The AST can be represnted using OCaml algebraic data type notation as:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">type</span> <span class="org-variable-name">sexp</span> = num  of <span class="org-type">int</span>          <span class="org-comment-delimiter">// </span><span class="org-comment">number literal </span>
          | sym of string        <span class="org-comment-delimiter">// </span><span class="org-comment">symbol, identifier or keyword</span>
          | str  of string       <span class="org-comment-delimiter">// </span><span class="org-comment">string literal between quotes ""</span>
          | <span class="org-type">bool</span> of boolean      <span class="org-comment-delimiter">// </span><span class="org-comment">boolean literak #t or #f </span>
          | nil                  <span class="org-comment-delimiter">// </span><span class="org-comment">represents null value </span>
          | cons of sexp * sexp  <span class="org-comment-delimiter">// </span><span class="org-comment">cons cell =&gt; It can represent a null-terminated </span>
</pre>
</div>

<p>
The previous grammar can be parsed using this pascal-like pseudocode:
</p>

<div class="org-src-container">
<pre class="src src-pascal">  <span class="org-comment">//                Token Types                     //</span>
  <span class="org-comment">//------------------------------------------------//</span>
  <span class="org-comment">// Delimiters </span>
  T_LPAR <span class="org-string">"("</span>  <span class="org-comment">// left parenthesis </span>
  T_RPAR <span class="org-string">")"</span>  <span class="org-comment">// right parenthesis</span>
  T_DOT  <span class="org-string">"."</span>  <span class="org-comment">// Dot - found in dotted pair '(a . b)</span>
  T_QUOTE <span class="org-string">"'"</span> <span class="org-comment">// quote (')</span>
  <span class="org-comment">// Literal token types (terminal elements of grammar)</span>
  T_NUM       <span class="org-comment">// number </span>
  T_STR       <span class="org-comment">// string literal "something else"</span>
  T_SYM       <span class="org-comment">// symbol         'my-symbol</span>
  T_NIL       <span class="org-comment">// nil =&gt; null element and empty list </span>
  T_BOOL      <span class="org-comment">// boolean #t (true) or #f (false)</span>
  <span class="org-comment">// Sentinel Token Types </span>
  T_EOF       <span class="org-comment">// End Of File </span>
  T_ERR       <span class="org-comment">// Error </span>
  T_NDF       <span class="org-comment">// Non Defined - non initialized token </span>

<span class="org-comment">// -------------------------------------------------------// </span>


 <span class="org-comment">// Those tokens come from the tokenizer which skips blank characters, white spaces and new lines, and </span>
 <span class="org-comment">// breaks the source code into terminal elements of the grammar. </span>
 tokens := [ Token(T_LPAR, <span class="org-string">"("</span>, Token(T_NUM, <span class="org-string">"-1245.13e3"</span>), Token(T_SYM, <span class="org-string">"x1"</span>)
           ,Token(T_STR, <span class="org-string">"hello world"</span>), Token(T_NIL, <span class="org-string">"nil"</span>), Token(T_BOOL, <span class="org-string">"#f"</span>)
           ,Token(T_BOOL, <span class="org-string">"#t"</span>), Token(T_DOT, <span class="org-string">"."</span>), Token(T_RPAR, <span class="org-string">")"</span>) 
          ] 

<span class="org-comment">// ------- Global Variables ==&gt; They should be contained in an object.</span>
<span class="org-comment">// Current position of cursors           </span>
<span class="org-function-name">index</span> := 0 
<span class="org-comment">// Current token  </span>
<span class="org-function-name">current</span> := Token(T_NDF, <span class="org-string">""</span>)

<span class="org-comment">// Advance to next token  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">advance</span>(): void  
  <span class="org-keyword">IF</span> index &gt;= len(tokens) <span class="org-keyword">THEN</span> 
      RETURN  Token(T_EOF, <span class="org-string">""</span>)
  <span class="org-keyword">END</span>
  current := tokens[index]
  index := index + 1 
<span class="org-keyword">END</span> 

<span class="org-comment">// Check whether the current token type has the same type as the argument </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">check</span>(token_type): bool  
  RETURN current.<span class="org-type">type</span> == token_type 
<span class="org-keyword">END</span> 

<span class="org-comment">// Returns true if the current token matches the expected type and consume it.</span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">match</span>(token_type): bool  
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type <span class="org-keyword">THEN</span> 
     advance()
     RETURN true 
  <span class="org-keyword">END</span> 
  RETURN false 
<span class="org-keyword">END</span> 

<span class="org-comment">// If the current token does not match the expected type, raise an error. </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">expect</span>(token_type)
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type 
     advance() 
  <span class="org-keyword">ELSE</span> 
     error(<span class="org-string">"Expected token "</span>, token_type, <span class="org-string">", but given "</span>, current)
  <span class="org-keyword">END</span> 
<span class="org-keyword">END</span> 

<span class="org-comment">// Return true if the current token is EOF (End Of File)  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">is_eof</span>(): bool 
  RETURN current.<span class="org-type">type</span> == EOF 
<span class="org-keyword">END</span> 

<span class="org-comment">//--------------------------------------------------------//</span>

<span class="org-comment">// Parse Lisp symbolic expression </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_sexp</span>(): Ast 
<span class="org-keyword">BEGIN</span> 
   <span class="org-keyword">IF</span>   token.is_atom() <span class="org-keyword">THEN</span>  
       RETURN parse_atom() 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> match(T_LPAR) <span class="org-keyword">THEN</span> 
       RETURN parse_list() 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> match(T_QUOTE) <span class="org-keyword">THEN</span> 
      q = self.parse_sexp()
      RETURN AstCons( AstSymbol(<span class="org-string">"quote"</span>),  AstCons(q, AstNil() ) )
   <span class="org-keyword">ELSE</span>
       error(<span class="org-string">"Invalid token: "</span>, token_string)
   <span class="org-keyword">END</span>   
<span class="org-keyword">END</span>  


<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_atom</span>(): Ast 
<span class="org-keyword">BEGIN</span> 
   ast := null  
   <span class="org-keyword">IF</span>      check(TOKEN_NUM)  <span class="org-keyword">THEN</span> ast := AstInt(parse_num(lexeme)) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_STR)  <span class="org-keyword">THEN</span> ast := AstStr(lexeme) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_SYM)  <span class="org-keyword">THEN</span> ast := AstSym(lexeme) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_NULL) <span class="org-keyword">THEN</span> ast := AstNil()       <span class="org-keyword">END</span> 
   <span class="org-comment">// If this line runs, it means that there is a bug.</span>
   <span class="org-keyword">ELSE</span> 
      error(<span class="org-string">"parse_atom() =&gt; invalid token: "</span>, token_string)
   <span class="org-keyword">END</span> 
   <span class="org-comment">// Advance token </span>
   advance() 
   RETURN ast 
<span class="org-keyword">END</span> 

<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_list</span>(): Ast 
   <span class="org-keyword">IF</span> match(T_RPAR) <span class="org-keyword">THEN</span> 
      RETURN AstNil()
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> match(T_DOT) <span class="org-keyword">THEN</span> 
      <span class="org-keyword">IF</span> match(T_RPAR) <span class="org-keyword">THEN</span> 
         error(<span class="org-string">"Error: ill-formed dotted list."</span>)
      <span class="org-keyword">END</span>
      element := parse_sexp()
      expect(T_RPAR)  
      RETURN element 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">iF</span> match(T_EOF)  <span class="org-keyword">THEN</span> 
      error(<span class="org-string">"Expected right parenthesis"</span>)
   <span class="org-keyword">END</span>  
   head := parse_sexp()
   tail := pase_list()
   pair := cons(head, tail)   
   RETURN pair 
<span class="org-keyword">END</span>  


<span class="org-comment">//---------- Program entry point - main() --------//</span>
<span class="org-comment">// </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">main</span>(): void 
   <span class="org-comment">// Lexical analysis, break text/source into tokens</span>
   tokens := tokenize(source_code)
   <span class="org-comment">// Initialize parser </span>
   advance()
   <span class="org-comment">// parser AST </span>
   ast    := parse_sexp()
   <span class="org-comment">// Display result</span>
   print(<span class="org-string">" Lisp AST: "</span>, ast)
<span class="org-keyword">END</span> 

</pre>
</div>

<p>
The next code is an executable implementation of the presented parsing
algorithm implemented in Python, but that can be easily translated to
any other programming language.
</p>

<p>
File: <span class="underline">sexp_parser1.py</span>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Any, Callable, Dict, NamedTuple, Optional, List, Tuple


<span class="org-comment-delimiter">#  </span><span class="org-comment">============= &gt;&gt;&gt;&gt; Token types &lt;&lt;&lt;&lt;===================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Literals -------------------------------------------------</span>
<span class="org-variable-name">T_INT</span>   = <span class="org-string">"T_INT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Integer:  1002 -245  9025</span>
<span class="org-variable-name">T_FLT</span>   = <span class="org-string">"T_FLT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Floating point number: -10.2522 9.25221 .0252e3 102.5E3</span>
<span class="org-variable-name">T_STR</span>   = <span class="org-string">"T_STR"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">String literal: "world"</span>
<span class="org-variable-name">T_SYM</span>   = <span class="org-string">"T_SYM"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Symbol: 'hello </span>
<span class="org-variable-name">T_NIL</span>   = <span class="org-string">"T_NIL"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Nil element or end of list </span>
<span class="org-variable-name">T_BOOL</span>  = <span class="org-string">"T_BOOL"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Boolean: #f or #t </span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Delimiters -----------------------------------------------</span>
<span class="org-variable-name">T_LPAR</span>  = <span class="org-string">"T_LPAR"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">left parenthesis </span>
<span class="org-variable-name">T_RPAR</span>  = <span class="org-string">"T_RPAR"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">right parenthesis </span>
<span class="org-variable-name">T_DOT</span>   = <span class="org-string">"T_DOT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">dot '.'</span>
<span class="org-variable-name">T_QUOTE</span> = <span class="org-string">"T_QUOTE"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">quote (')</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Sentinel tokens ---------------------------------------</span>
<span class="org-variable-name">T_NDF</span>   = <span class="org-string">"T_NDF"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Non defined, non initialized sentinel token </span>
<span class="org-variable-name">T_EOF</span>   = <span class="org-string">"T_EOF"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">End of file sentinel token </span>


<span class="org-keyword">class</span> <span class="org-type">Token</span>(NamedTuple):
    <span class="org-builtin">type</span>:   <span class="org-builtin">str</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token type </span>
    text:   <span class="org-builtin">str</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token text, also known as lexeme </span>
    pos:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token position </span>
    col:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token column - starts with 1 </span>
    lin:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token line  - starts with 1 </span>

<span class="org-variable-name">TOKEN_EOF</span> = Token(T_EOF, <span class="org-string">""</span>, 0, 0, 0)
<span class="org-variable-name">NULLCHAR</span> = <span class="org-string">'\0'</span>

<span class="org-keyword">class</span> <span class="org-type">Tokenizer</span>:

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, source: <span class="org-builtin">str</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Source code to be tokenized</span>
        <span class="org-keyword">self</span>._source = source
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current position of cursor </span>
        <span class="org-keyword">self</span>._pos = 0 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current line of cursor </span>
        <span class="org-keyword">self</span>._lin = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current column of cursor </span>
        <span class="org-keyword">self</span>._col = 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Position of first token character  </span>
        <span class="org-keyword">self</span>._token_pos = 0 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Column of first token character </span>
        <span class="org-keyword">self</span>._token_col = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Line of first token chracter </span>
        <span class="org-keyword">self</span>._token_lin = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current character </span>
        <span class="org-keyword">self</span>._chr = <span class="org-string">''</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current token </span>
        <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">advance</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._source):
            <span class="org-keyword">self</span>._chr = <span class="org-string">'\0'</span>
            <span class="org-keyword">return</span> 
        <span class="org-keyword">self</span>._chr = <span class="org-keyword">self</span>._source[<span class="org-keyword">self</span>._pos]
        <span class="org-keyword">self</span>._col += 1
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr == <span class="org-string">'\n'</span>:
            <span class="org-keyword">self</span>._lin += 1
            <span class="org-keyword">self</span>._col = 1
        <span class="org-keyword">self</span>._pos += 1

    <span class="org-keyword">def</span> <span class="org-function-name">is_eof</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if character is end of input"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr == NULLCHAR

    <span class="org-keyword">def</span> <span class="org-function-name">has_next</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:
        <span class="org-doc">"""Return true if tokenizer has next token"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof()

    <span class="org-keyword">def</span> <span class="org-function-name">is_space</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current character is space or blank character. """</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr.isspace()

    <span class="org-keyword">def</span> <span class="org-function-name">is_digit</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current character is digit."""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr.isdigit()

    <span class="org-keyword">def</span> <span class="org-function-name">is_delimiter</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr <span class="org-keyword">in</span> [<span class="org-string">"("</span>, <span class="org-string">")"</span>, <span class="org-string">"."</span>, <span class="org-string">"'"</span>]

    <span class="org-keyword">def</span> <span class="org-function-name">check</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr == <span class="org-builtin">chr</span> 

    <span class="org-keyword">def</span> <span class="org-function-name">peek</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return current character"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr

    <span class="org-keyword">def</span> <span class="org-function-name">lookahead</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span> = 1):
        <span class="org-doc">"""Returns next character in the stream without consuming it"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos + n &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._source):
            <span class="org-keyword">return</span> NULLCHAR
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._source[<span class="org-keyword">self</span>._pos + n - 1]

    <span class="org-keyword">def</span> <span class="org-function-name">expect</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr  == <span class="org-builtin">chr</span>:
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> 
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(f<span class="org-string">"Expected character {chr}, but given {self._chr}."</span>)
    
    <span class="org-keyword">def</span> <span class="org-function-name">match</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr == <span class="org-builtin">chr</span>: 
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> <span class="org-constant">True</span> 
        <span class="org-keyword">return</span> <span class="org-constant">False</span>

    <span class="org-keyword">def</span> <span class="org-function-name">next</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-doc">"""Return next token"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.is_eof(): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_EOF, <span class="org-string">""</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Skip whitespace </span>
        <span class="org-keyword">self</span>._skip_whitespace()
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">if</span>   <span class="org-keyword">self</span>.match(<span class="org-string">"("</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_LPAR, <span class="org-string">"("</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">")"</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_RPAR, <span class="org-string">")"</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">"."</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_DOT, <span class="org-string">"."</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">"'"</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_QUOTE, <span class="org-string">"'"</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.check(<span class="org-string">'-'</span>) <span class="org-keyword">and</span> <span class="org-keyword">self</span>.lookahead().isdigit(): 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_number()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.is_digit():  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_number()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.check(<span class="org-string">"\""</span>): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_string()
        <span class="org-keyword">else</span>:                  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_symbol_or_bool()

    <span class="org-keyword">def</span> <span class="org-function-name">tokens</span>(<span class="org-keyword">self</span>) -&gt; List[Token]:
        <span class="org-variable-name">lst</span> = []
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof():
            <span class="org-variable-name">t</span> = <span class="org-keyword">self</span>.<span class="org-builtin">next</span>()
            <span class="org-keyword">if</span> t.<span class="org-builtin">type</span> == T_EOF: <span class="org-keyword">break</span>
            lst.append(t)
        <span class="org-keyword">return</span> lst

    <span class="org-keyword">def</span> <span class="org-function-name">set_token_position</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Store position of beginning of token until this function is called again."""</span>
        <span class="org-keyword">self</span>._token_pos = <span class="org-keyword">self</span>._pos - 1
        <span class="org-keyword">self</span>._token_col = <span class="org-keyword">self</span>._col - 1
        <span class="org-keyword">self</span>._token_lin = <span class="org-keyword">self</span>._lin

    <span class="org-keyword">def</span> <span class="org-function-name">_skip_whitespace</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">while</span> <span class="org-keyword">self</span>.is_space() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof(): 
            <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">_token</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>, lexeme: <span class="org-builtin">str</span>) -&gt; Token:
        <span class="org-keyword">return</span> Token(<span class="org-builtin">type</span>, lexeme
                    ,<span class="org-keyword">self</span>._token_pos
                    ,<span class="org-keyword">self</span>._token_col
                    ,<span class="org-keyword">self</span>._token_lin)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_symbol_or_bool</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_space() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_delimiter():
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">if</span> lexeme == <span class="org-string">""</span>: 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_EOF, <span class="org-string">""</span>)
        <span class="org-keyword">if</span> lexeme == <span class="org-string">"#t"</span> <span class="org-keyword">or</span> lexeme == <span class="org-string">"#f"</span>: 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_BOOL, lexeme)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_SYM, lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_number</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-comment-delimiter"># </span><span class="org-comment">In grammars where '-' negative sign is not part of literal</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">remove the next line </span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"-"</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'.'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>._next_integer() 
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'.'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'e'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'E'</span>):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.peek().isalpha():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid number, cannot end with letter"</span>) 
            <span class="org-comment-delimiter"># </span><span class="org-comment">Identified integer type </span>
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_INT, lexeme)
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'.'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"."</span> + <span class="org-keyword">self</span>._next_integer()
        <span class="org-variable-name">letter</span> = <span class="org-keyword">self</span>.peek()
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'e'</span>) <span class="org-keyword">or</span> <span class="org-keyword">self</span>.match(<span class="org-string">'E'</span>):
            <span class="org-variable-name">lexeme</span> += letter
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_digit():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid floating point number: "</span> + lexeme)
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"-"</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_digit():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid floating point number. Expected digit, but got: "</span> + lexeme)
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>._next_integer()
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.peek().isalpha():
            <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid number, it cannot end with letter"</span>) 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return a lexeme (string representation) of a floating point number literal </span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_FLT, lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_integer</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">assert</span> <span class="org-keyword">self</span>.is_digit()
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">while</span> <span class="org-keyword">self</span>.is_digit() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof():
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">return</span> lexeme

    <span class="org-keyword">def</span> <span class="org-function-name">_next_string</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-keyword">self</span>.expect(<span class="org-string">'"'</span>)
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'"'</span>):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'\\'</span>):
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'n'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\n"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'t'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\t"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'v'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\v"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'"'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\""</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'\\'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\\"</span>; <span class="org-keyword">continue</span>
                  <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Tokenizer error, invalid escape character: '"</span> + <span class="org-keyword">self</span>._ch + <span class="org-string">"'"</span>)
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">self</span>.expect(<span class="org-string">'"'</span>)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_STR, lexeme)


<span class="org-variable-name">EXPR_CONS</span> = <span class="org-string">"EXPR_CONS"</span>
<span class="org-variable-name">EXPR_NIL</span>  = <span class="org-string">"EXPR_NIL"</span>
<span class="org-variable-name">EXPR_BOOL</span> = <span class="org-string">"EXPR_BOOL"</span>
<span class="org-variable-name">EXPR_STR</span>  = <span class="org-string">"EXPR_STR"</span>
<span class="org-variable-name">EXPR_SYM</span>  = <span class="org-string">"EXPR_SYM"</span>
<span class="org-variable-name">EXPR_NUM</span>  = <span class="org-string">"EXPR_NUM"</span>
<span class="org-variable-name">EXPR_ERR</span>  = <span class="org-string">"EXPR_ERR"</span>

<span class="org-keyword">class</span> <span class="org-type">Expr</span>:
    <span class="org-doc">"""Reprsents a S-Expression symbolic expression LISP linked list."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:    <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">str</span>:    <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:    <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_num</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">float</span>:  <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_pair</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_nil</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_num</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_bool</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_err</span>(sefl)  -&gt; <span class="org-builtin">bool</span>:   <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">car</span>(<span class="org-keyword">self</span>)     -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented"</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">cdr</span>(<span class="org-keyword">self</span>)     -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented"</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>.to_repr()

<span class="org-keyword">class</span> <span class="org-type">ExprNil</span>(Expr):
    <span class="org-doc">"""This AST node represents an empty list or null element."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_nil</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-string">"nil"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-string">"nil"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_NIL 

<span class="org-keyword">class</span> <span class="org-type">ExprCons</span>(Expr):
    <span class="org-doc">"""AST node represents a cons cell."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_CONS
    <span class="org-keyword">def</span> <span class="org-function-name">is_pair</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, car: Expr, cdr: Expr) -&gt; <span class="org-constant">None</span>:
        <span class="org-keyword">self</span>._car = car 
        <span class="org-keyword">self</span>._cdr = cdr 
    <span class="org-keyword">def</span> <span class="org-function-name">car</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._car 
    <span class="org-keyword">def</span> <span class="org-function-name">cdr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._cdr 
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-variable-name">head</span> = <span class="org-keyword">self</span>._car.to_repr()
        <span class="org-variable-name">tail</span> = <span class="org-keyword">self</span>._cdr.to_repr()
        <span class="org-keyword">return</span> f<span class="org-string">"cons({head}, {tail})"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.to_repr() 
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_CONS
        
<span class="org-keyword">class</span> <span class="org-type">ExprSym</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp symbol."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-string">"'"</span> + <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_SYM

<span class="org-keyword">class</span> <span class="org-type">ExprNum</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp number."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">int</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-builtin">str</span>(<span class="org-keyword">self</span>._value)
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-builtin">str</span>(<span class="org-keyword">self</span>._value)
    <span class="org-keyword">def</span> <span class="org-function-name">to_num</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">float</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_NUM 


<span class="org-keyword">class</span> <span class="org-type">ExprStr</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp symbol."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span>  <span class="org-string">'"'</span> + <span class="org-keyword">self</span>._value +  <span class="org-string">'"'</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_STR

<span class="org-keyword">class</span> <span class="org-type">ExprBool</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp boolean value."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">bool</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_bool</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span>  <span class="org-string">"#t"</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._value <span class="org-keyword">else</span> <span class="org-string">"#f"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span>  <span class="org-string">"#t"</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._value <span class="org-keyword">else</span> <span class="org-string">"#f"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_BOOL

<span class="org-keyword">class</span> <span class="org-type">ExprErr</span>(Expr):
    <span class="org-doc">"""AST node represents a runtime error value (not an AST value)."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_err</span>(sefl)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span> <span class="org-string">"err =&gt; "</span> + <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>): <span class="org-keyword">return</span>  <span class="org-keyword">self</span>._value
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_ERR 


<span class="org-keyword">class</span> <span class="org-type">Parser</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, source: <span class="org-builtin">str</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-keyword">self</span>._source = source 
        <span class="org-variable-name">tok</span> = Tokenizer(source)
        <span class="org-keyword">self</span>._tokens = tok.tokens() 
        <span class="org-keyword">self</span>._pos = 0 
        <span class="org-keyword">self</span>._current = Token(T_NDF, <span class="org-string">""</span>, 0, 0, 0)
        <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">peek</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current

    <span class="org-keyword">def</span> <span class="org-function-name">lookahead</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span> = 1):
        <span class="org-doc">"""Returns next character in the stream without consuming it"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos + n &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tokens):
            <span class="org-keyword">return</span> Token(T_EOF, 0, 0, 0, 0)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._tokens[<span class="org-keyword">self</span>._pos + n - 1]

    <span class="org-keyword">def</span> <span class="org-function-name">advance</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Advance to next token"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tokens):
            <span class="org-keyword">self</span>._current = Token(T_EOF, 0, 0, 0, 0)
            <span class="org-keyword">return</span> 
        <span class="org-keyword">self</span>._current = <span class="org-keyword">self</span>._tokens[<span class="org-keyword">self</span>._pos]
        <span class="org-keyword">self</span>._pos += 1

    <span class="org-keyword">def</span> <span class="org-function-name">match</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Returns true if the current token matches the expected type and consume it."""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == <span class="org-builtin">type</span>: 
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> <span class="org-constant">True</span> 
        <span class="org-keyword">return</span> <span class="org-constant">False</span>

    <span class="org-keyword">def</span> <span class="org-function-name">check</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Returns true if the current token matches the expected type and consume it."""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current == <span class="org-builtin">type</span> 
    
    <span class="org-keyword">def</span> <span class="org-function-name">expect</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Consume current token if it matches the expected type. Otherwise raise an error."""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == <span class="org-builtin">type</span>:
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> 
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(f<span class="org-string">"Expected token of type {type}, but given {self._current}."</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">is_eof</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current token is T_EOF"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == T_EOF

    <span class="org-comment-delimiter"># </span><span class="org-comment">------- End of reusable parser code ---------------_#</span>

    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current token is atom"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.peek().<span class="org-builtin">type</span> <span class="org-keyword">in</span> [ T_BOOL, T_FLT, T_INT, T_SYM, T_NIL, T_STR ]

    <span class="org-keyword">def</span> <span class="org-function-name">parse_sexp</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.is_atom():        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.parse_atom()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_LPAR):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>.parse_list()
        <span class="org-comment-delimiter"># </span><span class="org-comment">'x is parsed as(quote x)</span>
        <span class="org-comment-delimiter">#  </span><span class="org-comment">'(+ x 10) is parsed as (quote (+ x 10))</span>
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_QUOTE): 
            <span class="org-variable-name">q</span> = <span class="org-keyword">self</span>.parse_sexp()
            <span class="org-keyword">return</span> ExprCons(ExprSym(<span class="org-string">"quote"</span>), ExprCons(q, ExprNil()))
        <span class="org-keyword">else</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Invalid token: "</span> + <span class="org-builtin">str</span>(<span class="org-keyword">self</span>.peek()))

    <span class="org-keyword">def</span> <span class="org-function-name">parse_atom</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-variable-name">lexeme</span> = <span class="org-keyword">self</span>.peek().text
        <span class="org-keyword">if</span>   <span class="org-keyword">self</span>.match(T_INT):  <span class="org-keyword">return</span> ExprNum(<span class="org-builtin">float</span>(lexeme))
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_FLT):  <span class="org-keyword">return</span> ExprNum(<span class="org-builtin">float</span>(lexeme))
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_STR):  <span class="org-keyword">return</span> ExprStr(lexeme)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_SYM):  <span class="org-keyword">return</span> ExprSym(lexeme)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_BOOL): <span class="org-keyword">return</span> ExprBool(lexeme == <span class="org-string">"#t"</span>)
        <span class="org-keyword">else</span>: 
            <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Invalid token: "</span> + lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">parse_list</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-comment-delimiter"># </span><span class="org-comment">self.expect(T_LPAR)</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(T_RPAR):
            <span class="org-keyword">return</span> ExprNil()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_DOT):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(T_RPAR):
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Ill-formed dotted list."</span>)
            <span class="org-variable-name">elem</span> = <span class="org-keyword">self</span>.parse_sexp()
            <span class="org-keyword">self</span>.expect(T_RPAR)
            <span class="org-keyword">return</span> elem 
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_EOF):
            <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Expected right parenthesis"</span>)
        <span class="org-variable-name">car</span> = <span class="org-keyword">self</span>.parse_sexp()
        <span class="org-variable-name">cdr</span> = <span class="org-keyword">self</span>.parse_list()
        <span class="org-variable-name">ast</span> = ExprCons(car, cdr)
        <span class="org-keyword">return</span> ast 


<span class="org-keyword">def</span> <span class="org-function-name">sexp_parse</span>(source: <span class="org-builtin">str</span>) -&gt; Expr:
    <span class="org-variable-name">p</span> = Parser(source)
    <span class="org-keyword">return</span> p.parse_sexp()


<span class="org-keyword">def</span> <span class="org-function-name">sexp_equal</span>(lhs: Expr, rhs: Expr) -&gt; <span class="org-builtin">bool</span>:
    <span class="org-doc">"""Determine whether two S-Expressions are equal"""</span>
    <span class="org-keyword">if</span> lhs.<span class="org-builtin">type</span>() != rhs.<span class="org-builtin">type</span>():
        <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">elif</span> lhs.is_atom() <span class="org-keyword">and</span> rhs.is_atom():
        <span class="org-keyword">if</span>   lhs.is_num():   <span class="org-keyword">return</span> lhs.to_num() == rhs.to_num()
        <span class="org-keyword">elif</span> lhs.is_str():   <span class="org-keyword">return</span> lhs.to_str() == rhs.to_str()
        <span class="org-keyword">elif</span> lhs.is_sym():   <span class="org-keyword">return</span> lhs.to_str() == rhs.to_str()
        <span class="org-keyword">elif</span> lhs.is_bool():  <span class="org-keyword">return</span> lhs._value == rhs._value 
        <span class="org-keyword">elif</span> lhs.is_nil():   <span class="org-keyword">return</span> <span class="org-constant">True</span>
        <span class="org-keyword">else</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: edge case =&gt; code has bugs. "</span>)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">t</span> = sexp_equal(lhs.car(), rhs.car())
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> t: <span class="org-keyword">return</span> <span class="org-constant">False</span>
        <span class="org-variable-name">k</span> = sexp_equal(lhs.cdr(), rhs.cdr())
        <span class="org-keyword">return</span> k 

<span class="org-keyword">def</span> <span class="org-function-name">sexp_to_str</span>(sexp: Expr) -&gt; Expr:
    <span class="org-doc">"""Pretty printer of S-Expression"""</span>
    <span class="org-comment-delimiter">## </span><span class="org-comment">import pdb; pdb.set_trace()</span>
    <span class="org-keyword">if</span> sexp.is_str(): 
        <span class="org-keyword">return</span> sexp.to_repr()
    <span class="org-keyword">elif</span> sexp.is_atom(): 
        <span class="org-keyword">return</span> sexp.to_str()
    <span class="org-keyword">elif</span> sexp.is_pair():
        <span class="org-variable-name">s</span> = sexp 
        <span class="org-variable-name">text</span> = <span class="org-string">"("</span> 
        <span class="org-keyword">while</span> s.is_pair():
            <span class="org-variable-name">head</span> = s.car()
            <span class="org-variable-name">s</span> = s.cdr()
            <span class="org-variable-name">text</span> = text + <span class="org-string">" "</span> + sexp_to_str(head) 
        <span class="org-keyword">if</span> s.is_nil():
            <span class="org-variable-name">text</span> = text + <span class="org-string">")"</span>
        <span class="org-keyword">elif</span> s.is_atom():
            <span class="org-variable-name">text</span> = text + <span class="org-string">" . "</span> + s.to_str() + <span class="org-string">" )"</span>
        <span class="org-keyword">else</span>:
            <span class="org-type">RuntimeError</span>(<span class="org-string">"Edge case =&gt; this branch is impossible to happen."</span>)
        <span class="org-keyword">return</span> text 
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented for this Ast element: "</span> + sexp)



<span class="org-keyword">def</span> <span class="org-function-name">test_expr1</span>():
    <span class="org-doc">"""unit test of SEXP parser."""</span>
    <span class="org-variable-name">src</span> =  <span class="org-string">' ( 9.214 "world" a . end )'</span> 
    <span class="org-variable-name">expected</span> = ExprCons(ExprNum(9.214), 
                    ExprCons(ExprStr(<span class="org-string">"world"</span>), 
                      ExprCons(  ExprSym(<span class="org-string">'a'</span>), ExprSym(<span class="org-string">"end"</span>))) )
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-keyword">assert</span> sexp_equal(ast, expected)

<span class="org-keyword">def</span> <span class="org-function-name">test_expr2</span>():
    <span class="org-doc">"""Test in-meory AST representation of sexp"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">'( "hello world" (100 a . b) x1  z )'</span>
    <span class="org-variable-name">expected</span> = ExprCons( ExprStr(<span class="org-string">"hello world"</span>)
                          , ExprCons(  ExprCons(ExprNum(100.0), ExprCons(ExprSym(<span class="org-string">"a"</span>), ExprSym(<span class="org-string">"b"</span>)))
                            , ExprCons(ExprSym(<span class="org-string">"x1"</span>)
                               , ExprCons(ExprSym(<span class="org-string">"z"</span>),  ExprNil())))
                          )
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-keyword">assert</span> sexp_equal(ast, expected)

<span class="org-keyword">def</span> <span class="org-function-name">test_expr3</span>():
    <span class="org-doc">"""Test  quote quoted expression"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">' \'(+ x y z)'</span>
    <span class="org-variable-name">lst</span> =  ExprCons( ExprSym(<span class="org-string">"+"</span>) , ExprCons(ExprSym(<span class="org-string">"x"</span>), ExprCons(ExprSym(<span class="org-string">"y"</span>), ExprCons( ExprSym(<span class="org-string">"z"</span>), ExprNil()))))
    <span class="org-variable-name">expected</span> = ExprCons( ExprSym(<span class="org-string">"quote"</span>), ExprCons(lst, ExprNil()))
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-keyword">assert</span> sexp_equal(ast, expected)

<span class="org-keyword">def</span> <span class="org-function-name">test_expr4</span>():
    <span class="org-doc">"""Test  quoted expression"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">' \'(+ x y z)'</span>
    <span class="org-variable-name">expected</span> =  <span class="org-string">"cons('quote, cons(cons('+, cons('x, cons('y, cons('z, nil)))), nil))"</span>  
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-keyword">assert</span> <span class="org-builtin">str</span>(ast) == expected

<span class="org-keyword">def</span> <span class="org-function-name">test_exrp5</span>():
    <span class="org-doc">"""Test string representation of sexp"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">' \'(+ x y z)'</span>
    <span class="org-variable-name">s</span> = sexp_parse(src)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pretty print representation of SEXP</span>
    <span class="org-variable-name">p</span> = sexp_to_str(s)
    <span class="org-variable-name">expected</span> = <span class="org-string">'( quote ( + x y z))'</span> 
    <span class="org-keyword">assert</span> p == expected 

<span class="org-keyword">def</span> <span class="org-function-name">test_expr6</span>():
    <span class="org-variable-name">src</span> = <span class="org-string">""" (fn  myfunction(x y . lst)</span>
<span class="org-string">            (print x)</span>
<span class="org-string">            (print y)</span>
<span class="org-string">            (map print lst)</span>
<span class="org-string">           )</span>
<span class="org-string">     """</span>
    <span class="org-variable-name">expected</span> = <span class="org-string">'( fn myfunction ( x y . lst ) ( print x) ( print y) ( map print lst))'</span> 
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Pretty print representation of SEXP</span>
    <span class="org-variable-name">p</span> = sexp_to_str(ast)
    <span class="org-keyword">assert</span> p == expected
</pre>
</div>

<p>
Run unit tests:
</p>

<div class="org-src-container">
<pre class="src src-python"> $  pytest -q -v -rA sexp_parser1.py
============================================== test session starts ==============================================
platform linux -- Python 3.8.10, pytest-7.3.1, pluggy-1.0.0
<span class="org-function-name">rootdir</span>: /home/user/formula-parser
<span class="org-function-name">plugins</span>: anyio-3.5.0, xonsh-0.13.3
collected 6 items                                                                                               

sexp_parser1.py ......                                                                                    [100%]

==================================================== PASSES =====================================================
============================================ short test summary info ============================================
PASSED sexp_parser1.py::test_expr1
PASSED sexp_parser1.py::test_expr2
PASSED sexp_parser1.py::test_expr3
PASSED sexp_parser1.py::test_expr4
PASSED sexp_parser1.py::test_exrp5
PASSED sexp_parser1.py::test_expr6
=============================================== 6 passed <span class="org-keyword">in</span> 0.04s ===============================================
</pre>
</div>

<p>
Interact with the parser in the REPL:
</p>

<div class="org-src-container">
<pre class="src src-python">$ python3 -i sexp_parser1.py 

<span class="org-variable-name">src</span> =  <span class="org-string">""" ( a  x-&gt;1  </span>
<span class="org-string">                "My string literal"</span>
<span class="org-string">                (m1 . w ) </span>
<span class="org-string">                     (1.25 -9.251e3 0.255 nil)  </span>
<span class="org-string">                        z2-&gt;w .  object:method  )  """</span>

<span class="org-variable-name">ast</span> = sexp_parse(src)

&gt;&gt;&gt; ast
cons(<span class="org-string">'a, cons('</span>x-&gt;1, cons(<span class="org-string">"My string literal"</span>, cons(cons(<span class="org-string">'m1, '</span>w), cons(cons(1.25, cons(-9251.0, cons(0.255, cons(<span class="org-string">'nil, nil)))), cons('</span>z2-&gt;w, <span class="org-string">'object:method))))))</span>

<span class="org-string">&gt;&gt;&gt; ast.car()</span>
<span class="org-string">'</span>a

&gt;&gt;&gt; ast.cdr()
cons(<span class="org-string">'x-&gt;1, cons("My string literal", cons(cons('</span>m1, <span class="org-string">'w), cons(cons(1.25, cons(-9251.0, cons(0.255, cons('</span>nil, nil)))), cons(<span class="org-string">'z2-&gt;w, '</span><span class="org-builtin">object</span>:method)))))

&gt;&gt;&gt; ast.cdr().cdr()
cons(<span class="org-string">"My string literal"</span>, cons(cons(<span class="org-string">'m1, '</span>w), cons(cons(1.25, cons(-9251.0, cons(0.255, cons(<span class="org-string">'nil, nil)))), cons('</span>z2-&gt;w, <span class="org-string">'object:method))))</span>

<span class="org-string">&gt;&gt;&gt; ast.cdr().cdr().cdr()</span>
<span class="org-string">cons(cons('</span>m1, <span class="org-string">'w), cons(cons(1.25, cons(-9251.0, cons(0.255, cons('</span>nil, nil)))), cons(<span class="org-string">'z2-&gt;w, '</span><span class="org-builtin">object</span>:method)))

&gt;&gt;&gt; sexp_to_str(ast)
<span class="org-string">'( a x-&gt;1 "My string literal" ( m1 . w ) ( 1.25 -9251.0 0.255 nil) z2-&gt;w . object:method )'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr())
<span class="org-string">'( x-&gt;1 "My string literal" ( m1 . w ) ( 1.25 -9251.0 0.255 nil) z2-&gt;w . object:method )'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr().cdr())
<span class="org-string">'( "My string literal" ( m1 . w ) ( 1.25 -9251.0 0.255 nil) z2-&gt;w . object:method )'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr().cdr().cdr())
<span class="org-string">'( ( m1 . w ) ( 1.25 -9251.0 0.255 nil) z2-&gt;w . object:method )'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr().cdr().cdr().car())
<span class="org-string">'( m1 . w )'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr().cdr().cdr().car().car())
<span class="org-string">'m1'</span>

&gt;&gt;&gt; sexp_to_str(ast.cdr().cdr().cdr().car().cdr())
<span class="org-string">'w'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb472bae" class="outline-4">
<h4 id="orgb472bae"><span class="section-number-4">1.11.4</span> sexp parser algorithm without dotted list</h4>
<div class="outline-text-4" id="text-1-11-4">
<p>
Besides the dotted-pair approach that represents S-expressions as
linked lists of cons cells, S-expresions can also be represented by
nested lists or arrays. This approach is more suitable for data
exchange and serialization. Other advantage is the easier and quickier
implementation of a lisp-like embedded scripting languages hosted in a
garbage collected statically typed languages such as Java or
C#. Unlike the dotted-pair AST - abstract syntax tree, this type of AST
cannot represent improper lists.
</p>


<p>
EBNF for Lisp/Scheme Sexp S-Expression without cons pairs linked list:
</p>

<div class="org-src-container">
<pre class="src src-text">sexp := atom | list 
list := "(" sexp* ")"
atom := NUMBER | BOOLEAN | SYMBOL | STRING | KEYWORD
</pre>
</div>

<p>
Pascal-like pseudocde for S-expression parser implementation:
</p>

<div class="org-src-container">
<pre class="src src-pascal">  <span class="org-comment">//                Token Types                     //</span>
  <span class="org-comment">//------------------------------------------------//</span>
  <span class="org-comment">// Delimiters </span>
  T_LPAR <span class="org-string">"("</span>  <span class="org-comment">// left parenthesis </span>
  T_RPAR <span class="org-string">")"</span>  <span class="org-comment">// right parenthesis</span>
  T_DOT  <span class="org-string">"."</span>  <span class="org-comment">// Dot - found in dotted pair '(a . b)</span>
  T_QUOTE <span class="org-string">"'"</span> <span class="org-comment">// Quote </span>
  <span class="org-comment">// Literal token types (terminal elements of grammar)</span>
  T_NUM       <span class="org-comment">// number </span>
  T_STR       <span class="org-comment">// string literal "something else"</span>
  T_SYM       <span class="org-comment">// symbol         'my-symbol</span>
  T_NIL       <span class="org-comment">// nil =&gt; null element and empty list </span>
  T_BOOL      <span class="org-comment">// boolean #t (true) or #f (false)</span>
  <span class="org-comment">// Sentinel Token Types </span>
  T_EOF       <span class="org-comment">// End Of File </span>
  T_ERR       <span class="org-comment">// Error </span>
  T_NDF       <span class="org-comment">// Non Defined - non initialized token </span>

<span class="org-comment">// -------------------------------------------------------// </span>


 <span class="org-comment">// Those tokens come from the tokenizer which skips blank characters, white spaces and new lines, and </span>
 <span class="org-comment">// breaks the source code into terminal elements of the grammar. </span>
 tokens := [ Token(T_LPAR, <span class="org-string">"("</span>, Token(T_NUM, <span class="org-string">"-1245.13e3"</span>), Token(T_SYM, <span class="org-string">"x1"</span>)
           ,Token(T_STR, <span class="org-string">"hello world"</span>), Token(T_NIL, <span class="org-string">"nil"</span>), Token(T_BOOL, <span class="org-string">"#f"</span>)
           ,Token(T_BOOL, <span class="org-string">"#t"</span>), Token(T_DOT, <span class="org-string">"."</span>), Token(T_RPAR, <span class="org-string">")"</span>) 
          ] 

<span class="org-comment">// ------- Global Variables ==&gt; They should be contained in an object.</span>
<span class="org-comment">// Current position of cursors           </span>
<span class="org-function-name">index</span> := 0 
<span class="org-comment">// Current token  </span>
<span class="org-function-name">current</span> := Token(T_NDF, <span class="org-string">""</span>)

<span class="org-comment">// Advance to next token  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">advance</span>(): void  
  <span class="org-keyword">IF</span> index &gt;= len(tokens) <span class="org-keyword">THEN</span> 
      RETURN  Token(T_EOF, <span class="org-string">""</span>)
  <span class="org-keyword">END</span>
  current := tokens[index]
  index := index + 1 
<span class="org-keyword">END</span> 

<span class="org-comment">// Check whether the current token type has the same type as the argument </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">check</span>(token_type): bool  
  RETURN current.<span class="org-type">type</span> == token_type 
<span class="org-keyword">END</span> 

<span class="org-comment">// Returns true if the current token matches the expected type and consume it.</span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">match</span>(token_type): bool  
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type <span class="org-keyword">THEN</span> 
     advance()
     RETURN true 
  <span class="org-keyword">END</span> 
  RETURN false 
<span class="org-keyword">END</span> 

<span class="org-comment">// If the current token does not match the expected type, raise an error. </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">expect</span>(token_type)
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type 
     advance() 
  <span class="org-keyword">ELSE</span> 
     error(<span class="org-string">"Expected token "</span>, token_type, <span class="org-string">", but given "</span>, current)
  <span class="org-keyword">END</span> 
<span class="org-keyword">END</span> 

<span class="org-comment">// Return true if the current token is EOF (End Of File)  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">is_eof</span>(): bool 
  RETURN current.<span class="org-type">type</span> == EOF 
<span class="org-keyword">END</span> 

<span class="org-comment">//--------------------------------------------------------//</span>

<span class="org-comment">// Algebraic data types in languages like OCaml or Scala; </span>
<span class="org-comment">// or class hierarchy in languages like Java</span>
Ast is root class 
  -&gt; AstNum(val: int)     <span class="org-comment">// number value </span>
  -&gt; AstStr(val: str)     <span class="org-comment">// string value  </span>
  -&gt; AstSym(val: str)     <span class="org-comment">// symbol value </span>
  -&gt; AstBool(val: bool)   <span class="org-comment">// #t (true) or #f (false)</span>
  -&gt; AstNil()             <span class="org-comment">// nil </span>
  -&gt; AstList(val: [Ast]]  <span class="org-comment">// List instead of a cons cell </span>
  -&gt; AstErr(val: str)     <span class="org-comment">// Represents parser error or runtime error </span>


<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_sexp</span>(): Ast
<span class="org-keyword">BEGIN</span>
   <span class="org-keyword">IF</span> check(T_LPAR) <span class="org-keyword">THEN</span> 
      RETURN parse_list() 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> is_atom(token) <span class="org-keyword">THEN</span> 
      RETURN parse_atom()
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(QUOTE)  <span class="org-keyword">THEN</span> 
      sexp := parse_sexp()
      RETURN AstList([ AStSym(<span class="org-string">"quote"</span>), sexp])
   <span class="org-keyword">ELSE</span> 
   error(<span class="org-string">"Invalid token"</span>)
<span class="org-keyword">END</span> 

<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_atom</span>(): Ast 
<span class="org-keyword">BEGIN</span> 
   ast := null  
   <span class="org-comment">// Lexeme is that string that a tokens represents </span>
   <span class="org-keyword">IF</span>      check(TOKEN_NUM)  <span class="org-keyword">THEN</span> ast := AstInt(parse_num(lexeme)) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_STR)  <span class="org-keyword">THEN</span> ast := AstStr(lexeme) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_SYM)  <span class="org-keyword">THEN</span> ast := AstSym(lexeme) <span class="org-keyword">END</span> 
   <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(TOKEN_NULL) <span class="org-keyword">THEN</span> ast := AstNil()       <span class="org-keyword">END</span> 
   <span class="org-comment">// If this line runs, it means that there is a bug.</span>
   <span class="org-keyword">ELSE</span> 
      error(<span class="org-string">"parse_atom() =&gt; invalid token: "</span>, token_string)
   <span class="org-keyword">END</span> 
   <span class="org-comment">// Advance token </span>
   advance() 
   RETURN ast 
<span class="org-keyword">END</span> 

<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parse_list</span>(): Ast 
   expect(T_LPAR)
   list: [Ast] = []
   <span class="org-keyword">WHILE</span> <span class="org-keyword">NOT</span> check(T_RPAR) <span class="org-keyword">and</span> <span class="org-keyword">NOT</span> is_eof() <span class="org-keyword">THEN</span> 
       sexp = parse_sexp() 
       ASSERT sexp != error
       append_to_list(list, sexp)
   <span class="org-keyword">END</span> 
   expect(T_RPAR)
   RETURN list
<span class="org-keyword">END</span>  


<span class="org-comment">//---------- Program entry point - main() --------//</span>
<span class="org-comment">// </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">main</span>(): void 
   <span class="org-comment">// Lexical analysis, break text/source into tokens</span>
   tokens := tokenize(source_code)
   <span class="org-comment">// Initialize parser </span>
   advance()
   <span class="org-comment">// parser AST </span>
   ast    := parse_sexp()
   <span class="org-comment">// Display result</span>
   print(<span class="org-string">" Lisp AST: "</span>, ast)
<span class="org-keyword">END</span> 
</pre>
</div>

<p>
Parser algorithm implementation in Python:
</p>

<p>
File: <span class="underline">sexp_parser2.py</span>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> tokenize <span class="org-keyword">import</span> Double
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Any, Callable, Dict, NamedTuple, Optional, List, Tuple


<span class="org-comment-delimiter">#  </span><span class="org-comment">============= &gt;&gt;&gt;&gt; Token types &lt;&lt;&lt;&lt;===================</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Literals -------------------------------------------------</span>
<span class="org-variable-name">T_INT</span>   = <span class="org-string">"T_INT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Integer:  1002 -245  9025</span>
<span class="org-variable-name">T_FLT</span>   = <span class="org-string">"T_FLT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Floating point number: -10.2522 9.25221 .0252e3 102.5E3</span>
<span class="org-variable-name">T_STR</span>   = <span class="org-string">"T_STR"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">String literal: "world"</span>
<span class="org-variable-name">T_SYM</span>   = <span class="org-string">"T_SYM"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Symbol: 'hello </span>
<span class="org-variable-name">T_NIL</span>   = <span class="org-string">"T_NIL"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Nil element or end of list </span>
<span class="org-variable-name">T_BOOL</span>  = <span class="org-string">"T_BOOL"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">Boolean: #f or #t </span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Delimiters -----------------------------------------------</span>
<span class="org-variable-name">T_LPAR</span>  = <span class="org-string">"T_LPAR"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">left parenthesis </span>
<span class="org-variable-name">T_RPAR</span>  = <span class="org-string">"T_RPAR"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">right parenthesis </span>
<span class="org-variable-name">T_DOT</span>   = <span class="org-string">"T_DOT"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">dot '.'</span>
<span class="org-variable-name">T_QUOTE</span> = <span class="org-string">"T_QUOTE"</span> <span class="org-comment-delimiter"># </span><span class="org-comment">quote (')</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--- Sentinel tokens ---------------------------------------</span>
<span class="org-variable-name">T_NDF</span>   = <span class="org-string">"T_NDF"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Non defined, non initialized sentinel token </span>
<span class="org-variable-name">T_EOF</span>   = <span class="org-string">"T_EOF"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">End of file sentinel token </span>


<span class="org-keyword">class</span> <span class="org-type">Token</span>(NamedTuple):
    <span class="org-builtin">type</span>:   <span class="org-builtin">str</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token type </span>
    text:   <span class="org-builtin">str</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token text, also known as lexeme </span>
    pos:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token position </span>
    col:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token column - starts with 1 </span>
    lin:    <span class="org-builtin">int</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Token line  - starts with 1 </span>

<span class="org-variable-name">TOKEN_EOF</span> = Token(T_EOF, <span class="org-string">""</span>, 0, 0, 0)
<span class="org-variable-name">NULLCHAR</span> = <span class="org-string">'\0'</span>

<span class="org-keyword">class</span> <span class="org-type">Tokenizer</span>:

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, source: <span class="org-builtin">str</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">Source code to be tokenized</span>
        <span class="org-keyword">self</span>._source = source
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current position of cursor </span>
        <span class="org-keyword">self</span>._pos = 0 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current line of cursor </span>
        <span class="org-keyword">self</span>._lin = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current column of cursor </span>
        <span class="org-keyword">self</span>._col = 1
        <span class="org-comment-delimiter"># </span><span class="org-comment">Position of first token character  </span>
        <span class="org-keyword">self</span>._token_pos = 0 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Column of first token character </span>
        <span class="org-keyword">self</span>._token_col = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Line of first token chracter </span>
        <span class="org-keyword">self</span>._token_lin = 1 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current character </span>
        <span class="org-keyword">self</span>._chr = <span class="org-string">''</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Current token </span>
        <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">advance</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._source):
            <span class="org-keyword">self</span>._chr = <span class="org-string">'\0'</span>
            <span class="org-keyword">return</span> 
        <span class="org-keyword">self</span>._chr = <span class="org-keyword">self</span>._source[<span class="org-keyword">self</span>._pos]
        <span class="org-keyword">self</span>._col += 1
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr == <span class="org-string">'\n'</span>:
            <span class="org-keyword">self</span>._lin += 1
            <span class="org-keyword">self</span>._col = 1
        <span class="org-keyword">self</span>._pos += 1

    <span class="org-keyword">def</span> <span class="org-function-name">is_eof</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if character is end of input"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr == NULLCHAR

    <span class="org-keyword">def</span> <span class="org-function-name">has_next</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:
        <span class="org-doc">"""Return true if tokenizer has next token"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof()

    <span class="org-keyword">def</span> <span class="org-function-name">is_space</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current character is space or blank character. """</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr.isspace()

    <span class="org-keyword">def</span> <span class="org-function-name">is_digit</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current character is digit."""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr.isdigit()

    <span class="org-keyword">def</span> <span class="org-function-name">is_delimiter</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr <span class="org-keyword">in</span> [<span class="org-string">"("</span>, <span class="org-string">")"</span>, <span class="org-string">"."</span>, <span class="org-string">"'"</span>]

    <span class="org-keyword">def</span> <span class="org-function-name">check</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr == <span class="org-builtin">chr</span> 

    <span class="org-keyword">def</span> <span class="org-function-name">peek</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return current character"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._chr

    <span class="org-keyword">def</span> <span class="org-function-name">lookahead</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span> = 1):
        <span class="org-doc">"""Returns next character in the stream without consuming it"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos + n &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._source):
            <span class="org-keyword">return</span> NULLCHAR
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._source[<span class="org-keyword">self</span>._pos + n - 1]

    <span class="org-keyword">def</span> <span class="org-function-name">expect</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr  == <span class="org-builtin">chr</span>:
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> 
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(f<span class="org-string">"Expected character {chr}, but given {self._chr}."</span>)
    
    <span class="org-keyword">def</span> <span class="org-function-name">match</span>(<span class="org-keyword">self</span>, <span class="org-builtin">chr</span>: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._chr == <span class="org-builtin">chr</span>: 
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> <span class="org-constant">True</span> 
        <span class="org-keyword">return</span> <span class="org-constant">False</span>

    <span class="org-keyword">def</span> <span class="org-function-name">next</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-doc">"""Return next token"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.is_eof(): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_EOF, <span class="org-string">""</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Skip whitespace </span>
        <span class="org-keyword">self</span>._skip_whitespace()
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">if</span>   <span class="org-keyword">self</span>.match(<span class="org-string">"("</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_LPAR, <span class="org-string">"("</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">")"</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_RPAR, <span class="org-string">")"</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">"."</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_DOT, <span class="org-string">"."</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(<span class="org-string">"'"</span>):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_QUOTE, <span class="org-string">"'"</span>)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.check(<span class="org-string">'-'</span>) <span class="org-keyword">and</span> <span class="org-keyword">self</span>.lookahead().isdigit(): 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_number()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.is_digit():  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_number()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.check(<span class="org-string">"\""</span>): <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_string()
        <span class="org-keyword">else</span>:                  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._next_symbol_or_bool()

    <span class="org-keyword">def</span> <span class="org-function-name">tokens</span>(<span class="org-keyword">self</span>) -&gt; List[Token]:
        <span class="org-variable-name">lst</span> = []
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof():
            <span class="org-variable-name">t</span> = <span class="org-keyword">self</span>.<span class="org-builtin">next</span>()
            <span class="org-keyword">if</span> t.<span class="org-builtin">type</span> == T_EOF: <span class="org-keyword">break</span>
            lst.append(t)
        <span class="org-keyword">return</span> lst

    <span class="org-keyword">def</span> <span class="org-function-name">set_token_position</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Store position of beginning of token until this function is called again."""</span>
        <span class="org-keyword">self</span>._token_pos = <span class="org-keyword">self</span>._pos - 1
        <span class="org-keyword">self</span>._token_col = <span class="org-keyword">self</span>._col - 1
        <span class="org-keyword">self</span>._token_lin = <span class="org-keyword">self</span>._lin

    <span class="org-keyword">def</span> <span class="org-function-name">_skip_whitespace</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">while</span> <span class="org-keyword">self</span>.is_space() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof(): 
            <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">_token</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>, lexeme: <span class="org-builtin">str</span>) -&gt; Token:
        <span class="org-keyword">return</span> Token(<span class="org-builtin">type</span>, lexeme
                    ,<span class="org-keyword">self</span>._token_pos
                    ,<span class="org-keyword">self</span>._token_col
                    ,<span class="org-keyword">self</span>._token_lin)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_symbol_or_bool</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_space() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_delimiter():
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">if</span> lexeme == <span class="org-string">""</span>: 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_EOF, <span class="org-string">""</span>)
        <span class="org-keyword">if</span> lexeme == <span class="org-string">"#t"</span> <span class="org-keyword">or</span> lexeme == <span class="org-string">"#f"</span>: 
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_BOOL, lexeme)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_SYM, lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_number</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-comment-delimiter"># </span><span class="org-comment">In grammars where '-' negative sign is not part of literal</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">remove the next line </span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"-"</span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'.'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>._next_integer() 
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'.'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'e'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'E'</span>):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.peek().isalpha():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid number, cannot end with letter"</span>) 
            <span class="org-comment-delimiter"># </span><span class="org-comment">Identified integer type </span>
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_INT, lexeme)
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'.'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"."</span> + <span class="org-keyword">self</span>._next_integer()
        <span class="org-variable-name">letter</span> = <span class="org-keyword">self</span>.peek()
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'e'</span>) <span class="org-keyword">or</span> <span class="org-keyword">self</span>.match(<span class="org-string">'E'</span>):
            <span class="org-variable-name">lexeme</span> += letter
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_digit():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid floating point number: "</span> + lexeme)
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'-'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"-"</span>
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_digit():
                <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid floating point number. Expected digit, but got: "</span> + lexeme)
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>._next_integer()
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.peek().isalpha():
            <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error: invalid number, it cannot end with letter"</span>) 
        <span class="org-comment-delimiter"># </span><span class="org-comment">Return a lexeme (string representation) of a floating point number literal </span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_FLT, lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">_next_integer</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">assert</span> <span class="org-keyword">self</span>.is_digit()
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">while</span> <span class="org-keyword">self</span>.is_digit() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof():
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">return</span> lexeme

    <span class="org-keyword">def</span> <span class="org-function-name">_next_string</span>(<span class="org-keyword">self</span>) -&gt; Token:
        <span class="org-keyword">self</span>.expect(<span class="org-string">'"'</span>)
        <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">self</span>.set_token_position()
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof() <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(<span class="org-string">'"'</span>):
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'\\'</span>):
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'n'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\n"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'t'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\t"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'v'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\v"</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'"'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\""</span>; <span class="org-keyword">continue</span> 
                  <span class="org-keyword">if</span> <span class="org-keyword">self</span>.match(<span class="org-string">'\\'</span>): <span class="org-variable-name">lexeme</span> += <span class="org-string">"\\"</span>; <span class="org-keyword">continue</span>
                  <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Tokenizer error, invalid escape character: '"</span> + <span class="org-keyword">self</span>._ch + <span class="org-string">"'"</span>)
            <span class="org-variable-name">lexeme</span> += <span class="org-keyword">self</span>.peek()
            <span class="org-keyword">self</span>.advance()
        <span class="org-keyword">self</span>.expect(<span class="org-string">'"'</span>)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._token(T_STR, lexeme)


<span class="org-variable-name">EXPR_LIST</span> = <span class="org-string">"EXPR_LIST"</span>
<span class="org-variable-name">EXPR_NIL</span>  = <span class="org-string">"EXPR_NIL"</span>
<span class="org-variable-name">EXPR_BOOL</span> = <span class="org-string">"EXPR_BOOL"</span>
<span class="org-variable-name">EXPR_STR</span>  = <span class="org-string">"EXPR_STR"</span>
<span class="org-variable-name">EXPR_SYM</span>  = <span class="org-string">"EXPR_SYM"</span>
<span class="org-variable-name">EXPR_NUM</span>  = <span class="org-string">"EXPR_NUM"</span>
<span class="org-variable-name">EXPR_ERR</span>  = <span class="org-string">"EXPR_ERR"</span>

<span class="org-keyword">class</span> <span class="org-type">Expr</span>:
    <span class="org-doc">"""Reprsents a S-Expression, Lisp symbolic expression (but not linked list)"""</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Get Representation showing object type, for instance Sym[x] if x is a symbol</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Num[10], Str["my string"]</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:        <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Get S-Expression representation </span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">str</span>:        <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:        <span class="org-keyword">return</span> <span class="org-string">"&lt;NOT IMPLEMENTED&gt;"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_num</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">float</span>:      <span class="org-keyword">return</span> 0.0
    <span class="org-keyword">def</span> <span class="org-function-name">to_bool</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:      <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Attempt to convert AST node to string</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:         <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented."</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return nth element of expr list  </span>
    <span class="org-keyword">def</span> <span class="org-function-name">nth</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span>) -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not valid for this type"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Return nodes of a ExprList, but this method is only valid for this type </span>
    <span class="org-keyword">def</span> <span class="org-function-name">nodes</span>(<span class="org-keyword">self</span>) -&gt; List[<span class="org-string">'Expr'</span>]: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Method only valid for ExprList"</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_list</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_nil</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_num</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_bool</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">is_err</span>(sefl)  -&gt; <span class="org-builtin">bool</span>:       <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">def</span> <span class="org-function-name">car</span>(<span class="org-keyword">self</span>)     -&gt; <span class="org-string">'Expr'</span>:     <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented"</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">cdr</span>(<span class="org-keyword">self</span>)     -&gt; <span class="org-string">'Expr'</span>:     <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Not implemented"</span>)
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>.to_repr()

<span class="org-keyword">class</span> <span class="org-type">ExprNil</span>(Expr):
    <span class="org-doc">"""This AST node represents an empty list or null element."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_nil</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-string">"nil"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> <span class="org-string">"nil"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_NIL 
    <span class="org-keyword">def</span> <span class="org-function-name">to_bool</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:      <span class="org-keyword">return</span> <span class="org-constant">False</span>

<span class="org-keyword">class</span> <span class="org-type">ExprList</span>(Expr):
    <span class="org-doc">"""AST node represents a list."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_LIST
    <span class="org-keyword">def</span> <span class="org-function-name">is_list</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, nodes: List[Expr]) -&gt; <span class="org-constant">None</span>:
       <span class="org-keyword">self</span>._nodes = nodes  
        
    <span class="org-keyword">def</span> <span class="org-function-name">car</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._car 
    <span class="org-keyword">def</span> <span class="org-function-name">cdr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-string">'Expr'</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._cdr 

    <span class="org-keyword">def</span> <span class="org-function-name">nth</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span>) -&gt; <span class="org-string">'Expr'</span>: 
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._nodes[n]

    <span class="org-keyword">def</span> <span class="org-function-name">nodes</span>(<span class="org-keyword">self</span>) -&gt; List[Expr]:
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._nodes

    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-variable-name">nodes</span> = <span class="org-string">", "</span>.join([ n.to_repr() <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-keyword">self</span>._nodes ])
        <span class="org-keyword">return</span> f<span class="org-string">"List[ {nodes} ]"</span>

    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-variable-name">nodes</span> = <span class="org-string">" "</span>.join([ n.to_sexp() <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-keyword">self</span>._nodes ])
        <span class="org-keyword">return</span> f<span class="org-string">"({nodes})"</span>

    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>: <span class="org-keyword">return</span> EXPR_LIST
        
<span class="org-keyword">class</span> <span class="org-type">ExprSym</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp symbol."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span> f<span class="org-string">"Sym[{self._value}]"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:   <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:  <span class="org-keyword">return</span> EXPR_SYM

<span class="org-keyword">class</span> <span class="org-type">ExprNum</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp number."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">int</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:  <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_sym</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:  <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>):          <span class="org-keyword">return</span> f<span class="org-string">"Num[{self._value}]"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>):           <span class="org-keyword">return</span> <span class="org-builtin">str</span>(<span class="org-keyword">self</span>._value)
    <span class="org-keyword">def</span> <span class="org-function-name">is_num</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>:  <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_num</span>(<span class="org-keyword">self</span>) -&gt;  <span class="org-builtin">float</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:    <span class="org-keyword">return</span> <span class="org-builtin">str</span>(<span class="org-keyword">self</span>._value)
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:   <span class="org-keyword">return</span> EXPR_NUM 


<span class="org-keyword">class</span> <span class="org-type">ExprStr</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp symbol."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span>  <span class="org-string">'Str["'</span> + <span class="org-keyword">self</span>._value +  <span class="org-string">'"]'</span> 
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span> <span class="org-string">'"'</span> + <span class="org-keyword">self</span>._value + <span class="org-string">'"'</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:   <span class="org-keyword">return</span> <span class="org-builtin">str</span>(<span class="org-keyword">self</span>._value)
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:  <span class="org-keyword">return</span> EXPR_STR

<span class="org-keyword">class</span> <span class="org-type">ExprBool</span>(Expr):
    <span class="org-doc">"""AST node represents a lisp boolean value."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">bool</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:  <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_bool</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>:  <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>):          <span class="org-keyword">return</span>  <span class="org-string">"Bool["</span> + (<span class="org-string">"#t"</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._value <span class="org-keyword">else</span> <span class="org-string">"#f"</span>) + <span class="org-string">"]"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>):          <span class="org-keyword">return</span>  <span class="org-string">"#t"</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._value <span class="org-keyword">else</span> <span class="org-string">"#f"</span>
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:   <span class="org-keyword">return</span> EXPR_BOOL
    <span class="org-keyword">def</span> <span class="org-function-name">to_bool</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:    <span class="org-keyword">return</span> <span class="org-string">"#t"</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._value <span class="org-keyword">else</span> <span class="org-string">"#f"</span>

<span class="org-keyword">class</span> <span class="org-type">ExprErr</span>(Expr):
    <span class="org-doc">"""AST node represents a runtime error value (not an AST value)."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, value: <span class="org-builtin">str</span>): <span class="org-keyword">self</span>._value = value 
    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">is_err</span>(sefl)  -&gt; <span class="org-builtin">bool</span>: <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">def</span> <span class="org-function-name">to_repr</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span> <span class="org-string">"err =&gt; "</span> + <span class="org-keyword">self</span>._value 
    <span class="org-keyword">def</span> <span class="org-function-name">to_sexp</span>(<span class="org-keyword">self</span>):         <span class="org-keyword">return</span>  <span class="org-keyword">self</span>._value
    <span class="org-keyword">def</span> <span class="org-function-name">type</span>(<span class="org-keyword">self</span>)    -&gt; <span class="org-builtin">str</span>:  <span class="org-keyword">return</span> EXPR_ERR 
    <span class="org-keyword">def</span> <span class="org-function-name">to_str</span>(<span class="org-keyword">self</span>)  -&gt; <span class="org-builtin">str</span>:  <span class="org-keyword">return</span> <span class="org-keyword">self</span>._value 


<span class="org-keyword">class</span> <span class="org-type">Parser</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, source: <span class="org-builtin">str</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-keyword">self</span>._source = source 
        <span class="org-variable-name">tok</span> = Tokenizer(source)
        <span class="org-keyword">self</span>._tokens = tok.tokens() 
        <span class="org-keyword">self</span>._pos = 0 
        <span class="org-keyword">self</span>._current = Token(T_NDF, <span class="org-string">""</span>, 0, 0, 0)
        <span class="org-keyword">self</span>.advance()

    <span class="org-keyword">def</span> <span class="org-function-name">peek</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current

    <span class="org-keyword">def</span> <span class="org-function-name">lookahead</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span> = 1):
        <span class="org-doc">"""Returns next character in the stream without consuming it"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos + n &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tokens):
            <span class="org-keyword">return</span> Token(T_EOF, 0, 0, 0, 0)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._tokens[<span class="org-keyword">self</span>._pos + n - 1]

    <span class="org-keyword">def</span> <span class="org-function-name">advance</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Advance to next token"""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._pos &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tokens):
            <span class="org-keyword">self</span>._current = Token(T_EOF, 0, 0, 0, 0)
            <span class="org-keyword">return</span> 
        <span class="org-keyword">self</span>._current = <span class="org-keyword">self</span>._tokens[<span class="org-keyword">self</span>._pos]
        <span class="org-keyword">self</span>._pos += 1

    <span class="org-keyword">def</span> <span class="org-function-name">match</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Returns true if the current token matches the expected type and consume it."""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == <span class="org-builtin">type</span>: 
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> <span class="org-constant">True</span> 
        <span class="org-keyword">return</span> <span class="org-constant">False</span>

    <span class="org-keyword">def</span> <span class="org-function-name">check</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Returns true if the current token matches the expected type and consume it."""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == <span class="org-builtin">type</span> 
    
    <span class="org-keyword">def</span> <span class="org-function-name">expect</span>(<span class="org-keyword">self</span>, <span class="org-builtin">type</span>: <span class="org-builtin">str</span>):
        <span class="org-doc">"""Consume current token if it matches the expected type. Otherwise raise an error."""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == <span class="org-builtin">type</span>:
            <span class="org-keyword">self</span>.advance()
            <span class="org-keyword">return</span> 
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(f<span class="org-string">"Expected token of type {type}, but given {self._current}."</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">is_eof</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current token is T_EOF"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._current.<span class="org-builtin">type</span> == T_EOF

    <span class="org-comment-delimiter"># </span><span class="org-comment">------- End of reusable parser code ---------------_#</span>

    <span class="org-keyword">def</span> <span class="org-function-name">is_atom</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""Return true if current token is atom"""</span>
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.peek().<span class="org-builtin">type</span> <span class="org-keyword">in</span> [ T_BOOL, T_FLT, T_INT, T_SYM, T_NIL, T_STR ]

    <span class="org-keyword">def</span> <span class="org-function-name">parse_sexp</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-keyword">if</span>   <span class="org-keyword">self</span>.is_atom():      <span class="org-keyword">return</span> <span class="org-keyword">self</span>.parse_atom()
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.check(T_LPAR):  <span class="org-keyword">return</span> <span class="org-keyword">self</span>.parse_list()
        <span class="org-comment-delimiter"># </span><span class="org-comment">'x is parsed as(quote x)</span>
        <span class="org-comment-delimiter">#  </span><span class="org-comment">'(+ x 10) is parsed as (quote (+ x 10))</span>
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_QUOTE): 
            <span class="org-variable-name">q</span> = <span class="org-keyword">self</span>.parse_sexp()
            <span class="org-keyword">return</span> ExprList([ExprSym(<span class="org-string">"quote"</span>),  q]) 
        <span class="org-keyword">else</span>: <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Invalid token: "</span> + <span class="org-builtin">str</span>(<span class="org-keyword">self</span>.peek()))

    <span class="org-keyword">def</span> <span class="org-function-name">parse_atom</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-variable-name">lexeme</span> = <span class="org-keyword">self</span>.peek().text
        <span class="org-keyword">if</span>   <span class="org-keyword">self</span>.match(T_INT):  <span class="org-keyword">return</span> ExprNum(<span class="org-builtin">float</span>(lexeme))
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_FLT):  <span class="org-keyword">return</span> ExprNum(<span class="org-builtin">float</span>(lexeme))
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_STR):  <span class="org-keyword">return</span> ExprStr(lexeme)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_SYM):  
            <span class="org-keyword">if</span> lexeme == <span class="org-string">"nil"</span>: <span class="org-keyword">return</span> ExprNil()
            <span class="org-keyword">return</span> ExprSym(lexeme)
        <span class="org-keyword">elif</span> <span class="org-keyword">self</span>.match(T_BOOL): <span class="org-keyword">return</span> ExprBool(lexeme == <span class="org-string">"#t"</span>)
        <span class="org-keyword">else</span>: 
            <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Invalid token: "</span> + lexeme)

    <span class="org-keyword">def</span> <span class="org-function-name">parse_list</span>(<span class="org-keyword">self</span>) -&gt; Expr:
        <span class="org-keyword">self</span>.expect(T_LPAR) 
        nodes: <span class="org-variable-name">List</span>[Expr] = []
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.check(T_RPAR) <span class="org-keyword">and</span> <span class="org-keyword">not</span> <span class="org-keyword">self</span>.is_eof():
            <span class="org-variable-name">sexp</span> = <span class="org-keyword">self</span>.parse_sexp()
            nodes.append(sexp)
        <span class="org-keyword">self</span>.expect(T_RPAR)
        <span class="org-variable-name">ast</span> = ExprList(nodes)
        <span class="org-keyword">return</span> ast

<span class="org-keyword">def</span> <span class="org-function-name">sexp_parse</span>(source: <span class="org-builtin">str</span>) -&gt; Expr:
    <span class="org-doc">"""Parse S-Expression."""</span>
    <span class="org-variable-name">p</span> = Parser(source)
    <span class="org-variable-name">ast</span> = p.parse_sexp()
    <span class="org-keyword">return</span> ast 


<span class="org-keyword">def</span> <span class="org-function-name">sexp_equal</span>(lhs: Expr, rhs: Expr) -&gt; <span class="org-builtin">bool</span>:
    <span class="org-doc">"""Compare two S-expressions returning true if they are equal.</span>
<span class="org-doc">    This function is useful for unit testing.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> rhs.<span class="org-builtin">type</span>() != lhs.<span class="org-builtin">type</span>(): <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">elif</span> rhs.is_atom() <span class="org-keyword">and</span> lhs.is_atom():
        <span class="org-keyword">if</span> rhs.is_num():    <span class="org-keyword">return</span> rhs.to_num() == lhs.to_num()
        <span class="org-keyword">elif</span> rhs.is_bool(): <span class="org-keyword">return</span> rhs.to_bool() == lhs.to_bool()
        <span class="org-keyword">elif</span> rhs.is_sym():  <span class="org-keyword">return</span> rhs.to_sexp() == lhs.to_sexp()
        <span class="org-keyword">elif</span> rhs.is_str():  <span class="org-keyword">return</span> rhs.to_sexp() == lhs.to_sexp()
        <span class="org-keyword">elif</span> rhs.is_nil():  <span class="org-keyword">return</span> <span class="org-constant">True</span> 
    <span class="org-keyword">elif</span> rhs.is_list():
        <span class="org-variable-name">a</span> = lhs.nodes()
        <span class="org-variable-name">b</span> = rhs.nodes()
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(a) != <span class="org-builtin">len</span>(b): <span class="org-keyword">return</span> <span class="org-constant">False</span>
        <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(a)):
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> sexp_equal(a[n], b[n]):
                <span class="org-keyword">return</span> <span class="org-constant">False</span>
        <span class="org-keyword">return</span> <span class="org-constant">True</span>
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">RuntimeError</span>(<span class="org-string">"Error - reached edge case."</span>)



<span class="org-keyword">def</span> <span class="org-function-name">sexp_eval</span>(sexp: Expr) -&gt; Expr:
    <span class="org-doc">"""Non-turing complete S-Expression evaluator.</span>
<span class="org-doc">    It can only evaluate simple expressions without branching.</span>
<span class="org-doc">    """</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">import pdb; pdb.set_trace()</span>
    <span class="org-keyword">if</span> sexp.is_num():    <span class="org-keyword">return</span> sexp
    <span class="org-keyword">elif</span> sexp.is_str():  <span class="org-keyword">return</span> sexp
    <span class="org-keyword">elif</span> sexp.is_nil():  <span class="org-keyword">return</span> sexp
    <span class="org-keyword">elif</span> sexp.is_bool(): <span class="org-keyword">return</span> sexp
    <span class="org-keyword">elif</span> sexp.is_err():  <span class="org-keyword">return</span> sexp 
    <span class="org-comment-delimiter"># </span><span class="org-comment">Function or special-form evaluation</span>
    <span class="org-keyword">elif</span> sexp.is_list():
        <span class="org-comment-delimiter"># </span><span class="org-comment">import pdb; pdb.set_trace()</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(sexp.nodes()) == 0: <span class="org-keyword">return</span> ExprNil()
        <span class="org-variable-name">nodes</span> = sexp.nodes()
        <span class="org-variable-name">head</span> = nodes[0]
        <span class="org-variable-name">args</span> = nodes[1:]
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> head.is_sym(): <span class="org-keyword">return</span>  ExprErr(f<span class="org-string">"Error: {func} not callable."</span>)
        <span class="org-comment-delimiter"># </span><span class="org-comment">Obtain function name</span>
        <span class="org-variable-name">func</span> = head.to_sexp()
        <span class="org-comment-delimiter"># </span><span class="org-comment">Special form quote </span>
        <span class="org-keyword">if</span> func == <span class="org-string">"quote"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(args) != 1:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error: ill-formed quote special form"</span>)
            <span class="org-keyword">return</span> args[0]
        <span class="org-comment-delimiter"># </span><span class="org-comment">Sepcial form if: (if &lt;cond&gt; &lt;then_form&gt; &lt;else_form&gt;)</span>
        <span class="org-keyword">if</span> func == <span class="org-string">"if"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(args) &gt; 4 <span class="org-keyword">or</span> <span class="org-builtin">len</span>(args) &lt; 1:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Syntax error - Ill-formed special form if"</span>)
            <span class="org-variable-name">cond</span> = args[0]
            <span class="org-variable-name">cond_eval</span> = sexp_eval(cond)
            <span class="org-keyword">if</span> cond_eval.to_bool():
                <span class="org-comment-delimiter"># </span><span class="org-comment">evaluate the then-form </span>
                <span class="org-variable-name">res</span> = sexp_eval(args[1])
                <span class="org-keyword">return</span> res 
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(args) == 3:
                <span class="org-comment-delimiter"># </span><span class="org-comment">evaluate the else-form</span>
                <span class="org-variable-name">res</span> = sexp_eval(args[2])
                <span class="org-keyword">return</span> res 
            <span class="org-keyword">return</span> ExprNil()
        <span class="org-comment-delimiter"># </span><span class="org-comment">Evaluate all arguments before function application</span>
        <span class="org-variable-name">evaluated_args</span> = []
        <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args:
            <span class="org-variable-name">res</span> = sexp_eval(a)
            <span class="org-comment-delimiter"># </span><span class="org-comment">print(" [TRACE] res = ", res)</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Abort computation if the evaluation of any argument is an error</span>
            <span class="org-keyword">if</span> res.is_err(): <span class="org-keyword">return</span> res 
            evaluated_args.append(res)
        <span class="org-variable-name">result</span> = ExprNil()
        <span class="org-keyword">if</span> func == <span class="org-string">"list"</span>:
            <span class="org-variable-name">result</span> = ExprList(evaluated_args)
        <span class="org-keyword">elif</span> func == <span class="org-string">"car"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 1: 
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Function car() expects 1 argument of type list or nil"</span>) 
            lst: <span class="org-variable-name">Expr</span> = evaluated_args[0] 
            <span class="org-keyword">if</span> lst.is_nil(): <span class="org-keyword">return</span> ExprNil()
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> lst.is_list(): 
                <span class="org-keyword">return</span> Expr(<span class="org-string">"Function car() expects argument of type list."</span>)
            <span class="org-variable-name">n</span> = lst.nodes()
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(n) == 0: <span class="org-keyword">return</span> ExprNil()
            <span class="org-keyword">return</span> n[0]
        <span class="org-keyword">elif</span> func == <span class="org-string">"cdr"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 1: 
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Function cdr() expects 1 argument of type list or nil"</span>) 
            lst: <span class="org-variable-name">Expr</span> = evaluated_args[0] 
            <span class="org-keyword">if</span> lst.is_nil(): <span class="org-keyword">return</span> ExprNil()
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> lst.is_list():
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Function cdr() expects argument of type list."</span>)
            <span class="org-variable-name">n</span> = lst.nodes()
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(n) == 0: <span class="org-keyword">return</span> ExprNil()
            <span class="org-keyword">return</span> ExprList(n[1:])
        <span class="org-keyword">elif</span> func == <span class="org-string">"eval"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 1: 
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Function eval()) expects 1 argument."</span>) 
            <span class="org-variable-name">expr</span> = evaluated_args[0]
            <span class="org-variable-name">result</span> =  sexp_eval(expr)
        <span class="org-keyword">elif</span> func == <span class="org-string">"read"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 1: 
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Function eval()) expects 1 argument."</span>) 
            <span class="org-variable-name">src</span>  = evaluated_args[0].to_str()
            <span class="org-variable-name">ast</span>  = sexp_parse(src)
            <span class="org-keyword">return</span> ast
        <span class="org-keyword">elif</span> func == <span class="org-string">"+"</span>: 
            <span class="org-variable-name">result</span> = fold_list(<span class="org-keyword">lambda</span> x, acc: x + acc, evaluated_args)
        <span class="org-keyword">elif</span> func == <span class="org-string">"-"</span>: 
            <span class="org-variable-name">result</span> = fold_list(<span class="org-keyword">lambda</span> x, acc: x - acc, evaluated_args)
        <span class="org-keyword">elif</span> func == <span class="org-string">"*"</span>:
            <span class="org-variable-name">result</span> = fold_list(<span class="org-keyword">lambda</span> x, acc: x * acc, evaluated_args)
        <span class="org-keyword">elif</span> func == <span class="org-string">"/"</span>:
            <span class="org-variable-name">result</span> = fold_list(<span class="org-keyword">lambda</span> x, acc: x / acc, evaluated_args)
        <span class="org-keyword">elif</span> func == <span class="org-string">"&gt;"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 2:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - function (&gt;) expects two arguments"</span>)
            <span class="org-keyword">if</span> evaluated_args[0].<span class="org-builtin">type</span>() != EXPR_NUM:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - first argument should be a number"</span>)
            <span class="org-keyword">if</span> evaluated_args[1].<span class="org-builtin">type</span>() != EXPR_NUM:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - first argument should be a number"</span>)
            <span class="org-variable-name">a</span> = evaluated_args[0].to_num()
            <span class="org-variable-name">b</span> = evaluated_args[1].to_num()
            <span class="org-variable-name">result</span> = ExprBool(a &gt; b)
        <span class="org-keyword">elif</span> func == <span class="org-string">"&lt;"</span>:
            <span class="org-keyword">if</span> <span class="org-builtin">len</span>(evaluated_args) != 2:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - function (&gt;) expects two arguments"</span>)
            <span class="org-keyword">if</span> evaluated_args[0].<span class="org-builtin">type</span>() != EXPR_NUM:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - first argument should be a number"</span>)
            <span class="org-keyword">if</span> evaluated_args[1].<span class="org-builtin">type</span>() != EXPR_NUM:
                <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error - first argument should be a number"</span>)
            <span class="org-variable-name">a</span> = evaluated_args[0].to_num()
            <span class="org-variable-name">b</span> = evaluated_args[1].to_num()
            <span class="org-variable-name">result</span> = ExprBool(a &lt; b)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> ExprErr(f<span class="org-string">"Error unbound function '{func}' "</span>)
        <span class="org-keyword">return</span> result
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> ExprErr(f<span class="org-string">"Evaluator not implemented for {sexp}"</span>)
        

<span class="org-comment-delimiter">#</span><span class="org-comment">def fold_list(func: Callable[[Double, Double], Double], args: List[Expr]) -&gt; Expr:</span>
<span class="org-keyword">def</span> <span class="org-function-name">fold_list</span>(func, args: List[Expr]) -&gt; Expr:
    <span class="org-comment-delimiter">#</span><span class="org-comment">print(" [TRACE] args = ", args)</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(args) &lt; 1:
        <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error: expected at least 1 argument"</span>)
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> args[0].is_num():
        <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Error: expected numeric argument"</span>)
    <span class="org-variable-name">acc</span> = args[0].to_num()
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args[1:]:
        <span class="org-keyword">if</span> a.is_err(): <span class="org-keyword">return</span> a 
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> a.is_num(): <span class="org-keyword">return</span> ExprErr(<span class="org-string">"Expected numeric argument, but given: "</span>, a)
        <span class="org-variable-name">value</span> = a.to_num()
        <span class="org-keyword">try</span>:
            <span class="org-variable-name">acc</span> = func(acc, value)
        <span class="org-keyword">except</span> <span class="org-type">ZeroDivisionError</span> <span class="org-keyword">as</span> ex:
            <span class="org-keyword">return</span> ExprErr(<span class="org-builtin">str</span>(ex))
    <span class="org-variable-name">result</span> = ExprNum(acc)
    <span class="org-keyword">return</span> result


<span class="org-keyword">def</span> <span class="org-function-name">repl</span>():
    <span class="org-variable-name">show_ast</span> = <span class="org-constant">False</span>
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">line</span> = <span class="org-builtin">input</span>(<span class="org-string">" SEXP&gt; "</span>).strip()
        <span class="org-keyword">if</span> line == <span class="org-string">""</span>: <span class="org-keyword">continue</span>
        <span class="org-keyword">elif</span> line == <span class="org-string">":show_ast"</span>:
            <span class="org-variable-name">show_ast</span> = <span class="org-constant">True</span>
            <span class="org-keyword">continue</span>
        <span class="org-keyword">elif</span> line == <span class="org-string">":hide_ast"</span>:
            <span class="org-variable-name">show_ast</span> = <span class="org-constant">False</span>
            <span class="org-keyword">continue</span>
        <span class="org-variable-name">ast</span> = sexp_parse(line)
        <span class="org-keyword">if</span> show_ast:
            <span class="org-keyword">print</span>(<span class="org-string">" [TRACE] ast = "</span>, ast)
            <span class="org-keyword">print</span>(<span class="org-string">" [TRACE] ast = "</span>, ast.to_sexp())
        <span class="org-variable-name">result</span> = sexp_eval(ast)
        <span class="org-keyword">print</span>(<span class="org-string">" := "</span>, result.to_sexp())

<span class="org-comment-delimiter"># </span><span class="org-comment">----------- Unit Testing --------------------------------------------------#</span>

<span class="org-keyword">def</span> <span class="org-function-name">test_sexp_parser</span>():
    <span class="org-doc">"""Test S-Expression parser"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">"(list 'expr1 (* 3 5 6) 'expr2 (+ 1 2 (* 3 4)) )"</span> 
    <span class="org-variable-name">expr1</span> = ExprList([ ExprSym(<span class="org-string">"quote"</span>), ExprSym(<span class="org-string">"expr1"</span>)] )
    <span class="org-variable-name">expr2</span> = ExprList([ ExprSym(<span class="org-string">"quote"</span>), ExprSym(<span class="org-string">"expr2"</span>)] )
    <span class="org-variable-name">lst1</span> = ExprList([ ExprSym(<span class="org-string">"*"</span>), ExprNum(3.0), ExprNum(5.0), ExprNum(6.0) ])
    <span class="org-variable-name">lst2</span> = ExprList([ ExprSym(<span class="org-string">"+"</span>), ExprNum(1), ExprNum(2), 
                      ExprList([ ExprSym(<span class="org-string">"*"</span>), ExprNum(3.0), ExprNum(4.0)])])
    <span class="org-variable-name">expected</span> = ExprList([ ExprSym(<span class="org-string">"list"</span>), expr1, lst1, expr2, lst2 ])
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-keyword">assert</span> sexp_equal(ast, expected)

<span class="org-keyword">def</span> <span class="org-function-name">test_sexp_evaluator1</span>():
    <span class="org-doc">"""Test S-expression interpreter"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">"(list 'expr1 (* 3 5 6) 'expr2 (+ 1 2 (* 3 4)) )"</span> 
    <span class="org-variable-name">expected</span> = ExprList([ExprSym(<span class="org-string">"expr1"</span>), ExprNum(90.0), ExprSym(<span class="org-string">"expr2"</span>), ExprNum(15.0)])
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-variable-name">output</span> = sexp_eval(ast)
    <span class="org-keyword">assert</span> sexp_equal(output, expected)


<span class="org-keyword">def</span> <span class="org-function-name">test_sexp_evaluator2</span>():
    <span class="org-doc">"""Test S-expression interpreter"""</span>
    <span class="org-variable-name">src</span> = <span class="org-string">"   (read  \n \"(+ 1 2 3 4)\" )"</span> 
    <span class="org-variable-name">expected</span> = ExprList([ExprSym(<span class="org-string">"+"</span>), ExprNum(1.0), ExprNum(2.0), ExprNum(3.0), ExprNum(4.0)])
    <span class="org-variable-name">ast</span> = sexp_parse(src)
    <span class="org-variable-name">output</span> = sexp_eval(ast)
    <span class="org-keyword">assert</span> sexp_equal(output, expected)


<span class="org-comment-delimiter">#</span><span class="org-comment">-------------------------- End of Unit Testing ------------------------------#</span>

<span class="org-variable-name">src</span> = <span class="org-string">"""</span>
<span class="org-string">    (fn myfunc(x y z) </span>
<span class="org-string">            "Compute the distance from origin to point x, y, z"</span>
<span class="org-string">            (sqrt  (+ (* x x) (* y y) (* z z))  ) </span>
<span class="org-string">            )</span>

<span class="org-string">"""</span>
<span class="org-variable-name">ast</span> = sexp_parse(src)
</pre>
</div>

<p>
Run the unit testing:
</p>


<div class="org-src-container">
<pre class="src src-python">$  pytest -q -v -rA sexp_parser2.py

=============================== test session starts ================================
platform linux -- Python 3.8.10, pytest-7.3.1, pluggy-1.0.0
<span class="org-function-name">rootdir</span>: /home/user/formula-parser
collected 3 items                                                                  

sexp_parser2.py ...                                                          [100%]

====================================== PASSES ======================================
============================= short test summary info ==============================
PASSED sexp_parser2.py::test_sexp_parser
PASSED sexp_parser2.py::test_sexp_evaluator1
PASSED sexp_parser2.py::test_sexp_evaluator2
================================ 3 passed <span class="org-keyword">in</span> 0.04s =================================
</pre>
</div>


<p>
Test the parser in a interactive way:
</p>


<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; ast
List[ Sym[fn], Sym[myfunc], List[ Sym[x], Sym[y], Sym[z] ]
      , Str[<span class="org-string">"Compute the distance from origin to point x, y, z"</span>]
            , List[ Sym[sqrt], List[ Sym[+], List[ Sym[*], Sym[x], Sym[x] ]
               , List[ Sym[*], Sym[y], Sym[y] ], List[ Sym[*], Sym[z], Sym[z] ] ] ] ]

&gt;&gt;&gt; <span class="org-builtin">type</span>(ast)
&lt;<span class="org-keyword">class</span> <span class="org-string">'__main__.ExprList'</span>&gt;

&gt;&gt;&gt; ast.is_num()
<span class="org-constant">False</span>

&gt;&gt;&gt; ast.is_list()
<span class="org-constant">True</span>

&gt;&gt;&gt; ast.is_bool()
<span class="org-constant">False</span>

&gt;&gt;&gt; ast.is_sym()
<span class="org-constant">False</span>


&gt;&gt;&gt; ast.nth(0)
Sym[fn]

&gt;&gt;&gt; ast.nth(1)
Sym[myfunc]

&gt;&gt;&gt; ast.nth(2)
List[ Sym[x], Sym[y], Sym[z] ]

&gt;&gt;&gt; ast.nth(2).to_sexp()
<span class="org-string">'(x y z)'</span>

&gt;&gt;&gt; ast.nth(2).nth(0)
Sym[x]

&gt;&gt;&gt; ast.nth(2).nth(1)
Sym[y]

&gt;&gt;&gt; ast.nth(2).nth(2)
Sym[z]

&gt;&gt;&gt; ast.nth(3)
Str[<span class="org-string">"Compute the distance from origin to point x, y, z"</span>]

&gt;&gt;&gt; ast.nth(4)
List[ Sym[sqrt], List[ Sym[+], List[ Sym[*], Sym[x], Sym[x] ], 
         List[ Sym[*], Sym[y], Sym[y] ], List[ Sym[*], Sym[z], Sym[z] ] ] ]

&gt;&gt;&gt; ast.nth(4).to_sexp()
<span class="org-string">'(sqrt (+ (* x x) (* y y) (* z z)))'</span>
</pre>
</div>

<p>
Test the REPL (Read-Print-Eval-Loop). In order to keep, the code as
short as possible, a turing-complete Lisp-evaluator was not
included. As a result, the evaluator can only deal with simple
arithmetic expressions.
</p>

<div class="org-src-container">
<pre class="src src-lisp">&gt;&gt;&gt; repl()

 SEXP&gt; (list 'x (* 3 5 1) 'y (+ (* 3 5) (/ 100 5) 10) '(+ 100 x (* z w)) )
 <span class="org-builtin">:=</span>  (x 15.0 y 45.0 (+ 100.0 x (* z w)))

 SEXP&gt; 

 SEXP&gt; (read <span class="org-string">"(+ (* 3 5) (+ 1 2 3 ))"</span>)
 <span class="org-builtin">:=</span>  (+ (* 3.0 5.0) (+ 1.0 2.0 3.0))

 SEXP&gt; (eval (read <span class="org-string">"(+ (* 3 5) (+ 1 2 3 ))"</span>))
 <span class="org-builtin">:=</span>  21.0

 SEXP&gt; (/ 10 0)
 <span class="org-builtin">:=</span>  float division by zero

 SEXP&gt; (<span class="org-keyword">if</span> (&gt; 3 15) (+ 2 5) (/ 10 0))
 <span class="org-builtin">:=</span>  float division by zero

 SEXP&gt; (<span class="org-keyword">if</span> (&gt; 20 15) (+ 2 5) (/ 10 0))
 <span class="org-builtin">:=</span>  7.0

 SEXP&gt; (<span class="org-keyword">if</span> (&gt; 3 15) (+ 2 5) (/ 10 0))
 <span class="org-builtin">:=</span>  float division by zero

 SEXP&gt; (+ 100 (<span class="org-keyword">if</span> (&gt; 20 15) (+ 2 5) (/ 10 0)))
 <span class="org-builtin">:=</span>  107.0

 SEXP&gt; (+ 100 (<span class="org-keyword">if</span> (&gt; 10 15) (+ 2 5) (/ 10 0)))
 <span class="org-builtin">:=</span>  float division by zero
</pre>
</div>
</div>
</div>

<div id="outline-container-org9786615" class="outline-4">
<h4 id="org9786615"><span class="section-number-4">1.11.5</span> Interpreter for Kotlin - Java Platform</h4>
<div class="outline-text-4" id="text-1-11-5">
<p>
There ara many lisp-like programming languages for the Java Platform
and JVM, including Clojure, ABCL common lisp and Kawa Scheme. All
those implementations compile to JVM bytecodes, instructions of Java
Virtual Machine at runtime, but they don't work on Android, that uses
Dalvik virtual machine, a different virtual machine than JVM. 
</p>

<p>
This code is an incomplete Scheme-like embedded tree walking
interpreter implemented in Kotlin language, that is able to compile to
both JVM and Android Dalvik virtual machine. As a result, the code can
be embedded in Java desktop application or android apps for faster
experimentation and iteration since the interpreter allows instanting
and calling Java objects at runtime without any time wasted on
compilation. 
</p>


<p>
File: <span class="underline">sexpr.kt</span> (Almost: 2130 lines of code)
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">Embedded lisp-like interpreter hosted on Kotlin/JVM (Java Virtual Machine)</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Compile this program with: </span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">$ kotlinc sexpr.kt -include-runtime -d sexpr.ja </span>
<span class="org-comment-delimiter">// </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Run this sample program with:</span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">$ java -jar sexpr.jar  </span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">$ rlrwrap java -jar sexpr.jar </span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">----------------------------------------------------------------------------</span>

<span class="org-type">typealias</span> <span class="org-variable-name">Func</span> = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">List</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Ast 

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> AstType <span class="org-rainbow-delimiters-depth-1">{</span>
    INT, FLT, STR, SYM, KEY, OBJ, LST, ENV, BOOL, NIL
    , VOID, ERR, FUNC_NATIVE, FUNC_UDF
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Lisp Ast - Abstract Syntax Tree and Runtime values  </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">This is equivalent to an AGDT - Algebraic Data Type</span>
<span class="org-type">sealed</span> <span class="org-keyword">class</span>  Ast <span class="org-rainbow-delimiters-depth-1">{</span>

    open fun type<span class="org-rainbow-delimiters-depth-2">()</span>:      AstType      <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not implemented for this type of AST node."</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">toInt</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Int          <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 0   <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">toFlt</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Double       <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 0.0 <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">toBool</span><span class="org-rainbow-delimiters-depth-2">()</span>:    Boolean      <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node."</span><span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-2">()</span>:     String       <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node."</span><span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">toObj</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Object       <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node."</span><span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">nth</span><span class="org-rainbow-delimiters-depth-2">(</span>n: Int<span class="org-rainbow-delimiters-depth-2">)</span>: Ast          <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node. "</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">nodes</span><span class="org-rainbow-delimiters-depth-2">()</span>:     <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node. "</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Int          <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node."</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">head</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Ast          <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node. "</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">tail</span><span class="org-rainbow-delimiters-depth-2">()</span>:      <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>    <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Not valid for this type of AST node. "</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
    open <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if object is callable, in other words, the </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">object is a primtive function (defined in the host language)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">or a UDF (User-Defined-Function) defined in the hosted language </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isCallable</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is a runtime error </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isErr</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true is AST node is a symbol  </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isSym</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true is AST node is a string literal </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isStr</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is a keyword literal  </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isKey</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is a list </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isList</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is a integer or floating point </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isNum</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is a nil (null) object </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isNil</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if AST node is void </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isVoid</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">If true, then the runtime value represents a wrapped Java Object </span>
    open <span class="org-type">fun</span> <span class="org-function-name">isObj</span><span class="org-rainbow-delimiters-depth-2">()</span>:      Boolean     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Anything that is not false or nil is regarded  as true</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">in if-else special forms (if &lt;cond&gt; &lt;then&gt; &lt;else&gt;)</span>
    open <span class="org-type">fun</span> <span class="org-function-name">asBool</span><span class="org-rainbow-delimiters-depth-2">()</span>:     Boolean   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Null-element ASt - emtpy AST for initialializing variables of type AST</span>
    <span class="org-type">object</span> <span class="org-function-name">AstVoid</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
        override <span class="org-type">fun</span> <span class="org-function-name">isVoid</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span> 
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.VOID <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp integer literal </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstInt<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: Int<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">(){</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toInt</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Int     <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toFlt</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Double  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value.toDouble<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isNum</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.INT <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp floating point literal </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstFlt<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: Double<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">(){</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toFlt</span><span class="org-rainbow-delimiters-depth-3">()</span>: Double  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isNum</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>: String <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value.toString<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.FLT <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp string literal </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstStr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">(){</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>:  String  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isStr</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.STR <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp symbol literal  =&gt; 'hello-world, string-&gt;num  </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstSym<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>: String  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isSym</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.SYM <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp keyworkd literal, example =&gt; :width, :size </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstKey<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>:  String  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isKey</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.KEY <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp boolean value </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstBool<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: Boolean<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">(){</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toBool</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span> 
        override <span class="org-type">fun</span> <span class="org-function-name">asBool</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>: String <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>value<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-string">"#t"</span> <span class="org-keyword">else</span> <span class="org-string">"#f"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.BOOL <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Ast - indicates null or empty list </span>
    <span class="org-type">object</span> <span class="org-function-name">AstNil</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">asBool</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isNil</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>:  String   <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-string">"nil"</span><span class="org-rainbow-delimiters-depth-3">}</span> 
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.NIL <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp list </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstLst<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">nth</span><span class="org-rainbow-delimiters-depth-3">(</span>n: Int<span class="org-rainbow-delimiters-depth-3">)</span>: Ast          <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>   <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-3">()</span>:      Int          <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value.size <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">nodes</span><span class="org-rainbow-delimiters-depth-3">()</span>:     <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value      <span class="org-rainbow-delimiters-depth-3">}</span> 
        override <span class="org-type">fun</span> <span class="org-function-name">head</span><span class="org-rainbow-delimiters-depth-3">()</span>:      Ast          <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">tail</span><span class="org-rainbow-delimiters-depth-3">()</span>:      <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value.takeLast<span class="org-rainbow-delimiters-depth-4">(</span> value.size - 1 <span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isList</span><span class="org-rainbow-delimiters-depth-3">()</span>:    Boolean      <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:      AstType      <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.LST <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">------ Intepreter Runtime Values ---------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">They don't represent AST nodes. They are the result of AST evaluation </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">by the interpreter.</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Runtime error </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstErr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toStr</span><span class="org-rainbow-delimiters-depth-3">()</span>: String  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isErr</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:  AstType <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.ERR <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lisp environment contains bindings between variables and </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">runtime values  </span>
    <span class="org-keyword">class</span> <span class="org-type">AstEnv</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">parent</span>: AstEnv? = <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-2">)</span> : Ast<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">public</span> <span class="org-type">val</span> <span class="org-variable-name">env</span>: <span class="org-type">MutableMap</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">String</span>, <span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> = mutableMapOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">String</span>, <span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
       <span class="org-keyword">public</span> var name: String = <span class="org-string">""</span> 

       override fun type<span class="org-rainbow-delimiters-depth-3">()</span>:  AstType <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.ENV <span class="org-rainbow-delimiters-depth-3">}</span>

       override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>

       <span class="org-type">fun</span> <span class="org-function-name">has</span><span class="org-rainbow-delimiters-depth-3">(</span>name: String<span class="org-rainbow-delimiters-depth-3">)</span>: Boolean 
       <span class="org-rainbow-delimiters-depth-3">{</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> env.contains<span class="org-rainbow-delimiters-depth-5">(</span>name<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> parent == <span class="org-constant">null</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-type">val</span> <span class="org-variable-name">r</span> = parent<span class="org-negation-char">!</span>!.has<span class="org-rainbow-delimiters-depth-4">(</span>name<span class="org-rainbow-delimiters-depth-4">)</span>
           <span class="org-keyword">return</span> r
       <span class="org-rainbow-delimiters-depth-3">}</span>

       <span class="org-type">fun</span> <span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-3">(</span>name: String, value: Ast<span class="org-rainbow-delimiters-depth-3">){</span> env.put<span class="org-rainbow-delimiters-depth-4">(</span>name, value<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>

       <span class="org-comment-delimiter">// </span><span class="org-comment">Set only an existing binding</span>
       <span class="org-type">fun</span> <span class="org-function-name">setExisting</span><span class="org-rainbow-delimiters-depth-3">(</span>name: String, value: Ast<span class="org-rainbow-delimiters-depth-3">)</span>: Boolean
       <span class="org-rainbow-delimiters-depth-3">{</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> env.contains<span class="org-rainbow-delimiters-depth-5">(</span>name<span class="org-rainbow-delimiters-depth-5">)</span>  <span class="org-rainbow-delimiters-depth-4">){</span> 
                env.put<span class="org-rainbow-delimiters-depth-5">(</span>name, value<span class="org-rainbow-delimiters-depth-5">)</span> 
                <span class="org-keyword">return</span> <span class="org-constant">true</span> 
            <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> parent != <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">){</span>
              <span class="org-type">val</span> <span class="org-variable-name">b</span> = parent<span class="org-negation-char">!</span>!.setExisting<span class="org-rainbow-delimiters-depth-5">(</span>name, value<span class="org-rainbow-delimiters-depth-5">)</span>  
              <span class="org-keyword">return</span> b
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">return</span> <span class="org-constant">false</span> 
       <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove all elements from current environment</span>
       <span class="org-type">fun</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-3">(){</span> env.clear<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>

       <span class="org-type">fun</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-3">(</span>name: String<span class="org-rainbow-delimiters-depth-3">)</span>: Ast?
       <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">print(" [TRACE] (109) AstEnv.get() =&gt;  name = ${name} =&gt;  ${this}")</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>env.contains<span class="org-rainbow-delimiters-depth-5">(</span>name<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> env<span class="org-negation-char">!</span>!.get<span class="org-rainbow-delimiters-depth-5">(</span>name<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>parent == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> AstErr<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: (line 113) unbound variable ${name}"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-type">val</span> <span class="org-variable-name">r</span> =  parent<span class="org-negation-char">!</span>!.get<span class="org-rainbow-delimiters-depth-4">(</span>name<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] (116) AstEnv.get() =&gt; ${name} = ${r}")</span>
            <span class="org-keyword">return</span> r
       <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">data</span> <span class="org-keyword">class</span> AstFunc<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">name</span>: String, <span class="org-type">val</span> <span class="org-variable-name">func</span>: Func<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isCallable</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean   <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:  AstType <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.FUNC_NATIVE <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Represents a user-defined function </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstFuncUDF<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-type">val</span> <span class="org-variable-name">name</span>:   String
                         , <span class="org-type">val</span> <span class="org-variable-name">args</span>:   <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">String</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>
                         , <span class="org-type">val</span> <span class="org-variable-name">body</span>:   <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>   
                         , <span class="org-type">var</span> <span class="org-variable-name">env</span>:    AstEnv 
                      <span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isCallable</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean   <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:  AstType <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.FUNC_UDF <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">This AST node represents a Java object </span>
    <span class="org-type">data</span> <span class="org-keyword">class</span> AstObj<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">val</span> <span class="org-variable-name">value</span>: Object<span class="org-rainbow-delimiters-depth-2">)</span>: Ast<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isObj</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-3">()</span>: Boolean <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">toObj</span><span class="org-rainbow-delimiters-depth-3">()</span>:  Object  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value <span class="org-rainbow-delimiters-depth-3">}</span>
        override <span class="org-type">fun</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-3">()</span>:   AstType <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">AstType</span>.OBJ <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Type</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      T_Flt  <span class="org-comment-delimiter">// </span><span class="org-comment">Floating point number literal</span>
    , T_Int  <span class="org-comment-delimiter">// </span><span class="org-comment">Integer </span>
    , T_Str  <span class="org-comment-delimiter">// </span><span class="org-comment">String literal </span>
    , T_Sym  <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol literal `</span>
    , T_Key  <span class="org-comment-delimiter">// </span><span class="org-comment">keyword literal </span>
    , T_Nil  <span class="org-comment-delimiter">// </span><span class="org-comment">Nil literal </span>
    , T_Bool <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean literal </span>
    , T_Quote <span class="org-comment-delimiter">// </span><span class="org-comment">(')</span>
    , T_Lpar <span class="org-comment-delimiter">// </span><span class="org-comment">'(' Left parenthesis </span>
    , T_Rpar <span class="org-comment-delimiter">// </span><span class="org-comment">')' Right parenthesis </span>
    , T_EOF  <span class="org-comment-delimiter">// </span><span class="org-comment">Type EOF token </span>
    , T_ERR  <span class="org-comment-delimiter">// </span><span class="org-comment">Token error </span>
    , T_EMPTY 

<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Strings that matches the terminal element of a grammar </span>
<span class="org-type">data</span> <span class="org-keyword">class</span> Token<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">val</span> <span class="org-variable-name">type</span>: Type
                , <span class="org-type">val</span> <span class="org-variable-name">text</span>: String
                , <span class="org-type">val</span> <span class="org-variable-name">pos</span>:  Int
                , <span class="org-type">val</span> <span class="org-variable-name">lin</span>:  Int
                , <span class="org-type">val</span> <span class="org-variable-name">col</span>:  Int
                <span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-rainbow-delimiters-depth-1">{</span>
                    fun isErr<span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> type == <span class="org-constant">Type</span>.T_ERR <span class="org-rainbow-delimiters-depth-2">}</span>
                    <span class="org-type">fun</span> <span class="org-function-name">isEof</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> type == <span class="org-constant">Type</span>.T_EOF <span class="org-rainbow-delimiters-depth-2">}</span>
                <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Tokenizer</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">val</span> <span class="org-variable-name">source</span>: String<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Null character constant (sentinel value)</span>
    val NULL_CHAR = 0.toChar<span class="org-rainbow-delimiters-depth-2">()</span>
    val QUOTE_CHAR = 34.toChar<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-comment-delimiter">// </span><span class="org-comment">'"' breaks the syntax highlight</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize current character with NullChar</span>
    var ch: Char = NULL_CHAR 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Current position </span>
    var pos: Int = 0
    <span class="org-comment-delimiter">// </span><span class="org-comment">Current line </span>
    var lin: Int = 1
    <span class="org-comment-delimiter">// </span><span class="org-comment">Current column </span>
    var col: Int = 1 

    <span class="org-keyword">private</span> val TOKEN_EMPTY = Token<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">Type</span>.T_EMPTY, <span class="org-string">""</span>, 0, 0, 0<span class="org-rainbow-delimiters-depth-2">)</span>

    init <span class="org-rainbow-delimiters-depth-2">{</span>
        advance<span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">()</span>: Char <span class="org-rainbow-delimiters-depth-2">{</span>  <span class="org-keyword">return</span> ch <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">lookahed</span><span class="org-rainbow-delimiters-depth-2">(</span>n: Int<span class="org-rainbow-delimiters-depth-2">)</span>: Char <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>pos + n &gt;= source.length<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> NULL_CHAR <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> source<span class="org-rainbow-delimiters-depth-3">[</span>pos + n - 1<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">isEof</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> ch == NULL_CHAR <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">match</span><span class="org-rainbow-delimiters-depth-2">(</span>c: Char<span class="org-rainbow-delimiters-depth-2">)</span>: Boolean
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>c == ch<span class="org-rainbow-delimiters-depth-3">){</span> 
            advance<span class="org-rainbow-delimiters-depth-4">()</span> 
            <span class="org-keyword">return</span> <span class="org-constant">true</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">false</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span>c: Char<span class="org-rainbow-delimiters-depth-2">)</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> c == ch <span class="org-rainbow-delimiters-depth-2">}</span> 

    <span class="org-type">fun</span> <span class="org-function-name">expect</span><span class="org-rainbow-delimiters-depth-2">(</span>c: Char<span class="org-rainbow-delimiters-depth-2">)</span>: Token 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>c == ch<span class="org-rainbow-delimiters-depth-3">){</span>
            advance<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">return</span> TOKEN_EMPTY
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("Lexical error. Invalid character. Expected '${c}', but given '${ch}' ") </span>
        <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Lexical error. Invalid character. Expected '${c}', but given '${ch}' "</span><span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">advance</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>pos &gt;= source.length<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            ch = 0.toChar<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            ch = source<span class="org-rainbow-delimiters-depth-4">[</span>pos<span class="org-rainbow-delimiters-depth-4">]</span>
            pos = pos +  1
        <span class="org-rainbow-delimiters-depth-3">}</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">isSpace</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> ch == <span class="org-string">' '</span> || ch == <span class="org-string">'\t'</span> || ch == <span class="org-string">'\r'</span> || ch == <span class="org-string">'\n'</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">isDelimiter</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> ch == <span class="org-string">')'</span> || ch == <span class="org-string">'('</span> || ch == <span class="org-string">'\''</span> 
                                        || ch == <span class="org-string">'`'</span> || ch == <span class="org-string">','</span> || ch == <span class="org-string">'@'</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">isDigit</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> ch.isDigit<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">token</span><span class="org-rainbow-delimiters-depth-2">(</span>type: Type, lexeme: String<span class="org-rainbow-delimiters-depth-2">)</span>: Token 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val tok = Token<span class="org-rainbow-delimiters-depth-3">(</span>type, lexeme, pos, lin, col<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> tok 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns an error sentinel token. It is an alternative to exceptions.</span>
    <span class="org-type">fun</span> <span class="org-function-name">error</span><span class="org-rainbow-delimiters-depth-2">(</span>message: String<span class="org-rainbow-delimiters-depth-2">)</span>: Token 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val tok = token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_ERR, message<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> tok
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">tokens</span><span class="org-rainbow-delimiters-depth-2">()</span>: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val tokens = mutableListOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            val t = next<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>t.type == <span class="org-constant">Type</span>.T_EOF<span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">break</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            tokens.add<span class="org-rainbow-delimiters-depth-4">(</span>t<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> tokens
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">next</span><span class="org-rainbow-delimiters-depth-2">()</span>: Token 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Return sentinel token when at end of input </span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_EOF, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span>isSpace<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> advance<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        assert<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>isSpace<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Skip comment</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-5">)</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>.isEof<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>  advance<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> next<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'('</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Lpar, <span class="org-string">"("</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">')'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Rpar, <span class="org-string">")"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'\''</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Quote, <span class="org-string">"'"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-4">)</span> &amp;&amp; lookahed<span class="org-rainbow-delimiters-depth-4">(</span>1<span class="org-rainbow-delimiters-depth-4">)</span>.isDigit<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> nextNumber<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> isDigit<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> nextNumber<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> check<span class="org-rainbow-delimiters-depth-4">(</span>QUOTE_CHAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>  <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> nextString<span class="org-rainbow-delimiters-depth-4">()</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> nextSymbolOrBool<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("edge case")</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">nextSymbolOrBool</span><span class="org-rainbow-delimiters-depth-2">()</span>: Token
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var lexeme = <span class="org-string">""</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>isSpace<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>isDelimiter<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            lexeme += peek<span class="org-rainbow-delimiters-depth-4">()</span>
            advance<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lexeme == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_EOF, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lexeme == <span class="org-string">"#t"</span> || lexeme == <span class="org-string">"#f"</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Bool, lexeme<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lexeme.startsWith<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">":"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Key, lexeme.drop<span class="org-rainbow-delimiters-depth-5">(</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Sym, lexeme<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">nextString</span><span class="org-rainbow-delimiters-depth-2">()</span>: Token
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] peek() = " + peek())</span>
        var err = expect<span class="org-rainbow-delimiters-depth-3">(</span>QUOTE_CHAR<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>err.isErr<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err<span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span>QUOTE_CHAR<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'\\'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'n'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme += <span class="org-string">"\n"</span>; <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'t'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme += <span class="org-string">"\t"</span>; <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">if( match('v') ){ lexeme += "\v"; continue }</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'\\'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme += <span class="org-string">"\\"</span>; <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span>QUOTE_CHAR<span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme += <span class="org-string">"\""</span>; <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-comment-delimiter">//</span><span class="org-comment">throw Exception("Tokenizer error, invalid escape character.")</span>
                <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Tokenizer error, invalid escape character."</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            lexeme += peek<span class="org-rainbow-delimiters-depth-4">()</span>
            advance<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] lexeme = '${lexeme}' ")</span>
        err = expect<span class="org-rainbow-delimiters-depth-3">(</span>QUOTE_CHAR<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>err.isErr<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err<span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Str, lexeme<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">nextNumber</span><span class="org-rainbow-delimiters-depth-2">()</span>: Token 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var lexeme = <span class="org-string">""</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span> lexeme += <span class="org-string">"-"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span> lexeme += nextInteger<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-4">)</span> &amp;&amp; <span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'e'</span><span class="org-rainbow-delimiters-depth-4">)</span> &amp;&amp; <span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'E'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> peek<span class="org-rainbow-delimiters-depth-5">()</span>.isLetter<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("Invalid number. Numbers cannot terminate with letter.")</span>
                <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid number. Numbers cannot terminate with letter."</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Int, lexeme<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> lexeme += <span class="org-string">'.'</span> + nextInteger<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">letter</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'e'</span><span class="org-rainbow-delimiters-depth-4">)</span> or match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'E'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            lexeme += letter
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-5">)</span> &amp;&amp; <span class="org-negation-char">!</span>isDigit<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("Invalid floating point number: " + lexeme)</span>
                <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid floating point number: "</span> + lexeme<span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> lexeme += <span class="org-string">"-"</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>isDigit<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("Invalid floating point. Expected digit, but got: " + lexeme)</span>
                <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Invalid floating point. Expected digit, but got: "</span> + lexeme<span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            lexeme += nextInteger<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> peek<span class="org-rainbow-delimiters-depth-4">()</span>.isLetter<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">throw Exception("Invalid number. It cannot end with letter.")</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Invalid number. It cannot end with letter."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Flt, lexeme<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">nextInteger</span><span class="org-rainbow-delimiters-depth-2">()</span>: String 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var lexeme = <span class="org-string">""</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">this</span>.peek<span class="org-rainbow-delimiters-depth-4">()</span>.isDigit<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-keyword">this</span>.isEof<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            lexeme += peek<span class="org-rainbow-delimiters-depth-4">()</span>
            advance<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span>  lexeme 
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">----- End of class Tokenizer() -------------- //</span>


<span class="org-keyword">class</span> <span class="org-type">Parser</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">val</span> <span class="org-variable-name">source</span>: String<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">List of tokens to be processed </span>
    val tokens = Tokenizer<span class="org-rainbow-delimiters-depth-2">(</span>source<span class="org-rainbow-delimiters-depth-2">)</span>.tokens<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize current token with a null element </span>
    var current: Token = Token<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">Type</span>.T_EMPTY, <span class="org-string">""</span>, 0, 0, 0<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Position of current tokens </span>
    var pos = 0 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize parser state </span>
    init <span class="org-rainbow-delimiters-depth-2">{</span>
        advance<span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">()</span>: Token <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> current <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">advance</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> pos &gt;= tokens.size <span class="org-rainbow-delimiters-depth-3">){</span>
            current = Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_EOF, <span class="org-string">""</span>, 0, 0, 0<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        current = tokens<span class="org-rainbow-delimiters-depth-3">[</span>pos<span class="org-rainbow-delimiters-depth-3">]</span>
        pos = pos + 1    
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">match</span><span class="org-rainbow-delimiters-depth-2">(</span>type: Type<span class="org-rainbow-delimiters-depth-2">)</span>: Boolean  
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> current.type == type  <span class="org-rainbow-delimiters-depth-3">){</span>
            advance<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">return</span> <span class="org-constant">true</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">false</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span>type: Type<span class="org-rainbow-delimiters-depth-2">)</span>: Boolean
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> current.type == type 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">expect</span><span class="org-rainbow-delimiters-depth-2">(</span>type: Type<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> current.type == type <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> advance<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstVoid <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Parser Error: expected token "</span> + type + <span class="org-string">", but given "</span> + current<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">isEof</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> current.type == <span class="org-constant">Type</span>.T_EOF <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">isAtom</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Bool || peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Flt || peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Int
            || peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Sym || peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Str || peek<span class="org-rainbow-delimiters-depth-3">()</span>.type == <span class="org-constant">Type</span>.T_Key
    <span class="org-rainbow-delimiters-depth-2">}</span>
    
    <span class="org-type">fun</span> <span class="org-function-name">parseSexp</span><span class="org-rainbow-delimiters-depth-2">()</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span>     <span class="org-rainbow-delimiters-depth-3">(</span> isAtom<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>          <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> parseAtom<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Lpar<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> parseList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Quote<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-type">val</span> <span class="org-variable-name">s</span> = parseSexp<span class="org-rainbow-delimiters-depth-4">()</span>
            val lst = listOf<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"quote"</span><span class="org-rainbow-delimiters-depth-5">)</span>, s <span class="org-rainbow-delimiters-depth-4">)</span> 
            val r = <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-4">(</span>lst<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> r
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_ERR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [LEXICAL ERROR] "</span> + current <span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Parser Error: unexpected invalid token: "</span> + peek<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">parseAtom</span><span class="org-rainbow-delimiters-depth-2">()</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val lexeme = peek<span class="org-rainbow-delimiters-depth-3">()</span>.text 
        <span class="org-keyword">if</span>     <span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Int<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">(</span> lexeme.toInt<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Flt<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">(</span> lexeme.toDouble<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Str<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-4">(</span>lexeme<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Bool<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstBool<span class="org-rainbow-delimiters-depth-4">(</span>lexeme == <span class="org-string">"#t"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Key<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-4">(</span>lexeme<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Sym<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> lexeme == <span class="org-string">"nil"</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-4">(</span>lexeme<span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Parser Errror: Invalid token: ${peek()}"</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">parseList</span><span class="org-rainbow-delimiters-depth-2">()</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var err = expect<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Lpar<span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>err.isErr<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err<span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">nodes</span> = mutableListOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>.T_Rpar<span class="org-rainbow-delimiters-depth-4">)</span> &amp;&amp; <span class="org-negation-char">!</span>isEof<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            val sexp = parseSexp<span class="org-rainbow-delimiters-depth-4">()</span>
            nodes.add<span class="org-rainbow-delimiters-depth-4">(</span>sexp<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        err = expect<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>.T_Rpar<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>err.isErr<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err<span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">ast</span> = <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-3">(</span>nodes<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> ast
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of class Parser() ---------//</span>

<span class="org-type">object</span> <span class="org-variable-name">Sexp</span> <span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get S-Expression lisp-like string representation of AST</span>
    fun toStr<span class="org-rainbow-delimiters-depth-2">(</span>r: Ast<span class="org-rainbow-delimiters-depth-2">)</span>: String = when<span class="org-rainbow-delimiters-depth-2">(</span>r<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Emtpy AST =&gt; Null </span>
            is <span class="org-constant">Ast</span>.AstVoid -&gt; <span class="org-string">"&lt;void&gt;"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean value </span>
            is <span class="org-constant">Ast</span>.AstBool -&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>r.value<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-string">"#t"</span> <span class="org-keyword">else</span> <span class="org-string">"#f"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Floating point literal  </span>
            is <span class="org-constant">Ast</span>.AstFlt  -&gt; r.value.toString<span class="org-rainbow-delimiters-depth-3">()</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Integer point literal </span>
            is <span class="org-constant">Ast</span>.AstInt  -&gt; r.value.toString<span class="org-rainbow-delimiters-depth-3">()</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol literal </span>
            is <span class="org-constant">Ast</span>.AstSym  -&gt; r.value 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Keyword literal </span>
            is <span class="org-constant">Ast</span>.AstKey  -&gt; <span class="org-string">":"</span> + r.value 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Nul - null value </span>
            is <span class="org-constant">Ast</span>.AstNil  -&gt; <span class="org-string">"nil"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">String </span>
            is <span class="org-constant">Ast</span>.AstStr  -&gt; <span class="org-string">"\""</span> + r.value + <span class="org-string">"\""</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">List </span>
            is <span class="org-constant">Ast</span>.AstLst  -&gt; <span class="org-string">"("</span> + r.value.map <span class="org-rainbow-delimiters-depth-3">{</span> toStr<span class="org-rainbow-delimiters-depth-4">(</span>it<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>.joinToString<span class="org-rainbow-delimiters-depth-3">(</span> separator = <span class="org-string">" "</span><span class="org-rainbow-delimiters-depth-3">)</span> + <span class="org-string">")"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Runtime error </span>
            is <span class="org-constant">Ast</span>.AstErr  -&gt; <span class="org-string">"EROR: "</span> + r.value 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Environment - contains bindings between variables and values </span>
            is <span class="org-constant">Ast</span>.AstEnv  -&gt; <span class="org-string">"&lt;Env: ${r.env}&gt;"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Primitive function </span>
            is <span class="org-constant">Ast</span>.AstFunc    -&gt; <span class="org-string">"&lt;FuncPRM: ${r.name}&gt;"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">User-defined function </span>
            is <span class="org-constant">Ast</span>.AstFuncUDF -&gt; <span class="org-string">"&lt;FuncUDF: ${r.name}&gt;"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Java Object </span>
            is <span class="org-constant">Ast</span>.AstObj -&gt;  <span class="org-rainbow-delimiters-depth-3">{</span> 
                <span class="org-comment-delimiter">// </span><span class="org-comment">val klass = r.value::class.java.getName() </span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">"&lt;Object: ${klass}&gt;" </span>
                <span class="org-string">"&lt;Obj: ${r.value}&gt;"</span>
            <span class="org-rainbow-delimiters-depth-3">}</span>
            <span class="org-comment-delimiter">//</span><span class="org-comment">else       -&gt; "Not implemented"</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">parse</span><span class="org-rainbow-delimiters-depth-2">(</span>source: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val p = Parser<span class="org-rainbow-delimiters-depth-3">(</span>source<span class="org-rainbow-delimiters-depth-3">)</span>
        val ast = p.parseSexp<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">return</span> ast 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether two S-Expressions are equal</span>
    <span class="org-type">fun</span> <span class="org-function-name">equal</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs: Ast, rhs: Ast<span class="org-rainbow-delimiters-depth-2">)</span>: Boolean
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> != rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> rhs.isAtom<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; lhs.isAtom<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-type">val</span> <span class="org-variable-name">t</span> = rhs.type<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">if</span>      <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.INT  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toInt<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toInt<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.FLT  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toFlt<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toFlt<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.STR  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.SYM  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.KEY  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.ERR  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toStr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.BOOL <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> lhs.toBool<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.toBool<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.NIL  <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> t == <span class="org-constant">AstType</span>.VOID <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span> <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Edge case reached not implemented for =&gt; lhs = ${lhs} and rhs ${rhs}"</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">AstType</span>.LST <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-type">val</span> <span class="org-variable-name">a</span> = lhs.nodes<span class="org-rainbow-delimiters-depth-4">()</span>
            val b = rhs.nodes<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a.size != b.size<span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">n</span> <span class="org-function-name">in</span> 0..<span class="org-rainbow-delimiters-depth-5">(</span>a.size - 1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>equal<span class="org-rainbow-delimiters-depth-6">(</span>a<span class="org-rainbow-delimiters-depth-7">[</span>n<span class="org-rainbow-delimiters-depth-7">]</span>, b<span class="org-rainbow-delimiters-depth-7">[</span>n<span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span>  <span class="org-keyword">return</span> <span class="org-constant">false</span> <span class="org-rainbow-delimiters-depth-5">}</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">return</span> <span class="org-constant">true</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">throw</span> Exception<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Reached edge case =&gt; This exception is never supposed to be thrown."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Evaluator</span> <span class="org-rainbow-delimiters-depth-1">{</span>

    var logOnError = <span class="org-constant">false</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Default environment</span>
    val _env =  <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Special forms </span>
    val _forms = mutableMapOf&lt;<span class="org-type">String</span>, <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Ast&gt;<span class="org-rainbow-delimiters-depth-2">()</span>

    init <span class="org-rainbow-delimiters-depth-2">{</span>
        _env.name = <span class="org-string">"global"</span>
        reset<span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">this</span>._env.reset<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">---- Register primitive special forms --------------//</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Sepcial form for updating an already defined variable </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"set"</span>,   <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_set<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Special form for defining a new  variable </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"def"</span>,   <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_def<span class="org-rainbow-delimiters-depth-5">(</span>args, env <span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">}</span>  <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">If-else special form </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"if"</span>,    <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_if<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Function defintion or lambda special form </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"fn"</span>,    <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_fn<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Quote (quote (args ...)) sepcial form </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"quote"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_quote<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Do special-form borrowed from Clojure: (do (println "x") (println "z") (+ x  y z)) </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"do"</span>,    <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_do<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Call object default constructor (new javax.swing.Swing.JFrame)</span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"new"</span>,   <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_new<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Clojure-like doto special form </span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"doto"</span>,  <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_doto<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">//</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">---- Register primitive functions ------------------ //</span>
          <span class="org-comment-delimiter">/// </span><span class="org-comment">addFuncMathMany("+",     { a, b -&gt; a + b })</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"+"</span>,           ::primitive_add<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"-"</span>,           ::primitive_sub<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"*"</span>,           ::primitive_mul<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"/"</span>,           ::primitive_div<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"eval"</span>,        ::primitive_eval<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"load-script"</span>, ::primitive_loadScript<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"read"</span>,        ::primitive_read<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"list"</span>,        <span class="org-rainbow-delimiters-depth-4">{</span> args -&gt; <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-5">(</span>args<span class="org-rainbow-delimiters-depth-5">)</span>  <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"car"</span>,      ::primitive_car <span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cdr"</span>,      ::primitive_cdr <span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cons"</span>,     ::primitive_cons <span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"first"</span>,    ::primitive_car <span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"rest"</span>,     ::primitive_cdr <span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"nth"</span>,      ::primitive_nth <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Apply a function over a list </span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"apply"</span>,    ::primitive_apply<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Map a function over list </span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"map"</span>,      ::primitive_map <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Get element of a plist (property list) that matches a keyword argument</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(getf :x (list :z 200 :h 300 :x "hello")) =&gt; returns "hello"</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"getf"</span>,     ::primitive_getf<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Concatenate strings </span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"concat"</span>,   ::primitive_concat<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">addPrimitive("for-each", ::primitive_foreach )</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"println"</span>,  ::primitive_println <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/sin"</span>,     <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.sin<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/cos"</span>,     <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.cos<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/tan"</span>,     <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.tan<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/exp"</span>,     <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.exp<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/sqrt"</span>,    <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.sqrt<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/log"</span>,     <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.log<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        addMath1Arg<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/log10"</span>,   <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Math.log10<span class="org-rainbow-delimiters-depth-5">(</span>it<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Show all avaialabe methods of a Java object AstObj</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ref/show-methods"</span>,  ::primitive_showMethods <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Get a java class meta-object by its name as string </span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ref/class-by-name"</span>, ::primitive_getClassByName <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Get class meta-object of a java object </span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ref/get-obj-class"</span>, ::primitive_getObjClass <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">Cast a java object to an interface by reflection </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(ref/cast java.awt.Container object-here-Ast.AstObj)</span>
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ref/cast"</span>,         <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_cast<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        addSpecialForm<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"ref/static-field"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> args, env -&gt; <span class="org-keyword">this</span>.form_staticField<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>   <span class="org-rainbow-delimiters-depth-3">)</span> 
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"action-listener"</span>, ::primitive_toActionListener<span class="org-rainbow-delimiters-depth-3">)</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"java-null"</span>, ::primitive_javaNull<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">PI constant </span>
        set<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"m/PI"</span>, <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">(</span> 3.141592653589793<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Variable that references this environment object </span>
        set<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"env"</span>, _env<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Eval AST (Abstract Syntax Tree) by walking over it </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">and generate a interpreter runtime value </span>
    <span class="org-type">fun</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span>s: Ast, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast = when<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">){</span>
        is <span class="org-constant">Ast</span>.AstErr     -&gt; s 
        is <span class="org-constant">Ast</span>.AstVoid    -&gt; s 
        is <span class="org-constant">Ast</span>.AstBool    -&gt; s 
        is <span class="org-constant">Ast</span>.AstFlt     -&gt; s 
        is <span class="org-constant">Ast</span>.AstInt     -&gt; s  
        is <span class="org-constant">Ast</span>.AstKey     -&gt; s 
        is <span class="org-constant">Ast</span>.AstNil     -&gt; s 
        is <span class="org-constant">Ast</span>.AstStr     -&gt; s 
        is <span class="org-constant">Ast</span>.AstSym     -&gt; <span class="org-rainbow-delimiters-depth-3">{</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE]  envName = ${env.name} ; Evaluator.get =&gt;&gt; ${s}  \n")</span>
            env.get<span class="org-rainbow-delimiters-depth-4">(</span>s.toStr<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span> ?: <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: (line 549) unbound symbol ${s.toStr()} in ${env.name}"</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-function-name">AstEnv</span>     -&gt; s 
        is <span class="org-constant">Ast</span>.AstFunc    -&gt; s
        is <span class="org-constant">Ast</span>.AstFuncUDF -&gt; s
        is <span class="org-constant">Ast</span>.AstObj     -&gt; s 
        is <span class="org-constant">Ast</span>.AstLst     -&gt; evalApp<span class="org-rainbow-delimiters-depth-3">(</span>env, s<span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span>source: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val ast = Sexp.parse<span class="org-rainbow-delimiters-depth-3">(</span>source<span class="org-rainbow-delimiters-depth-3">)</span>
        val res = eval<span class="org-rainbow-delimiters-depth-3">(</span>ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span>ast: Ast<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val res = eval<span class="org-rainbow-delimiters-depth-3">(</span>ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-type">fun</span> <span class="org-function-name">loadScript</span><span class="org-rainbow-delimiters-depth-2">(</span>fileName: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var source: String? = <span class="org-constant">null</span> 
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            source = <span class="org-constant">java</span>.<span class="org-constant">io</span>.File<span class="org-rainbow-delimiters-depth-4">(</span>fileName<span class="org-rainbow-delimiters-depth-4">)</span>.inputStream<span class="org-rainbow-delimiters-depth-4">()</span>.readBytes<span class="org-rainbow-delimiters-depth-4">()</span>.toString<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Charsets</span>.UTF_8<span class="org-rainbow-delimiters-depth-4">)</span>  
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">io</span>.FileNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        source = <span class="org-string">"(do\n"</span> + source + <span class="org-string">"\n)"</span>
        val ast = Sexp.parse<span class="org-rainbow-delimiters-depth-3">(</span>source<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ast.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> ast <span class="org-rainbow-delimiters-depth-3">}</span>   
        <span class="org-type">val</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get value from environment </span>
    <span class="org-type">fun</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast?
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> _env.get<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Set value in environment </span>
    <span class="org-type">fun</span> <span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String, value: Ast<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        _env.set<span class="org-rainbow-delimiters-depth-3">(</span>name, value<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Interactive Read-Print-Eval-Loop</span>
    <span class="org-type">fun</span> <span class="org-function-name">repl</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val sc = <span class="org-constant">java</span>.<span class="org-constant">util</span>.Scanner<span class="org-rainbow-delimiters-depth-3">(</span>System.`in`<span class="org-rainbow-delimiters-depth-3">)</span>

        var count = 0

        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">){</span>
           System.out.print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" In[${count}]&gt; "</span><span class="org-rainbow-delimiters-depth-4">)</span>
           System.out.flush<span class="org-rainbow-delimiters-depth-4">()</span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">val line = sc.nextLine()</span>
           var line = readLine<span class="org-rainbow-delimiters-depth-4">()</span> ?: <span class="org-string">""</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".h"</span><span class="org-rainbow-delimiters-depth-4">){</span>
            println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"""</span>
<span class="org-string">            The interpreter has the following commands:</span>
<span class="org-string">              + .h or .help  =&gt; To display this help menu.</span>
<span class="org-string">              + .q or .quit  =&gt; To quit the interpreter.</span>
<span class="org-string">              + .multi       =&gt; To paste multi-line S-Expression in the repl </span>
<span class="org-string">              + .reset or .r =&gt; To reset the interpreter state </span>
<span class="org-string">              + .vars        =&gt; To display all variables </span>
<span class="org-string">              + .funcs       =&gt; To show all functions </span>
<span class="org-string">              + .verbose-on  =&gt; Enable verbose mode </span>
<span class="org-string">              + .verbose-off =&gt; Disable verbose mode </span>
<span class="org-string">            </span>
<span class="org-string">            """</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-keyword">continue</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".verbose-on"</span><span class="org-rainbow-delimiters-depth-4">){</span> 
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [INFO] Verbose mode enabled."</span><span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">this</span>.logOnError = <span class="org-constant">true</span> 
                <span class="org-keyword">continue</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".verbose-off"</span><span class="org-rainbow-delimiters-depth-4">){</span> 
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [INFO] Verbose mode disabled."</span><span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">this</span>.logOnError = <span class="org-constant">true</span> 
                <span class="org-keyword">continue</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".quit"</span> || line == <span class="org-string">".q"</span><span class="org-rainbow-delimiters-depth-4">){</span> System.exit<span class="org-rainbow-delimiters-depth-5">(</span>0<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-keyword">break</span> <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".reset"</span> || line == <span class="org-string">".r"</span><span class="org-rainbow-delimiters-depth-4">){</span> 
                <span class="org-keyword">this</span>.reset<span class="org-rainbow-delimiters-depth-5">()</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [INFO] Reset repl. All variables removed. Ok."</span><span class="org-rainbow-delimiters-depth-5">)</span> 
                <span class="org-keyword">continue</span> 
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".multi"</span><span class="org-rainbow-delimiters-depth-4">){</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [INFO] Type a multi-line expression and then type (;;) when you are done."</span><span class="org-rainbow-delimiters-depth-5">)</span>
                var entry = <span class="org-string">""</span>
                <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-5">){</span>
                    val lin = readLine<span class="org-rainbow-delimiters-depth-6">()</span> ?: <span class="org-string">""</span>
                    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span>lin == <span class="org-string">";;"</span><span class="org-rainbow-delimiters-depth-6">){</span> <span class="org-keyword">break</span> <span class="org-rainbow-delimiters-depth-6">}</span>
                    entry = entry + lin  
                <span class="org-rainbow-delimiters-depth-5">}</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [INFO] Exit multi-line mode. "</span><span class="org-rainbow-delimiters-depth-5">)</span>
                line = entry 
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Display all defined variables in current environment </span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".vars"</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" =&gt;&gt; Variables: "</span><span class="org-rainbow-delimiters-depth-5">)</span>
                _env.env.forEach<span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-rainbow-delimiters-depth-6">(</span>k, v<span class="org-rainbow-delimiters-depth-6">)</span> -&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-negation-char">!</span>v.isCallable<span class="org-rainbow-delimiters-depth-7">()</span><span class="org-rainbow-delimiters-depth-6">){</span> println<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">" "</span> + k<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-6">}</span> <span class="org-rainbow-delimiters-depth-5">}</span> 
                <span class="org-keyword">continue</span> 
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Display all defined functions in current environment </span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">".funcs"</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" =&gt;&gt; Functions: "</span><span class="org-rainbow-delimiters-depth-5">)</span>
                _env.env.forEach<span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-rainbow-delimiters-depth-6">(</span>k, v<span class="org-rainbow-delimiters-depth-6">)</span> -&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span> v.isCallable<span class="org-rainbow-delimiters-depth-7">()</span><span class="org-rainbow-delimiters-depth-6">){</span> println<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">" "</span> + k<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-6">}</span> <span class="org-rainbow-delimiters-depth-5">}</span> 
                <span class="org-keyword">continue</span> 
            <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-type">val</span> <span class="org-variable-name">result</span> = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>line<span class="org-rainbow-delimiters-depth-4">)</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> result.isErr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>
               println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: "</span> + result.toStr<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>
               <span class="org-keyword">continue</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">History variables $0, $1, $2, ... </span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">containing the evaluation results of </span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">previous inputs entered by the user </span>
           <span class="org-type">val</span> <span class="org-variable-name">label</span> = <span class="org-string">"\$${count}"</span>
           println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" ${label} = "</span> + Sexp.toStr<span class="org-rainbow-delimiters-depth-5">(</span>result<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
           count += 1
           <span class="org-comment-delimiter">// </span><span class="org-comment">Variable answer always contains the result </span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">of the last computation </span>
           <span class="org-keyword">this</span>.set<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"ans"</span>, result<span class="org-rainbow-delimiters-depth-4">)</span>
           <span class="org-keyword">this</span>.set<span class="org-rainbow-delimiters-depth-4">(</span>label, result<span class="org-rainbow-delimiters-depth-4">)</span>           
        <span class="org-rainbow-delimiters-depth-3">}</span>
        
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate application of function or special form </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(function-or-form arg0 arg1 ... argN-1)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">evalApp</span><span class="org-rainbow-delimiters-depth-2">(</span>env: <span class="org-constant">Ast</span>.AstEnv, lst: Ast<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">head</span> = lst.head<span class="org-rainbow-delimiters-depth-3">()</span>
        val args = lst.tail<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> head <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstSym</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            val x = head.toStr<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>x == <span class="org-string">"comment"</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstVoid
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> _forms.contains<span class="org-rainbow-delimiters-depth-5">(</span>x<span class="org-rainbow-delimiters-depth-5">)</span>  <span class="org-rainbow-delimiters-depth-4">){</span>
                val handler = _forms<span class="org-negation-char">!</span>!.get<span class="org-rainbow-delimiters-depth-5">(</span>x<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">Apply Special form </span>
                val res =  handler<span class="org-negation-char">!</span>!.invoke<span class="org-rainbow-delimiters-depth-5">(</span>args, env<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">return</span> res 
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check whether argument is function </span>
        <span class="org-type">val</span> <span class="org-variable-name">obj</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>head, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Abort computation on error </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> obj.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> obj <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Check whether object is a Java object (instance of a Java class)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> obj.isObj<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Perform method call</span>
            val r = invokeObjectMethod<span class="org-rainbow-delimiters-depth-4">(</span>obj <span class="org-type">as</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstObj</span>, args, env<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> r 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Abort computation if object is not callable</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>obj.isCallable<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Object not callable ${head}"</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">res</span> = funCall<span class="org-rainbow-delimiters-depth-3">(</span>env, obj, args<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Handle function call and evalute all arguments before function application.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">funCall(environment, function, list-of-arguments)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">funCall</span><span class="org-rainbow-delimiters-depth-2">(</span>env: <span class="org-constant">Ast</span>.AstEnv, obj: Ast, args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val evaluatedArgs = mutableListOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate arguments and abort evaluation on error </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>arg <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span>
           val r = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>arg, env<span class="org-rainbow-delimiters-depth-4">)</span> 
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> r.isVoid<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> r.isErr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> r<span class="org-rainbow-delimiters-depth-4">}</span>
           evaluatedArgs.add<span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">---- Evaluation of primtive function call in host language -------- //</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object is primtive function (defined in host language) </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>obj <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFunc</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TACE] Call primitive function ${obj}")</span>
            val func = obj as <span class="org-constant">Ast</span>.AstFunc
            val result = func.func<span class="org-rainbow-delimiters-depth-4">(</span>evaluatedArgs<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> result 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">------_ Evaluation of user-defined function call -----------// </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object is UDF - User-Defined Function  </span>
        <span class="org-type">val</span> <span class="org-variable-name">func</span> = obj as <span class="org-constant">Ast</span>.AstFuncUDF
        val nargs = func.args.size  
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>nargs != args.size <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Invalid number of arguments passed to function. It expects $nargs arguments. "</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Create temporary environment for function evaluation</span>
        <span class="org-type">val</span> <span class="org-variable-name">tenv</span> = <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-3">(</span>func.env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Set arguments in the temporary environment </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">k</span> <span class="org-function-name">in</span> <span class="org-rainbow-delimiters-depth-4">(</span>0..<span class="org-rainbow-delimiters-depth-5">(</span>nargs - 1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span>
            val argName = func.args<span class="org-rainbow-delimiters-depth-4">[</span>k<span class="org-rainbow-delimiters-depth-4">]</span>
            tenv.set<span class="org-rainbow-delimiters-depth-4">(</span>argName, evaluatedArgs<span class="org-rainbow-delimiters-depth-5">[</span>k<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">last</span>: Ast = <span class="org-constant">Ast</span>.AstNil
        <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate function body and return evaluation of last form</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>form <span class="org-type">in</span> func.<span class="org-variable-name">body</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            last = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>form, tenv<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">abort evaluation on error</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>last.isErr<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> last <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> last
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">error</span><span class="org-rainbow-delimiters-depth-2">(</span>message: String<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">this</span>.logOnError<span class="org-rainbow-delimiters-depth-3">){</span> System.err.println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [ERROR] "</span> + message<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-3">(</span>message<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add primitive function </span>
    <span class="org-type">fun</span> <span class="org-function-name">addPrimitive</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String, func: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">List</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; Ast<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        _env.set<span class="org-rainbow-delimiters-depth-3">(</span>name, <span class="org-constant">Ast</span>.AstFunc<span class="org-rainbow-delimiters-depth-4">(</span>name, func<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Register primitive math function of 1 argument </span>
    <span class="org-type">fun</span> <span class="org-function-name">addMath1Arg</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String, func: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Double</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; Double<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val func = <span class="org-rainbow-delimiters-depth-3">{</span> args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span> -&gt; 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-4">){</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Function ${name} expects 1 argument. "</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>.isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Expected numeric argument"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-type">val</span> <span class="org-variable-name">a</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>.toFlt<span class="org-rainbow-delimiters-depth-5">()</span>
                val r = func<span class="org-rainbow-delimiters-depth-5">(</span>a<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> r <span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        addPrimitive<span class="org-rainbow-delimiters-depth-3">(</span>name, func<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add special form (macro or control structure)</span>
    <span class="org-type">fun</span> <span class="org-function-name">addSpecialForm</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String, form: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">List</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>, <span class="org-constant">Ast</span>.<span class="org-type">AstEnv</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; Ast<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        _forms.put<span class="org-rainbow-delimiters-depth-3">(</span>name, form<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">----- Functions and special forms called by the interpreter --------//</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add math function of many arguments that is evaluated as:</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(func a b c d e f g h ...) = </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">a func b func c func d func e ... </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">func(a, func(b, func(c, func(e, ...))))</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">For instance: '+'</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(+ 10 2 5 6) = 10 + 2 + 5 + 6</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">addFuncMathMany</span><span class="org-rainbow-delimiters-depth-2">(</span>name: String, func: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Double</span>, <span class="org-type">Double</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; Double<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val value = <span class="org-constant">Ast</span>.AstFunc<span class="org-rainbow-delimiters-depth-3">(</span>name, <span class="org-rainbow-delimiters-depth-4">{</span> args -&gt; fold1<span class="org-rainbow-delimiters-depth-5">(</span>func, args<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        _env.set<span class="org-rainbow-delimiters-depth-3">(</span>name, value<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">fold1</span><span class="org-rainbow-delimiters-depth-2">(</span>func: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Double</span>, <span class="org-type">Double</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; Double, args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstErr<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function expects at leat 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span> 
       <span class="org-type">val</span> <span class="org-variable-name">head</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>  <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>head <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> || head is <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> 
          <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function requires numeric argument, given ${head}."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
       <span class="org-rainbow-delimiters-depth-3">}</span>
       <span class="org-type">var</span> <span class="org-variable-name">acc</span> = head.toFlt<span class="org-rainbow-delimiters-depth-3">()</span>
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">k</span> <span class="org-function-name">in</span> 1..<span class="org-rainbow-delimiters-depth-4">(</span>args.size - 1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span>
          val a = args<span class="org-rainbow-delimiters-depth-4">[</span>k<span class="org-rainbow-delimiters-depth-4">]</span>
          <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>  <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-5">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> || a is <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">)</span>  <span class="org-rainbow-delimiters-depth-4">){</span> 
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Error: function requires numeric argument, given ${a}."</span><span class="org-rainbow-delimiters-depth-5">)</span> 
          <span class="org-rainbow-delimiters-depth-4">}</span>
          <span class="org-type">val</span> <span class="org-variable-name">x</span> = a.toFlt<span class="org-rainbow-delimiters-depth-4">()</span>
          acc = func<span class="org-rainbow-delimiters-depth-4">(</span>acc, x<span class="org-rainbow-delimiters-depth-4">)</span>
       <span class="org-rainbow-delimiters-depth-3">}</span>
       <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-3">(</span>acc<span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Read S-expression from string  </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_read</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function read() requires 1 (one) agument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function read() expects 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">code</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        val ast  = Sexp.parse<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> ast
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_eval</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function eval() requires 1 (one) agument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">result</span>  = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>, _env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> result
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Get list head </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_car</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function 'car' requires at least 1 (one) agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function car expects 'list' argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">lst</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> as <span class="org-constant">Ast</span>.AstLst
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lst.isNil<span class="org-rainbow-delimiters-depth-4">()</span> || lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The rendudant variable is 'r' is useful for debugging </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">since debuggers work in a line by line manner.</span>
        <span class="org-type">val</span> <span class="org-variable-name">r</span> = lst.head<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">return</span> r
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get list tail </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_cdr</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function 'car' requires at least 1 (one) agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function car expects list argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">lst</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> as <span class="org-constant">Ast</span>.AstLst
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lst.isNil<span class="org-rainbow-delimiters-depth-4">()</span> || lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The rendudant variable is 'r' is useful for debugging </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">since debuggers work in a line by line manner.</span>
        <span class="org-type">val</span> <span class="org-variable-name">r</span> = <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-3">(</span>lst.tail<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> r 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_cons</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 2<span class="org-rainbow-delimiters-depth-3">)</span>      <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function 'cons' requires at least 2 agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isAtom<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function cons() expects first argument be an atom."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function cons() expects second argument be a list or nil."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">result</span> = listOf<span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span>.plus<span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.nodes<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>  
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-3">(</span>result<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get nth element of a list </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(nth 0 lst) =&gt; Get element of list 'lst'</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_nth</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 2<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function 'nth' requires at least 2  agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function nth expects number as 1st argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.isList<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function nth expects list as 2nd argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">n</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toInt<span class="org-rainbow-delimiters-depth-3">()</span>
        val lst = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span> as <span class="org-constant">Ast</span>.AstLst
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lst.isNil<span class="org-rainbow-delimiters-depth-4">()</span> || lst.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>n &gt;= lst.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: out of bounds access."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">r</span> = lst.nth<span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> r 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Apply =&gt; Apply a function to a list of arguments</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(apply + (list 1 2 3 5 6))</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">( (fn (x y) (+ x y))  (list 3 5)) =&gt; 7</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_apply</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 2<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function apply() requires at least 2  agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isCallable<span class="org-rainbow-delimiters-depth-4">()</span>    <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function apply() expects a function as 1st argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function apply() expects a list as 2nd argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">res</span> = funCall<span class="org-rainbow-delimiters-depth-3">(</span>_env, args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>, args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.nodes<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Example: (+ 1 2 5 100.252)</span>
    <span class="org-type">fun</span> <span class="org-function-name">primitive_add</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function + (add) expects at least 1 argument. No argument was given."</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">result</span>: Ast = <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-3">(</span>0<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>x <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>x.isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Function + (add) expects number argument"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-5">(</span> result.toInt<span class="org-rainbow-delimiters-depth-6">()</span> + x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> + x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span> <span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> + x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">primitive_sub</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function - (sub) expects at least 1 argument. No argument was given."</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">result</span>: Ast = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>result.isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function (sub) arguments must be numbers."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">i</span> <span class="org-function-name">in</span> 1..<span class="org-rainbow-delimiters-depth-4">(</span>args.size - 1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span>
            val x = args<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>x.isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Function - (sub) expects number argument"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-5">(</span> result.toInt<span class="org-rainbow-delimiters-depth-6">()</span> - x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> - x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span> <span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> - x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">primitive_mul</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function * (mul) expects at least 1 argument. No argument was given."</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">result</span>: Ast = <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-3">(</span>1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>x <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>x.isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Function * (mul) expects number argument"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-5">(</span> result.toInt<span class="org-rainbow-delimiters-depth-6">()</span> * x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> &amp;&amp; result is <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> * x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> x <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span> <span class="org-rainbow-delimiters-depth-4">){</span>  result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-5">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-6">()</span> * x.value <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">primitive_div</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function '/' (div) expects at least 1 argument. No argument was given."</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">var</span> <span class="org-variable-name">result</span>: Ast = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>result.isNum<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function '/' arguments must be numbers."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">i</span> <span class="org-function-name">in</span> 1..<span class="org-rainbow-delimiters-depth-4">(</span>args.size - 1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">){</span>
            val x = args<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>x.isNum<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Function - '/' expects number argument"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            result = <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">(</span> result.toFlt<span class="org-rainbow-delimiters-depth-5">()</span> / x.toFlt<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_map</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 2<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function apply() requires at least 2  agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isCallable<span class="org-rainbow-delimiters-depth-4">()</span>    <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function apply() expects a function as 1st argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function apply() expects a list as 2nd argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">func</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        val lst = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>.nodes<span class="org-rainbow-delimiters-depth-3">()</span>
        val result = mutableListOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">n</span> <span class="org-type">in</span> <span class="org-variable-name">lst</span><span class="org-rainbow-delimiters-depth-3">){</span>
            val r = <span class="org-keyword">this</span>.funCall<span class="org-rainbow-delimiters-depth-4">(</span>_env, func, listOf<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>n<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>r.isErr<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> r<span class="org-rainbow-delimiters-depth-4">}</span>
            result.add<span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-3">(</span>result<span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Concatenate the string representation of arguments </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_concat</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var s = <span class="org-string">""</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>a <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstStr</span><span class="org-rainbow-delimiters-depth-4">){</span> 
                s = s  + a.toStr<span class="org-rainbow-delimiters-depth-5">()</span>
                <span class="org-keyword">continue</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            s = s + Sexp.toStr<span class="org-rainbow-delimiters-depth-4">(</span>a<span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">result</span> = <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-3">(</span>s<span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Example: (getf :title (:x 100 :y 300 :title "hello")) =&gt; result: "hello"</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span>  <span class="org-function-name">primitive_getf</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 2<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function getf() requires at least 2  agument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-4">)</span>   <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function getf() expects a function as 1st argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>1<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function getf() expects a list as 2nd argument. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.size<span class="org-rainbow-delimiters-depth-4">()</span> == 0 || args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">key</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        val lst = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>.nodes<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">i</span> <span class="org-function-name">in</span> 0..<span class="org-rainbow-delimiters-depth-4">(</span>lst.size - 1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>i + 1 == lst.size<span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil<span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>lst<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstKey &amp;&amp; lst<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span>.toStr<span class="org-rainbow-delimiters-depth-5">()</span> == key<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> lst<span class="org-rainbow-delimiters-depth-5">[</span>i + 1<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Show methods of a Java objects =&gt; This function is intended for interactive use </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example: </span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(set obj (new javax.swing.JFrame))</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(reflect/show-methods obj)           =&gt; Display all object methods </span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(reflect/show-methods obj "method")  =&gt; Display all object methods containing the string method</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_showMethods</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size &lt; 1 || args.size &gt; 2<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function requires 1 agument of AstObj."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isObj<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function requires 1 argument of type AstObj."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">obj</span> = <span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> as <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-3">)</span>.value::<span class="org-keyword">class</span>.java
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size == 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span>m <span class="org-type">in</span> obj.<span class="org-function-name">getMethods</span><span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> println<span class="org-rainbow-delimiters-depth-5">(</span>m<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.isStr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> 
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Expected string as second argument"</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">search</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>m <span class="org-type">in</span> obj.<span class="org-function-name">getMethods</span><span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> 
            val s = m.toString<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> s.contains<span class="org-rainbow-delimiters-depth-5">(</span>search, ignoreCase  =  <span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span> println<span class="org-rainbow-delimiters-depth-5">(</span>s<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_getClassByName</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function requires 1 agument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span> is <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function requires 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">className</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>

        <span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-3">{</span>
            val cls = Class.forName<span class="org-rainbow-delimiters-depth-4">(</span>className<span class="org-rainbow-delimiters-depth-4">)</span> 
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-4">(</span>cls <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.ClassNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_getObjClass</span> <span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size != 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Error: function reflect/get-obj-class() requires 1 agument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isObj<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function requires 1 argument of type AstObj."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">cls</span> = <span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> as <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-3">)</span>.value::<span class="org-keyword">class</span>.java
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-3">(</span>cls <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">// For-each =&gt; Apply a function with side-effect to each element of a list </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">// (for-each print (list 1 2 5 10))</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">private fun primitive_foreach(args: List&lt;Ast&gt;): Ast</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">{</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">if(args.size != 2){ return error("Error: function 'for-each' requires at least 2  agument.") }</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">if( !(args[0].isCallable() ){ return error("Function for-each expects a function as 1st argument. ") }</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">return r </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">(print "string ..."  arg1 arg2 ... argN-1) </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_println</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>a <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">if</span>     <span class="org-rainbow-delimiters-depth-4">(</span> a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstStr</span> <span class="org-rainbow-delimiters-depth-4">){</span> System.out.print<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span> <span class="org-rainbow-delimiters-depth-4">){</span> System.out.print<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span> <span class="org-rainbow-delimiters-depth-4">){</span> System.out.print<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstBool</span><span class="org-rainbow-delimiters-depth-4">){</span> Sexp.toStr<span class="org-rainbow-delimiters-depth-5">(</span>a<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstNil</span><span class="org-rainbow-delimiters-depth-4">){</span> System.out.print<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"nil"</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span> System.out.print<span class="org-rainbow-delimiters-depth-5">(</span>Sexp.toStr<span class="org-rainbow-delimiters-depth-6">(</span>a<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            System.out.print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" "</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        System.out.print<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"\n"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function used to pass lambda to arguments of type java.awt.event.ActionListener </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example:   </span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(set btn (doto (new javax.swing.JButton) (setLabel "hello"))</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(btn addActionListener </span>
    <span class="org-comment-delimiter">//                   </span><span class="org-comment">(action-listener (fn () (println "clicked") )))</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_toActionListener</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size != 1 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function expects 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isCallable<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function expectes 1 argument of type function."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">import java.awt.event.ActionEvent;</span>
            <span class="org-comment-delimiter">//  </span><span class="org-comment">import java.awt.event.ActionListener;</span>
        <span class="org-type">val</span> <span class="org-variable-name">self</span> = <span class="org-keyword">this</span> 
        val listener = object: <span class="org-constant">java</span>.<span class="org-constant">awt</span>.<span class="org-constant">event</span>.ActionListener <span class="org-rainbow-delimiters-depth-3">{</span>
            override fun actionPerformed<span class="org-rainbow-delimiters-depth-4">(</span>evt: <span class="org-constant">java</span>.<span class="org-constant">awt</span>.<span class="org-constant">event</span>.ActionEvent<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                self.funCall<span class="org-rainbow-delimiters-depth-5">(</span>self._env, args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>, listOf<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">ret</span> =  <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-3">(</span>listener <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> ret
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Return a Java Null object </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_javaNull</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size !=0 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function expects 0 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">val ret = Ast.AstObj(null)</span>
        <span class="org-type">val</span> <span class="org-variable-name">ret</span> = <span class="org-constant">Ast</span>.AstNil
        <span class="org-keyword">return</span> ret
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Load file  (load-script "script.jlsp") </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">primitive_loadScript</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size != 1 &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isStr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Function expects 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">fileName</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        var source: String? = <span class="org-constant">null</span> 
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            source = <span class="org-constant">java</span>.<span class="org-constant">io</span>.File<span class="org-rainbow-delimiters-depth-4">(</span>fileName<span class="org-rainbow-delimiters-depth-4">)</span>.inputStream<span class="org-rainbow-delimiters-depth-4">()</span>.readBytes<span class="org-rainbow-delimiters-depth-4">()</span>.toString<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Charsets</span>.UTF_8<span class="org-rainbow-delimiters-depth-4">)</span>  
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">io</span>.FileNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [========&gt;&gt;&gt; Loaded Code &lt;&lt;&lt;============]"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        println<span class="org-rainbow-delimiters-depth-3">(</span>source<span class="org-rainbow-delimiters-depth-3">)</span>
        source = <span class="org-string">"(do\n"</span> + source + <span class="org-string">"\n)"</span>
        val ast = Sexp.parse<span class="org-rainbow-delimiters-depth-3">(</span>source<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ast.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> ast <span class="org-rainbow-delimiters-depth-3">}</span>   
        <span class="org-type">val</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>

        <span class="org-keyword">return</span> res 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Update an aready existing variablr </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Special form set =&gt; (set x (+ 1 2 4  6))</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example: (def x 100) (set x (+ x 1)) ...</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_set</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size != 2 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form set. Expected 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'set'. Expected symbol as first argument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">name</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        val expr = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>env.has<span class="org-rainbow-delimiters-depth-4">(</span>name<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Unbound variable ${name}"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">result</span> = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>expr, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> result.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> result <span class="org-rainbow-delimiters-depth-3">}</span>
        env.setExisting<span class="org-rainbow-delimiters-depth-3">(</span>name, result<span class="org-rainbow-delimiters-depth-3">)</span>                
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Define a new variable </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(def x 2000)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_def</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size != 2 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form def. Expected 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">name</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>name.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'def'. Expected symbol as first argument."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">expr</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>
        val result = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>expr, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> result.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> result <span class="org-rainbow-delimiters-depth-3">}</span>
        env.set<span class="org-rainbow-delimiters-depth-3">(</span>name.toStr<span class="org-rainbow-delimiters-depth-4">()</span>, result<span class="org-rainbow-delimiters-depth-3">)</span>                
        <span class="org-keyword">return</span> result 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Quote special form '(+ 1 2 3) or (quote (+ 1 2 3))</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_quote</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size != 1 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'quote'. Expected 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">expr</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-keyword">return</span> expr 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Special form 'do' - equivalent to 'begin' in Scheme.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(do (println x) (println y) (+ x y z)) </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_do</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var result: Ast = <span class="org-constant">Ast</span>.AstNil
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>form <span class="org-type">in</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">){</span>
            result = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>form, env<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> result
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">IF-else special form: </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt;&gt; (if &lt;cond&gt; &lt;then&gt;) or </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt;&gt; (if &lt;cond&gt; &lt;then&gt; &lt;else&gt;)</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(if (&gt; x 10) (print "greater than 10") (print "less than 10"))</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(+ z (if (&gt; x 10)  (* 3 x) (+ 10 x ) ))</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_if</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 2 || args.size &gt; 3<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form if-else. Expected at least 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">cond</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate condition/predicate </span>
        val cond_result = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>cond, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Short-circuit - abort computation on error </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>cond_result.isErr<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> cond_result<span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>cond_result.asBool<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span>
            val then_ast = args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>
            val then_result = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>then_ast, env<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> then_result 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size == 2 <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">else_ast</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>2<span class="org-rainbow-delimiters-depth-3">]</span>        
        val else_result = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>else_ast, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> else_result
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Lambda special form FN =&gt; function definition or lambda</span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">Lambda function    =&gt;&gt; (fn (x) (+ x  1))</span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">Function defintion =&gt;&gt; (fn increment (x) (+ x 1))</span>
    <span class="org-comment-delimiter">// </span>
    <span class="org-comment-delimiter">//   </span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_fn</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size &lt; 2<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed syntax for lambda. The function requires at least 2 arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">n</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Function name </span>
        val name = <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>n.isSym<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> n.toStr<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">else</span> <span class="org-string">""</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">List of arguments </span>
        val pargs =  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>n.isSym<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span> <span class="org-keyword">else</span> n 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-4">(</span>pargs <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstLst</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Special form FN expected list of arguments."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">_args</span> = pargs.nodes<span class="org-rainbow-delimiters-depth-3">()</span>.map <span class="org-rainbow-delimiters-depth-3">{</span>  it.toStr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">k</span> = <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>n.isSym<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> 2 <span class="org-keyword">else</span> 1
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] name = ${name}  ; args = ${_args}")</span>
        val body = mutableListOf<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>  
        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">i</span> <span class="org-type">in</span> <span class="org-function-name">k</span>..<span class="org-rainbow-delimiters-depth-4">(</span>args.size - 1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> body.add<span class="org-rainbow-delimiters-depth-4">(</span>  args<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">User-defined function </span>
        <span class="org-type">val</span> <span class="org-variable-name">p</span> =  <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-3">(</span>env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">p.name = "Function: " + name </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] (890) Function def =&gt;&gt; env.name = ${p.name}  p =  ${p}")</span>
        val udf = <span class="org-constant">Ast</span>.AstFuncUDF<span class="org-rainbow-delimiters-depth-3">(</span>name, _args, body,  p <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Register function in evironment if it is a non-lambda function</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>name != <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">){</span> env.set<span class="org-rainbow-delimiters-depth-4">(</span>name, udf<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> udf
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Special form borrowed from Clojure that allows calling </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">multiple methods of a java object with less repetition. </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example:</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(set frame (new javax.swing.JFrame))</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(doto frame </span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">(setSize 400 500)      ;; size     </span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">(setTitle "My frame")  ;; set  title </span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">(show))                ;; Show </span>
    <span class="org-comment-delimiter">//          </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">--------- It is simila rto </span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">frame.setSize(400 500)</span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">frame.setTitle("Mytitle")</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_doto</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 2 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'quote'. Expected 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">ref</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>
        val obj = eval<span class="org-rainbow-delimiters-depth-3">(</span>ref, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> obj.isErr<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> obj <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>obj.isObj<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Expected an instance of Java object, but got ${ Sexp.toStr(obj) }"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">_args</span> = args.takeLast<span class="org-rainbow-delimiters-depth-3">(</span> args.size - 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] args = " + _args)</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>a <span class="org-type">in</span> <span class="org-variable-name">_args</span><span class="org-rainbow-delimiters-depth-3">){</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span><span class="org-rainbow-delimiters-depth-5">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstLst</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
                <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"Expected list argument, but got ${ Sexp.toStr(a) }"</span><span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span> 
           <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] =&gt;&gt; a = ${ Sexp.toStr(a) }")</span>
           <span class="org-type">var</span> <span class="org-variable-name">argList</span> = a as <span class="org-constant">Ast</span>.AstLst
           val res = <span class="org-keyword">this</span>.invokeObjectMethod<span class="org-rainbow-delimiters-depth-4">(</span>obj <span class="org-type">as</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstObj</span>, argList.value, env<span class="org-rainbow-delimiters-depth-4">)</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> res.isErr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> res<span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> obj 
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">objToASt</span><span class="org-rainbow-delimiters-depth-2">(</span>arg: Any<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg <span class="org-type">is</span> <span class="org-variable-name">Int</span><span class="org-rainbow-delimiters-depth-3">)</span>    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-4">(</span>arg <span class="org-type">as</span> <span class="org-variable-name">Int</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg <span class="org-type">is</span> <span class="org-variable-name">Double</span> <span class="org-rainbow-delimiters-depth-3">){</span>  <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-4">(</span>arg <span class="org-type">as</span> <span class="org-variable-name">Double</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg <span class="org-type">is</span> <span class="org-variable-name">Boolean</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstBool<span class="org-rainbow-delimiters-depth-4">(</span>arg <span class="org-type">as</span> <span class="org-variable-name">Boolean</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg <span class="org-type">is</span> <span class="org-variable-name">String</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-4">(</span>arg <span class="org-type">as</span> <span class="org-variable-name">String</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-4">(</span>arg <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Special form for invoking consturctor of Java objects, for instance </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">for building a Java Swing </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">(set frame (new javax.swing.JFrame  arg0 arg1 ... argN-1))</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_new</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 1 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'new'. Expected at least argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'new'. Expected firstargument to be symbol."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">klassName</span>: String = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        var klass:  <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Class&lt;*&gt;? = <span class="org-constant">null</span> 

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to retrieve class metaobject </span>
            klass = Class.forName<span class="org-rainbow-delimiters-depth-4">(</span>klassName<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.ClassNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size == 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Create object using reflection and default costructor </span>
            val obj = klass.newInstance<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-4">(</span>obj <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">types</span> = ArrayList&lt;<span class="org-type">Class</span>&lt;*&gt;&gt;<span class="org-rainbow-delimiters-depth-3">()</span>
        val invokedArgs  = ArrayList<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Any</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>
        val _args = args.takeLast<span class="org-rainbow-delimiters-depth-3">(</span> args.size - 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to evalute arguments before method application </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">and abort if an error happens. </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>arg <span class="org-type">in</span> <span class="org-variable-name">_args</span><span class="org-rainbow-delimiters-depth-3">){</span>
           val a = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>arg, env<span class="org-rainbow-delimiters-depth-4">)</span> 
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a.isErr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> a<span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a.isVoid<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstBool</span><span class="org-rainbow-delimiters-depth-4">){</span> 
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Boolean::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Double::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Int::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstStr</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>String::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstObj</span><span class="org-rainbow-delimiters-depth-4">){</span>
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span>
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Special form new() not implemented for argument of type ${a} "</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
             val ctor = klass.getConstructor<span class="org-rainbow-delimiters-depth-4">(</span>*types.toTypedArray<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
             val obj = ctor.newInstance<span class="org-rainbow-delimiters-depth-4">(</span>*invokedArgs.toTypedArray<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
             <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> obj == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil <span class="org-rainbow-delimiters-depth-4">}</span>
             <span class="org-type">val</span> <span class="org-variable-name">r</span> = objToASt<span class="org-rainbow-delimiters-depth-4">(</span>obj<span class="org-rainbow-delimiters-depth-4">)</span>
             <span class="org-keyword">return</span> r 
         <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.NoSuchMethodException<span class="org-rainbow-delimiters-depth-3">)</span> 
         <span class="org-rainbow-delimiters-depth-3">{</span>
             <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: Exception<span class="org-rainbow-delimiters-depth-3">)</span>
         <span class="org-rainbow-delimiters-depth-3">{</span>
             <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Special form for getting static field of a class at runtime through reflection </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example: (static-field java.awt.Color Red)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_staticField</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 1 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'new'. Expected at least argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isSym<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'new'. Expected firstargument to be symbol."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">klassName</span>: String = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        val field = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        var klass:  <span class="org-constant">java</span>.<span class="org-constant">lang</span>.Class&lt;*&gt;? = <span class="org-constant">null</span> 

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to retrieve class metaobject </span>
            klass = Class.forName<span class="org-rainbow-delimiters-depth-4">(</span>klassName<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.ClassNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            val field = klass<span class="org-negation-char">!</span>!.getField<span class="org-rainbow-delimiters-depth-4">(</span>field<span class="org-rainbow-delimiters-depth-4">)</span>.get<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">)</span>
            val result = <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-4">(</span>field <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> result
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.NoSuchFieldException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to cast object to a class or interface </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">this method is useful for calling overloding methods </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Example:</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(set fr (doto (new javax.swing.JButton) setLabel "Click me"))</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(cast java.awt.Container fr)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">form_cast</span><span class="org-rainbow-delimiters-depth-2">(</span>args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 2 <span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'cast'. Expected 1 argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'cast'. Expected first argument to be symbol."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate first argument </span>
        <span class="org-type">val</span> <span class="org-variable-name">arg1</span> = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span>, env<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>arg1.isObj<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>arg1.isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Ill-formed special form 'cast'. Expected java object type as 2nd argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">obj</span>: Object? = <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> arg1.isNil<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">null</span> <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-rainbow-delimiters-depth-4">(</span>arg1 <span class="org-type">as</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstObj</span><span class="org-rainbow-delimiters-depth-4">)</span>.value  <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to retrieve class metaobject </span>
            val klass = Class.forName<span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>.toStr<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
            val ret = klass.cast<span class="org-rainbow-delimiters-depth-4">(</span>obj<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstObj<span class="org-rainbow-delimiters-depth-4">(</span>ret <span class="org-type">as</span> <span class="org-variable-name">Object</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.ClassNotFoundException<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.ClassCastException <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Invoke/call method of java method using reflection </span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">Example: </span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">(set frame (new javax.swing.JFrame))</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">(frame setSize 400 500)     ; invoke object method =&gt; frame.setSize(400, 500)</span>
    <span class="org-comment-delimiter">//     </span><span class="org-comment">(frame setVisible #t )      ; set object visible   =&gt; frame.setVisible(true)</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">invokeObjectMethod</span><span class="org-rainbow-delimiters-depth-2">(</span>obj: <span class="org-constant">Ast</span>.AstObj, args: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, env: <span class="org-constant">Ast</span>.AstEnv<span class="org-rainbow-delimiters-depth-2">)</span>: Ast 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val x: Object = obj.value 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 1<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Method requires a method name as symbol."</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object method </span>
        <span class="org-type">val</span> <span class="org-variable-name">m</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Get a property or set a property </span>
        <span class="org-comment-delimiter">//  </span><span class="org-comment">(object :property)       =&gt; Get a property value =&gt; object.property </span>
        <span class="org-comment-delimiter">//  </span><span class="org-comment">(object :property value) =&gt; Set a property value =&gt; object.property = value </span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> m.isKey<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> 
            val property = args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>.toStr<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Getter (Object :property) =&gt; Similar to object.property in infix notation</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> args.size == 1<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                val method = <span class="org-string">"get"</span> + property.capitalize<span class="org-rainbow-delimiters-depth-5">()</span>
                val argList = listOf<span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-6">(</span>method<span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">)</span>
                val res = invokeObjectMethod<span class="org-rainbow-delimiters-depth-5">(</span>obj, argList, env<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">return</span> res 
            <span class="org-comment-delimiter">// </span><span class="org-comment">Setter (Object :property value) =&gt; Similar to object.property = value in infix notation </span>
            <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> args.size == 2<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                val method = <span class="org-string">"set"</span> + property.capitalize<span class="org-rainbow-delimiters-depth-5">()</span>
                val values = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-5">(</span>args<span class="org-rainbow-delimiters-depth-6">[</span>1<span class="org-rainbow-delimiters-depth-6">]</span>, env<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>values.isErr<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> values <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-type">var</span> <span class="org-variable-name">argList</span>: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> =  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> values.isList<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">{</span> 
                                            listOf<span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span>method<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-6">)</span>.plus<span class="org-rainbow-delimiters-depth-6">(</span> values.nodes<span class="org-rainbow-delimiters-depth-7">()</span> <span class="org-rainbow-delimiters-depth-6">)</span> 
                                          <span class="org-rainbow-delimiters-depth-5">}</span>  <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-5">{</span> 
                                            listOf<span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span>method<span class="org-rainbow-delimiters-depth-7">)</span>, values <span class="org-rainbow-delimiters-depth-6">)</span> 
                                          <span class="org-rainbow-delimiters-depth-5">}</span>
                <span class="org-type">val</span> <span class="org-variable-name">res</span> = invokeObjectMethod<span class="org-rainbow-delimiters-depth-5">(</span>obj, argList, env<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-keyword">return</span> res 
            <span class="org-rainbow-delimiters-depth-4">}</span> 
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"""Invalid property call. Example of valid call: (object :property) or (object :property value)  """</span><span class="org-rainbow-delimiters-depth-4">)</span>  
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>m.isSym<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Invalid method call, expected symbol"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-type">val</span> <span class="org-variable-name">methodName</span> = m.toStr<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first element of args list </span>
        val _args = args.takeLast<span class="org-rainbow-delimiters-depth-3">(</span> args.size - 1<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Java metaclass, meta object =&gt; an object that describes a class</span>
        val klass = x::<span class="org-keyword">class</span>.java  
        val types = ArrayList&lt;<span class="org-type">Class</span>&lt;*&gt;?&gt;<span class="org-rainbow-delimiters-depth-3">()</span>
        val invokedArgs  = ArrayList<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Any</span>?<span class="org-rainbow-delimiters-depth-3">&gt;()</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to evalute arguments before method application </span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">and abort if an error happens. </span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>arg <span class="org-type">in</span> <span class="org-variable-name">_args</span><span class="org-rainbow-delimiters-depth-3">){</span>
           val a = <span class="org-keyword">this</span>.eval<span class="org-rainbow-delimiters-depth-4">(</span>arg, env<span class="org-rainbow-delimiters-depth-4">)</span> 
           <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> a.isErr<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> a<span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstBool</span><span class="org-rainbow-delimiters-depth-4">){</span> 
               <span class="org-comment-delimiter">// </span><span class="org-comment">invokedArgs.add(java.lang.Boolean(a.value) as Object)</span>
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Boolean::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstFlt</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Double::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstInt</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>Int::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstStr</span><span class="org-rainbow-delimiters-depth-4">){</span>  
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>String::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span> 
               <span class="org-comment-delimiter">//</span><span class="org-comment">invokedArgs.add(a.value as Object)</span>
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstObj</span><span class="org-rainbow-delimiters-depth-4">){</span>
               types.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value::<span class="org-keyword">class</span>.java<span class="org-rainbow-delimiters-depth-5">)</span>
               invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span>a.value<span class="org-rainbow-delimiters-depth-5">)</span>
           <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>a <span class="org-type">is</span> <span class="org-constant">Ast</span>.<span class="org-variable-name">AstNil</span><span class="org-rainbow-delimiters-depth-4">){</span>
                invokedArgs.add<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
           <span class="org-keyword">else</span> <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Not implemented invokeObjectMethod() for argument of type {a} "</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to get method metaObject </span>
            val mocMethod = klass.getMethod<span class="org-rainbow-delimiters-depth-4">(</span>methodName, *types.toTypedArray<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
            val result = mocMethod.invoke<span class="org-rainbow-delimiters-depth-4">(</span>x, *invokedArgs.toTypedArray<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> result == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil<span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-type">val</span> <span class="org-variable-name">r</span> = objToASt<span class="org-rainbow-delimiters-depth-4">(</span>result<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> r 
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: <span class="org-constant">java</span>.<span class="org-constant">lang</span>.NoSuchMethodException<span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] Second attempt to find method.")</span>
            val result = <span class="org-keyword">this</span>.invoke<span class="org-rainbow-delimiters-depth-4">(</span>x, methodName, invokedArgs<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> result 
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: Exception<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-4">(</span>ex.toString<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Invoke object method using reflection </span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">private fun invoke(targetObject: Object, methodName: String, parameters: List&lt;Object&gt; ): Ast</span>
    <span class="org-keyword">private</span> <span class="org-type">fun</span> <span class="org-function-name">invoke</span><span class="org-rainbow-delimiters-depth-2">(</span>targetObject: Object, methodName: String, parameters: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Any</span>?<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">)</span>: Ast
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] parameters.size = ${parameters.size}")</span>
        <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span>method <span class="org-type">in</span> <span class="org-function-name">targetObject</span>::<span class="org-keyword">class</span>.java.getMethods<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span>
             <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span> method.getName<span class="org-rainbow-delimiters-depth-5">()</span> != methodName<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">continue</span>  <span class="org-rainbow-delimiters-depth-4">}</span>
             <span class="org-type">val</span> <span class="org-variable-name">parameterTypes</span> = method.getParameterTypes<span class="org-rainbow-delimiters-depth-4">()</span>
             <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> parameterTypes.size != parameters.size <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-4">}</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">System.out.println("\n ----------------------------");</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">System.out.println(" [TRACE] Found method " + method);</span>
             <span class="org-type">var</span> <span class="org-variable-name">matches</span> = <span class="org-constant">true</span>;
             <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">i</span> <span class="org-function-name">in</span>  0..<span class="org-rainbow-delimiters-depth-5">(</span>parameterTypes.size - 1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> 
             <span class="org-rainbow-delimiters-depth-4">{</span>
                 <span class="org-type">val</span> <span class="org-variable-name">p</span> =  parameterTypes<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span>;
                 <span class="org-comment-delimiter">// </span><span class="org-comment">System.out.println(" [TRACE] p[" + i + "] = " + p)</span>
                 <span class="org-type">val</span> <span class="org-variable-name">param</span> =  parameters<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span> 
                 val klass = <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>param == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-constant">null</span> <span class="org-keyword">else</span> param<span class="org-negation-char">!</span>!::<span class="org-keyword">class</span>.java 
                 <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] klass = ${klass} ")</span>
                 <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> klass == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-5">}</span>
                 <span class="org-comment-delimiter">//</span><span class="org-comment">if (!p.isAssignableFrom( param.getClass())) </span>
                 <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-negation-char">!</span>p.isAssignableFrom<span class="org-rainbow-delimiters-depth-6">(</span>klass<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span> 
                 <span class="org-rainbow-delimiters-depth-5">{</span>
                     matches = <span class="org-constant">false</span>;
                     <span class="org-keyword">break</span>;
                 <span class="org-rainbow-delimiters-depth-5">}</span>
             <span class="org-rainbow-delimiters-depth-4">}</span>
             <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>matches<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">System.out.println(" [TRACE] Method invoked ");</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">obtain a Class[] based on the passed arguments as Object[]</span>
                 <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-5">{</span>
                    <span class="org-comment-delimiter">// </span><span class="org-comment">println(" [TRACE] parameters = ${parameters}")</span>
                    <span class="org-type">val</span> <span class="org-variable-name">result</span> = method.invoke<span class="org-rainbow-delimiters-depth-6">(</span>targetObject, *parameters.toTypedArray<span class="org-rainbow-delimiters-depth-7">()</span><span class="org-rainbow-delimiters-depth-6">)</span>;
                    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span> result == <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-6">){</span> <span class="org-keyword">return</span> <span class="org-constant">Ast</span>.AstNil<span class="org-rainbow-delimiters-depth-6">}</span>
                    <span class="org-type">val</span> <span class="org-variable-name">r</span> = objToASt<span class="org-rainbow-delimiters-depth-6">(</span>result<span class="org-rainbow-delimiters-depth-6">)</span>                 
                    <span class="org-keyword">return</span> r
                 <span class="org-rainbow-delimiters-depth-5">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-5">(</span>ex: Exception<span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">{</span>
                    <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-6">(</span> ex.toString<span class="org-rainbow-delimiters-depth-7">()</span> <span class="org-rainbow-delimiters-depth-6">)</span>
                 <span class="org-rainbow-delimiters-depth-5">}</span>
             <span class="org-rainbow-delimiters-depth-4">}</span>
         <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">--- End for ---------- //</span>
         <span class="org-keyword">return</span> error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Method ${methodName} not found."</span><span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span> 
<span class="org-comment-delimiter">// </span><span class="org-comment">---- End of  class Eval --------- // </span>


<span class="org-comment-delimiter">// </span><span class="org-comment">----- Primitive unit test framework --------//</span>
<span class="org-type">object</span> <span class="org-variable-name">Assert</span> <span class="org-rainbow-delimiters-depth-1">{</span>

    fun assert<span class="org-rainbow-delimiters-depth-2">(</span>predicate: Boolean, message: String = <span class="org-string">"Assertion failure"</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>predicate<span class="org-rainbow-delimiters-depth-3">){</span>  <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span>message<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">equal</span><span class="org-rainbow-delimiters-depth-2">(</span>expected: T, output: T<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>expected != output<span class="org-rainbow-delimiters-depth-3">){</span>  
            <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Equality test failure. Expected ${expected}, but got ${output}."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">astEqual</span><span class="org-rainbow-delimiters-depth-2">(</span>expected: Ast, output: Ast<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">val</span> <span class="org-variable-name">expectedStr</span> = Sexp.toStr<span class="org-rainbow-delimiters-depth-3">(</span>expected<span class="org-rainbow-delimiters-depth-3">)</span>
        val outputStr = Sexp.toStr<span class="org-rainbow-delimiters-depth-3">(</span>output<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>Sexp.equal<span class="org-rainbow-delimiters-depth-4">(</span>expected, output<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
            <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"AST equality test failure. \n =&gt; Expected ${expectedStr}, \n =&gt; but got ${outputStr}."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">listEqual</span><span class="org-rainbow-delimiters-depth-2">(</span>expected: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, output: <span class="org-type">List</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">val</span> <span class="org-variable-name">size</span> = expected.size 
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> expected.size != output.size <span class="org-rainbow-delimiters-depth-3">){</span>
            var msg =  <span class="org-string">"List equality test failure. Expected ${expected} (${expected.size} elements),"</span> 
            msg    +=  <span class="org-string">" but got ${output} (${output.size} elements).  "</span>
            <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span>msg<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">n</span> <span class="org-function-name">in</span> 0..<span class="org-rainbow-delimiters-depth-4">(</span>size  -1<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            val a = expected<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>
            val b = output<span class="org-rainbow-delimiters-depth-4">[</span>n<span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>a == b<span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span> <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-type">var</span> <span class="org-variable-name">msg</span> =  <span class="org-string">"""</span>
<span class="org-string">            List equality test failure. Expected ${expected} (${expected.size} elements) </span>
<span class="org-string">            Element ${n} expected to be ${a}, but got ${b}.            </span>
<span class="org-string">            """</span>.trimIndent<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Equality test failure. Expected ${expected}, but got ${output}."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-type">fun</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">notEqual</span><span class="org-rainbow-delimiters-depth-2">(</span>expected: T, output: T<span class="org-rainbow-delimiters-depth-2">)</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>expected == output<span class="org-rainbow-delimiters-depth-3">){</span>  
            <span class="org-keyword">throw</span> AssertionError<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Inequality test failure. Not expected ${expected}, but got ${output}."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">TestStatus</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates successful execution of a test </span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">(assertion does not thrown an AssertionError)</span>
      PASSED    
      <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates that the assertion predicate was evaluated to false</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">and the assumption made by the assertion failed.</span>
    , FAILURE
      <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates an unexpected error - not an AssertionError</span>
    , ERROR
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">data</span> <span class="org-keyword">class</span> TestCase<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">val</span> <span class="org-variable-name">name</span>: String, <span class="org-type">val</span> <span class="org-function-name">func</span>: <span class="org-rainbow-delimiters-depth-2">()</span> -&gt; Unit<span class="org-rainbow-delimiters-depth-1">)</span>

data <span class="org-keyword">class</span> TestResult<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">val</span> <span class="org-variable-name">name</span>: String,  <span class="org-type">val</span> <span class="org-variable-name">status</span>: TestStatus,  <span class="org-type">val</span> <span class="org-variable-name">exception</span>: Throwable?<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    fun isPassed<span class="org-rainbow-delimiters-depth-2">()</span>:  Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> status == <span class="org-constant">TestStatus</span>.PASSED  <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">fun</span> <span class="org-function-name">isFailure</span><span class="org-rainbow-delimiters-depth-2">()</span>: Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> status == <span class="org-constant">TestStatus</span>.FAILURE <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">fun</span> <span class="org-function-name">isError</span><span class="org-rainbow-delimiters-depth-2">()</span>:   Boolean <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> status == <span class="org-constant">TestStatus</span>.ERROR   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">TestSet</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">private</span> var name: String = <span class="org-string">""</span>
    <span class="org-keyword">private</span> val testcases = mutableListOf<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">TestCase</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
    <span class="org-keyword">private</span> var results =  mutableListOf<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">TestResult</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>

    fun addTest<span class="org-rainbow-delimiters-depth-2">(</span>name: String, testFunc: <span class="org-rainbow-delimiters-depth-3">()</span> -&gt; Unit<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        val test =  TestCase<span class="org-rainbow-delimiters-depth-3">(</span>name, testFunc<span class="org-rainbow-delimiters-depth-3">)</span>
        testcases.add<span class="org-rainbow-delimiters-depth-3">(</span>test<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Print all test cases and their identifiers.</span>
    <span class="org-type">fun</span> <span class="org-function-name">showTests</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
        var count = 0 
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>t <span class="org-type">in</span> <span class="org-variable-name">testcases</span><span class="org-rainbow-delimiters-depth-3">){</span> 
            println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [${count}] =&gt; ${t.name} "</span><span class="org-rainbow-delimiters-depth-4">)</span>
            count = count + 1
        <span class="org-rainbow-delimiters-depth-3">}</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">runTest</span><span class="org-rainbow-delimiters-depth-2">(</span>test: TestCase<span class="org-rainbow-delimiters-depth-2">)</span>: TestResult
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            test.func<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-keyword">return</span> TestResult<span class="org-rainbow-delimiters-depth-4">(</span>test.name, <span class="org-constant">TestStatus</span>.PASSED, <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: AssertionError<span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> TestResult<span class="org-rainbow-delimiters-depth-4">(</span>test.name, <span class="org-constant">TestStatus</span>.FAILURE, ex<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span>ex: Exception<span class="org-rainbow-delimiters-depth-3">){</span>
            <span class="org-keyword">return</span> TestResult<span class="org-rainbow-delimiters-depth-4">(</span>test.name, <span class="org-constant">TestStatus</span>.ERROR, ex<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Run a single test case given its number (unique identifier)</span>
    <span class="org-type">fun</span> <span class="org-function-name">runTestByNumber</span><span class="org-rainbow-delimiters-depth-2">(</span>n: Int<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>n &gt;= testcases.size<span class="org-rainbow-delimiters-depth-3">){</span>
            System.err.println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [ERROR] Test case with this number not found ${n}"</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">test</span> = testcases<span class="org-rainbow-delimiters-depth-3">[</span>n<span class="org-rainbow-delimiters-depth-3">]</span>
        val r = runTest<span class="org-rainbow-delimiters-depth-3">(</span>test<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> r.status == <span class="org-constant">TestStatus</span>.PASSED  <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>  
            println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"[PASSED] Test '${test.name}' (id = ${n}) passed. Ok."</span><span class="org-rainbow-delimiters-depth-4">)</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> r.status == <span class="org-constant">TestStatus</span>.FAILURE <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>  
            println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [FAILED] Test '${test.name}' (id = ${n}) failed. Assertion error. "</span><span class="org-rainbow-delimiters-depth-4">)</span>
            println<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(r.exception)</span>
            r.exception<span class="org-negation-char">!</span>!.printStackTrace<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> r.status == <span class="org-constant">TestStatus</span>.ERROR   <span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [ERROR ] Test '${test.name} (id = ${n}) error. Unexpected exception."</span><span class="org-rainbow-delimiters-depth-4">)</span>
            println<span class="org-rainbow-delimiters-depth-4">()</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">println(r.exception)</span>
            r.exception<span class="org-negation-char">!</span>!.printStackTrace<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">fun</span> <span class="org-function-name">runAll</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        var count = 0 
        var passed = 0 
        var failed = 0 
        var error  = 0
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>t <span class="org-type">in</span> <span class="org-keyword">this</span>.<span class="org-variable-name">testcases</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            val r = runTest<span class="org-rainbow-delimiters-depth-4">(</span>t<span class="org-rainbow-delimiters-depth-4">)</span> 
            results.add<span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">if</span>     <span class="org-rainbow-delimiters-depth-4">(</span>r.status == <span class="org-constant">TestStatus</span>.PASSED  <span class="org-rainbow-delimiters-depth-4">){</span>  passed += 1 <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>r.status == <span class="org-constant">TestStatus</span>.FAILURE <span class="org-rainbow-delimiters-depth-4">){</span>  failed += 1 <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>r.status == <span class="org-constant">TestStatus</span>.ERROR   <span class="org-rainbow-delimiters-depth-4">){</span>  error += 1 <span class="org-rainbow-delimiters-depth-4">}</span>
            count = count + 1
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">passedPercent</span> = 100.0 * passed / count 
        val failedPercent = 100.0 * failed / count 
        val errorPercent  = 100.0 * error  / count 
        println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"------------------------ TEST REPORT ----------------------------------\n"</span><span class="org-rainbow-delimiters-depth-3">)</span>   
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> failed == 0 || error == 0 <span class="org-rainbow-delimiters-depth-3">){</span> println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" [*] SUCCESS - ALL TESTS PASSED OK. "</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">}</span>
        println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [*] Passed =  ${passed} (${passedPercent}%) / Failures = ${failed} (${failedPercent}%) / Error = ${error} (${errorPercent}%) / Total = ${count}"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        var id = -1 
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span>r <span class="org-type">in</span> <span class="org-variable-name">results</span><span class="org-rainbow-delimiters-depth-3">){</span>
            id = id + 1
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>r.isFailure<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"\n [+] Test Failure =&gt;  name: '${r.name}' (id = ${id}) / Assertion Error "</span><span class="org-rainbow-delimiters-depth-5">)</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"........................................................................"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                println<span class="org-rainbow-delimiters-depth-5">()</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">println(r.exception)</span>
                r.exception<span class="org-negation-char">!</span>!.printStackTrace<span class="org-rainbow-delimiters-depth-5">()</span>
                <span class="org-keyword">continue</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>r.isError<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"\n [+] Test Error =&gt; name: '${r.name}' (id = ${id}) / Unexpected Exception"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                println<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"........................................................................"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                println<span class="org-rainbow-delimiters-depth-5">()</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">println(r.exception)</span>
                r.exception<span class="org-negation-char">!</span>!.printStackTrace<span class="org-rainbow-delimiters-depth-5">()</span>
                <span class="org-keyword">continue</span>
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>



<span class="org-comment-delimiter">// </span><span class="org-comment">---------- Program Entry Point --------------------//</span>

<span class="org-type">fun</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span>args: <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">String</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    val interp = Evaluator<span class="org-rainbow-delimiters-depth-2">()</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>args.size == 0<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">return</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> == <span class="org-string">"repl"</span><span class="org-rainbow-delimiters-depth-2">){</span>
        interp.eval<span class="org-rainbow-delimiters-depth-3">(</span>startCode<span class="org-rainbow-delimiters-depth-3">)</span>
        println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" =====&gt; Interactive S-Expression interpreter started. Ok. "</span><span class="org-rainbow-delimiters-depth-3">)</span>
        println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"  [*] Type .help or .h for showing the help menu."</span><span class="org-rainbow-delimiters-depth-3">)</span>
        println<span class="org-rainbow-delimiters-depth-3">()</span>
        interp.repl<span class="org-rainbow-delimiters-depth-3">()</span>
        <span class="org-keyword">return</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> == <span class="org-string">"script"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size &lt; 2<span class="org-rainbow-delimiters-depth-3">){</span> 
            System.err.println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"ERROR - exepcted script file name"</span><span class="org-rainbow-delimiters-depth-4">)</span> 
            System.err.println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Usage: java -jar sexpr.jar script &lt;FILE-NAME&gt;"</span><span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-keyword">return</span> 
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-type">val</span> <span class="org-variable-name">fileName</span> = args<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>
        interp.loadScript<span class="org-rainbow-delimiters-depth-3">(</span>fileName<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-keyword">return</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> args<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> == <span class="org-string">"tests"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>

        val testSet = TestSet<span class="org-rainbow-delimiters-depth-3">()</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Create a test case </span>
        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test parser - case parse a simple list"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">src</span>    = <span class="org-string">"(list \"some string\" 100.60 symbol :akeyword :x  )"</span>
            val expected = <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-5">(</span> 
                listOf<span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"list"</span><span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-7">(</span> <span class="org-string">"some string"</span> <span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-7">(</span>100.60<span class="org-rainbow-delimiters-depth-7">)</span>
                       , <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"symbol"</span><span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"akeword"</span><span class="org-rainbow-delimiters-depth-7">)</span>
                       , <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"x"</span><span class="org-rainbow-delimiters-depth-7">)</span>
                       <span class="org-comment-delimiter">//</span><span class="org-comment">, Ast.AstLst( listOf( Ast.AstSym("+"), Ast.AstInt(1), Ast.AstInt(2), Ast.AstInt(3) ) )</span>
                <span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
            val ast: Ast = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">val nodes = ast.nodes()</span>
            Assert.assert<span class="org-rainbow-delimiters-depth-5">(</span> Sexp.equal<span class="org-rainbow-delimiters-depth-6">(</span>expected, ast<span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test parser -parse a nested list"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">src</span>    = <span class="org-string">"(list \"some string\" 100.60 symbol :akeyword :x  (+ 1 2 sym) )"</span>
            val expected = <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-5">(</span> 
                listOf<span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"list"</span><span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstStr<span class="org-rainbow-delimiters-depth-7">(</span> <span class="org-string">"some string"</span> <span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstFlt<span class="org-rainbow-delimiters-depth-7">(</span>100.60<span class="org-rainbow-delimiters-depth-7">)</span>
                       , <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"symbol"</span><span class="org-rainbow-delimiters-depth-7">)</span>, <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"akeyword"</span><span class="org-rainbow-delimiters-depth-7">)</span>
                       , <span class="org-constant">Ast</span>.AstKey<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-string">"x"</span><span class="org-rainbow-delimiters-depth-7">)</span>
                       , <span class="org-constant">Ast</span>.AstLst<span class="org-rainbow-delimiters-depth-7">(</span> listOf<span class="org-rainbow-delimiters-depth-8">(</span> <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-9">(</span><span class="org-string">"+"</span><span class="org-rainbow-delimiters-depth-9">)</span>, <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-9">(</span>1<span class="org-rainbow-delimiters-depth-9">)</span>, <span class="org-constant">Ast</span>.AstInt<span class="org-rainbow-delimiters-depth-9">(</span>2<span class="org-rainbow-delimiters-depth-9">)</span>, <span class="org-constant">Ast</span>.AstSym<span class="org-rainbow-delimiters-depth-9">(</span><span class="org-string">"sym"</span><span class="org-rainbow-delimiters-depth-9">)</span> <span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-rainbow-delimiters-depth-7">)</span>
                <span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
            val ast: Ast = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span> 
            Assert.astEqual<span class="org-rainbow-delimiters-depth-5">(</span>expected, ast<span class="org-rainbow-delimiters-depth-5">)</span> 
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test intepreter - eval () empty list evaluation"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">interpreter</span> = Evaluator<span class="org-rainbow-delimiters-depth-5">()</span>
            val src         = <span class="org-string">" () ; empty list "</span>
            val expected    = <span class="org-constant">Ast</span>.AstNil
            val ast: Ast    = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span> 
            val result      = interpreter.eval<span class="org-rainbow-delimiters-depth-5">(</span>ast<span class="org-rainbow-delimiters-depth-5">)</span>
            Assert.astEqual<span class="org-rainbow-delimiters-depth-5">(</span>expected, result<span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test intepreter - expression evaluation"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">interpreter</span> = Evaluator<span class="org-rainbow-delimiters-depth-5">()</span>
            val src         =  <span class="org-string">" (list :x (* 1 2 3 4 5) '(sqrt 100) :y (/ (+ (* 3 5 1) 20) 100) :z \"hello world\")  "</span>
            val astExpected = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"  (:x 120 (sqrt 100) :y 0.35 :z \"hello world\"  )   "</span><span class="org-rainbow-delimiters-depth-5">)</span>
            val result      = interpreter.eval<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span>
            Assert.astEqual<span class="org-rainbow-delimiters-depth-5">(</span> astExpected, result <span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test intepreter - quoted expression evaluation"</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">interpreter</span> = Evaluator<span class="org-rainbow-delimiters-depth-5">()</span>
            val src         =  <span class="org-string">" '(list (* 3 5) x 'z 'w :keyword \"some string\" ) "</span> 
            val astExpected = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" (list (* 3 5) \n\t x 'z \n'w :keyword \"some string\" ) "</span><span class="org-rainbow-delimiters-depth-5">)</span>
            val result      = interpreter.eval<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span>
            Assert.astEqual<span class="org-rainbow-delimiters-depth-5">(</span> astExpected, result <span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        testSet.addTest<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"test intepreter - lambda function application "</span>, <span class="org-rainbow-delimiters-depth-4">{</span> 
            <span class="org-type">val</span> <span class="org-variable-name">interpreter</span> = Evaluator<span class="org-rainbow-delimiters-depth-5">()</span>
            val src         =  <span class="org-string">"(map (fn (x) (+ 5 (* 10 x)))  (list 1 2 5 -6 3.5 9.0 (+ 1 2 3 4)))) "</span> 
            val astExpected = Sexp.parse<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"  (15 25 55 \t\n-55 40.0\n95.0 105 ) ; comment expected result "</span><span class="org-rainbow-delimiters-depth-5">)</span>
            val result      = interpreter.eval<span class="org-rainbow-delimiters-depth-5">(</span>src<span class="org-rainbow-delimiters-depth-5">)</span>
            Assert.astEqual<span class="org-rainbow-delimiters-depth-5">(</span> astExpected, result <span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> args.size == 1<span class="org-rainbow-delimiters-depth-3">){</span>
            testSet.runAll<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>args.size == 2 &amp;&amp; args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">"--all"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            testSet.runAll<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 2 &amp;&amp; args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">"--list"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            testSet.showTests<span class="org-rainbow-delimiters-depth-4">()</span>
        <span class="org-rainbow-delimiters-depth-3">}</span> 
        <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>args.size == 3 &amp;&amp; args<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">"--single"</span><span class="org-rainbow-delimiters-depth-3">)</span> 
        <span class="org-rainbow-delimiters-depth-3">{</span>
            val n = args<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span>.toInt<span class="org-rainbow-delimiters-depth-4">()</span>
            testSet.runTestByNumber<span class="org-rainbow-delimiters-depth-4">(</span>n<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            System.err.println<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" Error: invalid option."</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
              
        <span class="org-keyword">return</span> 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
File: <span class="underline">swing.jlisp</span> =&gt; Sample script that creates a Java Swing GUI at runtime.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">----------------------------------------------;;</span>
<span class="org-comment-delimiter">;;            </span><span class="org-comment">Lisp Script                       ;;</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">----------------------------------------------;;</span>

(comment  <span class="org-type">Anything</span> in this comment special form is not evaluted.)

(<span class="org-keyword">fn</span> <span class="org-function-name">make-color</span> (r g b) (<span class="org-keyword">new</span> <span class="org-type">java.awt.Color</span> r g b))

<span class="org-comment-delimiter">;; </span><span class="org-comment">------- Color contants ------------------------;;</span>
(<span class="org-keyword">def</span> <span class="org-variable-name">color-light-blue</span> (make-color 51 204 255))
(<span class="org-keyword">def</span> <span class="org-variable-name">color-red</span>        (make-color 255 0 0)) 
(<span class="org-keyword">def</span> <span class="org-variable-name">color-white</span>      (make-color 255 255 255))
(<span class="org-keyword">def</span> <span class="org-variable-name">color-black</span>      (make-color 0 0 0 ))


(<span class="org-keyword">def</span> <span class="org-variable-name">label</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JLabel</span> <span class="org-string">"my label"</span>))
(label <span class="org-clojure-interop-method">setBounds</span> 200 10 200 30 )

(<span class="org-keyword">def</span> <span class="org-variable-name">output</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JTextArea</span>))
(<span class="org-keyword">def</span> <span class="org-variable-name">entry</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JTextArea</span>))
(<span class="org-keyword">def</span> <span class="org-variable-name">btn-run</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JButton</span> <span class="org-string">"Run"</span>))
(btn-run <span class="org-clojure-interop-method">setBounds</span> 10 60 100 30)

(<span class="org-keyword">def</span> <span class="org-variable-name">btn-demo</span> (<span class="org-keyword">doto</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JButton</span>) 
        (<span class="org-clojure-interop-method">setName</span> <span class="org-string">"btn-demo"</span>)
        (<span class="org-clojure-interop-method">setLabel</span> <span class="org-string">"Clik me"</span>)
        (<span class="org-clojure-interop-method">setBounds</span> 10 10 100 30)
         )) 
(btn <span class="org-clojure-interop-method">setBackground</span> color-light-blue)

(<span class="org-keyword">def</span> <span class="org-variable-name">scroll-entry</span> (<span class="org-keyword">doto</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JScrollPane</span>)
                          (<span class="org-clojure-interop-method">setViewportView</span> entry)
                          (<span class="org-clojure-interop-method">setBounds</span> 30 120 500 100)
                        ))


(<span class="org-keyword">def</span> <span class="org-variable-name">scroll-output</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JScrollPane</span>))
(scroll-output <span class="org-clojure-interop-method">setViewportView</span> output)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(setBounds x y width height) =&gt; (x, y) origin at top-left corner </span>
(scroll-output <span class="org-clojure-interop-method">setBounds</span>  30 250 500 250)

(<span class="org-keyword">def</span> <span class="org-variable-name">frame</span> (<span class="org-keyword">doto</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JFrame</span>) 
                  (<span class="org-clojure-keyword">:name</span> <span class="org-string">"frame1"</span>)
                  (<span class="org-clojure-keyword">:size</span> '(632 568))
                  (<span class="org-clojure-keyword">:title</span> <span class="org-string">"My Java Swing App"</span>) 
                  (<span class="org-clojure-interop-method">setLayout</span> <span class="org-constant">nil</span>)
                  <span class="org-comment-delimiter">;; </span><span class="org-comment">(setContentPane pane) </span>
                  <span class="org-comment-delimiter">;; </span><span class="org-comment">(</span><span class="org-clojure-keyword"><span class="org-comment">:visible</span></span><span class="org-comment"> #t)</span>
                  )) 

(frame add btn-demo)
(frame add btn-run)
(frame add label)
(frame add scroll-entry)
(frame add scroll-output)

(<span class="org-keyword">def</span> <span class="org-variable-name">count</span> 0)
(btn-demo <span class="org-clojure-interop-method">addActionListener</span> (action-listener 
                          (<span class="org-keyword">fn</span> () 
                               (<span class="org-keyword">def</span> <span class="org-variable-name">text</span>  (concat <span class="org-string">"Button clicked "</span>  count))
                               (set count (+ 1 count))
                             <span class="org-comment-delimiter">;; </span><span class="org-comment">(frame </span><span class="org-clojure-keyword"><span class="org-comment">:title</span></span><span class="org-comment"> text)</span>
                               (label <span class="org-clojure-keyword">:text</span> text)
                               (frame <span class="org-clojure-interop-method">setTitle</span> text)
                             ))) 

(btn-run <span class="org-clojure-interop-method">addActionListener</span> (action-listener 
                              (<span class="org-keyword">fn</span> () 
                                  (println <span class="org-string">"Btn-run clicked OK"</span>)
                                  (<span class="org-keyword">def</span> <span class="org-variable-name">result</span> (eval (read (concat <span class="org-string">"(do</span><span class="org-string"><span class="org-bold">\n</span></span><span class="org-string">"</span> (entry <span class="org-clojure-interop-method">getText</span>) <span class="org-string">"</span><span class="org-string"><span class="org-bold">\n</span></span><span class="org-string">)"</span>))))
                                  (println result)
                                  (output <span class="org-clojure-interop-method">setText</span> (concat result))
                                  (println <span class="org-string">"Code evaluated. OK."</span>)
                              )))

((frame <span class="org-clojure-interop-method">getContentPane</span>) <span class="org-clojure-keyword">:background</span> color-light-blue)
(frame <span class="org-clojure-interop-method">setVisible</span> #t)

(println  <span class="org-string">" [TRACE] Script started Ok. "</span>)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">------------------------------------------ ;;;</span>

(<span class="org-keyword">fn</span> <span class="org-function-name">jframe-setSize</span> (fr width height) (fr <span class="org-clojure-interop-method">setSize</span> width height)) 

(<span class="org-keyword">fn</span> <span class="org-function-name">jframe-setVisible</span> (fr flag) (fr <span class="org-clojure-interop-method">setVisible</span> flag)) 

(<span class="org-keyword">fn</span> <span class="org-function-name">build-frame</span> (title width height)
    (<span class="org-keyword">doto</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JFrame</span>)
        (<span class="org-clojure-interop-method">setSize</span> height height)
        (<span class="org-clojure-interop-method">setTitle</span> title)
        (<span class="org-clojure-interop-method">setVisible</span> #t)
      )
 )

(println <span class="org-string">" [TRACE ] Code evaluated OK. "</span>)
</pre>
</div>


<p>
Check compiler version:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kotlin -version
Kotlin version 1.7.10-release-333 (JRE 16.0.1+9-Ubuntu-120.04)
</pre>
</div>

<p>
Building:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ kotlinc sexpr.kt -include-runtime -d sexpr.jar
</pre>
</div>

<p>
Inspect the generated file:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ file sexpr.jar
<span class="org-function-name">sexpr.jar</span>: Java archive data (JAR)
</pre>
</div>

<p>
Run unit tests:
</p>

<div class="org-src-container">
<pre class="src src-sh"> <span class="org-comment-delimiter"># </span><span class="org-comment">------ List all tests -----------------------#</span>
 <span class="org-comment-delimiter">#</span>
 $ &gt;&gt; java -jar sexpr.jar tests --list
 [0] =&gt; test parser - case parse a simple list 
 [1] =&gt; test parser -parse a nested list 
 [2] =&gt; test intepreter - eval () empty list evaluation 
 [3] =&gt; test intepreter - expression evaluation 
 [4] =&gt; test intepreter - quoted expression evaluation 
 [5] =&gt; test intepreter - lambda <span class="org-keyword">function</span> <span class="org-function-name">application</span>

 <span class="org-comment-delimiter"># </span><span class="org-comment">--------- Run a single unit test -------------#</span>
 <span class="org-comment-delimiter">#</span>
 $ java -jar sexpr.jar tests --single 2
[PASSED] Test <span class="org-string">'test intepreter - eval () empty list evaluation'</span> (id = 2) passed. Ok.

 $ java -jar sexpr.jar tests --single 4
[PASSED] Test <span class="org-string">'test intepreter - quoted expression evaluation'</span> (id = 4) passed. Ok.

<span class="org-comment-delimiter">#</span><span class="org-comment">-------- Run all unit tests -------------------#</span>
<span class="org-comment-delimiter">#</span>
 $ &gt;&gt; java -jar sexpr.jar tests
------------------------ TEST REPORT ----------------------------------

 [*] SUCCESS - ALL TESTS PASSED OK. 
 [*] Passed =  6 (100.0%) / Failures = 0 (0.0%) / Error = 0 (0.0%) / Total = 6
</pre>
</div>

<p>
Run the REPL:
</p>

<div class="org-src-container">
<pre class="src src-clojure"> $ &gt;&gt; rlwrap java -jar <span class="org-type">sexpr.jar</span> repl
 [<span class="org-constant">TRACE</span> ] <span class="org-type">Code</span> evaluated <span class="org-type">OK.</span>  
 =====&gt; <span class="org-type">Interactive</span> S-Expression interpreter started. <span class="org-type">Ok.</span> 
  [*] <span class="org-type">Type</span> <span class="org-clojure-interop-method">.help</span> or <span class="org-clojure-interop-method">.h</span> for showing the help menu.


 <span class="org-comment">; ------------ Show the REPL help menu -----------;</span>
 <span class="org-type">In</span>[23]&gt; <span class="org-clojure-interop-method">.h</span>

            <span class="org-type">The</span> interpreter has the following commands:
              + <span class="org-clojure-interop-method">.h</span> or <span class="org-clojure-interop-method">.help</span>  =&gt; <span class="org-type">To</span> display this help menu.
              + <span class="org-clojure-interop-method">.q</span> or <span class="org-clojure-interop-method">.quit</span>  =&gt; <span class="org-type">To</span> quit the interpreter.
              + <span class="org-clojure-interop-method">.multi</span>       =&gt; <span class="org-type">To</span> paste multi-line S-Expression in the repl 
              + <span class="org-clojure-interop-method">.reset</span> or <span class="org-clojure-interop-method">.r</span> =&gt; <span class="org-type">To</span> reset the interpreter state 
              + <span class="org-clojure-interop-method">.vars</span>        =&gt; <span class="org-type">To</span> display all variables 
              + <span class="org-clojure-interop-method">.funcs</span>       =&gt; <span class="org-type">To</span> show all functions 
              + .verbose-on  =&gt; <span class="org-type">Enable</span> verbose mode 
              + .verbose-off =&gt; <span class="org-type">Disable</span> verbose mode 


 <span class="org-comment">; ------------ Playing with lits --------------------;</span>
 <span class="org-comment">; </span>

 <span class="org-type">In</span>[0]&gt; 

 <span class="org-type">In</span>[0]&gt; (list '+ (* 3 5 1) <span class="org-clojure-keyword">:y</span> (<span class="org-type">m</span><span class="org-default">/</span>sqrt (+ (* 3.0 3.0) (* 4.0 4.0))) 'symbol 'x 'z '(+ 1 2 3 5)))
 $0 = (+ 15 <span class="org-clojure-keyword">:y</span> 5.0 symbol x z (+ 1 2 3 5))
 <span class="org-type">In</span>[1]&gt; 

 <span class="org-type">In</span>[1]&gt; $0
 $1 = (+ 15 <span class="org-clojure-keyword">:y</span> 5.0 symbol x z (+ 1 2 3 5))

 <span class="org-type">In</span>[2]&gt; (car $0)
 $2 = +

 <span class="org-type">In</span>[3]&gt; (cdr $0)
 $3 = (15 <span class="org-clojure-keyword">:y</span> 5.0 symbol x z (+ 1 2 3 5))

 <span class="org-type">In</span>[4]&gt; (car (cdr $0))
 $4 = 15

 <span class="org-type">In</span>[5]&gt; (cdr (cdr $0))
 $5 = (<span class="org-clojure-keyword">:y</span> 5.0 symbol x z (+ 1 2 3 5))

 <span class="org-type">In</span>[6]&gt; (car (cdr (cdr $0)))
 $6 = <span class="org-clojure-keyword">:y</span>

 <span class="org-comment">; --------- Ge the nth element of a list ------------</span>

 <span class="org-type">In</span>[10]&gt; (nth 1 $0)
 $10 = 15

 <span class="org-type">In</span>[11]&gt; (nth 2 $0)
 $11 = <span class="org-clojure-keyword">:y</span>

 <span class="org-type">In</span>[12]&gt; (nth 4 $0)
 $12 = symbol

 <span class="org-type">In</span>[13]&gt; (nth 5 $0)
 $13 = x

 <span class="org-type">In</span>[14]&gt; (nth 6 $0)
 $14 = z

 <span class="org-comment">; ------------ Define variables ------------------;</span>

 <span class="org-type">In</span>[15]&gt; (<span class="org-keyword">def</span> <span class="org-variable-name">r</span> '(+ (* 3 5 10) (/ 100 20 5) (<span class="org-type">m</span><span class="org-default">/</span>exp 1)))
 $15 = (+ (* 3 5 10) (/ 100 20 5) (<span class="org-type">m</span><span class="org-default">/</span>exp 1))

 <span class="org-type">In</span>[16]&gt; r
 $16 = (+ (* 3 5 10) (/ 100 20 5) (<span class="org-type">m</span><span class="org-default">/</span>exp 1))

 <span class="org-type">In</span>[17]&gt; (eval r)
 $17 = 153.71828182845906

 <span class="org-type">In</span>[18]&gt; (nth 1 r)
 $18 = (* 3 5 10)

 <span class="org-type">In</span>[19]&gt; (eval (nth 1 r))
 $19 = 150

 <span class="org-comment">;----------- Functions ---------------------------------;</span>

 (<span class="org-keyword">def</span> <span class="org-variable-name">cnt</span> 0)
 (<span class="org-keyword">fn</span> <span class="org-function-name">increment</span>() (set cnt (+ cnt 1)) (println <span class="org-string">"cnt = "</span> cnt))

 <span class="org-type">In</span>[25]&gt;  (<span class="org-keyword">fn</span> <span class="org-function-name">increment</span>() (set cnt (+ cnt 1)) (println <span class="org-string">"cnt = "</span> cnt))
 $25 = &lt;FuncUDF: increment&gt;
 <span class="org-type">In</span>[26]&gt; 
 <span class="org-type">In</span>[26]&gt; (increment)
cnt =  1 
 $26 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[27]&gt; (increment)
cnt =  2 
 $27 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[28]&gt; (increment)
cnt =  3 
 $28 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[29]&gt; (increment)
cnt =  4 
 $29 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[30]&gt; (increment)
cnt =  5 
 $30 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[31]&gt; (increment)
cnt =  6 
 $31 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[32]&gt; (increment)
cnt =  7 
 $32 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[33]&gt; cnt
 $33 = 7

 <span class="org-type">In</span>[34]&gt; (list (+ cnt 10) (* 3 cnt) (* 5 (+ 10 cnt)))
 $34 = (17 21 85)

 <span class="org-comment">;----- Functions that return functions ------------------;</span>

 <span class="org-type">In</span>[35]&gt; (<span class="org-keyword">fn</span> <span class="org-function-name">make-add</span> (k) (<span class="org-keyword">fn</span> (x) (+ k x)))
 $35 = &lt;FuncUDF: make-add&gt;

 <span class="org-type">In</span>[36]&gt; ((make-add 10) 5)
 $36 = 15

 <span class="org-type">In</span>[37]&gt; ((make-add 10) 80)
 $37 = 90

 <span class="org-type">In</span>[38]&gt; ((make-add 20) 5)
 $38 = 25

 <span class="org-type">In</span>[39]&gt; ((make-add 20) 80)
 $39 = 100

 <span class="org-type">In</span>[40]&gt; (<span class="org-keyword">def</span> <span class="org-variable-name">add10</span> (make-add 10))
 $40 = &lt;FuncUDF: &gt;

 <span class="org-type">In</span>[41]&gt; (<span class="org-keyword">def</span> <span class="org-variable-name">add20</span> (make-add 20))
 $41 = &lt;FuncUDF: &gt;

 <span class="org-type">In</span>[42]&gt; (add20 50)
 $42 = 70
 <span class="org-type">In</span>[43]&gt; (add10 50)
 $43 = 60

 <span class="org-type">In</span>[44]&gt; (map (make-add 10) (list 1 2 3 4 5 6))
 $44 = (11 12 13 14 15 16)

 <span class="org-type">In</span>[45]&gt; (map (make-add 20) (list 1 2 3 4 5 6))
 $45 = (21 22 23 24 25 26)
 <span class="org-type">In</span>[46]&gt; 

 <span class="org-comment">;------- Interact with Java Objects --------------------;</span>

 <span class="org-type">In</span>[46]&gt; (<span class="org-keyword">def</span> <span class="org-variable-name">frame</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JFrame</span> <span class="org-string">"My Window"</span>))
 $46 = &lt;Obj: <span class="org-type">javax.swing.JFrame</span>[frame0,0,0,0x0,invalid,hidden,layout=java.awt.<span class="org-type">BorderLayout</span>
          ,title=My <span class="org-type">Window</span>,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE
            ,rootPane=javax.swing.<span class="org-type">JRootPane</span>[,0,0,0x0,invalid,layout=javax.swing.<span class="org-type">JRootPane$RootLayout</span>
           ,alignmentX=0.0,alignmentY=0.0,border=,flags=16777673,maximumSize=,minimumSize=,preferredSize=]
          ,rootPaneCheckingEnabled=true]&gt;

 <span class="org-type">In</span>[48]&gt; (frame <span class="org-clojure-keyword">:size</span> '(400 500)) <span class="org-comment">; equivalent to frame.size = (400 500) property</span>
 $48 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[49]&gt; (frame <span class="org-clojure-interop-method">setSize</span> 400 500) <span class="org-comment">; equivalent to frame.setSize(400, 500)</span>
 $49 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[50]&gt; (frame <span class="org-clojure-interop-method">setTitle</span> <span class="org-string">"My Java Swing Lisp"</span>)
 $50 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[51]&gt; (frame <span class="org-clojure-interop-method">setVisible</span> #t) <span class="org-comment-delimiter">;; </span><span class="org-comment">Equivlanet to frame.setVisible(true)</span>
 $51 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[52]&gt; (frame <span class="org-clojure-keyword">:visible</span> #f) <span class="org-comment">; Property call. frame.visible = false</span>
 $52 = <span class="org-constant">nil</span>

 <span class="org-type">In</span>[53]&gt; (frame <span class="org-clojure-keyword">:visible</span> #t) <span class="org-comment">; Property call. frame.visible = true</span>
 $53 = <span class="org-constant">nil</span>
 <span class="org-type">In</span>[54]&gt; 


 <span class="org-comment">; Get object class object </span>
 <span class="org-comment">;---------------------------------------------------;</span>
 <span class="org-type">In</span>[55]&gt; (<span class="org-type">ref</span><span class="org-default">/</span>get-obj-class frame)
 $55 = &lt;Obj: class <span class="org-type">javax.swing.</span>JFrame&gt;

 <span class="org-comment">; Display all methods of object javax.swing.JFrame </span>
 <span class="org-comment">;---------------------------------------------------;</span>
 <span class="org-type">In</span>[56]&gt; (<span class="org-type">ref</span><span class="org-default">/</span>show-methods frame)
 public void <span class="org-type">javax.swing.</span>JFrame.remove(<span class="org-type">java.awt.Component</span>)
 public void <span class="org-type">javax.swing.</span>JFrame.update(<span class="org-type">java.awt.Graphics</span>)
 public static boolean <span class="org-type">javax.swing.</span>JFrame.isDefaultLookAndFeelDecorated()
 public <span class="org-type">javax.swing.JRootPane</span> <span class="org-type">javax.swing.</span>JFrame.getRootPane()
 public void <span class="org-type">javax.swing.</span>JFrame.setJMenuBar(<span class="org-type">javax.swing.JMenuBar</span>)
 public <span class="org-type">javax.swing.JMenuBar</span> <span class="org-type">javax.swing.</span>JFrame.getJMenuBar()
   ... ... ... ... ....           ... .... ... ... 
   ... ... ... ... ....           ... .... ... ... 

<span class="org-comment-delimiter">; </span><span class="org-comment">Display all methods of object javax.swing.JFrame containing the string "visible"</span>
<span class="org-comment-delimiter">;</span><span class="org-comment">-----------------------------------------------------------------</span>
<span class="org-type">In</span>[47]&gt; (<span class="org-type">ref</span><span class="org-default">/</span>show-methods frame <span class="org-string">"visible"</span>)
public void <span class="org-type">java.awt.</span>Window.setVisible(boolean)
public boolean <span class="org-type">java.awt.</span>Component.isVisible()
$57 = <span class="org-constant">nil</span>


<span class="org-comment-delimiter">; </span><span class="org-comment">----- Quit the interpreter --------------------------;;</span>
<span class="org-type">In</span>[59]&gt; <span class="org-clojure-interop-method">.q</span>
</pre>
</div>

<p>
Loading script <span class="underline">swing.jlisp</span>, in the REPL, that creates a Java Swing GUI application:
</p>


<div class="figure">
<p><a href="images/lisp-java-swing-gui1.png"><img src="images/lisp-java-swing-gui1.png" alt="lisp-java-swing-gui1.png" /></a>
</p>
<p><span class="figure-number">Figure 1: </span>Sample Java GUI created by the lisp script swing.jlisp</p>
</div>


<div class="org-src-container">
<pre class="src src-clojure">   $ &gt;&gt; rlwrap java -jar <span class="org-type">sexpr.jar</span> repl
   [<span class="org-constant">TRACE</span> ] <span class="org-type">Code</span> evaluated <span class="org-type">OK.</span>  
   =====&gt; <span class="org-type">Interactive</span> S-Expression interpreter started. <span class="org-type">Ok.</span> 
    [*] <span class="org-type">Type</span> <span class="org-clojure-interop-method">.help</span> or <span class="org-clojure-interop-method">.h</span> for showing the help menu.
  
   <span class="org-type">In</span>[0]&gt; 
   <span class="org-type">In</span>[0]&gt; (load-script <span class="org-string">"swing.jlisp"</span>)
   [========&gt;&gt;&gt; <span class="org-type">Loaded</span> <span class="org-type">Code</span> &lt;&lt;&lt;============]
  <span class="org-comment-delimiter">;;</span><span class="org-comment">----------------------------------------------;;</span>
  <span class="org-comment-delimiter">;;            </span><span class="org-comment">Lisp Script                       ;;</span>
  <span class="org-comment-delimiter">;;</span><span class="org-comment">----------------------------------------------;;</span>
  
   ... ... ... ... ... ..
  
  (println <span class="org-string">" [TRACE ] Code evaluated OK. "</span>)
  
   [<span class="org-constant">TRACE</span>] <span class="org-type">Script</span> started <span class="org-type">Ok.</span>  
   [<span class="org-constant">TRACE</span> ] <span class="org-type">Code</span> evaluated <span class="org-type">OK.</span>  
   $0 = <span class="org-constant">nil</span>
   
  
   <span class="org-comment">; ...... Show all variables in the repl ---------;;</span>
  
   <span class="org-type">In</span>[1]&gt; <span class="org-clojure-interop-method">.vars</span>
   =&gt;&gt; Variables: 
   <span class="org-type">m</span><span class="org-default">/</span><span class="org-constant">PI</span>
   env
   color-light-blue
   color-red
   color-white
   color-black
   label
   output
   entry
   btn-run
   btn-demo
   scroll-entry
   scroll-output
   frame
   count
   ans
   $0
   
   <span class="org-type">In</span>[2]&gt; (<span class="org-type">m</span><span class="org-default">/</span>sin <span class="org-type">m</span><span class="org-default">/</span><span class="org-constant">PI</span>)
   $2 = 1.2246467991473532E-16
  
   <span class="org-type">In</span>[3]&gt; (<span class="org-type">m</span><span class="org-default">/</span>cos (* 2 <span class="org-type">m</span><span class="org-default">/</span><span class="org-constant">PI</span>))
   $3 = 1.0
  
   <span class="org-type">In</span>[4]&gt; (<span class="org-type">m</span><span class="org-default">/</span>tan (* 2 <span class="org-type">m</span><span class="org-default">/</span><span class="org-constant">PI</span>))
   $4 = -2.4492935982947064E-16
  
   <span class="org-type">In</span>[5]&gt; (frame <span class="org-clojure-interop-method">getTitle</span>)
   $5 = <span class="org-string">"My Java Swing App"</span>
  
   <span class="org-type">In</span>[6]&gt; (frame <span class="org-clojure-keyword">:title</span>)
   $6 = <span class="org-string">"My Java Swing App"</span>
  
   <span class="org-comment">; =&gt;&gt; User clicks at the button with the label 'Click me'</span>
   <span class="org-type">In</span>[8]&gt; (label <span class="org-clojure-interop-method">getText</span>)
   $8 = <span class="org-string">"Button clicked 25"</span>
   <span class="org-type">In</span>[9]&gt; 
   <span class="org-type">In</span>[9]&gt; (label <span class="org-clojure-keyword">:text</span>)
   $9 = <span class="org-string">"Button clicked 25"</span>
   <span class="org-type">In</span>[10]&gt; 
   <span class="org-type">In</span>[10]&gt; (label <span class="org-clojure-keyword">:text</span>)
   $10 = <span class="org-string">"Button clicked 29"</span>
   <span class="org-type">In</span>[11]&gt; 
   <span class="org-type">In</span>[11]&gt; (label <span class="org-clojure-keyword">:text</span>)
   $11 = <span class="org-string">"Button clicked 32"</span>
   <span class="org-type">In</span>[12]&gt; 
   <span class="org-type">In</span>[12]&gt; count
   $12 = 33
   <span class="org-type">In</span>[13]&gt; 
  
   <span class="org-comment-delimiter">;; </span><span class="org-comment">----- User enters some code at the upper JTextArea widget and press the button with label 'Run'</span>
   <span class="org-comment-delimiter">;;</span>
  
   <span class="org-type">In</span>[15]&gt; (<span class="org-keyword">def</span> <span class="org-variable-name">code</span> (entry <span class="org-clojure-interop-method">getText</span>))
   $15 = <span class="org-string">"(def myFrame (doto (new javax.swing.JFrame)</span>
<span class="org-string">                                (</span><span class="org-clojure-keyword"><span class="org-string">:size</span></span><span class="org-string"> '(400 500))</span>
<span class="org-string">                                (</span><span class="org-clojure-keyword"><span class="org-string">:title</span></span><span class="org-string"> "</span><span class="org-type">Lisp</span> <span class="org-type">Interpreter</span><span class="org-string">")</span>
<span class="org-string">                                (</span><span class="org-clojure-keyword"><span class="org-string">:visible</span></span><span class="org-string"> #t)))</span>
<span class="org-string">  "</span>
  
  <span class="org-comment-delimiter">;; </span><span class="org-comment">User clicks at the button 'Run' and the code is evaluated creating the variable myFrame </span>
   <span class="org-type">In</span>[16]&gt; Btn-run clicked <span class="org-constant">OK</span> 
  &lt;Obj: <span class="org-type">javax.swing.JFrame</span>[frame0,0,0,400x500, ....&gt;
  <span class="org-type">Code</span> evaluated. <span class="org-type">OK.</span> 
  
   <span class="org-type">In</span>[16]&gt; (<span class="org-clojure-interop-method">myFrame</span> <span class="org-clojure-keyword">:text</span>)
  Error: <span class="org-type">Method</span> <span class="org-clojure-interop-method">getText</span> not found.
  
   <span class="org-type">In</span>[16]&gt; (<span class="org-clojure-interop-method">myFrame</span> <span class="org-clojure-keyword">:title</span>)
   $16 = <span class="org-string">"Lisp Interpreter"</span>
  
  <span class="org-comment-delimiter">;; </span><span class="org-comment">----- Now the user types a new code in the upper JTextArea widget ------------;;</span>
   <span class="org-type">In</span>[17]&gt; (entry <span class="org-clojure-keyword">:text</span>)
   $17 = <span class="org-string">"(println "</span><span class="org-type">Code</span> typed by user in a <span class="org-type">JFrame</span> <span class="org-type">Widget</span><span class="org-string">")"</span>
  
    <span class="org-type">In</span>[19]&gt; (read (entry <span class="org-clojure-keyword">:text</span>))
   $19 = (println <span class="org-string">"Code typed by user in a JFrame Widget"</span>)
  
   <span class="org-type">In</span>[20]&gt; (eval (read (entry <span class="org-clojure-keyword">:text</span>)))
  <span class="org-type">Code</span> typed by user in a <span class="org-type">JFrame</span> <span class="org-type">Widget</span> 
   $20 = <span class="org-constant">nil</span>
  
   <span class="org-type">In</span>[22]&gt; (nth 1 (read (entry <span class="org-clojure-keyword">:text</span>)))
   $22 = <span class="org-string">"Code typed by user in a JFrame Widget"</span>
  
  <span class="org-comment-delimiter">;; </span><span class="org-comment">---- Now the user clicks at button 'Run' -------------------------------;;</span>
  <span class="org-comment-delimiter">;;</span>
   <span class="org-type">In</span>[23]&gt; Btn-run clicked <span class="org-constant">OK</span> 
  <span class="org-type">Code</span> typed by user in a <span class="org-type">JFrame</span> <span class="org-type">Widget</span> 
  <span class="org-constant">nil</span> 
<span class="org-type">Code</span> evaluated. <span class="org-type">OK.</span> 

</pre>
</div>

<p>
Run script <span class="underline">swing.jlisp</span> from command line without entering in the REPL:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ java -jar sexpr.jar script swing.jlisp
</pre>
</div>

<p>
<b>Creating a self-executable jar file</b>
</p>

<p>
A self-executable Jar file can be run without <span class="underline">java -jar file.jar</span> on
any Unix-like operating system, including, Linux, BSD or MacOSX. This
technique does not work on Microsoft Windows because unlike Unix-based
operating system, simple text files cannot be set as executable or be run
like a native executable on Windows without explicitly specifying the
interpreter.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Creates Unix shell script file 'sexpr' </span>
cat &lt;&lt;EOF &gt; sexpr  
<span class="org-sh-heredoc">#!/usr/bin/env sh </span>
<span class="org-sh-heredoc">java -jar "\$0" \$*</span>
<span class="org-sh-heredoc">exit 0</span>
<span class="org-sh-heredoc">EOF</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">append the contents of jar file to the script.</span>
$ cat sexpr.jar &gt;&gt; sexpr

<span class="org-comment-delimiter"># </span><span class="org-comment">Inspect it </span>
$ file sexpr
<span class="org-function-name">sexpr</span>: a /usr/bin/env sh  script executable (binary data)

<span class="org-comment-delimiter"># </span><span class="org-comment">Make it executable. </span>
chmod +x sexpr
</pre>
</div>

<p>
Inspect the generated file:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ file ./sexpr 
<span class="org-function-name">./sexpr</span>: a /usr/bin/env sh  script executable (binary data)

$ head -n 3 ./sexpr 
<span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/env sh </span>
java -jar <span class="org-string">"$0"</span> $<span class="org-variable-name">*</span>
<span class="org-keyword">exit</span> 0
</pre>
</div>

<p>
Run the executable:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">List all unit tests </span>
$ ./sexpr tests --list 
 [0] =&gt; test parser - case parse a simple list 
 [1] =&gt; test parser -parse a nested list 
 [2] =&gt; test intepreter - eval () empty list evaluation 
 [3] =&gt; test intepreter - expression evaluation 
 [4] =&gt; test intepreter - quoted expression evaluation 
 [5] =&gt; test intepreter - lambda <span class="org-keyword">function</span> <span class="org-function-name">application</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Run a single unit test</span>
$ ./sexpr tests --single 3
[PASSED] Test <span class="org-string">'test intepreter - expression evaluation'</span> (id = 3) passed. Ok.

<span class="org-comment-delimiter"># </span><span class="org-comment">Run the script </span>
$ ./sexpr script swing.jlisp 
 [TRACE] Script started Ok.  
 [TRACE ] Code evaluated OK.  
Btn-run clicked OK 
Hello world Java Rulez! 
nil 
Code evaluated. OK. 
</pre>
</div>

<p>
Install the executable for running it without specifying the relative
path with <span class="underline">/path/executable/sexpr</span> &lt;OPTIONS&gt;. Just move the file 'sexpr'
to any directory listed in $PATH environment variable such as /bin. 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">-------------------------------#</span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">BEFORE                  #</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">-------------------------------#</span>
$ which sexpr

$ sexpr

Command <span class="org-string">'sexpr'</span> not found, did you mean:

  <span class="org-builtin">command</span> <span class="org-string">'expr'</span> from deb coreutils (8.30-3ubuntu2)

<span class="org-function-name">Try</span>: sudo apt install &lt;deb name&gt;

<span class="org-comment-delimiter">#</span><span class="org-comment">--------------------------------#</span>
<span class="org-comment-delimiter">#      </span><span class="org-comment">INSTALLATION              #</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">--------------------------------#</span>
$ sudo cp -v ./sexpr /bin

<span class="org-comment-delimiter">#</span><span class="org-comment">------------------------------# </span>
<span class="org-comment-delimiter">#       </span><span class="org-comment">AFTER                  #</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">------------------------------#</span>
$ which sexpr
/usr/bin/sexpr

$ sexpr tests
------------------------ TEST REPORT ----------------------------------

 [*] SUCCESS - ALL TESTS PASSED OK. 
 [*] Passed =  6 (100.0%) / Failures = 0 (0.0%) / Error = 0 (0.0%) / Total = 6
</pre>
</div>

<p>
Run the script <span class="underline">swing.jlisp</span> without explicitly specifying the
interpreter in the command line. 
</p>

<ul class="org-ul">
<li>Add the following header to the script:</li>
</ul>


<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/</span><span class="org-keyword">env</span><span class="org-comment"> sh </span>
<span class="org-keyword">exec</span> /bin/sexpr script <span class="org-string">"$0"</span>
<span class="org-negation-char">!</span>#
</pre>
</div>

<p>
or 
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="org-comment">#!/usr/bin/env sh </span>
exec java -jar /bin/sexpr.jar script <span class="org-string">"$0"</span>
!#
</pre>
</div>

<p>
Now, the script <span class="underline">swing.jlisp</span> becomes:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/</span><span class="org-keyword">env</span><span class="org-comment"> sh </span>
<span class="org-keyword">exec</span> /bin/sexpr script <span class="org-string">"$0"</span>
<span class="org-negation-char">!</span>#
;;----------------------------------------------;;
;;            Lisp Script                       ;;
;;----------------------------------------------;;

(comment  Anything<span class="org-keyword"> in</span> this comment special form is not evaluted.)

(fn make-color (r g b) (new java.awt.Color r g b))

<span class="org-builtin">.</span> .. ..  ... ...         ... ... ... ... ... ... 
<span class="org-builtin">.</span> .. ..  ... ...         ... ... ... ... ... ... 
</pre>
</div>

<p>
Make the script executable:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ chmod +x swing.jlisp 
</pre>
</div>

<p>
Run the script:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./swing.jlisp 

 [TRACE] Script started Ok.  
 [TRACE ] Code evaluated OK.  
Btn-run clicked OK 
Btn-run clicked OK 
 ... ... ... ... ... ... ... ... 
 ... ... ... ... ... ... ... ... 
</pre>
</div>

<p>
The script execution can simplified even further by creating an
executor script named as <span class="underline">sexprsh</span> at /bin directory or any other
directory listed in the $PATH enviroment variable.
</p>

<p>
File: <span class="underline">/bin/sexprsh</span>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/</span><span class="org-keyword">env</span><span class="org-comment"> sh</span>
<span class="org-keyword">exec</span> java -jar /bin/sexpr.jar script <span class="org-string">"$1"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">exec java -jar /bin/sexpr script "$1"  # Alternative way</span>
</pre>
</div>

<p>
or:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/usr/bin/</span><span class="org-keyword">env</span><span class="org-comment"> sh</span>
<span class="org-keyword">exec</span> /bin/sexpr script <span class="org-string">"$1"</span>  
</pre>
</div>

<p>
Set the shell script as executable:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ sudo chmod  +x /bin/sexprsh
</pre>
</div>

<p>
Create a new script named as myscript.jlisp
</p>

<div class="org-src-container">
<pre class="src src-clojure">#<span class="org-type">!/bin</span><span class="org-default">/</span>sexprsh 

(<span class="org-keyword">def</span> <span class="org-variable-name">frame</span> (<span class="org-keyword">doto</span> (<span class="org-keyword">new</span> <span class="org-type">javax.swing.JFrame</span>) 
              (<span class="org-clojure-keyword">:title</span> <span class="org-string">"Hello world"</span>) <span class="org-comment">; Similar doto frame.setTile("hello world")</span>
              (<span class="org-clojure-keyword">:size</span> '(400 500))     <span class="org-comment">; Similar to frame.setSize(400, 400)</span>
              (<span class="org-clojure-keyword">:visible</span> #t)))        <span class="org-comment">; Similar to frame.setVisible(true) </span>


(<span class="org-keyword">def</span> <span class="org-variable-name">EXIT-ON-CLOSE</span> 3)

<span class="org-comment-delimiter">; </span><span class="org-comment">Exit process when user clicks at button close </span>
(frame <span class="org-clojure-interop-method">setDefaultCloseOperation</span> EXIT-ON-CLOSE)

(println <span class="org-string">"Hello world! [EN] / Hola Mundo! [ES]"</span>) 
</pre>
</div>

<p>
Make the script executable:  
</p>

<div class="org-src-container">
<pre class="src src-sh">$ sudo chmod +x myscript.jlisp 
</pre>
</div>

<p>
Run the script - the process terminates when the user clicks at the
button close of the Java Swing window located at the left upper
corner:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./myscript.jlisp 
Hello world! [EN] / Hola Mundo! [ES] 
</pre>
</div>

<p>
The GUI script myscript.jlisp can be launched clicking by creating a
desktop entry launcher file .desktop at directory
~/Desktop/myscript.jlisp. The shortcut files specified by Freedesktop
standard which is used by Linux and BSD distributions for launching
applications by clicking at icons don't support relative paths without
complicated shell scripts hacks what makes it harder to ship
self-contained applications for Linux desktop. Unfortunately, what
should be simple is not simple. 
</p>

<p>
Creating the file <span class="underline">~/Desktop/myscript.desktop</span>
</p>

<div class="org-src-container">
<pre class="src src-conf">[<span class="org-type">Desktop Entry</span>]
<span class="org-variable-name">Version</span>=1.0
<span class="org-variable-name">Type</span>=Application
<span class="org-variable-name">Name</span>=Myscript Launcher
<span class="org-variable-name">Comment</span>=JLisp Script with GUI interface 1 
<span class="org-variable-name">Exec</span>=java -jar /bin/sexpr.jar script /home/user/formula-parser/myscript.jlisp
<span class="org-variable-name">Icon</span>=terminator
<span class="org-variable-name">Path</span>=
<span class="org-variable-name">Terminal</span>=false
<span class="org-variable-name">StartupNotify</span>=true
</pre>
</div>

<p>
Or:
</p>

<div class="org-src-container">
<pre class="src src-conf">[<span class="org-type">Desktop Entry</span>]
<span class="org-variable-name">Version</span>=1.0
<span class="org-variable-name">Type</span>=Application
<span class="org-variable-name">Name</span>=Myscript Launcher
<span class="org-variable-name">Comment</span>=JLisp Script with GUI interface 1 
<span class="org-variable-name">Exec</span>= /home/user/formula-parser/myscript.jlisp
<span class="org-variable-name">Icon</span>=terminator
<span class="org-variable-name">Path</span>=
<span class="org-variable-name">Terminal</span>=false
<span class="org-variable-name">StartupNotify</span>=true
</pre>
</div>

<p>
Make the desktop entry executable. Now the ad-hoc GUI lisp-like
application can be launched just by clicking at the desktop file icon.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ chmod +x  myscript.desktop
</pre>
</div>

<p>
See:
</p>

<ol class="org-ol">
<li><a href="https://unix.stackexchange.com/questions/428992/why-do-freedesktop-desktop-files-not-allow-relative-paths">Why do freedesktop .desktop files not allow relative paths?</a></li>

<li><a href="https://askubuntu.com/questions/5172/running-a-desktop-file-in-the-terminal">Running a .desktop file in the terminal</a></li>

<li><a href="https://askubuntu.com/questions/262861/how-to-change-working-directory-when-open-a-file-with-double-clicking-on-ubuntu">How to change working directory when open a file with double clicking on ubuntu desktop?</a></li>

<li><a href="https://unix.stackexchange.com/questions/144422/getting-the-current-path-in-desktop-exec-command">Getting the current path in .desktop EXEC command</a></li>

<li><a href="https://askubuntu.com/questions/722179/icon-path-in-desktop-file">Icon path in .desktop file</a></li>
</ol>
</div>
</div>

<div id="outline-container-org70d4034" class="outline-4">
<h4 id="org70d4034"><span class="section-number-4">1.11.6</span> Further Reading</h4>
<div class="outline-text-4" id="text-1-11-6">
<p>
<b>Scheme and Lisp Introduction:</b>
</p>

<ul class="org-ul">
<li><a href="https://beautifulracket.com/appendix/glossary.html#reader">Beautiful Racket: Glossary</a></li>

<li><a href="https://spritely.institute/static/papers/scheme-primer.html">A Scheme Primer</a>
<ul class="org-ul">
<li>Introduction to Scheme programming language.</li>
</ul></li>

<li><a href="http://axisofeval.blogspot.com/2010/08/three-principles-of-lisp.html">The Axis of Eval: Three Principles of Lisp</a></li>

<li><a href="http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/">Homoiconicity isnt the point</a></li>

<li><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html">Beautiful Racket: Why Racket? Why Lisp?</a></li>

<li><a href="http://www.paulgraham.com/rootsoflisp.html">The Roots of Lisp</a> - Paul Graham</li>

<li><a href="http://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf">Growing a Language - Guy L. Steele Jr.</a></li>

<li><a href="https://lwn.net/Articles/778550/">Lisp and the foundations of computing - LWN.net</a></li>

<li><a href="https://gist.github.com/vindarel/c1ef5e043773921e3b11d8f4fe1ca7ac">Common Lisp VS Racket. Feedback from lispers.  GitHub</a></li>

<li><a href="https://dept-info.labri.fr/~strandh/Teaching/Langages-Enchasses/Common/Strandh-Tutorial/diff-scheme.html">Differences between Scheme and Common Lisp</a></li>

<li><a href="https://www-users.cse.umn.edu/~gini/4511/lisp/scheme.html">Notes on Lisp </a></li>

<li><a href="https://dreamsongs.com/Separation.html">Function Cells and Value Cells</a></li>

<li><a href="https://erikexplores.substack.com/p/what-makes-lisp-unique">What Makes LISP Unique? - by Erik Engheim - Erik Explores</a></li>

<li>Book: <a href="https://people.eecs.berkeley.edu/~bh/ss-toc2.html">Simply Scheme: Introducing Computer Science</a> (1999)</li>

<li><a href="https://www.arxiv-vanity.com/papers/1505.07375/">The Mysteries of Lisp &#x2013; I: The Way to S-expression Lisp arXiv Vanity</a></li>
</ul>


<p>
<b>About how to implement Lisp-like dialects:</b>
</p>

<ul class="org-ul">
<li><a href="https://norvig.com/lispy.html">(How to Write a (Lisp) Interpreter (in Python))</a> - Peter Norvig</li>

<li><a href="http://norvig.com/lispy2.html">(An ((Even Better) Lisp) Interpreter (in Python))</a> - Peter Norvig</li>

<li><a href="http://fogus.me/fun/lithp/">Lithp - A interpreter for John McCarthy's original Lisp.</a>
<ul class="org-ul">
<li>Interpreter written in Python in literate programming style.</li>
</ul></li>

<li>BOOK: <a href="https://en.m.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world</a>
<ul class="org-ul">
<li>Scheme implementation in Haskell programming language, that can
be hard to understand for people not acquainted with Haskell.</li>
</ul></li>

<li>BOOK: <a href="https://write-yourself-a-scheme.pangwa.com/#/">Write Yourself a scheme in 48 hours in F# (FSharp)</a></li>

<li>BOOK: <a href="https://wespiser.com/writings/wyas/00_overview.html">Write You A Scheme, Version 2.0</a>
<ul class="org-ul">
<li>Scheme implementation in Haskell.</li>
</ul></li>

<li>BOOK: <a href="https://www.buildyourownlisp.com">Learn C  Build Your Own Lisp</a></li>

<li>BOOK: <a href="http://t3x.org/lfn/">Lisp from nothing</a> 
<ul class="org-ul">
<li>Presents how to build a metacircular LISP interpreter in common
lisp; a metacircular lisp interpreter in Scheme; a self-hosting
lisp compiler and garbage collector.</li>
</ul></li>

<li>BOOK: <a href="https://lispcookbook.github.io/cl-cookbook/">The Common Lisp Cookbook</a></li>

<li>BOOK: <a href="https://sarabander.github.io/sicp/html/">Structure and Interpretation of Computer Programs, 2e: Top</a></li>

<li>BOOK: <a href="https://en.m.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics">Structure and Interpretation of Classical Mechanics</a></li>

<li>BOOK: <a href="https://www.cs.cmu.edu/~dst/LispBook/">Common Lisp: A Gentle Introduction to Symbolic Computation</a></li>

<li><a href="https://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">Kwang's Haskell Blog - Write you an interpreter</a>
<ul class="org-ul">
<li>Scheme implementation in Haskell.</li>
</ul></li>

<li><a href="http://kflu.github.io/2018/04/15/2018-04-15-implement-scheme/">How to write a Scheme interpreter  hello world </a> 
<ul class="org-ul">
<li>Implementation in .NET</li>
<li>Repository: <a href="https://github.com/Microsoft/schemy">https://github.com/Microsoft/schemy</a></li>
</ul></li>

<li><a href="http://peter.michaux.ca/articles/scheme-from-scratch-introduction">Scheme from Scratch - Introduction</a></li>

<li><a href="https://swatson555.github.io/posts/2022-05-06-make-a-lisp-2.html">Roll A Lisp In C - Evaluation</a></li>

<li><a href="https://github.com/rzubek/CSLisp">rzubek/CSLisp: C# Scheme - Lisp implementation for embedding in .NET projects</a></li>

<li><a href="https://brianmckenna.org/blog/sexp_scala">S-expression Compiler in Scala</a></li>

<li><a href="http://www.elizas.website/seax/implementation/secd.html">The SECD Abstract Machine</a></li>

<li><a href="https://eli.thegreenplace.net/2022/why-is-it-easy-to-implement-a-lisp/">Why is it easy to implement a Lisp? - Eli Bendersky's website</a></li>

<li><a href="https://www.cs.umd.edu/class/spring2022/cmsc430/Notes.html">CMSC 430:  Design and Implementation of Programming Languages</a></li>

<li><a href="https://github.com/norvig/paip-lisp">https://github.com/norvig/paip-lisp</a> 
<ul class="org-ul">
<li>Brief: "This is an open-source repository for the book Paradigms
of Artificial Intelligence Programming: Case Studies in Common
Lisp by <span class="underline">Peter Norvig</span> (1992), and the code contained therein. The
copyright has reverted to the author, who has shared it here
under MIT license. On the list of most influential books for
programmers. As seen on TV. See also: errata, comments,
retrospective."</li>
</ul></li>
</ul>


<p>
<b>Lisp Variants:</b>
</p>

<ul class="org-ul">
<li><a href="https://janet-lang.org">Janet Programming Language</a> (akin to Clojure)</li>

<li><a href="https://github.com/picolisp/pil21">GitHub - picolisp/pil21: PicoLisp dialect</a></li>

<li><a href="https://woodrush.github.io/blog/lambdalisp.html">LambdaLisp - A Lisp Interpreter That Runs on Lambda Calculus | Woodrushs Blog</a></li>

<li><a href="https://github.com/programming-nu/nu">NU Lisp</a>
<ul class="org-ul">
<li>"Nu is an interpreted Lisp that builds on the Objective-C runtime and Foundation framework."</li>
</ul></li>

<li><a href="http://www.newlisp.org/index.cgi?FAQ">newLISP  - FAQ</a> 
<ul class="org-ul">
<li>"newLISP is a general purpose scripting language for developing
web applications and programs in general in the domains of
artificial intelligence (AI), statistics and machine learning."</li>
</ul></li>

<li><a href="http://www.ulisp.com/show?2XZH">uLisp - ARM Assembler in Lisp</a></li>

<li><a href="http://lush.sourceforge.net/">http://lush.sourceforge.net/</a></li>

<li><a href="https://github.com/JeffBezanson/femtolisp">Femtolisp</a>
<ul class="org-ul">
<li>Scheme-lisp dialect that inspired the Julia programming
language.</li>
</ul></li>

<li><a href="https://ccrma.stanford.edu/software/snd/snd/s7.html">s7 Scheme - Embedded Scripting Language</a></li>

<li><a href="https://scsh.net/">SCSH Scheme</a> - Unix-shell scripting in scheme scripting language
<ul class="org-ul">
<li>"Scsh is an open-source Unix shell embedded within Scheme,
running on all major Unix platforms including AIX, Cygwin,
Linux, FreeBSD, GNU Hurd, HP-UX, Irix, Mac OS X, Solaris, and
some others. Scsh is a variant of Scheme 48 (an R5RS compliant
new-tech Scheme system) Scsh is designed for writing real-life
standalone Unix programs and shell scripts. Scsh spans a wide
range of application, from script applications usually handled
with perl or sh, to more standard systems applications usually
written in C."</li>
</ul></li>

<li><a href="https://scsh.net/docu/html/man-Z-H-1.html">Scsh - Scheme Unix Shell Scripting - Reference Manual</a>
<ul class="org-ul">
<li>"This is the reference manual for scsh, a Unix shell that is
embedded within Scheme. Scsh is a Scheme system designed for
writing useful standalone Unix programs and shell scripts &#x2013; it
spans a wide range of application, from ``script'' applications
usually handled with perl or sh, to more standard systems
applications usually written in C. Scsh comes built on top of
Scheme 48, and has two components: a process notation for
running programs and setting up pipelines and redirections, and
a complete syscall library for low-level access to the operating
system. This manual gives a complete description of scsh. A
general discussion of the design principles behind scsh can be
found in a companion paper, ``A Scheme Shell.'' "</li>
</ul></li>

<li>[PDF] <a href="https://www.ccs.neu.edu/home/shivers/papers/scsh.pdf">A Scheme Shell - MIT - Olin Shivers</a></li>

<li>[PDF] <a href="https://3e8.org/pub/scheme/doc/lisp-pointers/v6i3/p71-petrus.pdf">SKILL: a Lisp Based Extension Language</a></li>

<li>[PDF] <a href="https://community.cadence.com/cfs-file/__key/telligent-evolution-components-attachments/00-28-01-00-00-01-04-75/CadScriptingLanguages_5F00_skill.pdf">A quick tour to skill programming language - Cadence CAD / Lisp.</a></li>

<li>[PDF] <a href="https://perun.pmf.uns.ac.rs/radovanovic/publications/2002-prim-lisp.pdf">An implementation of LISPKIT Lisp in Java</a> (SECD Abstract Machine)</li>

<li><a href="http://www.lispme.de/lispme/doc/lm_hood.htm">LispMe internals</a>
<ul class="org-ul">
<li>This implementation uses a SECD Virtual Machine instead of a
recursive AST evaluator. The code is compiled to SECD machine
bytecodes and later executed by a SECD virtual machine.</li>
</ul></li>

<li><a href="http://kflu.github.io/2018/04/15/2018-04-15-implement-scheme/">How to write a Scheme interpreter  hello world </a> 
<ul class="org-ul">
<li>Implementation in .NET</li>
<li>Repository: <a href="https://github.com/Microsoft/schemy">https://github.com/Microsoft/schemy</a></li>
</ul></li>

<li><a href="https://github.com/shikantaza/pLisp">GitHub - shikantaza/pLisp: Don't Lisp, Talk!</a></li>

<li><a href="https://european-lisp-symposium.org/static/2018/jayaprakash.pdf">pLisp: A Friendly Lisp IDE for Beginners</a>
<ul class="org-ul">
<li>"pLisp is an integrated development environment for Lisp. While
it aims to be a friendly Lisp development system for beginners,
its feature-set is comprehensive enough to address the needs of
a small-to-medium sized Lisp project."</li>
<li>Note: Based on Commonlisp, Scheme and Smalltalk.</li>
</ul></li>

<li><a href="https://paulhammant.com/2013/03/28/interface-builders-alternative-lisp-timeline/">Interface Builder's Alternative Lisp timeline</a></li>

<li><a href="https://www.softwarepreservation.org/projects/LISP/le_lisp">Le_Lisp  Software Preservation Group</a></li>

<li><a href="https://gitlab.com/embeddable-common-lisp/ecl/">Embeddable Common-Lisp / ECL  GitLab</a></li>

<li><a href="https://www.isi.edu/isd/LOOM/Stella/index.html">STELLA Programming Language / Lisp that compiles to Java or C++ ; lisp</a></li>

<li><a href="https://github.com/kanaka/mal">GitHub - kanaka/mal: mal - Make a Lisp</a>
<ul class="org-ul">
<li>"Each implementation of mal is separated into 11 incremental,
self-contained (and testable) steps that demonstrate core
concepts of Lisp. The last step is capable of self-hosting
(running the mal implementation of mal). See the make-a-lisp
process guide. Mal is implemented in 87 languages (93 different
implementations and 115 runtime modes)."</li>
</ul></li>

<li><a href="https://web.archive.org/web/20160324184251/https://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">Embedding Scheme for a game mission scripting DSL</a></li>

<li><a href="https://en.m.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp">Game Oriented Assembly Lisp - Wikipedia</a></li>

<li><a href="https://opengoal.dev">OpenGOAL | OpenGOAL</a></li>

<li><a href="https://www.gamedeveloper.com/design/postmortem-naughty-dog-s-i-jak-and-daxter-the-precursor-legacy-i-">Postmortem: Naughty Dog's Jak and Daxter: the Precursor Legacy</a></li>

<li><a href="https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/">Making Crash Bandicoot  GOOL  part 9 - All Things Andy Gavin</a></li>

<li>[PDF] <a href="https://www.dreamsongs.com/Files/Timrep.pdf">Performance and Evaluation of Lisp Systems</a></li>

<li><span class="underline">AutoLisp</span> - Lisp Dialect, based on common lisp, used by Autocad
software for engineering drawings.
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/AutoLISP">AutoLISP - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dialog_Control_Language">Dialog Control Language</a></li>
<li><a href="https://www.afralisp.net/index.php">Learn AutoLISP for AutoCAD productivity</a></li>
<li><a href="https://www.cad-notes.com/good-autolisp-programming-techniques/">Good AutoLISP Programming Techniques</a></li>
<li>[PDF] <a href="http://docs.autodesk.com/ACDMAC/2013/ENU/PDFs/acdmac_2013_autolisp_developers_guide.pdf">AutoCAD 2013 AutoLISP Developer's Guide</a></li>
<li><a href="https://autocadtips1.com/category/autolisp-3d/">https://autocadtips1.com/category/autolisp-3d/</a></li>
</ul></li>
</ul>


<p>
<b>Common Lisp:</b>
</p>

<ul class="org-ul">
<li><a href="http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial.html">Common LISP Hints - 1993</a></li>

<li><a href="https://mikelevins.github.io/posts/2020-12-18-repl-driven/">On repl-driven programming - by mikel evins</a></li>

<li><a href="https://journal.infinitenegativeutility.com/structurally-typed-condition-handling">Structurally-Typed Condition Handling  Infinite Negative Utility</a></li>

<li><a href="http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html">Condition Handling in the Lisp Language Family'' c by Kent Pitman</a></li>

<li><a href="https://lisper.in/restarts">Common Lisp: A Tutorial on Conditions and Restarts</a></li>

<li><a href="https://www.kazimirmajorinc.com/Documents/On-Pitmans-Special-forms-in-Lisp/index.html">On Pitman's Special forms in Lisp</a></li>

<li><a href="https://ostash.dev/posts/2021-06-24-edn-data-notation/">Data notation in Clojure - Ostash.Dev</a></li>

<li><a href="http://www.lispworks.com/documentation/lw71/COM/html/com-11.htm#pgfId-889564">LispWorks - 1.7 Calling COM interface methods</a></li>

<li><a href="https://courses.cs.northwestern.edu/325/readings/clos.php">The Common Lisp Object System</a></li>

<li><a href="https://lisper.in/reader-macros">Reader Macros in Common Lisp</a></li>

<li><a href="https://gist.github.com/chaitanyagupta/9324402">Reader Macros in Common Lisp  GitHub</a></li>

<li><a href="https://www.lurklurk.org/cpp_clos.html">C++ and Lisp / multiple dispatch, multimethod, visitor design pattern</a></li>

<li><a href="https://sodocumentation.net/common-lisp/topic/1369/loop--a-common-lisp-macro-for-iteration">common-lisp Tutorial - LOOP, a Common Lisp macro for iteration</a></li>

<li><a href="https://borodust.org/delivering-common-lisp">Delivering games written in Common Lisp</a></li>

<li><a href="https://texdraft.github.io/lisp-compiler/internals.html">Lisp Compiler</a></li>
</ul>


<p>
<b>S-Expression Parsing:</b>
</p>

<ul class="org-ul">
<li><a href="https://wiki.c2.com/?EssExpressions">Wiki C2 - ESS Expressions</a></li>

<li><a href="https://rosettacode.org/w/index.php?title=S-expressions&amp;useformat=mobile">S-expressions - Rosetta Code</a></li>

<li><a href="https://github.com/edn-format/edn">EDN / Clojure - edn-format/edn: Extensible Data Notation</a> 
<ul class="org-ul">
<li>Clojure variant of S-Expressions (SExp) - Clojure EDN is easier
to read and has more rich data types than lisp's SEXP.</li>
</ul></li>

<li><a href="https://learnxinyminutes.com/docs/edn/">Clojure EDN - Learn edn in Y Minutes</a></li>

<li><a href="https://gist.github.com/DmitrySoshnikov/2a434dda67019a4a7c37">S-expression parser  GitHub</a> (JavaScript)</li>

<li><a href="https://wiki.c2.com/?XmlIsaPoorCopyOfEssExpressions">WIKI C2 - Xml Isa Poor Copy Of Ess Expressions</a></li>

<li><a href="https://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions">Some thoughts on JSON vs. S-expressions</a></li>

<li><a href="https://wiki.c2.com/?ExampleOfGreenspunsTenthAtWork">Example Of Greenspuns Tenth At Work</a></li>

<li><a href="https://kitchingroup.cheme.cmu.edu/blog/2017/05/04/An-emacs-lisp-dsl-for-gnuplot/">An Emacs Lisp DSL for GNU Plot</a></li>

<li><a href="https://macoy.me/blog/programming/CakelispIntro">Cakelisp: a programming language for games</a></li>

<li><a href="https://people.csail.mit.edu/rivest/Sexp.txt">S-expressions data structure - Ron Rivest</a></li>

<li><a href="https://github.com/janestreet/sexplib">GitHub - janestreet/sexplib: Automated S-expression conversion</a>
<ul class="org-ul">
<li>OCaml S-Expression parser</li>
</ul></li>

<li><a href="https://blog.janestreet.com/s-expressions-in-ruby/">S-Expressions in ruby - Janestreet</a>
<ul class="org-ul">
<li>"We use a lot of S-Expressions at Jane Street. Almost every
system written at Jane Street in OCaml uses sexps for config
files, and we use it for a lot of IPC (Inter-Process
Communication) when resources arent an issue."</li>
</ul></li>

<li><a href="https://dev.realworldocaml.org/data-serialization.html">Data Serialization with S-Expressions - Real World OCaml</a></li>

<li><a href="https://github.com/dryruby/sxp.rb">SXP - A universal S-expression parser for Ruby</a>
<ul class="org-ul">
<li>"This is a Ruby implementation of a universal S-expression
parser. Parses S-expressions in universal, Scheme, Common Lisp,
or SPARQL syntax."</li>
</ul></li>

<li><a href="https://jena.apache.org/documentation/notes/sse.html">SPARQL S-Expressions (or "SPARQL Syntax Expressions")</a></li>

<li><a href="https://github.com/BitPuffin/sexpresso">https://github.com/BitPuffin/sexpresso</a>
<ul class="org-ul">
<li>C++ S-Expression parser library</li>
</ul></li>

<li><a href="https://github.com/SuperTux/sexp-cpp">https://github.com/SuperTux/sexp-cpp</a>
<ul class="org-ul">
<li>C++ S-Expression parser library (GPL 3)</li>
</ul></li>

<li><a href="https://hackage.haskell.org/package/s-cargot">s-cargot: A flexible, extensible s-expression library</a>
<ul class="org-ul">
<li>Haskell S-Expression parser. The description of this page also
tells how SExp can be used as storage format, serialization
format and data description language.</li>
</ul></li>

<li><a href="https://github.com/drslump/sexp-php">GitHub - drslump/sexp-php: S-expression parser and serializer for PHP</a></li>

<li><a href="https://srfi.schemers.org/srfi-110/srfi-110.html">SRFI 110: Sweet-expressions (t-expressions)</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfb2baa8" class="outline-3">
<h3 id="orgfb2baa8"><span class="section-number-3">1.12</span> Expression interpreter</h3>
<div class="outline-text-3" id="text-1-12">
</div>
<div id="outline-container-org910d903" class="outline-4">
<h4 id="org910d903"><span class="section-number-4">1.12.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
The following source code provides an implementation of an interpreter
that able evaluate infix math expressions, with mathematics operator
precendence rules, and programming constructs including if-else
statements, while loop, for loop, function calls and function
definition. The application is comprised of three parts a lexer and
evaluator. The tokenizer, also known as tokenizer, is a component that
breaks the source code into lexical units called tokens. In this case,
a token is a struct containing the token <span class="underline">lexeme</span>, a string that
represents the token; the token <span class="underline">type</span> enumeration, which indicates
whether the token is a number, a keyword or a string; and metadata
related to the token position, column and line in the source code. The
parser component takes the token stream generated by the tokenizer as
input and produces an <span class="underline">AST - Abstract Syntax Tree</span> using a recursive
descent parsing algorithm that consists of mutually recursive
functions, each implementing a non-terminal grammar symbol. The final
part of the expression interpreter is an AST evaluator, that traverses
the AST - Abstract Syntax Tree nodes generated by the parser in a
recursive way for producing runtime values, that represents all
possible computation results. 
</p>

<p>
The techniques adopted in this sample code, can be used for
implementing formula evaluators, spreadsheets, CAS - Computer Algebra
Ssystems, DSL - Domain Specific Languages or embedded scripting
languages for allowing extending applications at runtime. Despite that
the C++ was used for implementing this interpreter, the algorithm can
easily be implemented in any other programming language and rewritten
in a more concise way in functional programming languages with pattern
matching and algebraic data types. For instance, in a functional
programming language, the visitor design pattern could be replaced by
a more concise pattern matching and the class hierarchies representing
the AST - Abstract Syntax Tree and interpreter runtime values could be
replaced by algebraic data types.
</p>


<p>
This parser implements the following grammar stated in ANTLR-style
EBNF (Extended Backnaur notation). The syntax of programming
constructs were borrowed from Basic and Pascal programming languages.
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">Complete program - is a collection of zero or more statements </span>
<span class="org-function-name">prog</span>: stat* ;

<span class="org-comment-delimiter">// </span><span class="org-comment">Statement </span>
<span class="org-function-name">stat</span>: expr <span class="org-string">";"</span>?          <span class="org-comment-delimiter">// </span><span class="org-comment">Expression </span>
    | IDEN <span class="org-string">"="</span> expr <span class="org-string">";"</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Assignment </span>
    | while_loop          
    | for_loop 
    ;

<span class="org-function-name">expr</span>:        logical ;
<span class="org-function-name">logical</span>:     equality ( ( <span class="org-string">"or"</span> | <span class="org-string">"and"</span> ) equality )* ;
<span class="org-function-name">equality</span>:    comparison ( ( <span class="org-string">"!="</span> | <span class="org-string">"=="</span> ) comparison )* ;
<span class="org-function-name">comparison</span>:  arithmetic ( ( <span class="org-string">"&gt;"</span> | <span class="org-string">"&gt;="</span> | <span class="org-string">"&lt;"</span> | <span class="org-string">"&lt;="</span> ) arithmetic )* ;

<span class="org-function-name">arithmetic</span>:  factor ( (<span class="org-string">"+"</span> | <span class="org-string">"-"</span>) factor  )* ;
<span class="org-function-name">factor</span>:      unary  ( (<span class="org-string">"*"</span> | <span class="org-string">"/"</span>) unary   )* ;

<span class="org-function-name">unary</span>: <span class="org-string">"+"</span>  unary  
      | <span class="org-string">"-"</span> unary  
      | <span class="org-string">"!"</span> unary  
      | power 
      ;

<span class="org-function-name">power</span>: call (<span class="org-string">"^"</span> unary)*  ; <span class="org-comment-delimiter">// </span><span class="org-comment">Exponentiation </span>

<span class="org-function-name">call</span>: atom 
    | IDEN <span class="org-string">"("</span> ( expr ( <span class="org-string">","</span> expr )* )?  <span class="org-string">")"</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Function call </span>
    ;

<span class="org-function-name">atom</span>  :  INTEGER         <span class="org-comment-delimiter">// </span><span class="org-comment">number </span>
       | FLOATING_POINT 
       | IDEN            <span class="org-comment-delimiter">// </span><span class="org-comment">Identifier, example function name or variable name   </span>
       | BOOLEAN         <span class="org-comment-delimiter">// </span><span class="org-comment">Logical value  </span>
       | SYMBOL          <span class="org-comment-delimiter">// </span><span class="org-comment">symbol like Lisp keyword or Ruby's symbols </span>
       | NIL             <span class="org-comment-delimiter">// </span><span class="org-comment">null value </span>
       | <span class="org-string">"("</span> expr <span class="org-string">")"</span>
       | expr_if         <span class="org-comment-delimiter">// </span><span class="org-comment">If-else statement </span>
       | expr_def        <span class="org-comment-delimiter">// </span><span class="org-comment">Function definition  </span>
       ;   

<span class="org-comment-delimiter">// </span><span class="org-comment">IF-Else statement (NOT IMPLEMENTED)</span>
<span class="org-function-name">expr_if</span>: <span class="org-string">"if"</span> expr <span class="org-string">"then"</span> stat+ <span class="org-string">"end"</span>
       | <span class="org-string">"if"</span> expr <span class="org-string">"then"</span> stat+ <span class="org-string">"else"</span> stat+ <span class="org-string">"end"</span>
       ;

<span class="org-comment-delimiter">// </span><span class="org-comment">Function definition </span>
<span class="org-function-name">expr_def</span>: <span class="org-string">"fn"</span> IDEN <span class="org-string">"("</span> (IDEN  (<span class="org-string">","</span> IDEN)*)?  <span class="org-string">")"</span> stat* <span class="org-string">"end"</span>
        | <span class="org-string">"fn"</span> IDEN <span class="org-string">"("</span> (IDEN (<span class="org-string">","</span> IDEN)* ))? <span class="org-string">")"</span> <span class="org-string">"-&gt;"</span> expr 
        ;

<span class="org-function-name">while_loop</span>: <span class="org-string">"while"</span> expr <span class="org-string">"do"</span> stat* <span class="org-string">"end"</span> ; 
<span class="org-function-name">for_loop</span>:   <span class="org-string">"for"</span> IDEN <span class="org-string">"="</span> expr <span class="org-string">"to"</span> expr (<span class="org-string">"by"</span> expr)? <span class="org-string">"do"</span> stat* <span class="org-string">"end"</span> ;

<span class="org-function-name">BOOLEAN</span>: <span class="org-string">"true"</span> | <span class="org-string">"false"</span> ;
<span class="org-function-name">NIL</span>:     <span class="org-string">"nil"</span> ;
<span class="org-function-name">SYMBOL</span>:  <span class="org-string">":"</span> ID ;
</pre>
</div>

<p>
The expression parser is able to parse the following syntax:
</p>

<div class="org-src-container">
<pre class="src src-pascal"><span class="org-comment">// Math expressions and formulas </span>
10 + 3 * 5 / (x + 2 * y + 4 * z) + exp(2.1) ^ 2 ^ 3 

<span class="org-comment">// Numbers in percent </span>
30% <span class="org-comment">// 0.30 </span>

<span class="org-comment">// Numbers with _ as thousand separator </span>
10_125_905 <span class="org-comment">// 10125905</span>

<span class="org-comment">// Floating point numbers </span>
2.15e3 

<span class="org-keyword">if</span> x &gt; 0 <span class="org-keyword">then</span> 
  print(<span class="org-string">"x is positive"</span>)
<span class="org-keyword">else</span> 
  print(<span class="org-string">"x is negative or zero"</span>)
<span class="org-keyword">end</span> 

x = 20

<span class="org-comment">// Result z = 100 </span>
z = <span class="org-keyword">if</span> x &gt; 10 <span class="org-keyword">then</span> 
      5 * x 
    <span class="org-keyword">else</span> 
      10 * x
    <span class="org-keyword">end</span> 

<span class="org-keyword">for</span> i = 1 <span class="org-keyword">to</span> 10 <span class="org-keyword">do</span> 
   print(<span class="org-string">" i = "</span>, i)
<span class="org-keyword">end</span> 

k = 10
<span class="org-keyword">while</span> k &gt; 0 <span class="org-keyword">do</span> 
   print(<span class="org-string">" k = "</span>, k)
   k = k - 1
<span class="org-keyword">end</span> 

fn short_function(x) -&gt; 3 * x + log10(x)

fn long_function(x, y, z)
   print(<span class="org-string">" x = "</span>, x)
   print(<span class="org-string">" y = "</span>, y)
   print(<span class="org-string">" z = "</span>, z)
<span class="org-keyword">end</span>
</pre>
</div>


<p>
<b>BNF - Backus-Naur and grammar-related terminology</b>
</p>

<ul class="org-ul">
<li><span class="underline">CFG</span> - Context-Free Grammar
<ul class="org-ul">
<li>As opposite to CSG - Context-Sensitive Grammars, production
rules of CFG grammars does not depend on the context. This type
of grammar can be described by BNF or EBFN notation.</li>
</ul></li>

<li><span class="underline">CSG</span> - Context-Sensitive Grammar 
<ul class="org-ul">
<li>Grammar which production rules are context-sensitive and depends
on the current context. The C and C++ programming languages grammars are
context-sensitive, since the interpretation of many programming
constructs are context-dependent. For instance, the meaning of
T * X in C and are dependent on the context, if T is type, such
as int, then X is a pointer variable. If both X and T are of
type int, float or any other numeric type, then the expression
is a multiplication between variables T and X.</li>
</ul></li>

<li>CFG - <span class="underline">Control Flow Graph</span></li>

<li><a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> - Backus-Naur Normal Form
<ul class="org-ul">
<li>Notation introduced by John Backus and Peter Naur for formally
describing <span class="underline">context-free grammars</span>, which are <span class="underline">not</span>
<span class="underline">context-sensitive</span> and not ambiguous. For instance C and C++
grammars are not context-free grammars since the meaning of an
expressions depends on the context, whether the symbol is a
function, pointer, class and so on.</li>
</ul></li>

<li><a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a> - Extended Backus-Naur Form</li>

<li><a href="https://en.wikipedia.org/wiki/ABNF">ABNF</a> - Augmented Backus-Naur Form
<ul class="org-ul">
<li>Modified Back-Naur Form notation for describing bidirectional
communication protocols. This notation is used to describe the
Http protocol, FTP protocol and other network protocols.</li>
</ul></li>

<li><a href="https://en.wikipedia.org/wiki/ANTLR">ANTLR</a> - <span class="underline">ANother Tool For Language Recognition</span>
<ul class="org-ul">
<li>Open source tool written in Java that takes an ANTLR-style EBNF
grammar and generates a parser for this grammar in a given
target language, such as Python, Ruby, Perl, Go (Golang), Java,
C# (CSharp), C, C++, JavaScript (ECMAScript), PHP and
Swift. ANTLR is one of the most used tools for generating
parsers and lexers/tokenizers. This parser generator tool has
its own EBNF grammar style that does not conform to ISO/IEC
14977 technical standard.</li>
</ul></li>

<li><a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> - Program that generates scanner/tokenizer/texer source code in C programming language.</li>

<li><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a> - (Yet Another Compiler-Compiler) - Program, akin to ANTLR,
that generates parser source code in C programming language. Yacc
is often used alongside Lex (Lex &amp; Yacc).</li>

<li><a href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)">Flex</a> (Lexical Analyser Generator) - GNU alternative to Lex.</li>

<li><a href="https://en.wikipedia.org/wiki/GNU_Bison">GNU Bison</a> - GNU alternative to Yacc. Ofen used together with Flex (Flex &amp; Bison).</li>

<li><a href="https://re2c.org/">RE2C</a> - Lexer code generator for C/C++, Go and Rust. This tool is
used by PHP, Ninja build system and BRL-CAD.</li>

<li><span class="underline">Parsing</span> - process of turning a string from text or source code
into some data structure such as AST - Abstract Syntax
Tree. Example, turning a string containing a JSON (Java-Script
Object) notation code into a tree-like data structure.</li>

<li><span class="underline">AST</span> - Abstract Syntax Tree 
<ul class="org-ul">
<li>Data structure that describes a tree representation of the
source code used as input of compiler code generators, bytecode
code generators, interpreters and pretty printers.</li>
</ul></li>

<li><a href="https://en.wikipedia.org/wiki/Document_Object_Model">DOM</a> - Document Object Model 
<ul class="org-ul">
<li>Abstract Syntax Tree representation of an XML or HTML
document. Whenever a web page is loaded, the web browser turns
the html code into a DOM object, a tree-like representatio the
html source code that is exposed to the JavaScript (ECMaScript)
code.</li>
</ul></li>

<li>DAG - Direct Acyclic Graph</li>

<li><span class="underline">SEXP</span> S-Expression from Lisp 
<ul class="org-ul">
<li>Lisp S-expressions are one of the most convenient and compact to
represent AST - Abstract Syntax Trees as text.</li>
</ul></li>

<li><span class="underline">Top-down Recursive Descent Parsing</span> or just <span class="underline">Recursive Descent Parsing</span>
<ul class="org-ul">
<li>Parser algorithm that uses mutually recursive functions or
methods for each non-terminal production rule. Despite the
simplicity of implementation of this parsing technique, it has
few shortcomings such as not being able to deal with
left-recursive and ambiguous grammars.</li>
</ul></li>

<li><span class="underline">TDOP - Top-Down Operator Precedence Parser</span> (the same as <span class="underline">Pratt Parser</span>)
<ul class="org-ul">
<li>Parser algorithm that can parse infix, prefix and postfix
expressions different operator precedence levels without a
non-terminal grammar rule for every precedence level. This
algorithm is more flexible than Top-Down Recursive Descent
Parsing since new operator precedence levels can be added
without modifying the grammar or adding new recursive function.</li>
</ul></li>

<li><span class="underline">Shunting-yard algorithm</span> (Edsger Dijkstra)
<ul class="org-ul">
<li>This algorithm uses a stack for turning infix expressions into
postfix expression, RPL - Reverse Polish Notation, which is
suitable for direct evaluation of infix expressions. Unlike
other algorithms, the output is not an AST - Abstract Syntax
Tree. Therefore, if an AST is needed, an additional algorithm
will be required for turning the postfix output into an AST.</li>
</ul></li>

<li><span class="underline">LALR</span> - Look Ahead Left-to-Right Rightmost derivation parser (Parser Algorithm)</li>

<li><a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">DFA</a> - Deterministic Finite Automaton</li>

<li>DSA - Deterministic Stack Automata (related to automata theory and formal languages)</li>

<li>NSA - Non-deterministic Stack Automata  (related to automata theory and formal languages)</li>

<li><span class="underline">DSL</span> - Domain Specific Language</li>

<li><span class="underline">GPL</span> - General Purpose Language</li>

<li><a href="https://en.wikipedia.org/wiki/Computer_algebra_system">CAS</a> - Computer Algebra System</li>

<li><span class="underline">SAS</span> - Symbolic Algebra System (Another name of CAS)</li>

<li>IR - Intermediate Representation</li>

<li>IL - Intermediate Language</li>

<li><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> Static Single-Assignment Form</li>

<li>EOI - End Of Input</li>

<li>EOF - End Of File</li>

<li>EOL - End Of Line</li>

<li>CR - Carriage Return - new line character (<code>\r</code> - 0x0D - 13)</li>

<li>LF - Line Feed - new line character (<code>\n</code> - 0x0A - 10)</li>

<li>CRLF - Carriage Return and Line Feed (<code>\r\n</code>)</li>

<li>LHS - Left-Hand Side, often the left-hand side of an infix
operator such as (plus): lhs + rhs.</li>

<li>RHS - Right-Hand Side, often the right-hand side of an infix
operator such as (star): lhs * rhs.</li>

<li><span class="underline">terminals</span> - (ANTLR) are written with upper case letters, for
instance, IDENTIFIER, NUMBER, &#x2026;
<ul class="org-ul">
<li>A Terminal symbol is just a single token that represents
an AST (Abstract Syntax Tree) node without any child AST
nodes. For instance, terminal symbols are string literals;
boolean literals (True, False in Python); integer literals;
floating point literals and so on.</li>
</ul></li>

<li><span class="underline">non-terminals</span> - (ANTLR) are written using camel-case or
snake-case convention. For instance: expr, program, <code>for_loop</code>.
<ul class="org-ul">
<li>A non-terminal symbol are symbols comprised of multiple terminal
symbols or tokens. Non-terminal symbols correponds to AST -
Abstract Syntax Tree nodes with multiple AST child nodes. For
instance, non-terminal symbols are often if-else statement,
for-loop statement, while-loop and so on.</li>
</ul></li>

<li>'=' - ISO/IEC 14977 - definition of grammar production rules
(non-terminals and terminals)</li>

<li>':' - (ANTLR) - definition of grammar production rules</li>

<li>':=' - defintion of grammar production rules - this notation is
used by some EBNF grammar variants.</li>

<li>'*' - Kleene Star - means 0 or more occurences of a pattern</li>

<li>'+' - Kleene Cross - means 1 or more occurrences of a pattern</li>

<li>'?' - question mark - means 0 or 1 occurences of a pattern</li>

<li>',' - (ISO/IEC 14977) - concatenation</li>

<li>'|' - (ISO/IEC 14977) alternation - separation between alternatives grammar production rules.</li>

<li>{ &#x2026; } - (ISO/IEC 14977) - repetition of 0 or more ocurrences - equivalent to (&#x2026;)*</li>

<li>( &#x2026; ) - parentheses are used for grouping</li>

<li>" &#x2026; " - terminal string</li>

<li>' &#x2026; ' - terminal string</li>

<li>(* &#x2026; *) - (ISO/IEC 14977) - comment</li>

<li>// &#x2026; - (ANTLR) comment</li>

<li>';' - ANTLR used as delimiter of grammar production rules</li>

<li>'' - Epsilon - used in grammar descriptions for eliminating
<span class="underline">left-recursion</span> by indicating an empty string. This notation is not
used by EBFN, that uses an empty string instead of any special
notation.</li>
</ul>


<p>
<b>Performance Optimization for Interpreters</b>
</p>


<ul class="org-ul">
<li>Compilation to <a href="https://en.wikipedia.org/wiki/Virtual_machine">virtual machine</a>
<ul class="org-ul">
<li>Most programming languages interpreter engines do not execute
AST nodes directly, instead they compile the source code to
bytecodes, which are a instructions for some virtual machine.</li>
</ul></li>

<li>Compilation to a standardized virtual machine
<ul class="org-ul">
<li>Rather than implementing its own bytecode virtual machine, a
programming language could use a standardized bytecode virtual
machine runtimes that are exposed to external use and not
likely to have breaking changes on every release since they are
regarded as public APIs and interfaces. Some of these virtual
machines, that are a compilation target of many programming
languages, are <span class="underline">JVM</span> - Java Virtual Machine, used by Jython
(Python for JVM), Clojure and Groovy; <span class="underline">CRL</span> - Commong Language
Runtime (.NET Virtual Machine), use by C# (CSharp), F#
(FSharp), IronPython; and <span class="underline">WASM</span> - Web Assembly.</li>
</ul></li>

<li><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT - Just-In-Time compilation</a> 
<ul class="org-ul">
<li>Compilation of bytecodes (virtual machine instructions) to
machine code (also known as native code) at runtime. This
processs combines the advantage of interpretation and
compilation to native code. The shortcoming of this approach is
the loss of flexibility and portability, since the JIT has to
be ported to every processor architecture where the virtual
machine will be deployed.</li>
</ul></li>

<li>FFI - Foreign Function Interface
<ul class="org-ul">
<li>FFI allows loading native code shared libraries, which may be written
in C, C++, Rust, D (Dlang), exposing a C interface and C symbols.</li>
</ul></li>

<li>Native Extension API 
<ul class="org-ul">
<li>A plugin system that allows loading libraries provided as
shared libraries (*.so - files on Linux, BSD; *.dylib on MacOSX
or *.dll on Windows), written in C, C++, Rust or any other
language that compiles to native code, conforming to an
expected C interface. Example: Java's JNI that allows loading
Java Libraries written in C or C++ that conforms to the JNI API
by using JNI SDK - Software Development Kit.</li>
</ul></li>

<li>Hidden Class Optimization used in JavaScript V8 engine =&gt; See: <a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">richardartoul - hidden class</a></li>

<li>Choice and implementation of garbage collector algorithm</li>

<li><a href="https://en.wikipedia.org/wiki/String_interning">String Interning</a></li>

<li><a href="https://arpitbhayani.me/blogs/constant-folding-python">Constant Folding</a></li>

<li><a href="https://compileroptimizations.com/category/constant_propagation.htm">Constant Propagation</a></li>

<li><a href="https://blogs.oracle.com/javamagazine/post/escape-analysis-in-the-hotspot-jit-compiler">Escape Analysis</a></li>

<li><a href="https://piotrduperas.com/posts/nan-boxing/">NaN Boxing</a></li>
</ul>


<p>
<b>Further Reading</b> 
</p>

<p>
Parsing:
</p>

<ul class="org-ul">
<li><a href="https://tomassetti.me/guide-parsing-algorithms-terminology/">A Guide To Parsing: Algorithms And Terminology</a></li>

<li><a href="https://www.oilshell.org/blog/2017/02/11.html">From AST to Lossless Syntax Tree</a></li>

<li><a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free grammar - wikipedia</a></li>

<li><a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BackusNaur form - wikipedia</a></li>

<li><a href="https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form">Augmented BackusNaur form - wikipedia</a></li>

<li><a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended BackusNaur form - wikipedia</a></li>

<li><a href="https://tomassetti.me/ebnf/">EBNF: How to Describe the Grammar of a Language</a> - tomassetti.net</li>

<li><a href="https://dzone.com/articles/ebnf-how-to-describe-the-grammar-of-a-language">EBNF: How to Describe the Grammar of a Language</a> - Dzone</li>

<li><a href="https://matt.might.net/articles/grammars-bnf-ebnf/">The language of languages</a></li>

<li><a href="https://dwheeler.com/essays/dont-use-iso-14977-ebnf.html">Dont Use ISO/IEC 14977 Extended Backus-Naur Form (EBNF)</a></li>

<li><a href="https://datatracker.ietf.org/doc/html/rfc5234">RFC5234 - Augmented BNF for Syntax Specifications: ABNF</a></li>

<li><a href="https://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf">ISO/IEC 14977 : 1996(E)</a> - [PDF] 
<ul class="org-ul">
<li>"Defines a notation, Extended BNF, for specifying the syntax of
a linear sequence of symbols. It defines both the logical
structure of the notation and its graphical representation. "</li>
</ul></li>

<li><a href="https://www.grammarware.net/text/2012/bnf-was-here.pdf">BNF - Unnecessary Diversity of Notation for Syntactic Definitions</a> [PDF]
<ul class="org-ul">
<li>Original title: "BNF WAS HERE: What Have We Done About the
Unnecessary Diversity of Notation for Syntactic Definitions"</li>
</ul></li>

<li><a href="https://www.cs.cornell.edu/courses/cs211/2006sp/Sections/S3/grammars.html">CS211 - Gramamr and Parsing - Cornell</a></li>

<li><a href="http://trevorjim.com/c-and-cplusplus-are-not-context-free/">C and C++ are not context free</a></li>

<li><a href="https://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-cs-grammar-revisited">The context sensitivity of Cs grammar, revisited</a></li>

<li><a href="https://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/">The context sensitivity of C's grammar</a></li>

<li><a href="https://mortoray.com/2012/07/20/why-i-dont-use-a-parser-generator/">Why I dont use a Parser Generator  Musing Mortoray</a></li>

<li><a href="https://tomassetti.me/antlr-mega-tutorial/">The ANTLR Mega Tutorial</a> - tomassetti.net</li>

<li><a href="https://tomassetti.me/parsing-in-javascript/">Parsing in JavaScript: all the tools and libraries you can use</a></li>

<li><a href="https://tomassetti.me/parsing-in-java/">Parsing in Java: all the tools and libraries you can use</a></li>

<li><a href="https://tomassetti.me/parsing-in-python/">Parsing in Python: all the tools and libraries you can use Strumenta</a></li>

<li><a href="https://github.com/antlr/grammars-v4">https://github.com/antlr/grammars-v4</a>
<ul class="org-ul">
<li>Collection of ANTLR-EBNF grammars for several programming
languages and markup languages including, Fortran 77, GraphQL,
Java, Kotlin, Lua, JSON - JavaScript Object Notation, html.</li>
</ul></li>
</ul>



<p>
Semantics:
</p>

<ul class="org-ul">
<li><a href="https://en.m.wikipedia.org/wiki/Evaluation_strategy">Evaluation strategy</a></li>

<li><a href="https://en.wikipedia.org/wiki/Eval">eval - programming languages</a></li>

<li><a href="https://wiki.c2.com/?CallByName">https://wiki.c2.com/?CallByName</a></li>

<li><a href="https://en.wikipedia.org/wiki/Thunk">Thunk</a></li>

<li><a href="https://en.m.wikipedia.org/wiki/De_Bruijn_notation">De Bruijn notation</a></li>

<li><a href="https://eecs390.github.io/notes/data.html">Functional Data Abstraction</a></li>

<li><a href="https://en.wikipedia.org/wiki/Halting_problem">Halting problem</a></li>

<li><a href="https://bguppl.github.io/interpreters/class_material/2.5OperationalSemantics.html">Operational Semantics | Principles of Programming Languages</a></li>

<li><a href="https://en.wikibooks.org/wiki/Introduction_to_Programming_Languages/Evaluation_Strategies">Introduction to Programming Languages/Evaluation Strategies</a></li>

<li><a href="https://en.wikipedia.org/wiki/TLA%2B">TLA+ - Formal Specification Language</a></li>

<li><a href="https://en.wikipedia.org/wiki/Formal_specification">Formal Specification</a></li>

<li><a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing completeness - Wikipedia</a></li>

<li><a href="https://increment.com/programming-languages/turing-incomplete-advantages/">It doesnt have to be Turing complete to be useful  Increment: Programming Languages</a></li>

<li><a href="https://www.infoq.com/articles/excel-lambda-turing-complete/">The Excel Formula Language Is Now Turing-Complete</a></li>

<li><a href="https://tomassetti.me/domain-specific-languages/">The complete guide to (external) Domain Specific Languages - Strumenta</a></li>

<li><a href="https://en.m.wikipedia.org/wiki/Abstract_semantic_graph">Abstract semantic graph</a></li>

<li><a href="https://www.informit.com/articles/article.aspx?p=25914">Common Object Operations in .NET | Object Equality and Identity</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">Equality comparisons and sameness - JavaScript | MDN</a></li>

<li><a href="https://en.m.wikipedia.org/wiki/Computability">Computability and models of computation</a></li>

<li><a href="https://tratt.net/laurie/blog/2023/why_arent_programming_language_specifications_comprehensive.html">Laurence Tratt: Why Aren't Programming Language Specifications Comprehensive?</a></li>
</ul>



<p>
Operator Precedence:
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Polish_notation">Polish notation</a></li>

<li><a href="https://blog.adamant-lang.org/2019/operator-precedence/">Operator Precedence: We can do better</a></li>

<li><a href="https://wiki.c2.com/?OperatorPrecedenceConsideredHarmful">Operator Precedence Considered Harmful</a></li>

<li><a href="https://web.archive.org/web/20190804031555/https://www.nytimes.com/2019/08/02/science/math-equation-pedmas-bemdas-bedmas.html">The Math Equation That Tried to Stump the Internet - The New York Times</a></li>

<li><a href="http://lambda-the-ultimate.org/node/2943">Languages without operator precedence</a></li>

<li><a href="https://www.jsoftware.com/papers/APLOperators.htm">The Role of Operators in APL</a> - Kenneth E. Iverson
<ul class="org-ul">
<li>Note: APL, just like Smalltalk programming language, does not
have operator precedence, all operators have the same precedence
level. In order to specify a particular order of evaluation, the
user must use parentheis.</li>
</ul></li>

<li><a href="https://wiki.c2.com/?SmalltalkMessageRules">Smalltalk Message Rules</a></li>

<li><a href="https://en.wikipedia.org/wiki/Operator_associativity">Operator associativity</a></li>

<li><a href="https://en.wikipedia.org/wiki/Order_of_operations">Order of Operations</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Operator Precedence in JavaScript</a></li>

<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/">C# operators and expressions (C# reference)</a></li>

<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ built-in operators, precedence, and associativity</a></li>

<li><a href="https://rosettacode.org/wiki/Operator_precedence">https://rosettacode.org/wiki/Operator_precedence</a></li>

<li><a href="https://wuciawe.github.io/functional%20programming/haskell/2016/07/03/infix-functions-in-haskell.html">Infix Functions In Haskell</a> (Operator Precedence in Haskell)</li>

<li><a href="https://stackoverflow.com/questions/15080128/operator-precedence-in-haskell">operator precedence in Haskell - stack overflow</a></li>

<li><a href="https://old.reddit.com/r/haskell/comments/ipfok/confusion_between_and_operators">r/haskell - Confusion between (.) and ($) operators</a>  (Operator Precedence in Haskell)</li>

<li><a href="https://www.scattered-thoughts.net/writing/better-operator-precedence/">Better operator precedence</a></li>

<li><a href="https://en.wikipedia.org/wiki/Null_coalescing_operator">https://en.wikipedia.org/wiki/Null_coalescing_operator</a></li>

<li><a href="https://kotlin-quick-reference.com/156-R-elvis-operator.html">Kotlin - The Elvis Operator (?:) - null coalescing operator</a></li>

<li><a href="https://kotlinlang.org/docs/null-safety.html">Kotlin - Null Safety</a></li>

<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator">Null coalescing operators - ?? and ??= operators (C# reference)</a></li>
</ul>


<p>
Non-Categorized:
</p>

<ul class="org-ul">
<li><a href="https://astexplorer.net/">AST explorer</a></li>

<li><a href="https://nextjournal.com/dubroy/ohm-parsing-made-easy">Ohm: Parsing Made Easy - Nextjournal</a>  =&gt; JavaScript parser
library, but it is useful for prototyping parsers and grammars for
custom/bespoke DSL - Domain Specific Programming languages.</li>

<li><a href="https://www.freecodecamp.org/news/programming-naming-conventions-explained/">Programming Naming Conventions  Camel, Snake, Kebab, and Pascal Case Explained</a></li>

<li><a href="https://khalilstemmler.com/blogs/camel-case-snake-case-pascal-case/">Camel Case vs. Snake Case vs. Pascal Case  Naming Conventions</a></li>

<li><a href="https://github.com/DSLsofMath/DSLsofMath">GitHub - DSLsofMath/DSLsofMath: Domain-Specific Languages of Mathematics</a></li>

<li><a href="http://mathscitech.org/articles/pol">Forth, Lisp, &amp; Ruby: languages that make it easy to write your own domain specific language (DSL)</a></li>

<li><a href="https://ratfactor.com/forth/forth_talk_2023.html">Forth: The programming language that writes itself /  Dave's Forth Talk 2023</a></li>

<li><a href="https://blog.information-superhighway.net/what-the-hell-is-forth">What the hell is Forth?  blog dot information dash superhighway dot net</a></li>

<li><a href="https://el-tramo.be/blog/waforth/">A Dynamic Forth Compiler for WebAssembly | mko.re</a></li>

<li><a href="https://ayazhafiz.com/articles/23/a-lambda-calculus-with-coroutines-and-heapless-closures#source-language">A Lambda Calculus With Coroutines and Heapless, Directly-Called Closures</a></li>

<li><a href="https://blog.regehr.org/archives/169">Why Take a Compiler Course?  Embedded in Academia</a></li>

<li><a href="http://www.wolczko.com/CS294/index.html">UCB CS294-113: Virtual Machines and Managed Runtimes</a></li>

<li><a href="https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/">CS 6120: Advanced Compilers: The Self-Guided Online Course - Cornell</a></li>

<li><a href="https://github.com/IUCompilerCourse/Essentials-of-Compilation">GitHub - IUCompilerCourse/Essentials-of-Compilation: A book about compiling Racket and Python to x86-64 assembly</a></li>

<li><a href="https://github.com/MattPD/cpplinks/blob/master/compilers.md#books">cpplinks/compilers.md at master  MattPD/cpplinks  GitHub</a></li>

<li>Essentials of Compilation: An Incremental Approach
<ul class="org-ul">
<li><a href="https://github.com/IUCompilerCourse/Essentials-of-Compilation">https://github.com/IUCompilerCourse/Essentials-of-Compilation</a></li>
</ul></li>

<li>Introduction to Compilers and Language Design
<ul class="org-ul">
<li><a href="http://compilerbook.org/">http://compilerbook.org/</a></li>
</ul></li>

<li>Static Single Assignment (SSA) Book
<ul class="org-ul">
<li><a href="http://web.archive.org/http://ssabook.gforge.inria.fr/latest/book-full.pdf">http://web.archive.org/http://ssabook.gforge.inria.fr/latest/book-full.pdf</a></li>
</ul></li>

<li>SSA-based Compiler Design
<ul class="org-ul">
<li><a href="https://link.springer.com/book/9783030805142">https://link.springer.com/book/9783030805142</a></li>
</ul></li>

<li><a href="https://craftinginterpreters.com">https://craftinginterpreters.com</a>
<ul class="org-ul">
<li>=&gt; Online book about how to implement interpreter in C programming language.</li>
</ul></li>

<li><a href="https://rust-hosted-langs.github.io/book/chapter-interp-vm-impl.html">Writing Interpreters in Rust: a Guide</a>
<ul class="org-ul">
<li>=&gt; Online book about how to implement interpreter and bytecode
virtual machines using Rust (better memory-safety).</li>
</ul></li>

<li><a href="https://github.com/pfalcon/ssabook">https://github.com/pfalcon/ssabook</a></li>

<li><a href="https://craftinginterpreters.com/optimization.html">https://craftinginterpreters.com/optimization.html</a></li>

<li><a href="https://iucompilercourse.github.io/IU-Fall-2022/">Course Webpage for Compilers (P423, P523, E313, and E513) | IU-Fall-2022</a></li>

<li><a href="https://github.com/IUCompilerCourse/Essentials-of-Compilation">https://github.com/IUCompilerCourse/Essentials-of-Compilation</a>  
<ul class="org-ul">
<li>IUCompilerCourse/Essentials-of-Compilation: A book about compiling Racket and Python to x86-64 assembly</li>
</ul></li>

<li><a href="https://www.martinfowler.com/dslCatalog/">DSL Patterns</a> - Martin Fowler</li>

<li><a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html">Chapter 2. The Structure of the Java Virtual Machine</a></li>

<li><a href="https://www.slideshare.net/nwind/virtual-machine-and-javascript-engine">Virtual machine and javascript engine</a></li>

<li><a href="https://jmmv.dev/2022/11/endbasic-bytecode.html">From AST to bytecode execution in EndBASIC</a></li>

<li><a href="https://www.pypy.org/posts/2022/07/toy-optimizer.html">Implementing a Toy Optimizer | PyPy</a></li>

<li><a href="https://v8.dev/blog/pointer-compression">Pointer Compression in V8  V8</a> (JavaScript Engine used by Chrome browser variants, NodeJS and Deno runtime)</li>

<li><a href="https://v8.dev/blog/oilpan-pointer-compression">Pointer compression in Oilpan</a></li>

<li><a href="https://bernsteinbear.com/blog/small-objects/">Small objects and pointer tagging | Max Bernstein</a></li>

<li><a href="https://pointersgonewild.com/2023/03/12/memory-pages-mmap-and-linear-address-spaces/">Memory, Pages, mmap, and Linear Address Spaces | Pointers Gone Wild</a></li>

<li><a href="https://thesephist.com/posts/lua/">Interesting things about the Lua interpreter | thesephist.com</a></li>

<li>[PDF] <a href="https://www.plai.org/3/2/PLAI%20Version%203.2.2%20electronic.pdf">Book - Programming Language - Application and Interpretation</a></li>

<li>[PDF] <a href="https://static.aminer.org/pdf/PDF/000/530/289/pascal_s_a_subset_and_its_implementation.pdf">Niklaus Wirth - A PASCAL Subset and its Implementation (Oberon)</a></li>

<li><a href="https://capitalex.codeberg.page/scripting-languages-without-gcs/">Scripting Objects without Trash Day | Capital's Corner</a></li>

<li><a href="https://en.m.wikipedia.org/wiki/BASIC_interpreter">BASIC interpreter</a></li>

<li><a href="https://outerproduct.net/trivial/2023-01-11_nan.html">Another NaN-based tagging strategy for dynamic programming languages</a></li>

<li><a href="https://pdos.csail.mit.edu/~baford/vm/">VX32 Virtual Extension Environment</a></li>

<li><a href="https://buttondown.email/hillelwayne/archive/microfeatures-id-like-to-see-in-more-languages/">Microfeatures I'd like to see in more languages  Buttondown</a></li>

<li><a href="https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#bitstrings">Binaries, strings, and charlists - The Elixir programming language</a></li>

<li><a href="https://llsoftsec.github.io/llsoftsecbook/">Low-Level Software Security for Compiler Developers</a></li>

<li><a href="https://softwareengineering.stackexchange.com/questions/387526/how-can-one-interpret-an-abstract-syntax-tree-without-recursion">data structures - How can one interpret an Abstract Syntax Tree without recursion?</a></li>

<li><a href="https://softwareengineering.stackexchange.com/questions/185406/what-is-the-purpose-of-nan-boxing">design patterns - What is the purpose of NaN boxing? - Software Engineering Stack Exchange</a></li>

<li><a href="https://ppkwok.blogspot.com/2012/11/java-cafe-1-never-write-nan-nan_24.html">ppkwok: Java Cafe 1 : Never write NaN == NaN (they're not equal)</a></li>

<li><a href="https://github.com/byo-books/pretty_laughable_lang">GitHub - byo-books/pretty_laughable_lang</a>
<ul class="org-ul">
<li>An educational C-like toy programming language that compiles to x64 binary.</li>
</ul></li>

<li><a href="https://github.com/AZHenley/teenytinycompiler">GitHub - AZHenley/teenytinycompiler: A small BASIC-to-C compiler written in Python.</a></li>

<li><a href="https://www.zhenghao.io/posts/javascript-memory">JavaScript memory model demystified</a></li>

<li><a href="http://c2.com/cgi/wiki?TransparentPersistence">http://c2.com/cgi/wiki?TransparentPersistence</a></li>

<li><a href="http://lambda-the-ultimate.org/node/526">Transparent Persistence | Lambda the Ultimate</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6ea15ce" class="outline-4">
<h4 id="org6ea15ce"><span class="section-number-4">1.12.2</span> Code</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
All the sources are available at gist: 
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/b5c5dc8d940a5927159f9d48d7b43a0c">https://gist.github.com/b5c5dc8d940a5927159f9d48d7b43a0c</a></li>
</ul>

<p>
File: <span class="underline">xmake.lua</span>
</p>

<div class="org-src-container">
<pre class="src src-lua">add_rules(<span class="org-string">"mode.debug"</span>, <span class="org-string">"mode.release"</span>)

target(<span class="org-string">"formula"</span>)
  set_kind(<span class="org-string">"binary"</span>)
  add_files(<span class="org-string">"./formula.cpp"</span>)
</pre>
</div>

<p>
File: <span class="underline">script.txt</span> =&gt; Contains scripting code for the expression parser.
</p>

<div class="org-src-container">
<pre class="src src-text">print("\t[TRACE] Starting user script ")

print("\t[INFO] REPL Version = " + version)

// Function that computes square 
fn sq(x) -&gt; x * x 

print("\n ------ Test IF-ELSE -------------")

x = -10 

if x &gt; 0 then 
   print(" =&gt; x greater than zero ")
else 
  print(" =&gt; x negative or zero ")
end 

z = if x &gt; 0 then 
  print(" =&gt; x greater than zero ")
  100 
else 
  print(" =&gt; x negative or zero ")
  200 
end 

print(" [TRACE] z = ", z)

fn test_number(x)
  if x &lt; 0  then print(" =&gt; x = ", x, " =&gt; negative ") end 
  if x == 0 then print(" =&gt; x = ", x, " =&gt; zero ")     end 
  if x &gt; 0  then print(" =&gt; x = ", x, " =&gt; positive ") end 
end 

test_number(-10)
test_number(20)
test_number(0)


print("\n---------- WHILE LOOP ----------- ")


fn do_sum(i)
  sum = 0;

  // Start  loop 
  while i &gt; 0 do 
    i = i - 1;
    sum = sum + sq(i);
    print("\tsq(i) = ", sq(i));
  end 

  print("\tsum = ", sum);
  // The return value is the last function value 
  sum;                     
end 

sum = do_sum(5)

print(" sum = do_sum(5) =  ", sum)

print("\n---------- FOR LOOP  ----------- ")

for i = 10 to 0 by -2 do 
  print(" \t i = ", i, " ; i^2 = ", i * i) 
end

print("\n ------- CLOSURES ----------------------")

fn make_add(k) -&gt; fn(x) -&gt; k + x 
add10 = make_add(10)
add20 = make_add(20)
add30 = make_add(30)

fn test_function(name, fun)
   print("\n --- Testing function: ", name)
   for k = 10 to 30 by 5 do 
     print("\t", name, "(", k,")", " = ", fun(k))
   end 
end 

test_function("add10", add10)
test_function("add20", add20)
test_function("add30", add30)
</pre>
</div>

<p>
File: <span class="underline">formula.cpp</span> (about 2600 lines of code)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#undef</span> EOF 

<span class="org-comment-delimiter">// </span><span class="org-comment">Token Type </span>
<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Type</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-variable-name">INT</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Number - integer </span>
   , <span class="org-variable-name">FLT</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Number - floating point  </span>
   , <span class="org-variable-name">NPC</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Number in percent ending with '%' character  </span>
   , <span class="org-variable-name">IDEN</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Identifier </span>
   , <span class="org-variable-name">BOOL</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean </span>
   , <span class="org-variable-name">STR</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">String </span>
   , <span class="org-variable-name">SYM</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol - starts with ':', for instance :asymbol </span>
   , <span class="org-variable-name">NIL</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Nil </span>
   , <span class="org-variable-name">ADD</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'+' operator </span>
   , <span class="org-variable-name">SUB</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'-'</span>
   , <span class="org-variable-name">MUL</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'*' multiplication operator </span>
   , <span class="org-variable-name">DIV</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'/' division operator </span>
   , <span class="org-variable-name">MOD</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'%' modulus operator </span>
   , <span class="org-variable-name">POW</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'^' power operator - example 2^3 = 8 </span>
   , <span class="org-variable-name">ASN</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'=' assignment </span>
   , <span class="org-variable-name">EQ</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'==' equal </span>
   , <span class="org-variable-name">NEQ</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'!=' not equal </span>
   , <span class="org-variable-name">LT</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'&lt;' less than </span>
   , <span class="org-variable-name">GT</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'&gt;' greater than </span>
   , <span class="org-variable-name">LTE</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'&lt;=' less or equal than </span>
   , <span class="org-variable-name">GTE</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'&gt;=' greater or equal than </span>
   , <span class="org-variable-name">NOT</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'!' not  - invert logical value </span>
   , <span class="org-variable-name">OR</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'or' - or operator keyword </span>
   , <span class="org-variable-name">AND</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'and' - and operator keyword</span>
   , <span class="org-variable-name">FN</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'fn' - keyword for defining functions </span>
   , <span class="org-variable-name">END</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'end' - keyword delimiter </span>
   , <span class="org-variable-name">BEGIN</span> <span class="org-comment-delimiter">// </span><span class="org-comment">'begin' keyword  </span>
   , <span class="org-variable-name">FOR</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">'for' - keyword </span>
   , <span class="org-variable-name">WHILE</span> <span class="org-comment-delimiter">// </span><span class="org-comment">'while' - keyword </span>
   , <span class="org-variable-name">IF</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'if' - keyword </span>
   , <span class="org-variable-name">ELSE</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">'else' - keyword </span>
   , <span class="org-variable-name">THEN</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">'then' - keyword </span>
   , <span class="org-variable-name">DO</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'do' - keyword </span>
   , <span class="org-variable-name">TO</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'to' - keyword (used in for-loop) </span>
   , <span class="org-variable-name">BY</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">'by' - keyword </span>
   , <span class="org-variable-name">ARROW</span> <span class="org-comment-delimiter">// </span><span class="org-comment">'-&gt;'  - token used short function defintion </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">--- Delimiters  --- //</span>
   , <span class="org-variable-name">LPAR</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Left parenthesis </span>
   , <span class="org-variable-name">RPAR</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Right parenthesis </span>
   , <span class="org-variable-name">COM</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">',' Comma</span>
   , <span class="org-variable-name">SEM</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">';' semicolon </span>
   , <span class="org-variable-name">EOF</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">End of File   </span>
   , <span class="org-variable-name">ERR</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates lexer error  </span>
   , <span class="org-variable-name">NONE</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates an empty token, non initialized token. </span>
    
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Oper</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-variable-name">ADD</span>, <span class="org-variable-name">SUB</span>, <span class="org-variable-name">MUL</span>, <span class="org-variable-name">DIV</span>, <span class="org-variable-name">MOD</span>, <span class="org-variable-name">POW</span>, <span class="org-variable-name">NOT</span>, <span class="org-variable-name">EQ</span>, <span class="org-variable-name">NEQ</span>, <span class="org-variable-name">LT</span>, <span class="org-variable-name">LTE</span>, <span class="org-variable-name">GT</span>, <span class="org-variable-name">GTE</span>, <span class="org-variable-name">AND</span>, <span class="org-variable-name">OR</span>, <span class="org-variable-name">ERR</span>  
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::string operators<span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"+"</span>, <span class="org-string">"-"</span>, <span class="org-string">"*"</span>, <span class="org-string">"/"</span>, <span class="org-string">"%"</span>, <span class="org-string">"^"</span>, <span class="org-string">"!"</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::string operator_names<span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"ADD"</span>, <span class="org-string">"SUB"</span>, <span class="org-string">"MUL"</span>, <span class="org-string">"DIV"</span>, <span class="org-string">"MOD"</span>, <span class="org-string">"POW"</span>, <span class="org-string">"NOT"</span> <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Converts token type to operator </span>
<span class="org-type">Oper</span> <span class="org-function-name">type_to_oper</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Type</span> <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">map</span> =  <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Type</span>, <span class="org-type">Oper</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::ADD, <span class="org-constant">Oper</span>::ADD<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::SUB, <span class="org-constant">Oper</span>::SUB<span class="org-rainbow-delimiters-depth-3">}</span>,   <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::MUL, <span class="org-constant">Oper</span>::MUL<span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::DIV, <span class="org-constant">Oper</span>::DIV<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::MOD, <span class="org-constant">Oper</span>::MOD<span class="org-rainbow-delimiters-depth-3">}</span>,   <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::POW, <span class="org-constant">Oper</span>::POW<span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NOT, <span class="org-constant">Oper</span>::NOT<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::EQ,  <span class="org-constant">Oper</span>::EQ <span class="org-rainbow-delimiters-depth-3">}</span>,   <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NEQ, <span class="org-constant">Oper</span>::NEQ<span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::LT,  <span class="org-constant">Oper</span>::LT <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::LTE,  <span class="org-constant">Oper</span>::LTE <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::AND, <span class="org-constant">Oper</span>::AND<span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::GT,  <span class="org-constant">Oper</span>::GT<span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::GTE,  <span class="org-constant">Oper</span>::GTE <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::OR,  <span class="org-constant">Oper</span>::OR <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> map.at<span class="org-rainbow-delimiters-depth-2">(</span>t<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string oper_to_name<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Oper</span> <span class="org-variable-name">op</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">map</span> =  <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Oper</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::ADD, <span class="org-string">"ADD"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::SUB, <span class="org-string">"SUB"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::MUL, <span class="org-string">"MUL"</span><span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::DIV, <span class="org-string">"DIV"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::MOD, <span class="org-string">"MOD"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::POW, <span class="org-string">"POW"</span><span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::NOT, <span class="org-string">"NOT"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::EQ,  <span class="org-string">"EQ"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::NEQ, <span class="org-string">"NEQ"</span><span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::LT,  <span class="org-string">"LT"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::LTE, <span class="org-string">"LTE"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::AND, <span class="org-string">"AND"</span><span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::GT,  <span class="org-string">"GT"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::GTE, <span class="org-string">"GTE"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::OR,  <span class="org-string">"OR"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> map.at<span class="org-rainbow-delimiters-depth-2">(</span>op<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string oper_to_str<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Oper</span> <span class="org-variable-name">op</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">map</span> =  <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Oper</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::ADD, <span class="org-string">"+"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::SUB, <span class="org-string">"-"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::MUL, <span class="org-string">"*"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::DIV, <span class="org-string">"/"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::MOD, <span class="org-string">"%"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::POW, <span class="org-string">"^"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::NOT, <span class="org-string">"!"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::EQ,  <span class="org-string">"=="</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::NEQ, <span class="org-string">"!="</span> <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::LT,  <span class="org-string">"&lt;"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::LTE, <span class="org-string">"&lt;="</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::AND, <span class="org-string">"and"</span><span class="org-rainbow-delimiters-depth-3">}</span> 
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::GT,  <span class="org-string">"&gt;"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::GTE, <span class="org-string">"&gt;="</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Oper</span>::OR,  <span class="org-string">"or"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">return</span> map.at<span class="org-rainbow-delimiters-depth-2">(</span>op<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">struct</span> <span class="org-type">Token</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Type</span> <span class="org-variable-name">type</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span>;
  <span class="org-type">int</span> <span class="org-variable-name">begin</span>;
  <span class="org-type">int</span> <span class="org-variable-name">end</span>;
  <span class="org-type">int</span> <span class="org-variable-name">lin</span>;
  <span class="org-type">int</span> <span class="org-variable-name">col</span>;

  <span class="org-function-name">Token</span><span class="org-rainbow-delimiters-depth-2">(){</span>
    type = <span class="org-constant">Type</span>::NONE;
    text = <span class="org-string">""</span>;
    begin = end = lin = col = 0;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">Token</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">type</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">text</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span>, <span class="org-type">int</span> <span class="org-variable-name">lin</span>, <span class="org-type">int</span> <span class="org-variable-name">col</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : type<span class="org-rainbow-delimiters-depth-2">(</span>type<span class="org-rainbow-delimiters-depth-2">)</span>, text<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>, begin<span class="org-rainbow-delimiters-depth-2">(</span>begin<span class="org-rainbow-delimiters-depth-2">)</span>, end<span class="org-rainbow-delimiters-depth-2">(</span>end<span class="org-rainbow-delimiters-depth-2">)</span>, lin<span class="org-rainbow-delimiters-depth-2">(</span>lin<span class="org-rainbow-delimiters-depth-2">)</span>, col<span class="org-rainbow-delimiters-depth-2">(</span>col<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">isEOF</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> type == <span class="org-constant">Type</span>::EOF; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-variable-name">Token</span> <span class="org-keyword">const</span>&amp; tok<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">map</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Type</span>, <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span>
     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::INT, <span class="org-string">"INT"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::FLT, <span class="org-string">"FLT"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::IDEN, <span class="org-string">"IDEN"</span><span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::BOOL, <span class="org-string">"BOOL"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::STR, <span class="org-string">"STR"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NIL, <span class="org-string">"NIL"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::ADD,  <span class="org-string">"ADD"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::SUB,  <span class="org-string">"SUB"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::MUL, <span class="org-string">"MUL"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::DIV, <span class="org-string">"DIV"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::MOD,  <span class="org-string">"MOD"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::POW,  <span class="org-string">"POW"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::ASN, <span class="org-string">"ASN"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::EQ,  <span class="org-string">"EQ"</span> <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NEQ,  <span class="org-string">"NEQ"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::LT,   <span class="org-string">"LT"</span>   <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::GT,  <span class="org-string">"GT"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::LTE, <span class="org-string">"LTE"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::GTE,  <span class="org-string">"GTE"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NOT,  <span class="org-string">"NOT"</span>  <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::OR,  <span class="org-string">"OR"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::AND, <span class="org-string">"AND"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::LPAR, <span class="org-string">"LPAR"</span><span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::RPAR, <span class="org-string">"RPAR"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::COM, <span class="org-string">"COM"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::COM, <span class="org-string">"COM"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::SEM,  <span class="org-string">"SEM"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::RPAR, <span class="org-string">"RPAR"</span> <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::EOF, <span class="org-string">"EOF"</span><span class="org-rainbow-delimiters-depth-3">}</span>,     <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::ERR, <span class="org-string">"ERR"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NONE,  <span class="org-string">"NONE"</span> <span class="org-rainbow-delimiters-depth-3">}</span>,  <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::FN,   <span class="org-string">"FN"</span>   <span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::WHILE, <span class="org-string">"WHILE"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::ARROW, <span class="org-string">"ARROW"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::END, <span class="org-string">"END"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::BEGIN, <span class="org-string">"BEGIN"</span><span class="org-rainbow-delimiters-depth-3">}</span>
    ,<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::TO, <span class="org-string">"TO"</span><span class="org-rainbow-delimiters-depth-3">}</span>,       <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">Type</span>::NPC, <span class="org-string">"PEC"</span><span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  os &lt;&lt; <span class="org-string">"Token( "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> tok.type &lt;&lt; <span class="org-string">" ; type =  "</span> &lt;&lt; map<span class="org-rainbow-delimiters-depth-2">[</span>tok.type<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; tok.text &lt;&lt; <span class="org-string">"; "</span> 
        &lt;&lt; <span class="org-string">" ; begin = "</span> &lt;&lt; tok.begin &lt;&lt; <span class="org-string">" ; end = "</span> &lt;&lt; tok.end &lt;&lt;  <span class="org-string">" ) "</span>;
  <span class="org-keyword">return</span> os;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Tokenizer</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">_is</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Input stream </span>
  <span class="org-type">char</span> <span class="org-variable-name">_chr</span> = <span class="org-string">'\0'</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Current character  </span>
  <span class="org-type">int</span> <span class="org-variable-name">_pos</span> = 0;      <span class="org-comment-delimiter">// </span><span class="org-comment">Current position </span>
  <span class="org-type">int</span> <span class="org-variable-name">_col</span> = 0;      <span class="org-comment-delimiter">// </span><span class="org-comment">current column </span>
  <span class="org-type">int</span> <span class="org-variable-name">_lin</span> = 0;      <span class="org-comment-delimiter">// </span><span class="org-comment">current line </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Keywords database </span>
  <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_keywords</span>;

<span class="org-function-name">public</span>:

  <span class="org-function-name">Tokenizer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_is</span><span class="org-rainbow-delimiters-depth-2">(</span>is<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-keyword">this</span>-&gt;next_chr<span class="org-rainbow-delimiters-depth-3">()</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"true"</span>,  <span class="org-constant">Type</span>::BOOL<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"false"</span>, <span class="org-constant">Type</span>::BOOL<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"nil"</span>,   <span class="org-constant">Type</span>::NIL<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"or"</span>,    <span class="org-constant">Type</span>::OR<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"and"</span>,   <span class="org-constant">Type</span>::AND<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"fn"</span>,    <span class="org-constant">Type</span>::FN<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"if"</span>,    <span class="org-constant">Type</span>::IF<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"do"</span>,    <span class="org-constant">Type</span>::DO<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"else"</span>,  <span class="org-constant">Type</span>::ELSE<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"then"</span>,  <span class="org-constant">Type</span>::THEN<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"begin"</span>, <span class="org-constant">Type</span>::BEGIN<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"end"</span>,   <span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"for"</span>,   <span class="org-constant">Type</span>::FOR<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"to"</span>,    <span class="org-constant">Type</span>::TO<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"by"</span>,    <span class="org-constant">Type</span>::BY<span class="org-rainbow-delimiters-depth-3">)</span>;
     add_keyword<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"while"</span>, <span class="org-constant">Type</span>::WHILE<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">add_keyword</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">keyword</span>, <span class="org-type">Type</span> <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    _keywords<span class="org-rainbow-delimiters-depth-3">[</span>keyword<span class="org-rainbow-delimiters-depth-3">]</span> = type;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if at end of file </span>
  <span class="org-type">bool</span> <span class="org-function-name">is_eof</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _is.eof<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">char</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _is.peek<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Advances to next character   </span>
  <span class="org-type">char</span> <span class="org-function-name">next_chr</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
     _chr = _is.get<span class="org-rainbow-delimiters-depth-3">()</span>;
     _pos++; 
     _col++;
     <span class="org-comment-delimiter">// </span><span class="org-comment">Assumes that characcter for new line </span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">always will be '\n' and never '\r\n' or '\r'</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_chr == <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-3">){</span>
       _col = 0;
       _lin++;
     <span class="org-rainbow-delimiters-depth-3">}</span>

     <span class="org-keyword">return</span> _chr;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">match</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _chr == x<span class="org-rainbow-delimiters-depth-3">){</span> next_chr<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Generates an error token</span>
  <span class="org-type">Token</span> <span class="org-function-name">error</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">message</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::ERR, message, _pos, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;  
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return all tokens </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">tokens</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">toks</span>;
    <span class="org-type">Token</span> <span class="org-variable-name">tk</span>; 
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> tk.type != <span class="org-constant">Type</span>::EOF <span class="org-rainbow-delimiters-depth-3">){</span>
      tk = <span class="org-keyword">this</span>-&gt;next_token<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> tk.type == <span class="org-constant">Type</span>::EOF<span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      toks.push_back<span class="org-rainbow-delimiters-depth-4">(</span>tk<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> toks;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">Token</span> <span class="org-function-name">next_token</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore blank characters, such as white spaces, tabs and</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">new line characters. </span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>is_eof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-constant">std</span>::isspace<span class="org-rainbow-delimiters-depth-4">(</span>_chr<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span>
      next_chr<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] _chr = %c \n", _chr); </span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> is_eof<span class="org-rainbow-delimiters-depth-4">()</span> || _chr == <span class="org-string">'\0'</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::EOF, <span class="org-string">""</span>, _pos, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>  

    <span class="org-comment-delimiter">// </span><span class="org-comment">Sanity checking   </span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>isspace<span class="org-rainbow-delimiters-depth-4">(</span>_chr<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>; 

    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;

    <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = next_delimiter<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> tok.type != <span class="org-constant">Type</span>::NONE<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> tok; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Number =&gt; Integer or floating point </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-4">(</span>_chr<span class="org-rainbow-delimiters-depth-4">)</span> || _chr == <span class="org-string">'.'</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> next_number<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Identifier or keyword </span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::isalpha<span class="org-rainbow-delimiters-depth-4">(</span>_chr<span class="org-rainbow-delimiters-depth-4">)</span> || _chr == <span class="org-string">'_'</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> next_identifier_or_keyword<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Symbol literal </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">':'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> next_symbol<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">String literal </span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>_chr == <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> next_string<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Discard next character to avoid infinite loop   </span>
    <span class="org-type">char</span> <span class="org-variable-name">ch</span> = _chr;
    next_chr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Return a tokenizer error value </span>
    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::ERR, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Edge case - tokenizer cannot match character: "</span><span class="org-rainbow-delimiters-depth-4">)</span> + ch , _pos, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-function-name">private</span>:

  <span class="org-type">Token</span> <span class="org-function-name">next_delimiter</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'('</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::LPAR, <span class="org-string">"("</span>, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">')'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::RPAR, <span class="org-string">")"</span>, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'+'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::ADD, <span class="org-string">"+"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'&gt;'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::ARROW, <span class="org-string">"-&gt;"</span>, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span> 
        <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::SUB, <span class="org-string">"-"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'*'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::MUL, <span class="org-string">"*"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'/'</span><span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span>  
         <span class="org-comment-delimiter">// </span><span class="org-comment">Ingore comment until new line </span>
         <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'/'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">{</span>
           <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>is_eof<span class="org-rainbow-delimiters-depth-6">()</span> &amp;&amp; _chr != <span class="org-string">'\n'</span> <span class="org-rainbow-delimiters-depth-5">){</span> next_chr<span class="org-rainbow-delimiters-depth-6">()</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
           <span class="org-keyword">return</span> next_token<span class="org-rainbow-delimiters-depth-5">()</span>;
         <span class="org-rainbow-delimiters-depth-4">}</span>
         <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::DIV, <span class="org-string">"/"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'^'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::POW, <span class="org-string">"^"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">','</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::COM, <span class="org-string">","</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::SEM, <span class="org-string">";"</span>,  begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
        <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::EQ, <span class="org-string">"=="</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::ASN, <span class="org-string">"="</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'&gt;'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::GTE, <span class="org-string">"&gt;="</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::GT, <span class="org-string">"&gt;"</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'&lt;'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::LTE, <span class="org-string">"&lt;="</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::LT, <span class="org-string">"&lt;"</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'!'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>  
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::NEQ, <span class="org-string">"!="</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::NOT, <span class="org-string">"!"</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::NONE, <span class="org-string">""</span>, begin, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>; 
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">Token</span> <span class="org-function-name">next_identifier_or_keyword</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">lexeme</span>;
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>is_eof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-type">isalnum</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-variable-name">_chr</span><span class="org-rainbow-delimiters-depth-5">)</span> || _chr == <span class="org-string">'_'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      lexeme = lexeme + _chr;
      next_chr<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = _keywords.find<span class="org-rainbow-delimiters-depth-3">(</span>lexeme<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>it != _keywords.end<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-type">Type</span> <span class="org-variable-name">t</span> = it-&gt;second;
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span>t, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::IDEN, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">Token</span> <span class="org-function-name">next_symbol</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">lexeme</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">next_chr();</span>
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>is_eof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-type">isalnum</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-variable-name">_chr</span><span class="org-rainbow-delimiters-depth-5">)</span> || _chr == <span class="org-string">'_'</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      lexeme = lexeme + _chr;
      next_chr<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::SYM, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns next string literal </span>
  <span class="org-type">Token</span> <span class="org-function-name">next_string</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span> _chr == <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">lexeme</span>;
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;
    next_chr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Detect string literal\n"); </span>
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>is_eof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; _chr != <span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Handle escape characters </span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'\\'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'n'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\n"</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'t'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\t"</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'r'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\r"</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'v'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\v"</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'"'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\""</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> match<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-string">'\\'</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">){</span> lexeme = lexeme + <span class="org-string">"\\"</span>; <span class="org-keyword">continue</span>;  <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::ERR, <span class="org-string">"Tokenizer error - invalid escape character."</span>, _pos, _pos, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span> 
      lexeme = lexeme + _chr;
      next_chr<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span> _chr == <span class="org-string">'"'</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    next_chr<span class="org-rainbow-delimiters-depth-3">()</span>; 
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] _chr = %c \n", _chr); </span>
    <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::STR, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns next integer   </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">next_int</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>;
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-4">(</span>_chr<span class="org-rainbow-delimiters-depth-4">)</span> || _chr == <span class="org-string">'_'</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      lexeme = lexeme + _chr;
      next_chr<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] next number = %s \n", lexeme.c_str());</span>
    <span class="org-keyword">return</span> lexeme;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns next number token </span>
  <span class="org-type">Token</span> <span class="org-function-name">next_number</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">lexeme</span> = <span class="org-string">""</span>;
      <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _pos - 1;     

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_chr != <span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-3">){</span>
         lexeme = next_int<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, "[TRACE] _chr = %c \n", _chr);</span>

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_chr != <span class="org-string">'.'</span> &amp;&amp; _chr != <span class="org-string">'e'</span> &amp;&amp; _chr != <span class="org-string">'E'</span> <span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">{</span> 

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'%'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::NPC, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-5">)</span>;  <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::INT, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>; 
      <span class="org-rainbow-delimiters-depth-3">}</span>

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'.'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">{</span>
        lexeme = lexeme + <span class="org-string">"."</span>;
        lexeme = lexeme + next_int<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; " [TRACE] chr = " &lt;&lt; _chr &lt;&lt; std::endl;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Floating point exponent </span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'e'</span><span class="org-rainbow-delimiters-depth-4">)</span> || match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'E'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, "[TRACE] Found exponent \n");</span>
        lexeme = lexeme + <span class="org-string">"e"</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">next_chr();</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> _chr != <span class="org-string">'-'</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-5">(</span>_chr<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
          <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::ERR, <span class="org-string">"Invalid floatitng point number: "</span> + lexeme, begin, _pos -1, _lin, _col <span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
          lexeme = lexeme + <span class="org-string">"-"</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>isdigit<span class="org-rainbow-delimiters-depth-5">(</span>_chr<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span>
          <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::ERR, <span class="org-string">"Invalid floatitng point number. Expected digit."</span>, begin, _pos -1, _lin, _col <span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span>

        lexeme = lexeme + next_int<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span>

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'%'</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::NPC, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-4">)</span>;  <span class="org-rainbow-delimiters-depth-3">}</span>
      <span class="org-keyword">return</span> Token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::FLT, lexeme, begin, _pos - 1, _lin, _col<span class="org-rainbow-delimiters-depth-3">)</span>;

  <span class="org-rainbow-delimiters-depth-2">}</span>


<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">------ End of class Tokenizer ---------</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Forward declaration </span>
<span class="org-keyword">struct</span> <span class="org-type">AstNil</span>; 
<span class="org-keyword">struct</span> <span class="org-type">AstInt</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstFlt</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstIden</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstSym</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstBool</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstStr</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstBinop</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstUnop</span>; 
<span class="org-keyword">struct</span> <span class="org-type">AstAsn</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstCall</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstDef</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstIf</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstWhile</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstFor</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstProg</span>;
<span class="org-keyword">struct</span> <span class="org-type">AstErr</span>;

<span class="org-keyword">struct</span> <span class="org-type">IAstVisitor</span><span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstNil</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstInt</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstFlt</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstIden</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>   = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstSym</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstBool</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>   = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstStr</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstBinop</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstUnop</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>   = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstAsn</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstCall</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>   = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstDef</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstWhile</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstIf</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>     = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstFor</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstProg</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>   = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstErr</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>    = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-comment-delimiter">// </span><span class="org-comment">Represents abstract syntax tree noes </span>
<span class="org-keyword">struct</span> <span class="org-type">Ast</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">begin</span> = 0;
  <span class="org-type">int</span> <span class="org-variable-name">end</span> = 0;

  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Ast</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>; 

  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is nil (null value)</span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_nil</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is number </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is integer </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is floating point  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is boolean </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is identifier </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_iden</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is symbol  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_sym</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is string  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is binary operation </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_binop</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check if AST node is unary operation </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_unop</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check whether AST node is assignment  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_asn</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-comment-delimiter">/// </span><span class="org-comment">Check whether AST node is an error </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_err</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check if AST is function call </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_call</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check if AST is function defintion </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_def</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check if AST is if statement </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_if</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check if AST is while statement </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_while</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Chekc if AST is for-loop statement </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_for</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check if AST is program  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_prog</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-keyword">virtual</span> <span class="org-type">int</span>         <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">virtual</span> <span class="org-type">double</span>      <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> -1; <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">""</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Nil AST node </span>
<span class="org-keyword">struct</span> <span class="org-type">AstNil</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_nil</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstNil</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">AstNil</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Integer AST node </span>
<span class="org-keyword">struct</span> <span class="org-type">AstInt</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstInt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstInt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">bool</span> <span class="org-function-name">is_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">virtual</span> <span class="org-type">int</span>    <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">virtual</span> <span class="org-type">double</span> <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Floating point literal </span>
<span class="org-keyword">struct</span> <span class="org-type">AstFlt</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstFlt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstFlt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">bool</span> <span class="org-function-name">is_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">int</span>    <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">double</span> <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Identifier node </span>
<span class="org-keyword">struct</span> <span class="org-type">AstIden</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstIden</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstIden</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_iden</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Symbol node - for isntance, :x, :y, :asymbol </span>
<span class="org-keyword">struct</span> <span class="org-type">AstSym</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstSym</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstSym</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_sym</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">":"</span> + value; <span class="org-rainbow-delimiters-depth-2">}</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Boolean literal </span>
<span class="org-keyword">struct</span> <span class="org-type">AstBool</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">bool</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstBool</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstBool</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span> <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">String literal AST node </span>
<span class="org-keyword">struct</span> <span class="org-type">AstStr</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span>;
  <span class="org-function-name">AstStr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">AstStr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    <span class="org-keyword">this</span>-&gt;begin = begin;
    <span class="org-keyword">this</span>-&gt;end  = end;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Binary operation such as: &lt;node&gt; + &lt;node&gt; </span>
<span class="org-keyword">struct</span> <span class="org-type">AstBinop</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Operator </span>
  <span class="org-type">Oper</span> <span class="org-variable-name">op</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Left-hand side </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">lhs</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Right-hand side </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">rhs</span>; 

  <span class="org-function-name">AstBinop</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Oper</span> <span class="org-variable-name">op</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">lhs</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : op<span class="org-rainbow-delimiters-depth-2">(</span>op<span class="org-rainbow-delimiters-depth-2">)</span>, lhs<span class="org-rainbow-delimiters-depth-2">(</span>lhs<span class="org-rainbow-delimiters-depth-2">)</span>, rhs<span class="org-rainbow-delimiters-depth-2">(</span>rhs<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_binop</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Unary operation such as: -&lt;node&gt; +&lt;node&gt; -200</span>
<span class="org-keyword">struct</span> <span class="org-type">AstUnop</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Operator </span>
  <span class="org-type">Oper</span> <span class="org-variable-name">op</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Left-hand side </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">node</span>;

  <span class="org-function-name">AstUnop</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Oper</span> <span class="org-variable-name">op</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">node</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : op<span class="org-rainbow-delimiters-depth-2">(</span>op<span class="org-rainbow-delimiters-depth-2">)</span>, node<span class="org-rainbow-delimiters-depth-2">(</span>node<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_unop</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Assignment node ('=') - represents expressions such as </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">x = 20;  z = call(20, 1.25) </span>
<span class="org-keyword">struct</span> <span class="org-type">AstAsn</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">identifier  (left-hand side) L-value </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">iden</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">right-hand side of  assignment R-value </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">node</span>;

  <span class="org-function-name">AstAsn</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">iden</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">node</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : iden<span class="org-rainbow-delimiters-depth-2">(</span>iden<span class="org-rainbow-delimiters-depth-2">)</span>, node<span class="org-rainbow-delimiters-depth-2">(</span>node<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_asn</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a function call</span>
<span class="org-keyword">struct</span> <span class="org-type">AstCall</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">identifier - AST or function name (identidier)</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">iden</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">args</span>;

  <span class="org-type">bool</span> <span class="org-function-name">is_call</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Get function name   </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>iden-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> iden-&gt;to_str<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> <span class="org-string">""</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstCall</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-function-name">AstCall</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">iden</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : iden<span class="org-rainbow-delimiters-depth-2">(</span>iden<span class="org-rainbow-delimiters-depth-2">)</span>, args<span class="org-rainbow-delimiters-depth-2">(</span>args<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstCall</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : iden<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstIden</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>name<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-2">)</span>, args<span class="org-rainbow-delimiters-depth-2">(</span>args<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Function defintion </span>
<span class="org-keyword">struct</span> <span class="org-type">AstDef</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">identifier  </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">args</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function body </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">body</span>;

  <span class="org-type">bool</span> <span class="org-function-name">is_def</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstDef</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">AstIf</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Condition of an if-else statement </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">cond</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Code block related to then statement  </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">then_block</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Coode block related to else statement  </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">else_block</span>; 

  <span class="org-type">bool</span> <span class="org-function-name">is_if</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstIf</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">AstWhile</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">cond</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">block</span>;

  <span class="org-type">bool</span> <span class="org-function-name">is_while</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstWhile</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a for-loop, for instance:</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">for i=0 to 10 do print(i) end </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">for i=10 to 0 by -2 do print(i) end</span>
<span class="org-keyword">struct</span> <span class="org-type">AstFor</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">For-loop variable </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">var</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">For-loop lower limit  </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">lower</span> = <span class="org-constant">nullptr</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">For-loop upper limit  </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">upper</span> = <span class="org-constant">nullptr</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">For-loop step </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">step</span> = <span class="org-constant">nullptr</span>; 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Code block executed each cycle </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">std::vector&lt;std::shared_ptr&lt;AST&gt;&gt; body{};</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">block</span> = <span class="org-rainbow-delimiters-depth-2">{}</span>; 

  <span class="org-type">bool</span> <span class="org-function-name">is_for</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-function-name">AstFor</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a program - zero or more statements  </span>
<span class="org-keyword">struct</span> <span class="org-type">AstProg</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">statements</span>;

  <span class="org-function-name">AstProg</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

  <span class="org-function-name">AstProg</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">statements</span><span class="org-rainbow-delimiters-depth-2">)</span>
    : statements<span class="org-rainbow-delimiters-depth-2">(</span>statements<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_prog</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Node returned by parser when there is an error </span>
<span class="org-keyword">struct</span> <span class="org-type">AstErr</span>: <span class="org-keyword">public</span> <span class="org-type">Ast</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span>; 

   <span class="org-function-name">AstErr</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
   <span class="org-function-name">AstErr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">message</span><span class="org-rainbow-delimiters-depth-2">(</span>message<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span>        <span class="org-function-name">is_err</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> message ; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span>        <span class="org-function-name">accept</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IAstVisitor</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> v.visit<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">Val</span>;
<span class="org-keyword">struct</span> <span class="org-type">ValErr</span>;

<span class="org-comment-delimiter">/// </span><span class="org-comment">Type alias for interpreter function </span>
<span class="org-keyword">using</span> <span class="org-type">InterpFunc</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">ValType</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-variable-name">INT</span>, <span class="org-variable-name">FLT</span>, <span class="org-variable-name">SYM</span>, <span class="org-variable-name">STR</span>, <span class="org-variable-name">NIL</span>, <span class="org-variable-name">BOOL</span>, <span class="org-variable-name">FUN</span>, <span class="org-variable-name">ERR</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents all runtime values produced by the interpreter</span>
<span class="org-keyword">struct</span> <span class="org-type">Val</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Val</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

  <span class="org-keyword">virtual</span> <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0; 

  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is a number </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is int </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is floating point number  </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is string </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is bool </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is symbpl </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_sym</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is nil </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_nil</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether runtime value is error </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_err</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Checks whether value is a function </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_fun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert runtime value to integer </span>
  <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 0; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert runtime value to  floating point </span>
  <span class="org-keyword">virtual</span> <span class="org-type">double</span> <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 0; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert value to string </span>
  <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0 ;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert value boolean - anything not nil or false (bool) is true </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0; 

  <span class="org-comment-delimiter">// </span><span class="org-comment">It evaluates to true if function value is native (implemented in C++) </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The usage of this function makes no sense if the current value is </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not a function. </span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">is_native</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;

  <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
  <span class="org-function-name">call</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; 
  <span class="org-rainbow-delimiters-depth-2">}</span> 

  <span class="org-keyword">friend</span> <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-type">Val</span>&amp; <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> val.print<span class="org-rainbow-delimiters-depth-3">(</span>os<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-keyword">return</span> os; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">Env</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">store</span>;
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">outer</span> = <span class="org-constant">nullptr</span>;

  <span class="org-function-name">Env</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">Env</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">outer</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">outer</span><span class="org-rainbow-delimiters-depth-2">(</span>outer<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = store.find<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>it != store.end<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> it-&gt;second;  <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> outer == <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = outer-&gt;get<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> res; 
  <span class="org-rainbow-delimiters-depth-2">}</span> 

  <span class="org-type">void</span> <span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    store<span class="org-rainbow-delimiters-depth-3">[</span>name<span class="org-rainbow-delimiters-depth-3">]</span> = value;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> store.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">/// </span><span class="org-comment">Reprents an integer number</span>
<span class="org-keyword">struct</span> <span class="org-type">ValInt</span> : <span class="org-keyword">public</span> <span class="org-type">Val</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">value</span> = 0;
  <span class="org-function-name">ValInt</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValInt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::INT; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">int</span>    <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">double</span> <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>
  
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; value; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a floating point number</span>
<span class="org-keyword">struct</span> <span class="org-type">ValFlt</span> : <span class="org-keyword">public</span> <span class="org-type">Val</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">double</span> <span class="org-variable-name">value</span> = 0.0;
  <span class="org-function-name">ValFlt</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValFlt</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::FLT; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_num</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">int</span>    <span class="org-function-name">to_int</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">double</span> <span class="org-function-name">to_flt</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; value; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a string </span>
<span class="org-keyword">struct</span> <span class="org-type">ValStr</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span> = <span class="org-string">""</span>;
  <span class="org-function-name">ValStr</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValStr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::STR; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span> 
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">'"'</span> &lt;&lt; value &lt;&lt; <span class="org-string">'"'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a symbol </span>
<span class="org-keyword">struct</span> <span class="org-type">ValSym</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span> = <span class="org-string">""</span>;
  <span class="org-function-name">ValSym</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValSym</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Remove first character from string </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> == <span class="org-string">':'</span><span class="org-rainbow-delimiters-depth-3">){</span> value.erase<span class="org-rainbow-delimiters-depth-4">(</span>0, 1<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">this</span>-&gt;value = value; 
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::SYM; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span> 
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_sym</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">':'</span> &lt;&lt; value ; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a boolean </span>
<span class="org-keyword">struct</span> <span class="org-type">ValBool</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">false</span>;
  <span class="org-function-name">ValBool</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValBool</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">value</span><span class="org-rainbow-delimiters-depth-2">(</span>value<span class="org-rainbow-delimiters-depth-2">){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::BOOL; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>value ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span> <span class="org-rainbow-delimiters-depth-3">)</span> ;<span class="org-rainbow-delimiters-depth-2">}</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a nil </span>
<span class="org-keyword">struct</span> <span class="org-type">ValNil</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-function-name">ValNil</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::NIL; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"nil"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_nil</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"nil"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a runtime error (interpreter error)</span>
<span class="org-keyword">struct</span> <span class="org-type">ValErr</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">int</span> <span class="org-variable-name">code</span> = 0; 
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span> = <span class="org-string">""</span>;
  <span class="org-function-name">ValErr</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-function-name">ValErr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">message</span><span class="org-rainbow-delimiters-depth-2">(</span>message<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-function-name">ValErr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">code</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span><span class="org-rainbow-delimiters-depth-2">)</span>: code<span class="org-rainbow-delimiters-depth-2">(</span>code<span class="org-rainbow-delimiters-depth-2">)</span>, message<span class="org-rainbow-delimiters-depth-2">(</span>message<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::ERR; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> message; <span class="org-rainbow-delimiters-depth-2">}</span> 
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">bool</span> <span class="org-function-name">is_err</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> os &lt;&lt; <span class="org-string">"ERROR - "</span> &lt;&lt; message ; <span class="org-rainbow-delimiters-depth-2">}</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Represents a function at runtime </span>
<span class="org-keyword">struct</span> <span class="org-type">ValFun</span>: <span class="org-keyword">public</span> <span class="org-type">Val</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function name or identifier </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> = <span class="org-string">""</span>;              
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function description metadata  </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">desc</span> = <span class="org-string">""</span>;              
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments names </span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">args</span> = <span class="org-rainbow-delimiters-depth-2">{}</span>;       
  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, this flag indicates that the function is implemented in C++</span>
  <span class="org-type">bool</span> <span class="org-variable-name">_is_native</span>  = <span class="org-constant">false</span>;    
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function body </span>
  <span class="org-type">AstProg</span> <span class="org-variable-name">body</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Funcion implementation  in C++</span>
  <span class="org-type">InterpFunc</span> <span class="org-variable-name">func</span> = <span class="org-constant">nullptr</span>;  
  <span class="org-comment-delimiter">// </span><span class="org-comment">Function environment </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">env</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;

  <span class="org-function-name">ValFun</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
  <span class="org-type">ValType</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">ValType</span>::FLT; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert value to string </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">to_str</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"&lt;Function "</span> + name + <span class="org-string">"() &gt;"</span>; <span class="org-rainbow-delimiters-depth-2">}</span> ;

  <span class="org-type">bool</span> <span class="org-function-name">is_fun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_native</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> func != <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Convert value boolean - anything not nil or false (bool) is true </span>
  <span class="org-type">bool</span> <span class="org-function-name">to_bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
    os &lt;&lt; <span class="org-string">"&lt;Function "</span> &lt;&lt; name &lt;&lt; <span class="org-string">"&gt;"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
  <span class="org-function-name">call</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;func<span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-3">)</span>; 
  <span class="org-rainbow-delimiters-depth-2">}</span> 

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">/// </span><span class="org-comment">Print AST as Lisp-like S-expression </span>
<span class="org-keyword">struct</span> <span class="org-type">PrintSexpVisitor</span>: <span class="org-keyword">public</span> <span class="org-type">IAstVisitor</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstNil</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"nil"</span>;     <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstInt</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstFlt</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstIden</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstSym</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">":"</span> &lt;&lt; ast.value; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstBool</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-rainbow-delimiters-depth-3">(</span>ast.value ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstStr</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">'"'</span> &lt;&lt; ast.value &lt;&lt; <span class="org-string">'"'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstBinop</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = oper_to_str<span class="org-rainbow-delimiters-depth-3">(</span>ast.op<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"("</span> &lt;&lt; op;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.lhs-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.rhs-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" )"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstUnop</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = oper_to_str<span class="org-rainbow-delimiters-depth-3">(</span>ast.op<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"("</span> &lt;&lt; op;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.node-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstAsn</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(SET "</span> &lt;&lt; ast.iden;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.node-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstCall</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(CALL "</span>;
    ast.iden-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">arg</span>: ast.args<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
      arg-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstDef</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(FN "</span> &lt;&lt; ast.name &lt;&lt; <span class="org-string">" ( "</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">arg</span>: ast.args<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::cout &lt;&lt; arg &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">") "</span>;    

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">s</span>: ast.body<span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-3">{</span> 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>; 
      s-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstIf</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(IF "</span>; 
    ast.cond-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    ast.then_block-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
    ast.else_block-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstWhile</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(WHILE "</span>; 
    ast.cond-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" (DO "</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">st</span>: ast.block<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> 
      st-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span> ;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"))"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstFor</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(FOR "</span> &lt;&lt; ast.var; 
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.lower-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    ast.upper-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ast.step <span class="org-rainbow-delimiters-depth-3">){</span>
      ast.step-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    ast.block-&gt;accept<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstProg</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(DO "</span>; 
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">stat</span>: ast.statements<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n  "</span>;
      stat-&gt;accept<span class="org-rainbow-delimiters-depth-4">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" \n)"</span>;    
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">visit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstErr</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"(ERROR "</span> &lt;&lt; ast.to_str<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">" )"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Pretty print AST as infix expressions (no lisp-like S-Expressions) </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">This procedure is useful for printing ASTs representing math expressions in math format (infix). </span>
<span class="org-type">void</span> <span class="org-function-name">pprint</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Ast</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-keyword">auto</span> <span class="org-variable-name">priority</span> = <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">Oper</span> <span class="org-variable-name">op</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">int</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>op == <span class="org-constant">Oper</span>::ADD || op == <span class="org-constant">Oper</span>::SUB<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> 3; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>op == <span class="org-constant">Oper</span>::MUL || op == <span class="org-constant">Oper</span>::DIV<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> 4; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>op == <span class="org-constant">Oper</span>::POW<span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> 5; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-string">" Not implemented for operator: "</span> + oper_to_str<span class="org-rainbow-delimiters-depth-4">(</span>op<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_int<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>       <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.to_int<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_flt<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.to_flt<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_iden<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; ast.to_str<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_asn<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">AstAsn</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; n.iden &lt;&lt; <span class="org-string">" = "</span>;
    pprint<span class="org-rainbow-delimiters-depth-3">(</span>*n.node<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_call<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">std::fprintf(stderr, " [TRACE] Function call AST node \n");</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">AstCall</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-3">)</span>;
    pprint<span class="org-rainbow-delimiters-depth-3">(</span>*n.iden<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"("</span>;
    <span class="org-type">size_t</span> <span class="org-variable-name">k</span> = n.args.size<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> k &gt; 0<span class="org-rainbow-delimiters-depth-3">){</span>
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 1; i &lt; n.args.size<span class="org-rainbow-delimiters-depth-4">()</span>; i++<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">", "</span>;
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.args<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_unop<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">AstUnop</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = n.op;

    <span class="org-constant">std</span>::cout &lt;&lt; oper_to_str<span class="org-rainbow-delimiters-depth-3">(</span>op<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.node-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> || n.node-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> || n.node-&gt;is_nil<span class="org-rainbow-delimiters-depth-4">()</span> || n.node-&gt;is_bool<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.node<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.node-&gt;is_binop<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"("</span>;
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.node<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">")"</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span> ast.is_binop<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">n</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">AstBinop</span>&amp;<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = n.op;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> || n.lhs-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> || n.lhs-&gt;is_unop<span class="org-rainbow-delimiters-depth-4">()</span> || n.lhs-&gt;is_call<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.lhs<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span> 
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.lhs-&gt;is_binop<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>n.lhs<span class="org-rainbow-delimiters-depth-4">)</span>; 
      <span class="org-keyword">auto</span> <span class="org-variable-name">opn</span> = lhs-&gt;op;
      <span class="org-comment-delimiter">//</span><span class="org-comment">if( (op == Oper::MUL || op == Oper::DIV) &amp;&amp; (opn == Oper::ADD || opn == Oper::SUB) )</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> priority<span class="org-rainbow-delimiters-depth-5">(</span>op<span class="org-rainbow-delimiters-depth-5">)</span> &gt; priority<span class="org-rainbow-delimiters-depth-5">(</span>opn<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"( "</span>;
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*lhs-&gt;lhs<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; oper_to_str<span class="org-rainbow-delimiters-depth-5">(</span>opn<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*lhs-&gt;rhs<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" )"</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span>
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*lhs<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; oper_to_str<span class="org-rainbow-delimiters-depth-3">(</span>op<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">" "</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> || n.rhs-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> || n.rhs-&gt;is_unop<span class="org-rainbow-delimiters-depth-4">()</span> || n.rhs-&gt;is_call<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      pprint<span class="org-rainbow-delimiters-depth-4">(</span>*n.rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span> 
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> n.rhs-&gt;is_binop<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>n.rhs<span class="org-rainbow-delimiters-depth-4">)</span>; 
      <span class="org-keyword">auto</span> <span class="org-variable-name">opn</span> = rhs-&gt;op;
      <span class="org-comment-delimiter">//</span><span class="org-comment">if( (op == Oper::MUL || op == Oper::DIV) &amp;&amp; (opn == Oper::ADD || opn == Oper::SUB) )</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> priority<span class="org-rainbow-delimiters-depth-5">(</span>op<span class="org-rainbow-delimiters-depth-5">)</span> &gt; priority<span class="org-rainbow-delimiters-depth-5">(</span>opn<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"( "</span>;
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*rhs-&gt;lhs<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; oper_to_str<span class="org-rainbow-delimiters-depth-5">(</span>opn<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span>;
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*rhs-&gt;rhs<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" )"</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span>
        pprint<span class="org-rainbow-delimiters-depth-5">(</span>*rhs<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">std::cerr &lt;&lt; " [ERROR] Not implemented for this AST node \n";</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">---- End of pprint() function -----//</span>

<span class="org-keyword">class</span> <span class="org-type">Parser</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-type">Token</span> <span class="org-variable-name">_token</span>; 
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Token</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_tokens</span>;
  <span class="org-type">int</span> <span class="org-variable-name">_idx</span>; 
<span class="org-function-name">public</span>:

  <span class="org-function-name">Parser</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    _tokens = <span class="org-rainbow-delimiters-depth-3">{}</span>;
    _idx = 0;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">read</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    <span class="org-type">Tokenizer</span> <span class="org-variable-name">tok</span><span class="org-rainbow-delimiters-depth-3">(</span>is<span class="org-rainbow-delimiters-depth-3">)</span>;
    _tokens = tok.tokens<span class="org-rainbow-delimiters-depth-3">()</span>;
    _idx = 0;
    <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse a program </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">parse</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span><span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
    read<span class="org-rainbow-delimiters-depth-3">(</span>ss<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> _parse_prog<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">parse</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    read<span class="org-rainbow-delimiters-depth-3">(</span>is<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> _parse_prog<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse a single expression or statement </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">parse_expr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span><span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">this</span>-&gt;read<span class="org-rainbow-delimiters-depth-3">(</span>ss<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> _parse_stat<span class="org-rainbow-delimiters-depth-3">()</span>; 
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-type">Token</span> <span class="org-function-name">next</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">_token =  _tokenizer.next_token();</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cerr &lt;&lt; " [TRACE] token = " &lt;&lt; _token &lt;&lt; std::endl;</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _idx == _tokens.size<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> _token = Token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::EOF, <span class="org-string">""</span>, 0, 0, 0, 0<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _idx &lt; _tokens.size<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      _token = _tokens<span class="org-rainbow-delimiters-depth-4">[</span>_idx<span class="org-rainbow-delimiters-depth-4">]</span>;
      _idx = _idx + 1;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">return</span> _token;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">Token</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _token; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">is_eof</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _token.type == <span class="org-constant">Type</span>::EOF; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _token.type == type; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">bool</span> <span class="org-function-name">match</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == type <span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">true</span>; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">expect</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">type</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">message</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == type <span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">return</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span>message<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
  <span class="org-function-name">expect_token</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Type</span> <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == type<span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">this</span>-&gt;next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;  
    ss &lt;&lt; <span class="org-string">"Expected token of type "</span>;
    <span class="org-keyword">if</span>     <span class="org-rainbow-delimiters-depth-3">(</span>type == <span class="org-constant">Type</span>::ASN <span class="org-rainbow-delimiters-depth-3">){</span> ss &lt;&lt; <span class="org-string">"'=' (assignemnt)"</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>type == <span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-3">){</span> ss &lt;&lt; <span class="org-string">"')' right/closing parenthesis"</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">else</span>                       <span class="org-rainbow-delimiters-depth-3">{</span> ss &lt;&lt; <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-4">)</span> type; <span class="org-rainbow-delimiters-depth-3">}</span>
    ss &lt;&lt; <span class="org-string">" but got token "</span> &lt;&lt; _token;
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ss.str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
 <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-function-name">private</span>: 

  <span class="org-comment-delimiter">// </span><span class="org-comment">Replace string </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">replace</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">text</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">rep</span>,  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">subst</span> <span class="org-rainbow-delimiters-depth-2">)</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span> = text;                                                      
  <span class="org-comment-delimiter">// </span><span class="org-comment">Find position of character matching the string                            </span>
  <span class="org-type">size_t</span> <span class="org-variable-name">i</span> = out.find<span class="org-rainbow-delimiters-depth-3">(</span>rep<span class="org-rainbow-delimiters-depth-3">)</span>;                                                    
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span>i != <span class="org-constant">std</span>::<span class="org-constant">string</span>::npos<span class="org-rainbow-delimiters-depth-3">){</span>                                               
    out.replace<span class="org-rainbow-delimiters-depth-4">(</span>i, rep.size<span class="org-rainbow-delimiters-depth-5">()</span>, subst<span class="org-rainbow-delimiters-depth-4">)</span>;                                         
    i = out.find<span class="org-rainbow-delimiters-depth-4">(</span>rep, i<span class="org-rainbow-delimiters-depth-4">)</span>;                                                      
  <span class="org-rainbow-delimiters-depth-3">}</span>                                                                            
  <span class="org-keyword">return</span> out;                                                                  
<span class="org-rainbow-delimiters-depth-2">}</span> 


  <span class="org-comment-delimiter">/// </span><span class="org-comment">Parse atom </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_atom</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = peek<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse integer number </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::INT<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstInt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> <span class="org-constant">std</span>::<span class="org-type">stoi</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-variable-name">replace</span><span class="org-rainbow-delimiters-depth-6">(</span>tok.text, <span class="org-string">"_"</span>, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">)</span>, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse floating point number </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::FLT<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> <span class="org-constant">std</span>::<span class="org-type">stod</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-variable-name">replace</span><span class="org-rainbow-delimiters-depth-6">(</span>tok.text, <span class="org-string">"_"</span>, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">)</span>, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse floating point number (in percent format)</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::NPC<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> <span class="org-constant">std</span>::<span class="org-type">stod</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-variable-name">replace</span><span class="org-rainbow-delimiters-depth-6">(</span>tok.text, <span class="org-string">"_"</span>, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-5">)</span> / 100.0, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::NIL<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstNil</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> tok.begin, tok.end<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::STR<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstStr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> tok.text, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::IDEN<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstIden</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> tok.text, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::SYM<span class="org-rainbow-delimiters-depth-4">)</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstSym</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> tok.text, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::BOOL<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> tok.text == <span class="org-string">"true"</span> ? <span class="org-constant">true</span> : <span class="org-constant">false</span>, tok.begin, tok.end <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::FN <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> _parse_def<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::IF <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> _parse_if<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::LPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">this</span>-&gt;_parse_expr<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-comment-delimiter">//</span><span class="org-comment">std::cout &lt;&lt; " [TRACE] token = " &lt;&lt; _token &lt;&lt; std::endl;</span>
      <span class="org-type">int</span> <span class="org-variable-name">end</span> = _token.end;

      <span class="org-keyword">auto</span> <span class="org-variable-name">err</span> = expect_token<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>err != <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> err; <span class="org-rainbow-delimiters-depth-4">}</span>

      <span class="org-comment-delimiter">// </span><span class="org-comment">expect(Type::RPAR, "Expected right/closing parenthesis");</span>
      expr-&gt;begin = begin;
      expr-&gt;end = end;
      <span class="org-keyword">return</span> expr;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">throw std::runtime_error("Error: - atom() function - not implemented ");</span>
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>; 
    ss &lt;&lt; <span class="org-string">"ERROR - edge case found - atom() cannot be parserd =&gt; token = "</span> &lt;&lt; tok;
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ss.str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse function call, example atan2(y, x)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">call: atom </span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">| IDEN "(" ( expr ( "," expr )* )?  ")" </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_call</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">atom</span> = <span class="org-keyword">this</span>-&gt;_parse_atom<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> atom-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> atom; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::LPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> atom; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = atom-&gt;begin;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Function arguments </span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function with zero arguments </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> 
      <span class="org-keyword">auto</span> <span class="org-variable-name">_call</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstCall</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>atom, args<span class="org-rainbow-delimiters-depth-4">)</span>; 
      _call-&gt;begin = begin;
      _call-&gt;end = _token.end;
      <span class="org-keyword">return</span> _call;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">arg</span> = _parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    args.push_back<span class="org-rainbow-delimiters-depth-3">(</span>arg<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::COM <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      arg = _parse_expr<span class="org-rainbow-delimiters-depth-4">()</span>;
      args.push_back<span class="org-rainbow-delimiters-depth-4">(</span>arg<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-type">int</span> <span class="org-variable-name">end</span> = _token.end;
    <span class="org-keyword">auto</span> <span class="org-variable-name">err</span>  = expect_token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> err <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">_call</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstCall</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>atom, args<span class="org-rainbow-delimiters-depth-3">)</span>;
    _call-&gt;begin = begin; 
    _call-&gt;end = end;
    <span class="org-keyword">return</span> _call;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse power operation such as 2^3</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_power</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_call<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
    <span class="org-type">int</span> <span class="org-variable-name">end</span> = lhs-&gt;end;
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> check<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::POW<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_unary<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
      lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>op, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
      end = lhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    lhs-&gt;begin = begin;
    lhs-&gt;end = end;
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse unary expressions such as: a, -a or +a </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_unary</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = _token;
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cerr &lt;&lt; " [TRACE] unary =&gt; token = " &lt;&lt; tok &lt;&lt; std::endl;</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> tok.type == <span class="org-constant">Type</span>::SUB || tok.type == <span class="org-constant">Type</span>::ADD || tok.type == <span class="org-constant">Type</span>::NOT<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>

      <span class="org-type">int</span> <span class="org-variable-name">begin</span> = tok.begin;
      <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stdout, " [TRACE] unary =&gt;&gt; begin = %d ; end = %d \n"</span>
      <span class="org-comment-delimiter">//          </span><span class="org-comment">, tok.begin, tok.end); </span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">oper</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>tok.type<span class="org-rainbow-delimiters-depth-4">)</span>;
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">factor</span> = _parse_unary<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> factor-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> factor; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-type">int</span> <span class="org-variable-name">end</span> = factor-&gt;end;
      <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstUnop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>oper, factor<span class="org-rainbow-delimiters-depth-4">)</span>;
      ast-&gt;begin = begin;
      ast-&gt;end = end;
      <span class="org-keyword">return</span> ast;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> _parse_power<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse multiplication and division expressions </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">such as 10 * 20 or x / y </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_factor</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_unary<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::MUL || _token.type == <span class="org-constant">Type</span>::DIV <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">oper</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_unary<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
      lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>oper, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
      lhs-&gt;begin = begin;
      lhs-&gt;end   = rhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">lhs-&gt;begin = begin;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">lhs-&gt;end = end;</span>
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse arithmetic expressions, such as sum and subtraction expressions such as </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a + 10 ; a - b</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_arithmetic</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_factor<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::ADD || _token.type == <span class="org-constant">Type</span>::SUB <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">oper</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_factor<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
      lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>oper, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
      lhs-&gt;begin = begin;
      lhs-&gt;end = rhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse comparison expressions </span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">x &gt;= 10  ; x + 20 &lt; 200 </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_comparison</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_arithmetic<span class="org-rainbow-delimiters-depth-3">()</span>; 
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::LT || _token.type == <span class="org-constant">Type</span>::LTE 
       || _token.type == <span class="org-constant">Type</span>::GT || _token.type == <span class="org-constant">Type</span>::GTE <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
       next<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_arithmetic<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
       <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
       lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>op, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
       lhs-&gt;begin = begin; 
       lhs-&gt;end = rhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse equality and inequality expressions </span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">a + 200 == 400  ; a &gt; 10 == a &gt; 20 </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_equality</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">return term1();</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_comparison<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::EQ || _token.type == <span class="org-constant">Type</span>::NEQ <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
       next<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_comparison<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
       <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
       lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>op, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
       lhs-&gt;begin = begin; 
       lhs-&gt;end = rhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse logical expressions such as  '10 &gt; x and x &gt; sqrt(y) or false' </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_expr</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = _parse_equality<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::AND || _token.type == <span class="org-constant">Type</span>::OR <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">op</span> = type_to_oper<span class="org-rainbow-delimiters-depth-4">(</span>_token.type<span class="org-rainbow-delimiters-depth-4">)</span>;
       next<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = _parse_equality<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-4">}</span>
       <span class="org-type">int</span> <span class="org-variable-name">begin</span> = lhs-&gt;begin;
       lhs = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>op, lhs, rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
       lhs-&gt;begin = begin; 
       lhs-&gt;end = rhs-&gt;end;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> lhs;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse while-do-end statement </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">For instance, this function parses this syntax: </span>
  <span class="org-comment-delimiter">//   </span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">while i &gt; 0 do </span>
  <span class="org-comment-delimiter">//      </span><span class="org-comment">print(i);</span>
  <span class="org-comment-delimiter">//      </span><span class="org-comment">i = i - 1; </span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">end </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_while</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::WHILE<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid while statement. Expected keyword 'while'"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">cond</span> = _parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> cond-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> cond; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">err</span> = expect_token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::DO<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> err <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">block</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span> _token.type != <span class="org-constant">Type</span>::END <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">stat</span> = <span class="org-keyword">this</span>-&gt;_parse_stat<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> stat-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> stat; <span class="org-rainbow-delimiters-depth-4">}</span>
       block.push_back<span class="org-rainbow-delimiters-depth-4">(</span>stat<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = _token.end;
    err = expect_token<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> err <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> err; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstWhile</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    ast-&gt;begin = begin;
    ast-&gt;end = end;
    ast-&gt;cond = cond; 
    ast-&gt;block = block;    
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse for-statement </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Syntax example: for i = 0 to 10 by 2 do print(i) end </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Syntax example: for i = 0 to 10 do print(i) end </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Syntax: for &lt;VAR&gt; = &lt;LOWER&gt; to &lt;UPPER&gt; do &lt;BLOCK&gt;... end </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Syntax  for &lt;VAR&gt; = &lt;LOWER&gt; to &lt;UPPER&gt; by &lt;STEP&gt; do &lt;BLOCK&gt;... end </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_for</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::FOR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected keyword 'for'"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">atom</span> = _parse_atom<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>atom-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> atom; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>atom-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected identifier"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">For-loop variable </span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">var</span> = atom-&gt;to_str<span class="org-rainbow-delimiters-depth-3">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Equal '=' sign </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::ASN<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected '=' sign."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">lower</span> = _parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>lower-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lower; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::TO<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected 'to' keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">upper</span> = _parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>upper-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> upper; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">step</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::BY<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      step = _parse_expr<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> step-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> step; <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::DO<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected 'do' keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">block</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span> _token.type != <span class="org-constant">Type</span>::END <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">stat</span> = <span class="org-keyword">this</span>-&gt;_parse_stat<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> stat-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> stat; <span class="org-rainbow-delimiters-depth-4">}</span>
       block.push_back<span class="org-rainbow-delimiters-depth-4">(</span>stat<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = _token.end;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid FOR statement. Expected 'end' keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstFor</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    ast-&gt;begin = begin;
    ast-&gt;end = end; 
    ast-&gt;var = var;
    ast-&gt;lower = lower;
    ast-&gt;upper = upper;
    ast-&gt;step = step; 
    ast-&gt;block =  <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>block<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_block</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">block</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span> _token.type != <span class="org-constant">Type</span>::END  &amp;&amp; _token.type != <span class="org-constant">Type</span>::ELSE &amp;&amp; _token.type != <span class="org-constant">Type</span>::END <span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">parse statement </span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">stat</span> = <span class="org-keyword">this</span>-&gt;_parse_stat<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">Abort computation if there is any error </span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> stat-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> stat; <span class="org-rainbow-delimiters-depth-4">}</span>
       block.push_back<span class="org-rainbow-delimiters-depth-4">(</span>stat<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = _token.end;
    <span class="org-comment-delimiter">//</span><span class="org-comment">auto err = expect_token(Type::END);</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">if( err ){ return err; }</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>block<span class="org-rainbow-delimiters-depth-3">)</span>;
    ast-&gt;begin = begin; 
    ast-&gt;end = end;
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">/**</span>
<span class="org-comment">   * @brief Parse if-else satements.</span>
<span class="org-comment">   *</span>
<span class="org-comment">   * Example =&gt; Parses statements such as:</span>
<span class="org-comment">   *  </span>
<span class="org-comment">   *   if x &gt; 10 then </span>
<span class="org-comment">   *       print("Greater than 10")  </span>
<span class="org-comment">   *   end </span>
<span class="org-comment">   * </span>
<span class="org-comment">   *   z = if x &lt; 0 then </span>
<span class="org-comment">   *          print("negative")</span>
<span class="org-comment">   *          :pos  </span>
<span class="org-comment">   *       else </span>
<span class="org-comment">   *          print("Positive or zero")</span>
<span class="org-comment">   *          :neg_or_zero  </span>
<span class="org-comment">   *       end </span>
<span class="org-comment">   * </span>
<span class="org-comment">   */</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_if</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Enter _parse_if() \n");</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::IF<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid if-else statement. Expected IF keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">cond</span> = _parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> cond-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> cond; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::THEN<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid if-else statement. Expected THEN keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">then_block</span> = _parse_block<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> then_block-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> then_block; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstIf</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    ast-&gt;begin = begin;
    ast-&gt;then_block = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>then_block<span class="org-rainbow-delimiters-depth-3">)</span>;
    ast-&gt;cond = cond; 
    ast-&gt;end = _token.end;
    ast-&gt;else_block = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> ast; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::ELSE<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid if-else statement. Expected ELSE keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">else_block</span> = _parse_block<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> else_block-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> else_block; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid if-else statement. Expected END keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    ast-&gt;else_block = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>else_block<span class="org-rainbow-delimiters-depth-3">)</span>;
    ast-&gt;end = _token.end;
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse function defintion </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Example: </span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">fn myfun (x, y) -&gt; 2 * y + y </span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">myfun = fn(x, y) -&gt; 2 * y + y </span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">fn myfun(x, y)</span>
  <span class="org-comment-delimiter">//       </span><span class="org-comment">z = x / 10;</span>
  <span class="org-comment-delimiter">//       </span><span class="org-comment">a = z - x; </span>
  <span class="org-comment-delimiter">//       </span><span class="org-comment">a + z        // Last value of block is the return value </span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">end </span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">//   </span><span class="org-comment">fn &lt;identifier&gt; "(" arg0, arg1, ..., argN-1 ")"</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_def</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tok</span> = _token;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::FN<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid function defintion. Expected keyword 'fn'"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span> = <span class="org-string">""</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::IDEN <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      name = _token.text;
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">return std::make_shared&lt;ASTErr&gt;("Invalid function defintion. Expected identifier.");</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::LPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid function defintion. Expected left parenthesis '('."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function with empty argument, example: fn myfun() -&gt; 10 + random()</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">out</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstDef</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>;
      out-&gt;name = name;
      out-&gt;args = <span class="org-rainbow-delimiters-depth-4">{}</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::ARROW<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = _parse_expr<span class="org-rainbow-delimiters-depth-5">()</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> expr-&gt;is_err<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> expr; <span class="org-rainbow-delimiters-depth-5">}</span>

        out-&gt;body = <span class="org-rainbow-delimiters-depth-5">{</span> expr <span class="org-rainbow-delimiters-depth-5">}</span>;
        out-&gt;begin = tok.begin;
        out-&gt;end = expr-&gt;end;
        <span class="org-keyword">return</span> out;
      <span class="org-rainbow-delimiters-depth-4">}</span>

      <span class="org-keyword">auto</span> <span class="org-variable-name">block</span> = _parse_block<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>block-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> block; <span class="org-rainbow-delimiters-depth-4">}</span>
      assert<span class="org-rainbow-delimiters-depth-4">(</span> block-&gt;is_prog<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Invalid function definition. Expected end keyword."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      out-&gt;body = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>block<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;statements;
      out-&gt;end = block-&gt;end; 
      <span class="org-keyword">return</span> out;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">arg0</span> = _parse_atom<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>arg0-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid function defintion. Expected identifier as argument."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">args</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span> arg0-&gt;to_str<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">}</span>;

    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::COM<span class="org-rainbow-delimiters-depth-3">){</span>
      next<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">arg</span> = _parse_atom<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>arg0-&gt;is_iden<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>
          <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Invalid function defintion. Expected identifier as argument."</span><span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
      args.push_back<span class="org-rainbow-delimiters-depth-4">(</span> arg-&gt;to_str<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::RPAR<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid function defintion. Expected right parenthesis."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">out</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstDef</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    out-&gt;name = name;
    out-&gt;args = args;
    out-&gt;begin = tok.begin;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::ARROW<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = _parse_expr<span class="org-rainbow-delimiters-depth-4">()</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> expr-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> expr; <span class="org-rainbow-delimiters-depth-4">}</span>
        out-&gt;body = <span class="org-rainbow-delimiters-depth-4">{</span> expr <span class="org-rainbow-delimiters-depth-4">}</span>;
        out-&gt;end = expr-&gt;end;
        <span class="org-keyword">return</span> out;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse multiple statements until an 'end' keyword is found   </span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">block</span> = _parse_block<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>block-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> block; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::END<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid function definition. Expected end keyword."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span> block-&gt;is_prog<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    out-&gt;body = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>block<span class="org-rainbow-delimiters-depth-3">)</span>-&gt;statements;
    out-&gt;end = block-&gt;end; 
    <span class="org-keyword">return</span> out;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Parse statement </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">stat: expr | IDEN '=' expr </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_stat</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::WHILE <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> _parse_while<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> _token.type == <span class="org-constant">Type</span>::FOR   <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> _parse_for<span class="org-rainbow-delimiters-depth-4">()</span>;   <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Enter stats() function \n");</span>
    <span class="org-type">int</span>  <span class="org-variable-name">saved_idx</span> = _idx;
    <span class="org-keyword">auto</span> <span class="org-variable-name">saved_token</span> = _token;
    <span class="org-comment-delimiter">// </span><span class="org-comment">int begin = atom-&gt;begin;</span>
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-keyword">auto</span> <span class="org-variable-name">atom</span> = <span class="org-keyword">this</span>-&gt;_parse_atom<span class="org-rainbow-delimiters-depth-3">()</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> atom-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> || <span class="org-negation-char">!</span>atom-&gt;is_iden<span class="org-rainbow-delimiters-depth-4">()</span> ||  _token.type != <span class="org-constant">Type</span>::ASN <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">Backtrack parser - restoring its state </span>
       _idx = saved_idx;
       _token = saved_token;
       <span class="org-comment-delimiter">// </span><span class="org-comment">attempt to parse an expression </span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">this</span>-&gt;_parse_expr<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">expect(Type::SEM, "Expected semicolon");</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">optional semicolon for avoid ambiguity</span>
       match<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">Type</span>::SEM<span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-keyword">return</span> expr; 
    <span class="org-rainbow-delimiters-depth-3">}</span>
    expect<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::ASN, <span class="org-string">"Expected assignment"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">this</span>-&gt;_parse_expr<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> expr-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> expr; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-type">int</span> <span class="org-variable-name">end</span> = _token.end;
    <span class="org-comment-delimiter">//</span><span class="org-comment">expect(Type::SEM, "Expected semicolon");</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">optional semicolon for avoid ambiguity</span>
       match<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">Type</span>::SEM<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstAsn</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>atom-&gt;to_str<span class="org-rainbow-delimiters-depth-4">()</span>, expr<span class="org-rainbow-delimiters-depth-3">)</span>;    
    ast-&gt;begin = begin;
    ast-&gt;end = end;
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">_parse_prog</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">statements</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;{}</span>;
    <span class="org-type">int</span> <span class="org-variable-name">begin</span> = _token.begin;
    <span class="org-type">int</span> <span class="org-variable-name">end</span> = 0;
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-3">(</span> _token.type != <span class="org-constant">Type</span>::EOF <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">auto</span> <span class="org-variable-name">stat</span> = <span class="org-keyword">this</span>-&gt;_parse_stat<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> stat-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> stat; <span class="org-rainbow-delimiters-depth-4">}</span>
       end = stat-&gt;end;
       statements.push_back<span class="org-rainbow-delimiters-depth-4">(</span>stat<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">AstProg</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>statements<span class="org-rainbow-delimiters-depth-3">)</span>;    
    ast-&gt;begin = begin;
    ast-&gt;end = end;
    <span class="org-keyword">return</span> ast;
  <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">----- End of class Parser ----------- //</span>


<span class="org-function-name">std</span>::<span class="org-type">string</span> substring<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">str</span>, <span class="org-type">int</span> <span class="org-variable-name">begin</span>, <span class="org-type">int</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span>;
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">k</span> = begin; k &lt; end; k++<span class="org-rainbow-delimiters-depth-2">){</span>
    out = out + str<span class="org-rainbow-delimiters-depth-3">[</span>k<span class="org-rainbow-delimiters-depth-3">]</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> out;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Interpreter - turns the AST into a runtime value </span>
<span class="org-keyword">class</span> <span class="org-type">Interp</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_env</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">verbose</span> = <span class="org-constant">false</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">in_function</span> = <span class="org-constant">false</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">code</span> = <span class="org-string">""</span>;

<span class="org-function-name">public</span>:

  <span class="org-function-name">Interp</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    _env = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    reset<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">set_verbose</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span> <span class="org-variable-name">flag</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> verbose = flag; <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Interpreter's RPL - Read-Print-Eval Loop (interactive shell)</span>
  <span class="org-type">void</span> <span class="org-function-name">repl</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-type">Parser</span> <span class="org-variable-name">parser</span>;
      <span class="org-type">PrintSexpVisitor</span> <span class="org-variable-name">printer</span>;
      <span class="org-keyword">this</span>-&gt;set_verbose<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-type">bool</span> <span class="org-variable-name">show_ast</span> = <span class="org-constant">false</span>;
      <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>, <span class="org-variable-name">command</span>, <span class="org-variable-name">arg</span>;

      <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Ast</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-3">}</span>;

      <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n $&gt; "</span>;
        <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>line == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">continue</span>; <span class="org-rainbow-delimiters-depth-4">}</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">ss</span> = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-4">(</span>line<span class="org-rainbow-delimiters-depth-4">)</span>;
        ss &gt;&gt; command &gt;&gt; arg;        

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>command == <span class="org-string">":show_ast"</span><span class="org-rainbow-delimiters-depth-4">){</span> show_ast = <span class="org-constant">true</span>; <span class="org-keyword">continue</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>command == <span class="org-string">":hide_ast"</span><span class="org-rainbow-delimiters-depth-4">){</span> show_ast = <span class="org-constant">false</span>; <span class="org-keyword">continue</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>command == <span class="org-string">":quit"</span> || line == <span class="org-string">":q"</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>command == <span class="org-string">":reset"</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">this</span>-&gt;reset<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-keyword">continue</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Allows entering a multi-line expression</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>command == <span class="org-string">":block"</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] Enter multi-line expression mode. Type (;;) when you are done. \n"</span>;
          <span class="org-keyword">auto</span> <span class="org-variable-name">text</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-5">{}</span>;

          <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
          <span class="org-rainbow-delimiters-depth-5">{</span>
            <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-6">)</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span>line == <span class="org-string">";;"</span><span class="org-rainbow-delimiters-depth-6">){</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-6">}</span>
            text = text + line;
          <span class="org-rainbow-delimiters-depth-5">}</span>
          line = text;
        <span class="org-rainbow-delimiters-depth-4">}</span>

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> command == <span class="org-string">":load"</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-constant">std</span>::<span class="org-type">ifstream</span> <span class="org-variable-name">ifs</span><span class="org-rainbow-delimiters-depth-5">(</span>arg<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>ifs.good<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">){</span>
              <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-6">(</span>stderr, <span class="org-string">" [ERROR] Unable to open file '%s' \n"</span>, arg.c_str<span class="org-rainbow-delimiters-depth-7">()</span><span class="org-rainbow-delimiters-depth-6">)</span>;
              <span class="org-keyword">continue</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>
            ast = parser.parse<span class="org-rainbow-delimiters-depth-5">(</span>ifs<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span>
            ast = parser.parse<span class="org-rainbow-delimiters-depth-5">(</span>line<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-rainbow-delimiters-depth-4">}</span>

        assert<span class="org-rainbow-delimiters-depth-4">(</span> ast  != <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>show_ast<span class="org-rainbow-delimiters-depth-4">){</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Print AST in SEXP (S-Expression) Lisp-like format </span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ast = "</span>;
          ast-&gt;accept<span class="org-rainbow-delimiters-depth-5">(</span>printer<span class="org-rainbow-delimiters-depth-5">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">'\n'</span>;
          <span class="org-comment-delimiter">// </span><span class="org-comment">Print AST in math-like infix notation </span>
           <span class="org-comment-delimiter">/// </span><span class="org-comment">std::cout &lt;&lt; " pprint(ast) = "; pprint(*ast); std::cout &lt;&lt; '\n';</span>
        <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = <span class="org-keyword">this</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>*ast<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Set answer variable</span>
        <span class="org-keyword">this</span>-&gt;add_var<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"ans"</span>, result<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; *result &lt;&lt; <span class="org-string">'\n'</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">add_var</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
    _env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>name, val<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">add_var</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValStr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
    _env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>name, val<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">add_var</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    _env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>name, value<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add C++ native function to interpreter </span>
  <span class="org-type">void</span> <span class="org-function-name">add_fun</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">fun</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-keyword">auto</span> <span class="org-variable-name">fn</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValFun</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
     fn-&gt;name = name;
     fn-&gt;args = <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-string">"x"</span> <span class="org-rainbow-delimiters-depth-3">}</span>;
     fn-&gt;func = <span class="org-rainbow-delimiters-depth-3">[</span>=<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-5">&gt;</span><span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>
     <span class="org-rainbow-delimiters-depth-3">{</span>
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> args.size<span class="org-rainbow-delimiters-depth-5">()</span> != 1<span class="org-rainbow-delimiters-depth-4">){</span>
         <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Function expects 1 argument"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
       <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">){</span>
         <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Type mismatch - function expects number argument"</span><span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = args<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span>-&gt;to_flt<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">y</span> = fun<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>y<span class="org-rainbow-delimiters-depth-4">)</span>;
     <span class="org-rainbow-delimiters-depth-3">}</span>;
     _env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>name, fn<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-type">void</span> <span class="org-function-name">add_fun</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">InterpFunc</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">fn</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValFun</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    fn-&gt;name = name;
    fn-&gt;func = func;
    _env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>name, fn<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Reset interpreter environment (state)</span>
  <span class="org-type">void</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    _env-&gt;clear<span class="org-rainbow-delimiters-depth-3">()</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"inv"</span>,    <span class="org-rainbow-delimiters-depth-4">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> 1.0 / x; <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>; 
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"abs"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::abs<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"cos"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::cos<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"sin"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::sin<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"tan"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::tan<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"exp"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::exp<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"sqrt"</span>,   <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"log"</span>,    <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::log<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"log10"</span>,  <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::log10<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"log2"</span>,   <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-5">(</span>*<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>&amp;<span class="org-constant">std</span>::log2<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    add_var<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"PI"</span>, 3.1415<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">version constant  </span>
    add_var<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"version"</span>, <span class="org-string">"0.1"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Load script file </span>
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"load"</span>, <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-variable-name">self</span> = <span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1 <span class="org-rainbow-delimiters-depth-5">){</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Expects 1 argument of type string."</span><span class="org-rainbow-delimiters-depth-6">)</span>;
      <span class="org-rainbow-delimiters-depth-5">}</span> 
      <span class="org-keyword">auto</span> <span class="org-variable-name">file</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;to_str<span class="org-rainbow-delimiters-depth-5">()</span>;
      <span class="org-constant">std</span>::<span class="org-type">ifstream</span> <span class="org-variable-name">ifs</span><span class="org-rainbow-delimiters-depth-5">(</span>file<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>ifs.good<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">){</span>
          <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> =  <span class="org-string">" [ERROR] Unable to open file "</span> + file;
          <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;()</span>;
      <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-type">Parser</span> <span class="org-variable-name">parser</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = parser.parse<span class="org-rainbow-delimiters-depth-5">(</span>ifs<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">return</span> self-&gt;eval<span class="org-rainbow-delimiters-depth-5">(</span>*ast<span class="org-rainbow-delimiters-depth-5">)</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"print"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">a</span>: args<span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-constant">std</span>::cout &lt;&lt; a-&gt;to_str<span class="org-rainbow-delimiters-depth-6">()</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">'\n'</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValNil</span><span class="org-rainbow-delimiters-depth-5">&gt;()</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    
    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"type"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> != 1 <span class="org-rainbow-delimiters-depth-5">){</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Function type() expects 1 argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>;
      <span class="org-rainbow-delimiters-depth-5">}</span> 
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_bool<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"bool"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_nil<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"nil"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_fun<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"fun"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_int<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"int"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"flt"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_str<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"str"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_sym<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"sym"</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Edge case - function type() edge case ."</span><span class="org-rainbow-delimiters-depth-5">)</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    add_fun<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"max"</span>, <span class="org-rainbow-delimiters-depth-4">[</span>=<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-6">&gt;</span><span class="org-rainbow-delimiters-depth-5">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-4">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> args.size<span class="org-rainbow-delimiters-depth-6">()</span> &lt; 1 <span class="org-rainbow-delimiters-depth-5">)</span>
      <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Function max() expects at least 1 argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span> 
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>args<span class="org-rainbow-delimiters-depth-6">[</span>0<span class="org-rainbow-delimiters-depth-6">]</span>-&gt;is_num<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>
      <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Function max() expects number as argument."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>

      <span class="org-keyword">auto</span> <span class="org-variable-name">max</span> = args<span class="org-rainbow-delimiters-depth-5">[</span>0<span class="org-rainbow-delimiters-depth-5">]</span>-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span>;
      <span class="org-type">float</span> <span class="org-variable-name">x</span> = max;

      <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">a</span>: args<span class="org-rainbow-delimiters-depth-5">){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span> <span class="org-negation-char">!</span>a-&gt;is_num<span class="org-rainbow-delimiters-depth-7">()</span> <span class="org-rainbow-delimiters-depth-6">)</span>
        <span class="org-rainbow-delimiters-depth-6">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-7">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-7">&gt;(</span><span class="org-string">"Function max() expects number as argument."</span><span class="org-rainbow-delimiters-depth-7">)</span>; <span class="org-rainbow-delimiters-depth-6">}</span>
        x = a-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span>max &lt; x<span class="org-rainbow-delimiters-depth-6">){</span> max = x;<span class="org-rainbow-delimiters-depth-6">}</span>
      <span class="org-rainbow-delimiters-depth-5">}</span>

      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>max<span class="org-rainbow-delimiters-depth-5">)</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-type">Parser</span> <span class="org-variable-name">parser</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = parser.parse<span class="org-rainbow-delimiters-depth-3">(</span>code<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">this</span>-&gt;code = code;
    <span class="org-keyword">return</span> eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Ast</span>&amp; <span class="org-variable-name">ast</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> eval<span class="org-rainbow-delimiters-depth-3">(</span>ast, _env<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Ast</span>&amp; <span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Parser error</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Parser error - "</span> + ast.to_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_nil<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValNil</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_int<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast.to_int<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_flt<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast.to_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_bool<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTBool&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBool</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>it.value<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValStr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast.to_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_sym<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValSym</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast.to_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_binop<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTBinop&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstBinop</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_binop<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_unop<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTUnop&gt;(ast);</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">auto it = static_cast&lt;ASTUnop const&amp;&gt;(ast); </span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstUnop</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_unop<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_asn<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTAsn&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstAsn</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_asn<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_iden<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">name</span> = ast.to_str<span class="org-rainbow-delimiters-depth-4">()</span>;
      <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = env-&gt;get<span class="org-rainbow-delimiters-depth-4">(</span>name<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>val == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Unbound variable "</span> + name<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> val;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_prog<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTProg&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstProg</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_prog<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.is_call<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTCall&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstCall</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_call<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>ast.is_def<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTDef&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstDef</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_def<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>ast.is_if<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstIf</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_if<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>ast.is_while<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTWhile&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstWhile</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_while<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>ast.is_for<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">//</span><span class="org-comment">auto it = std::static_pointer_cast&lt;ASTFor&gt;(ast);</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">AstFor</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-4">&gt;(</span>ast<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> eval_for<span class="org-rainbow-delimiters-depth-4">(</span>it, env<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"Interpreter not implemented for this AST type"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of eval() ---- //</span>

<span class="org-function-name">private</span>:

  <span class="org-comment-delimiter">// </span><span class="org-comment">Equality operator evaluation </span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">equal</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Val</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">Val</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span> <span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.is_num<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; rhs.is_num<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> 
    <span class="org-rainbow-delimiters-depth-3">{</span>   <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs.to_flt<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.to_flt<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> != rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span> <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::STR &amp;&amp; rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::STR <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs.to_str<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.to_str<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::SYM &amp;&amp; rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::SYM <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs.to_str<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.to_str<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::BOOL &amp;&amp; rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::BOOL <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs.to_bool<span class="org-rainbow-delimiters-depth-5">()</span> == rhs.to_bool<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::NIL &amp;&amp; rhs.type<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-constant">ValType</span>::NIL <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"Type mismatch. Invalid use case of operator (==)."</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval assignment operation</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_asn</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstAsn</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">value</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.node, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>value-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> value; <span class="org-rainbow-delimiters-depth-3">}</span>
    env-&gt;set<span class="org-rainbow-delimiters-depth-3">(</span>ast.iden, value<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> value;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval unary operation</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_unop</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstUnop</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">node</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.node, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>node-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> node; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.op<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::ADD:
      <span class="org-keyword">return</span> node;
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::SUB:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>node-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Negative operation is only valid for numbers"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>node-&gt;is_int<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>-node-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>node-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>-node-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-keyword">default</span>:
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Operation not defined for this operator: "</span> + oper_to_str<span class="org-rainbow-delimiters-depth-5">(</span>ast.op<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval binary operation</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_binop</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstBinop</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> &amp;<span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lhs</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.lhs, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">rhs</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.rhs, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>lhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> lhs; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>rhs-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> rhs; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.op<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::ADD:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span> || rhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span> + rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lhs-&gt;is_int<span class="org-rainbow-delimiters-depth-5">()</span> || rhs-&gt;is_int<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span> + rhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lhs-&gt;is_str<span class="org-rainbow-delimiters-depth-5">()</span> || rhs-&gt;is_str<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValStr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_str<span class="org-rainbow-delimiters-depth-6">()</span> + rhs-&gt;to_str<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Type mismatch (+) operator only valid for numbers or strings"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::SUB:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Addition operation is only valid for numbers"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span> || rhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span> - rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span> - rhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::MUL:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Multiplication operation is only valid for numbers"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>lhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span> || rhs-&gt;is_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span> * rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">else</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span> * rhs-&gt;to_int<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::DIV:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Division operation not valid for non numbers"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span> / rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">POwer operation a^b</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::POW:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Power operation not valid for numbers"</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValFlt</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">std</span>::pow<span class="org-rainbow-delimiters-depth-5">(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span>, rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Less than =&gt; lhs &lt; rhs</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::LT:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Type mismatch. Less than (&lt;) operator is only valid for numbers."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span> &lt; rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Greater than =&gt; lhs &gt; rhs</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::GT:
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"Type mismatch. Greater than (&gt;) operator is only valid for numbers."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span> &gt; rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Less or equal than =&gt; lhs &lt;= rhs</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::LTE:
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-6">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>
      <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Type mismatch. Operator (&lt;=) is only valid for numbers."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span> &lt;= rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>res<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Greater or equal than or equal =&gt; lhs &gt;= rhs</span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::GTE:
    <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-negation-char">!</span>lhs-&gt;is_num<span class="org-rainbow-delimiters-depth-6">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_num<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">)</span>
      <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Type mismatch. Operator (&gt;=) is only valid for numbers."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = lhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span> &gt;= rhs-&gt;to_flt<span class="org-rainbow-delimiters-depth-5">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>res<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Equality operator: lhs == rhs </span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::EQ:
      <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;equal<span class="org-rainbow-delimiters-depth-4">(</span>*lhs, *rhs<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Inequality operator: lhs != rhs </span>
    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::NEQ: <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>-&gt;equal<span class="org-rainbow-delimiters-depth-5">(</span>*lhs, *rhs<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> res-&gt;is_err<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> res; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = res-&gt;to_bool<span class="org-rainbow-delimiters-depth-5">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-negation-char">!</span>b<span class="org-rainbow-delimiters-depth-5">)</span>; 
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span>

    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::OR: <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span> <span class="org-negation-char">!</span>lhs-&gt;is_bool<span class="org-rainbow-delimiters-depth-6">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_bool<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span> 
      <span class="org-rainbow-delimiters-depth-5">{</span>   <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-string">"Or logical operator only valid for booleans."</span><span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span>lhs-&gt;to_bool<span class="org-rainbow-delimiters-depth-6">()</span> || rhs-&gt;to_bool<span class="org-rainbow-delimiters-depth-6">()</span> <span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span>

    <span class="org-keyword">case</span> <span class="org-constant">Oper</span>::AND: 
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-negation-char">!</span>lhs-&gt;is_bool<span class="org-rainbow-delimiters-depth-5">()</span> || <span class="org-negation-char">!</span>rhs-&gt;is_bool<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span> 
      <span class="org-rainbow-delimiters-depth-4">{</span>   <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-5">&gt;(</span><span class="org-string">"And logical operator only valid for booleans."</span><span class="org-rainbow-delimiters-depth-5">)</span>; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValBool</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>lhs-&gt;to_bool<span class="org-rainbow-delimiters-depth-5">()</span> &amp;&amp; rhs-&gt;to_bool<span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-keyword">break</span>;

    <span class="org-keyword">default</span>:
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Binary operation not defined for this operator: "</span> + oper_to_str<span class="org-rainbow-delimiters-depth-5">(</span>ast.op<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">---- End of eval_binop() ------ //</span>


  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstIf</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">cond</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.cond, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> cond-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span>  <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> cond; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> cond-&gt;to_bool<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> eval_prog<span class="org-rainbow-delimiters-depth-4">(</span>*ast.then_block, env<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> eval_prog<span class="org-rainbow-delimiters-depth-3">(</span>*ast.else_block, env<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstWhile</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">cond</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.cond, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>cond-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> cond; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span> cond-&gt;to_bool<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">st</span>: ast.block<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = eval<span class="org-rainbow-delimiters-depth-5">(</span>*st, env<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>res-&gt;is_err<span class="org-rainbow-delimiters-depth-6">()</span><span class="org-rainbow-delimiters-depth-5">){</span> <span class="org-keyword">return</span> res; <span class="org-rainbow-delimiters-depth-5">}</span>
      <span class="org-rainbow-delimiters-depth-4">}</span>
      cond = eval<span class="org-rainbow-delimiters-depth-4">(</span>*ast.cond, env<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>cond-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> cond; <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
    
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstFor</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">lower</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.lower, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>lower-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> lower; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">upper</span> = eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.upper, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>upper-&gt;is_err<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> upper; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">step</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> ast.step != <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-3">){</span>
      step = eval<span class="org-rainbow-delimiters-depth-4">(</span>*ast.step, env<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>step-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">){</span> <span class="org-keyword">return</span> step; <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>lower-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Expected number as for-loop lower limit"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>upper-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Expected number as for-loop upper limit"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> step &amp;&amp; <span class="org-negation-char">!</span>step-&gt;is_num<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Expected number as for-loop step"</span><span class="org-rainbow-delimiters-depth-4">)</span>;  <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">lo</span> = lower-&gt;to_int<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">up</span> = upper-&gt;to_int<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">sp</span> = step != <span class="org-constant">nullptr</span> ?  step-&gt;to_int<span class="org-rainbow-delimiters-depth-3">()</span> : 1;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> sp == 0 <span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Expected for-loop step to be non zero."</span><span class="org-rainbow-delimiters-depth-4">)</span>;  <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Create temporary environment </span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tenv</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>env<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> lo &lt;= up<span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">k</span> = lo; k &lt; up; k = k + sp <span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        tenv-&gt;set<span class="org-rainbow-delimiters-depth-5">(</span>ast.var, <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>;
        eval<span class="org-rainbow-delimiters-depth-5">(</span>*ast.block, tenv<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span> sp &gt; 0 <span class="org-rainbow-delimiters-depth-4">){</span> sp = -sp; <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">k</span> = lo; k &gt; up; k = k + sp <span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        tenv-&gt;set<span class="org-rainbow-delimiters-depth-5">(</span>ast.var, <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-type">ValInt</span><span class="org-rainbow-delimiters-depth-6">&gt;(</span><span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>;
        eval<span class="org-rainbow-delimiters-depth-5">(</span>*ast.block, tenv<span class="org-rainbow-delimiters-depth-5">)</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval program</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_prog</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstProg</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">res</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValNil</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">n</span> : ast.statements<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      res = eval<span class="org-rainbow-delimiters-depth-4">(</span>*n, env<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>res-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-keyword">return</span> res;
      <span class="org-rainbow-delimiters-depth-4">}</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>verbose &amp;&amp; <span class="org-negation-char">!</span>in_function<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">s</span> = substring<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">this</span>-&gt;code, n-&gt;begin, n-&gt;end<span class="org-rainbow-delimiters-depth-5">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [*] "</span> &lt;&lt; s &lt;&lt; <span class="org-string">" =&gt; "</span> &lt;&lt; *res &lt;&lt; <span class="org-constant">std</span>::endl;
      <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> res;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval function defintion</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_def</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstDef</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">val</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValFun</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::fprintf(stderr, " [TRACE] Fundef =&gt; name = %s \n", ast.name.c_str());</span>
    val-&gt;name = ast.name;
    val-&gt;args = ast.args;
    val-&gt;_is_native = <span class="org-constant">false</span>;
    val-&gt;body = ast.body;
    val-&gt;env-&gt;outer = env;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Only register non anonymous functions (non lambdas)</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> val-&gt;name != <span class="org-string">""</span> <span class="org-rainbow-delimiters-depth-3">){</span> env-&gt;set<span class="org-rainbow-delimiters-depth-4">(</span>val-&gt;name, val<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">return</span> val;
    <span class="org-comment-delimiter">// </span><span class="org-comment">return std::make_shared&lt;ValErr&gt;("Not implemented for ASTDef");</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Eval function call</span>
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">eval_call</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AstCall</span> <span class="org-keyword">const</span> &amp;<span class="org-variable-name">ast</span>, <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">env</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">auto it = env.get(ast.name);</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = <span class="org-keyword">this</span>-&gt;eval<span class="org-rainbow-delimiters-depth-3">(</span>*ast.iden, env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">//</span><span class="org-comment">if ( it == nullptr )</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">{ return std::make_shared&lt;ValErr&gt;("Function " + ast.name + " not defined"); }</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-negation-char">!</span>it-&gt;is_fun<span class="org-rainbow-delimiters-depth-4">()</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Object is not a function."</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">fun</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ValFun</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>it<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Vector containing evaluated function arguments</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Val</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">args</span>;
    args.reserve<span class="org-rainbow-delimiters-depth-3">(</span>ast.args.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Evalute arguments before function application</span>
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">arg</span> : ast.args<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate function argument</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = <span class="org-keyword">this</span>-&gt;eval<span class="org-rainbow-delimiters-depth-4">(</span>*arg, env<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Abort computation if any error is found.</span>
      <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>res-&gt;is_err<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-keyword">return</span> res; <span class="org-rainbow-delimiters-depth-4">}</span>
      args.push_back<span class="org-rainbow-delimiters-depth-4">(</span>res<span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Native function - implemented in C++     </span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span> fun-&gt;func != <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = fun-&gt;func<span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-keyword">return</span> res;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">---- Non native function ---------- //</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Create temporary enviroment.</span>
    <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>ast.args.size<span class="org-rainbow-delimiters-depth-4">()</span> != fun-&gt;args.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">ValErr</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-string">"Invalid number of arguments passed to function "</span> + fun-&gt;name<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">tenv</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Env</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>fun-&gt;env<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; fun-&gt;args.size<span class="org-rainbow-delimiters-depth-4">()</span>; i++<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span> tenv-&gt;set<span class="org-rainbow-delimiters-depth-4">(</span>fun-&gt;args<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span>, <span class="org-type">args</span><span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

    in_function = <span class="org-constant">true</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Evaluate function body using the temporary environment.</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">res</span> = eval_prog<span class="org-rainbow-delimiters-depth-3">(</span>fun-&gt;body, tenv<span class="org-rainbow-delimiters-depth-3">)</span>;
    in_function = <span class="org-constant">false</span>;
    <span class="org-keyword">return</span> res;
  <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">---- End of class interp -------------- //</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

<span class="org-preprocessor">#if</span> 1 
  printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n =============  Interpreter =============== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-type">Interp</span> <span class="org-variable-name">interp</span>; 
  interp.set_verbose<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-keyword">auto</span> <span class="org-variable-name">parser</span> = Parser<span class="org-rainbow-delimiters-depth-2">()</span>;

  <span class="org-keyword">auto</span> <span class="org-variable-name">ast</span> = parser.parse_expr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" z = - ( -20 + 8 * 10 / 25 ) - 3 * random()  + 100 / sqrt( 5 * 10 + 3 * (20 - 7 + 8) + 3 ^ (2 * 3) ) * 15"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">PrintSexpVisitor</span> <span class="org-variable-name">printer</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ast = "</span>;
  ast-&gt;accept<span class="org-rainbow-delimiters-depth-2">(</span>printer<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" PPRINT =&gt; "</span>;
  pprint<span class="org-rainbow-delimiters-depth-2">(</span>*ast<span class="org-rainbow-delimiters-depth-2">)</span>;

  interp.repl<span class="org-rainbow-delimiters-depth-2">()</span>;

<span class="org-preprocessor">#endif</span>

  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
<b>Building and running</b>
</p>

<p>
Building:
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Clone repository </span>
$ git clone https://gist.github.com/b5c5dc8d940a5927159f9d48d7b43a0c interp

<span class="org-comment-delimiter"># </span><span class="org-comment">Enter project directory </span>
$ cd interp 

<span class="org-comment-delimiter"># </span><span class="org-comment">List repository </span>
$ ls
formula.cpp  script.txt  xmake.lua

<span class="org-comment-delimiter"># </span><span class="org-comment">Build  </span>
$ xmake build -P .
checking for <span class="org-variable-name">platform </span>... <span class="org-compilation-warning">linux</span>
checking for <span class="org-variable-name">architecture </span>... <span class="org-compilation-warning">x86_64</span>
[ 25%]: ccache compiling.release formula.cpp
[ 50%]: linking.release formula
[100%]: build ok!
</pre>
</div>

<p>
<b>Running:</b>
</p>

<p>
Start interpreter:
</p>

<div class="org-src-container">
<pre class="src src-js"> $ rlwrap xmake run  

 =============  Interpreter =============== 
 ast = (SET z (+ (- (- (+ (- 20) (<span class="org-string">/ (* 8 10 ) 25 ) )) (* 3 (CALL random) ) ) (* (/</span> 100 (CALL sqrt (+ (+ (* 5 10 ) (* 3 (+ (- 20 7 ) 8 ) ) ) (^ 3 (* 2 3 ) ) )) ) 15 ) ))
 PPRINT =&gt; z = -(-20 + 8 * 10 / 25) - 3 * random() + 100 / sqrt(5 * 10 + 3 * ( 20 - 7 + 8 ) + 3 ^ ( 2 * 3 )) * 15
 $&gt; 

 $&gt; <span class="org-string">" String literal "</span> 
 = <span class="org-string">" String literal "</span>

 $&gt; :symbol_literal
 = :symbol_literal

 $&gt; <span class="org-constant">true</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean literal </span>
 = <span class="org-constant">true</span>

 $&gt; <span class="org-constant">false</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean literal</span>
 = <span class="org-constant">false</span>


 $&gt; sin <span class="org-comment-delimiter">// </span><span class="org-comment">Function object </span>
 = &lt;Function sin&gt;

 $&gt; type(sin)  <span class="org-comment-delimiter">// </span><span class="org-comment">Get type of object (result is a symbol)</span>
 = :fun

 $&gt; type(sin) == :fun
 = <span class="org-constant">true</span>

 $&gt; nil <span class="org-comment-delimiter">// </span><span class="org-comment">nil literal</span>
 = nil

 $&gt; 201.5E3
 = 201500

 $&gt; 201.5e3 <span class="org-comment-delimiter">// </span><span class="org-comment">Floating point number</span>
 = 201500

 $&gt; .215e3
 = 215

 $&gt; 10% <span class="org-comment-delimiter">// </span><span class="org-comment">10 percent</span>
 = 0.1


 $&gt; 90.25 <span class="org-comment-delimiter">// </span><span class="org-comment">90.25 percent</span>
 = 90.25

 $&gt; 10 + 3 * 5 * 2 ^ 2 ^ 3 - 5 * exp(4.2)
 ast = (DO 
  (- (+ 10 (* (* 3 5 ) (^ 2 (^ 2 3 ) ) ) ) (* 5 (CALL exp 4.2) ) ) 
)
 = 3516.57

 $&gt; -20 + 100 * 4 * 2 ^ 2 ^ 3
 ast = (DO 
  (+ (- 20) (* (* 100 4 ) (^ 2 (^ 2 3 ) ) ) ) 
)
 = 102380

 $&gt; log10(-20 + 100 * 4 * 2 ^ 2 ^ 3)
 ast = (DO 
  (CALL log10 (+ (- 20) (* (* 100 4 ) (^ 2 (^ 2 3 ) ) ) )) 
)
 = 5.01022

 $&gt; ans * 5 / 100
 ast = (DO 
  (<span class="org-string">/ (* ans 5 ) 100 ) </span>
<span class="org-string">)</span>
<span class="org-string"> = 0.250511</span>

<span class="org-string"> $&gt; ans</span>
<span class="org-string"> ast = (DO </span>
<span class="org-string">  ans </span>
<span class="org-string">)</span>
<span class="org-string"> = 0.250511</span>

<span class="org-string"> $&gt; x = log10(-20 + 100 * 4 * 2 ^ 2 ^ 3)</span>
<span class="org-string"> = 5.01022</span>

<span class="org-string"> $&gt; y = 10 * x - 4 * log(x)</span>
<span class="org-string"> = 43.6562</span>

<span class="org-string"> $&gt; z = 4 * x + y</span>
<span class="org-string"> = 63.6971</span>



</pre>
</div>

<p>
Playing with for-loops:
</p>

<div class="org-src-container">
<pre class="src src-js"> $&gt; :block
 [INFO] Enter multi-line expression mode. Type (;;) when you are done. 
<span class="org-keyword">for</span> i = 1 to 100 by 10 <span class="org-keyword">do</span>
   print(<span class="org-string">" i = "</span>, i, <span class="org-string">" sqrt(i) = "</span>, sqrt(i))
end
;;
 ast = (DO 
  (FOR i 1 100 10 (DO 
  (CALL print <span class="org-string">" i = "</span> i <span class="org-string">" sqrt(i) = "</span> (CALL sqrt i)) 
)) 
)
 i = 1 sqrt(i) = 1.000000
 i = 11 sqrt(i) = 3.316625
 i = 21 sqrt(i) = 4.582576
 i = 31 sqrt(i) = 5.567764
 i = 41 sqrt(i) = 6.403124
 i = 51 sqrt(i) = 7.141428
 i = 61 sqrt(i) = 7.810250
 i = 71 sqrt(i) = 8.426150
 i = 81 sqrt(i) = 9.000000
 i = 91 sqrt(i) = 9.539392
 = nil
</pre>
</div>

<p>
Playing with while-loops:
</p>

<div class="org-src-container">
<pre class="src src-js"> $&gt; :block 
 [INFO] Enter multi-line expression mode. Type (;;) when you are done. 
k = 20;
<span class="org-keyword">while</span> k &gt; 0 <span class="org-keyword">do</span> 
    print(<span class="org-string">"\t count down =&gt; k = "</span>, k);
    k = k - 4;
end
;;
 ast = (DO 
  (SET k 20)
  (WHILE (&gt; k 0 ) (DO (CALL print <span class="org-string">"      count down =&gt; k = "</span> k) (SET k (- k 4 )) )) 
)
       count down =&gt; k = 20
       count down =&gt; k = 16
       count down =&gt; k = 12
       count down =&gt; k = 8
       count down =&gt; k = 4
 = nil
</pre>
</div>

<p>
Playing with functions:
</p>

<div class="org-src-container">
<pre class="src src-js"> :show_ast 

 <span class="org-comment-delimiter">// </span><span class="org-comment">Define a short function (single line function)</span>
 $&gt; get_yield = fn (rate, nper) -&gt; 100 * ((1 + rate) ^ nper - 1) <span class="org-comment-delimiter">// </span><span class="org-comment">rate (interest rate) ; nper - number of periods </span>
 ast = (DO 
  (SET get_yield (FN  ( rate nper )  (* 100 (- (^ (+ 1 rate ) nper ) 1 ) ))) 
)
 = &lt;Function &gt;

 $&gt; :hide_ast

 $&gt; get_yield(0.25%, 12) <span class="org-comment-delimiter">// </span><span class="org-comment">0.25 per month =&gt; gets the total return per year</span>
 = 3.0416

 $&gt; get_yield(1%, 12) 
 = 12.6825

 $&gt; get_yield(5%, 12) 
 = 79.5856

 $&gt; rate
 = ERROR - Unbound variable rate

 $&gt; nper
 = ERROR - Unbound variable nper

<span class="org-comment-delimiter">// </span><span class="org-comment">----- define a long function --------//</span>

 $&gt; :block
 [INFO] Enter multi-line expression mode. Type (;;) when you are done. 
fn myfunc(x, y, z)
   k = 3 * x + 5 * log(z) / exp(y) 
   a = k + x + y + z 
   print(<span class="org-string">" x = "</span>, x)
   print(<span class="org-string">" y = "</span>, y)
   print(<span class="org-string">" k = "</span>, k, <span class="org-string">" ; a = "</span>, a) 
   k + a + x + y        
end
;;
 ast = (DO 
  (FN myfunc ( x y z )  (SET k (+ (* 3 x ) (<span class="org-string">/ (* 5 (CALL log z) ) (CALL exp y) ) )) </span>
<span class="org-string">        (SET a (+ (+ (+ k x ) y ) z )) (CALL print " x = " x) (CALL print " y = " y) </span>
<span class="org-string">        (CALL print " k = " k " ; a = " a) (+ (+ (+ k a ) x ) y )) </span>
<span class="org-string">)</span>
<span class="org-string"> = &lt;Function myfunc&gt;</span>

<span class="org-string"> $&gt; myfunc(2, 5, 6)</span>
<span class="org-string"> x = 2</span>
<span class="org-string"> y = 5</span>
<span class="org-string"> k = 6.060364 ; a = 19.060364</span>
<span class="org-string"> = 32.1207</span>

<span class="org-string"> $&gt; result = myfunc(2, 5, 6)</span>
<span class="org-string"> x = 2</span>
<span class="org-string"> y = 5</span>
<span class="org-string"> k = 6.060364 ; a = 19.060364</span>
<span class="org-string"> = 32.1207</span>

<span class="org-string"> $&gt; result</span>
<span class="org-string"> = 32.1207</span>

</pre>
</div>

<p>
Load a script file (script.txt)
</p>

<pre class="example">
$&gt; :load /home/gmhf8z4/formula-parser/interp/script.txt
      [TRACE] Starting user script 
      [INFO] REPL Version = 0.1

 ------ Test IF-ELSE -------------
 =&gt; x negative or zero 
 =&gt; x negative or zero 
 [TRACE] z = 200
 =&gt; x = -10 =&gt; negative 
 =&gt; x = 20 =&gt; positive 
 =&gt; x = 0 =&gt; zero 

---------- WHILE LOOP ----------- 
      sq(i) = 16
      sq(i) = 9
      sq(i) = 4
      sq(i) = 1
      sq(i) = 0
      sum = 30
 sum = do_sum(5) =  30

---------- FOR LOOP  ----------- 
       i = 10 ; i^2 = 100
       i = 8 ; i^2 = 64
       i = 6 ; i^2 = 36
       i = 4 ; i^2 = 16
       i = 2 ; i^2 = 4

 ------- CLOSURES ----------------------

 --- Testing function: add10
      add10(10) = 20
      add10(15) = 25
      add10(20) = 30
      add10(25) = 35

 --- Testing function: add20
      add20(10) = 30
      add20(15) = 35
      add20(20) = 40
      add20(25) = 45

 --- Testing function: add30
      add30(10) = 40
      add30(15) = 45
      add30(20) = 50
      add30(25) = 55
 = nil

$&gt; sq(2)
 = 4

 $&gt; sq(6)
 = 36

 $&gt; x
 = -10

 $&gt; add10(20)
 = 30

 $&gt; add30(100)
 = 130
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfa94dd1" class="outline-3">
<h3 id="orgfa94dd1"><span class="section-number-3">1.13</span> Operator Precedence Climbing Algorithm</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Despite the simplicity of recursive-descent parser implementations,
they are inefficient and cumbersome for parsing typical infix
expressions found in mathematics and programming languages with lots
operators, such as C, C++ or Python, since this type of parser require
a grammar production rule and a recursive function call for every
operator precedence level. In addition, changing or adding new
operators with different associativity or precedence, requires a
significant amount of changes in the recursive descent parser
code. Parser algorithms including operator precedence climbing and
Pratt parser are more suitable for dealing with infix expressions than
pure recursive descent parser, since they don't need a recursive
function call for every precedence level and allow new operators with
custom precedence and associativity to be even be added at runtime or
at compile-time without a huge amount of code changes. These
precedence parsers, are not full replacement for conventional parsers,
instead they are better used as a components of larger parsers.
</p>

<p>
Besides the complexity that nested infix operators with several
precedence levels and associativity introduces in parser
implementations, they can also be cumbersome for readers to reason
about the code evaluation and lead to subtle bugs since only the
precedence and associativity of math arithmetic and assignment
operators are common, while other operators, including logical and
bitwise, vary across programming languages. As a result, in order to
understand a piece of code is evaluated in a particular programming
language it is necessary to check the operator precedence and
associativity table of this language.
</p>


<p>
<b>Operator Properties</b>
</p>

<ul class="org-ul">
<li>Types of operators according with arity (number of operands):

<ol class="org-ol">
<li>unary prefix operators (-, !, +]
<ul class="org-ul">
<li>=&gt; Example: +100, -25, !false</li>
</ul></li>

<li>unary postfix operators
<ul class="org-ul">
<li>=&gt; Example: factorial 5! = 120</li>
</ul></li>

<li>infix operators (*, +, /..]
<ul class="org-ul">
<li>=&gt; Example: 125 * 3 / 5</li>
</ul></li>

<li>infix left associative
<ul class="org-ul">
<li>=&gt; Example: 4 + 3 + 10 is evaluated as  ((4 + 3] + 10]</li>
</ul></li>

<li>infix right associative
<ul class="org-ul">
<li>=&gt; Example: 2 ^ 3 ^ 4 is evaluated as  (2 ^ (3 ^ 4]]</li>
</ul></li>

<li>ternary operator
<ul class="org-ul">
<li>=&gt; Example:  w = x &gt; z ? "greater" : "LT";</li>
</ul></li>
</ol></li>

<li>Mneumonics of operator precedence listed from highest precendence
level to lowest precedence level:
<ul class="org-ul">
<li>PEDMAS =&gt; Parenthesis, Exponents, Multiplication/Division, Addition/Subtraction</li>
<li>BEDMAS =&gt; Bracket, Order, Division/Multiplication</li>
<li>BODMAS =&gt; Bracket, Order, Division/Multiplication, Addition/Subtraction</li>
<li>BIDMAS =&gt; Bracket, Indices, Division/Multiplication, Addition/Subtraction</li>
</ul></li>

<li>In general, assignment operators, including :=, <code>+=</code> and <code>*=</code>, and
exponentiation operator (^) or (**) in Fortran and Python, are
right associative. So, a = b = c is evaluated as a = (b = c) and
regarding exponentiation, <code>x^y^z = x^(y^z)</code>.</li>

<li>Operator precedence confusion =&gt; case when there are (-] minus
prefix and (^] power/exponentiation.
<ul class="org-ul">
<li>In mathematics and Python, <code>-a^b</code> is evaluated as -<code>(a^b]</code>, so <code>-1^2 = -1</code></li>
<li>In Microsoft Excel and in C, unary operators always have higher
precendence levels than binary operators, so <code>-a^b</code> is evaluated
as <code>(-a]^b</code>, therefore <code>-1^2</code> is evaluated to +1 as opposite of
what most people familiar with mathematics expects. Other
spreadsheet software copy the same bug that Excel keeps due to
backward compatibility reasons.</li>
</ul></li>

<li>Spaceship operator: &lt;=&gt; introduced in C++20 for implementing three-way comparison.
<ul class="org-ul">
<li>x &lt;=&gt; y  <code>=&gt;</code> evaluates to 0 if  <code>x == y</code></li>
<li>x &lt;=&gt; y  <code>=&gt;</code> evaluates to -1 if  <code>x &lt; y</code></li>
<li>x &lt;=&gt; y  <code>=&gt;</code> evaluates to +1 if  <code>x &gt; y</code></li>
</ul></li>

<li>In some literature, multiplicaton can have a higher precedence
than division, so:
<ul class="org-ul">
<li>x  5 * y  is interpreted as  x  (5 * y)</li>
</ul></li>

<li>Operator precedence confusion =&gt; exponentiation associativity 

<ul class="org-ul">
<li>Exponentiation operator is left associative in Matlab
(MathWorks], Octave (Matlab clone] and Excel, so <code>4^3^2</code> is
evaluated as (4 ^ 3) ^ 2 = (^ (^ 4 3) 2) 4096</li>

<li>In mathematics and most programming languages, the
exponentiation operator is right associative, so <code>4^3^2</code> is
evaluated as <code>4^(3^2)</code> = (^ 4 (^ 3 2)) = 262144</li>
</ul></li>
</ul>

<p>
<b>Operator Classification</b>
</p>


<div class="org-src-container">
<pre class="src src-text">                            +----&gt;&gt; Unary Operator
                           |           Takes one argument
             +--- arity --&gt;+           Example: -10, not x &gt; y, !finished()
            /              |                          
operator--&gt;+               +----&gt;&gt; Binary Operator
           |               |           Takes 2 arguments. 
           |               |           Example: +, *, -, ^
           |               | 
           |               +----&gt;&gt; Ternary Operator =&gt; Example from C or C++: x &gt; y ? 10 : 50  or lisp (if (&gt; x y) 10 50)
           |
           |                      /----&gt; Left associative:   
           |                     |               20 * 5 * 3 is computed as ((20 * 5) * 3) or in Lisp notation: (* (* 20 5) 3) 
           +----&gt;&gt; associativity +
           |                     |
           |                      \----&gt; Right associative (exponentiaion and operators 'and' and 'or' in Python)  
           |                               Example: 2 ^ 3 ^ 4 = (2 ^ (3 ^ 4)) = (^ 2 (^ 3 4))
           |
           | 
           |               +--&gt; Logical 
           |              /
           |             /
           +----&gt;&gt; types +----&gt; Arithmetic 
           |             \
           |              \----&gt; Bitwise operators =&gt; &lt;&lt; (left shift in C or C++), &gt;&gt; (right shift in C or C++)


</pre>
</div>


<p>
<b>See:</b>
</p>

<ul class="org-ul">
<li><a href="https://www.oilshell.org/blog/2016/11/01.html">Pratt Parsing and Precedence Climbing Are the Same Algorithm</a></li>

<li><a href="https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">Parsing Expressions by Recursive Descent</a></li>

<li><a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">Operator-precedence parser</a></li>

<li><a href="https://en.wikipedia.org/wiki/Polish_notation">Polish notation</a></li>

<li><a href="https://blog.adamant-lang.org/2019/operator-precedence/">Operator Precedence: We can do better</a></li>

<li><a href="https://wiki.c2.com/?OperatorPrecedenceConsideredHarmful">Operator Precedence Considered Harmful</a></li>

<li><a href="https://web.archive.org/web/20190804031555/https://www.nytimes.com/2019/08/02/science/math-equation-pedmas-bemdas-bedmas.html">The Math Equation That Tried to Stump the Internet - The New York Times</a></li>

<li><a href="http://lambda-the-ultimate.org/node/2943">Languages without operator precedence</a></li>

<li><a href="https://www.jsoftware.com/papers/APLOperators.htm">The Role of Operators in APL</a> - Kenneth E. Iverson
<ul class="org-ul">
<li>Note: APL, just like Smalltalk programming language, does not
have operator precedence, all operators have the same precedence
level. In order to specify a particular order of evaluation, the
user must use parentheis.</li>
</ul></li>

<li><a href="https://wiki.c2.com/?SmalltalkMessageRules">Smalltalk Message Rules</a></li>

<li><a href="https://en.wikipedia.org/wiki/Operator_associativity">Operator associativity</a></li>

<li><a href="https://en.wikipedia.org/wiki/Order_of_operations">Order of Operations</a></li>

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Operator Precedence in JavaScript</a></li>

<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/">C# operators and expressions (C# reference)</a></li>

<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ built-in operators, precedence, and associativity</a></li>

<li><a href="https://rosettacode.org/wiki/Operator_precedence">https://rosettacode.org/wiki/Operator_precedence</a></li>

<li><a href="https://wuciawe.github.io/functional%20programming/haskell/2016/07/03/infix-functions-in-haskell.html">Infix Functions In Haskell</a> (Operator Precedence in Haskell)</li>

<li><a href="https://stackoverflow.com/questions/15080128/operator-precedence-in-haskell">operator precedence in Haskell - stack overflow</a></li>

<li><a href="https://old.reddit.com/r/haskell/comments/ipfok/confusion_between_and_operators">r/haskell - Confusion between (.) and ($) operators</a>  (Operator Precedence in Haskell)</li>

<li><a href="https://www.scattered-thoughts.net/writing/better-operator-precedence/">Better operator precedence</a></li>

<li><a href="https://en.wikipedia.org/wiki/Null_coalescing_operator">https://en.wikipedia.org/wiki/Null_coalescing_operator</a></li>

<li><a href="https://kotlin-quick-reference.com/156-R-elvis-operator.html">Kotlin - The Elvis Operator (?:) - null coalescing operator</a></li>

<li><a href="https://kotlinlang.org/docs/null-safety.html">Kotlin - Null Safety</a></li>

<li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator">Null coalescing operators - ?? and ??= operators (C# reference)</a></li>
</ul>



<p>
<b>Precedence Climbing Parser Algorithm Pseudocode</b>
</p>

<p>
Pseudocode of a precedence climbing parsing algorithm, based on 
<a href="https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">(Norvell, 1999)</a>, but modified for parsing infix expressions with
function calls, such as 10 + 3 * x / sqrt(x + y) or atan2(3 * x + y, x).
</p>

<div class="org-src-container">
<pre class="src src-pascal">  <span class="org-comment">//                Token Types                     //</span>
  <span class="org-comment">//------------------------------------------------//</span>
  <span class="org-comment">// Delimiters </span>
  T_LPAR <span class="org-string">"("</span>  <span class="org-comment">// left parenthesis </span>
  T_RPAR <span class="org-string">")"</span>  <span class="org-comment">// right parenthesis</span>
  T_DOT  <span class="org-string">"."</span>  <span class="org-comment">// Dot - found in dotted pair '(a . b)</span>
  T_QUOTE <span class="org-string">"'"</span> <span class="org-comment">// quote (')</span>
  <span class="org-comment">// Literal token types (terminal elements of grammar)</span>
  T_NUM       <span class="org-comment">// number </span>
  T_STR       <span class="org-comment">// string literal "something else"</span>
  T_IDENT     <span class="org-comment">// identifier </span>
  T_NIL       <span class="org-comment">// nil =&gt; null element and empty list </span>
  T_BOOL      <span class="org-comment">// boolean #t (true) or #f (false)</span>
  <span class="org-comment">// Sentinel Token Types </span>
  T_EOF       <span class="org-comment">// End Of File </span>
  T_ERR       <span class="org-comment">// Error </span>
  T_NDF       <span class="org-comment">// Non Defined - non initialized token </span>

<span class="org-comment">// -------------------------------------------------------// </span>

<span class="org-comment">// --------- Abstract Syntax Tree --------</span>
Ast =   AstInteger(x: int)
      | AstVariable(x: string)
      | AstBoolean(x: bool)
        <span class="org-comment">// Binary operator </span>
      | AstBinop(operator: string, lhs: Ast, rhs: Ast)
        <span class="org-comment">// Unary operator </span>
      | AstUnop
        <span class="org-comment">// Function call </span>
      | AstCall(ident: string, args: List[Ast])


 <span class="org-comment">// Those tokens come from the tokenizer which skips blank characters, white spaces and new lines, and </span>
 <span class="org-comment">// breaks the source code into terminal elements of the grammar. </span>
 tokens := [ Token(T_LPAR, <span class="org-string">"("</span>, Token(T_NUM, <span class="org-string">"-1245.13e3"</span>), Token(T_SYM, <span class="org-string">"x1"</span>)
           ,Token(T_STR, <span class="org-string">"hello world"</span>), Token(T_NIL, <span class="org-string">"nil"</span>), Token(T_BOOL, <span class="org-string">"#f"</span>)
           ,Token(T_BOOL, <span class="org-string">"#t"</span>), Token(T_DOT, <span class="org-string">"."</span>), Token(T_RPAR, <span class="org-string">")"</span>) 
          ] 

<span class="org-comment">// ------- Global Variables ==&gt; They should be contained in an object.</span>
<span class="org-comment">// Current position of cursors           </span>
<span class="org-function-name">index</span> := 0 
<span class="org-comment">// Current token  </span>
<span class="org-function-name">current</span> := Token(T_NDF, <span class="org-string">""</span>)

<span class="org-comment">// Advance to next token  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">advance</span>(): void  
  <span class="org-keyword">IF</span> index &gt;= len(tokens) <span class="org-keyword">THEN</span> 
      RETURN  Token(T_EOF, <span class="org-string">""</span>)
  <span class="org-keyword">END</span>
  current := tokens[index]
  index := index + 1 
<span class="org-keyword">END</span> 

<span class="org-comment">// Check whether the current token type has the same type as the argument </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">check</span>(token_type): bool  
  RETURN current.<span class="org-type">type</span> == token_type 
<span class="org-keyword">END</span> 

<span class="org-comment">// Returns true if the current token matches the expected type and consume it.</span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">match</span>(token_type): bool  
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type <span class="org-keyword">THEN</span> 
     advance()
     RETURN true 
  <span class="org-keyword">END</span> 
  RETURN false 
<span class="org-keyword">END</span> 

<span class="org-comment">// If the current token does not match the expected type, raise an error. </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">expect</span>(token_type)
  <span class="org-keyword">IF</span> current.<span class="org-type">type</span> == token_type 
     advance() 
  <span class="org-keyword">ELSE</span> 
     error(<span class="org-string">"Expected token "</span>, token_type, <span class="org-string">", but given "</span>, current)
  <span class="org-keyword">END</span> 
<span class="org-keyword">END</span> 

<span class="org-comment">// Return true if the current token is EOF (End Of File)  </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">is_eof</span>(): bool 
  RETURN current.<span class="org-type">type</span> == EOF 
<span class="org-keyword">END</span> 

<span class="org-comment">//--------------------------------------------------------//</span>

<span class="org-comment">// Parse infix expression (parse entrypoint)</span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parseExpr</span>()
    expr := parseBinary(0)
    RETURN expr 
<span class="org-keyword">END</span> 

<span class="org-comment">// Parse infix expression with binary operator  </span>
<span class="org-comment">// such as '+', '/' or '&amp;&amp;' and </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parseBinary</span>(precedence)
   <span class="org-comment">// left hand-side of infix expression</span>
   lhs := parsePrimary()
   <span class="org-keyword">WHILE</span> operator := peek(); operator.isBinary() <span class="org-keyword">AND</span> operator.precedence &gt;= precedence <span class="org-keyword">DO</span>
        oper := operator 
        advance()
        prec := 0 
        <span class="org-keyword">IF</span> oper.isRightAssociative() <span class="org-keyword">THEN</span> prec := oper.precedence
        <span class="org-keyword">IF</span> oper.isLeftAssociative()  <span class="org-keyword">THEN</span> prec := 1 + oper.precedence 
        <span class="org-comment">// right hand side of infix expression </span>
        rhs := parseBinary(prec)          
        <span class="org-comment">// oper.lexeme =&gt; string  representation of operator such as "+" or "*"</span>
        lhs := AstBinop( oper.lexeme, lhs, rhs )
   <span class="org-keyword">END</span> 
   RETURN lhs
<span class="org-keyword">END</span> 

<span class="org-keyword">FUNCTION</span> <span class="org-function-name">parsePrimary</span>()
    <span class="org-comment">// Get current token </span>
    tok := peek()
    <span class="org-comment">// Unary operator including: '+' in +10, or - in -20</span>
    <span class="org-keyword">IF</span> tok.isUnaryOperator() <span class="org-keyword">THEN</span> 
       op := token
       advance()
       rhs    := parseBinary(op.precedence)
       result := AstUnop(op.lexeme, rhs)
       RETURN rhs 
    <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(T_LPAR) <span class="org-keyword">THEN</span> 
       advance()
       expr := parseBinary(0)
       RETURN expr
    <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> check(T_INT) 
       expr := parseInt(tok.lexeme) 
       RETURN AstInt(expr)
    <span class="org-comment">// Function call such as hypothn(x, y) </span>
    <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> T_IDEN <span class="org-keyword">AND</span> lookAheadToken(1) == T_LPAR <span class="org-keyword">THEN</span> 
       expr := parseFunction()
       REUTNR expr 
    <span class="org-keyword">ELSE</span> <span class="org-keyword">IF</span> T_IDEN 
       expr := AstVariable(tok.lexeme) 
       advance()
       RETURN expr 
    <span class="org-keyword">ELSE</span> 
        ERROR(<span class="org-string">"Invalid token"</span>)
    <span class="org-keyword">END</span>

    <span class="org-keyword">FUNCTION</span> <span class="org-function-name">parseFunction</span>()
        functioName := peek().lexeme 
        advance()
        expect(T_LPAR)
        <span class="org-keyword">IF</span> match(T_RPAR) <span class="org-keyword">THEN</span> 
           expr := AstCall(functionName, [])
        <span class="org-keyword">ELSE</span>  
           <span class="org-comment">// Parse first  argument</span>
           x := parseExpr()
           <span class="org-comment">// List  or arguments</span>
           args := [ arg ]
           <span class="org-comment">// Iterate while there is a comma</span>
           <span class="org-keyword">WHILE</span> match(T_COMMA) <span class="org-keyword">DO</span> 
               <span class="org-comment">// Parse remaining arguments</span>
               x := parseExpr()
               lst.append(x)
           <span class="org-keyword">END</span> 
           <span class="org-comment">// Expect right parenthesis</span>
           expect(T_RPAR)
           <span class="org-comment">// Build AST - Abstract Syntax Tree Node</span>
           expr := AstCall(functionName, lst)
           RETURN expr 
        <span class="org-keyword">END</span> 
    <span class="org-keyword">END</span> 
<span class="org-keyword">THEN</span> 

<span class="org-comment">//---------- Program entry point - main() --------//</span>
<span class="org-comment">// </span>
<span class="org-keyword">FUNCTION</span> <span class="org-function-name">main</span>(): void 
   <span class="org-comment">// Lexical analysis, break text/source into tokens</span>
   tokens := tokenize(source_code)
   <span class="org-comment">// Initialize parser </span>
   advance()
   <span class="org-comment">// parser infix expression </span>
   ast := parseExpr()
   <span class="org-comment">// Display result</span>
   print(<span class="org-string">" Infix Expression AST: "</span>, ast)
<span class="org-keyword">END</span> 

</pre>
</div>

<p>
<b>Example - Precedence Clibing Algorithm in F# (FSharp) language</b>
</p>

<p>
File: <span class="underline">parser.fsx</span> 
</p>

<div class="org-src-container">
<pre class="src src-fsharp">
<span class="org-comment-delimiter">/// </span><span class="org-comment">Position within a source file </span>
<span class="org-keyword">type</span> <span class="org-type">Position</span> = {
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Offset - position of cursor as the number of characters </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">from beginning of the file until current cursor position </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">minus one. The offset starts from zero.</span>
    Offset: <span class="org-type">int</span>                             
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Line where a token or ast node is found within a file. (Starts from one)"</span>
    Line:   <span class="org-type">int</span> 
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Column where a token or ast node is found within a file. (Starts from one)"</span>
    Column: <span class="org-type">int</span> 
}

<span class="org-comment-delimiter">/// </span><span class="org-comment">Ast metadata </span>
<span class="org-keyword">type</span> <span class="org-type">Location</span> = {
    File:  <span class="org-type">string</span> 
    Start: <span class="org-type">Position</span>
    End:   <span class="org-type">Position</span>
}  <span class="org-keyword">with</span> 
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Null location for default intialization </span>
    <span class="org-keyword">static</span> <span class="org-keyword">member</span> <span class="org-function-name">EmptyLocation</span> = 
        <span class="org-keyword">let</span> <span class="org-variable-name">pos</span>: <span class="org-type">Position</span> = { Offset = -1; Line = -1; Column = -1}
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span>: <span class="org-type">Location</span> = { File = <span class="org-string">""</span>; Start = pos; End = pos }
        loc 


<span class="org-comment-delimiter">/// </span><span class="org-comment">Merge two locations returning a new one return a new location </span>
<span class="org-comment-delimiter">/// </span><span class="org-comment">where location.Start = a.Start and location.end = b.End </span>
<span class="org-keyword">let</span> <span class="org-function-name">mergeLocation</span> (<span class="org-variable-name">a</span>: <span class="org-type">Location</span>) (<span class="org-variable-name">b</span>: <span class="org-type">Location</span>) = 
    <span class="org-keyword">let</span> <span class="org-variable-name">result</span>: <span class="org-type">Location</span> = { File = a.File; Start = a.Start; End = b.End }
    result 

<span class="org-keyword">type</span> <span class="org-type">TokenKind</span> = 
    | TInt       <span class="org-comment-delimiter">// </span><span class="org-comment">Integer number </span>
    | TFlt       <span class="org-comment-delimiter">// </span><span class="org-comment">Floating point number </span>
    | TStr       <span class="org-comment-delimiter">// </span><span class="org-comment">String </span>
    | TBool      <span class="org-comment-delimiter">// </span><span class="org-comment">Boolean </span>
    | TEql       <span class="org-comment-delimiter">// </span><span class="org-comment">'==' Equal </span>
    | TAsn       <span class="org-comment-delimiter">// </span><span class="org-comment">':=' Assignment </span>
    | TIden      <span class="org-comment-delimiter">// </span><span class="org-comment">Identifier =&gt; variable name or function name</span>
    | TOper      <span class="org-comment-delimiter">// </span><span class="org-comment">Operator: '+', '==', '-', '+' ....</span>
    | TKey       <span class="org-comment-delimiter">// </span><span class="org-comment">Keyword</span>
    | TLpar      <span class="org-comment-delimiter">// </span><span class="org-comment">'(' Left parenthesis </span>
    | TRpar      <span class="org-comment-delimiter">// </span><span class="org-comment">')' Right parenthesis </span>
    | TComm      <span class="org-comment-delimiter">// </span><span class="org-comment">',' Comma</span>
    | TSemicolon      <span class="org-comment-delimiter">// </span><span class="org-comment">';'</span>
    | TComment   <span class="org-comment-delimiter">// </span><span class="org-comment">Any line starting with double forward slash // .... </span>
    | TNL        <span class="org-comment-delimiter">// </span><span class="org-comment">New line</span>
    | TEof       <span class="org-comment-delimiter">// </span><span class="org-comment">End of file </span>
    | TErr       <span class="org-comment-delimiter">// </span><span class="org-comment">Tokenizer error </span>
    | TEmpty     <span class="org-comment-delimiter">// </span><span class="org-comment">Used for initializing a dummy empty token </span>

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsErr</span>() = this = TErr
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsEof</span>() = this = TEof


<span class="org-keyword">type</span> <span class="org-type">Token</span> = {
    Kind:     <span class="org-type">TokenKind</span> 
    Lexeme:   <span class="org-type">string</span>  
    Location: <span class="org-type">Location</span>
} 
  <span class="org-keyword">with</span> 
    <span class="org-comment-delimiter">/// </span><span class="org-comment">Null token or default intialization </span>
    <span class="org-keyword">static</span> <span class="org-keyword">member</span> <span class="org-function-name">EmptyToken</span> = 
        <span class="org-keyword">let</span> <span class="org-variable-name">pos</span>: <span class="org-type">Position</span> = { Offset = -1; Line = -1; Column = -1}
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span>: <span class="org-type">Location</span> = { File = <span class="org-string">""</span>; Start = pos; End = pos }
        <span class="org-keyword">let</span> <span class="org-variable-name">tok</span>: <span class="org-type">Token</span>    = { Kind = TokenKind.TEmpty; Lexeme = <span class="org-string">""</span>; Location = loc }
        tok  

<span class="org-keyword">let</span> <span class="org-function-name">tokenOffset</span> (<span class="org-variable-name">tok</span>: <span class="org-type">Token</span>) = 
    (tok.Location.Start.Offset, tok.Location.End.Offset)



<span class="org-comment-delimiter">/// </span><span class="org-comment">Abstract Syntax tree nodes</span>
<span class="org-comment-delimiter">/// </span><span class="org-comment">@tag: expression ast </span>
<span class="org-keyword">type</span> <span class="org-type">ast</span> = 
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Integer literal AST node </span>
        | AstInt   <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Val: <span class="org-type">int</span>  
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Floating point literal AST node </span>
        | AstFlt   <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Val: <span class="org-type">float</span>  
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Variable AST node </span>
        | AstVar   <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Val: <span class="org-type">string</span>  
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Unary operator AST node </span>
        | AstUnop  <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Opr: <span class="org-type">string *</span> Rhs: <span class="org-type">ast</span> 
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Binary operator AST node </span>
        | AstBinop <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Opr: <span class="org-type">string *</span> Lhs: <span class="org-type">ast *</span> Rhs: <span class="org-type">ast</span>
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Functoon call AST node </span>
        | AstCall  <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Ident:  <span class="org-type">string *</span> Args: <span class="org-type">ast list</span> 
        <span class="org-comment-delimiter">/// </span><span class="org-comment">Source code comments </span>
        | AstComment <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span>  Content: <span class="org-type">string</span>
        | AstProg <span class="org-keyword">of</span> Loc: <span class="org-type">Location *</span> Statements: <span class="org-type">ast list</span> 

        <span class="org-comment-delimiter">/// </span><span class="org-comment">Get source location of AST node</span>
        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Location</span>(): <span class="org-type">Location</span> = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstInt  (Loc = loc)    -&gt; loc  
            | AstFlt  (Loc = loc)    -&gt; loc 
            | AstVar  (Loc = loc)    -&gt; loc 
            | AstUnop (Loc = loc)    -&gt; loc 
            | AstBinop(Loc = loc)    -&gt; loc 
            | AstCall (Loc = loc)    -&gt; loc 
            | AstComment (Loc = loc) -&gt; loc 
            | AstProg (Loc = loc)    -&gt; loc 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ToInt</span>(): <span class="org-type">int</span> = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstInt(Val = value) -&gt; value 
            | _ -&gt; failwith <span class="org-string">"This type cannot be casted to integer"</span>
        
        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ToFloat</span>(): <span class="org-type">float</span> = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstFlt(Val = value) -&gt; value 
            | _ -&gt; failwith <span class="org-string">"This type cannot be casted to floating point."</span>

        <span class="org-comment-delimiter">/// </span><span class="org-comment">Convert variable to string identifier</span>
        <span class="org-comment-delimiter">/// </span><span class="org-comment">This is a convenience method for quickly accessing the string representation of a variable</span>
        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ToId</span>: <span class="org-type">string</span> = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstVar(Val = value) -&gt; value 
            | _ -&gt; failwith <span class="org-string">"This type cannot be casted to string."</span>

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsVar</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstVar(_, _) -&gt; <span class="org-keyword">true</span> 
            | _      -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsInt</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstInt _ -&gt; <span class="org-keyword">true</span> 
            | _         -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsFlt</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstFlt _ -&gt; <span class="org-keyword">true</span> 
            | _         -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsUnop</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstUnop _ -&gt; <span class="org-keyword">true</span> 
            | _             -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsBinop</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstBinop _ -&gt; <span class="org-keyword">true</span> 
            | _             -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsComment</span>() = 
            <span class="org-keyword">match</span> this <span class="org-keyword">with</span> 
            | AstBinop _ -&gt; <span class="org-keyword">true</span> 
            | _           -&gt; <span class="org-keyword">false</span> 

        <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ToStr</span>() = 
            <span class="org-keyword">match</span>  this <span class="org-keyword">with</span> 
            | AstInt   (Val = value) -&gt; value.ToString()
            | AstFlt   (Val = value) -&gt; value.ToString()
            | AstVar   (Val = value) -&gt; value.ToString()
            | AstUnop  (Opr = opr; Rhs = rhs) -&gt; sprintf <span class="org-string">"(%s %s)"</span> opr (rhs.ToStr())
            | AstBinop (Opr = opr; Lhs = lhs; Rhs = rhs) -&gt; sprintf <span class="org-string">"(%s %s %s)"</span> opr (lhs.ToStr()) (rhs.ToStr())
            | AstCall  ( Ident = func; Args = args) -&gt; 
                <span class="org-keyword">let</span> <span class="org-function-name">f</span> (<span class="org-variable-name">x</span>: <span class="org-type">ast</span>) = x.ToStr()
                <span class="org-keyword">let</span> <span class="org-variable-name">xs</span> = List.map f args
                <span class="org-keyword">let</span> <span class="org-variable-name">st</span> =  System.String.Join(<span class="org-string">" "</span>, xs)
                <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = sprintf <span class="org-string">"(CALL %s %s)"</span> func st 
                res 
            | AstProg(Statements = stats) -&gt; 
                <span class="org-keyword">let</span> <span class="org-function-name">f</span> (<span class="org-variable-name">x</span>: <span class="org-type">ast</span>) = x.ToStr()
                <span class="org-keyword">let</span> <span class="org-variable-name">xs</span> = List.map f stats
                <span class="org-keyword">let</span> <span class="org-variable-name">st</span> = <span class="org-string">"\n  "</span> + System.String.Join(<span class="org-string">"\n  "</span>, xs)
                <span class="org-keyword">let</span> <span class="org-variable-name">res</span> = <span class="org-string">"(Program "</span> + st + <span class="org-string">"\n)"</span>
                res
            | AstComment(Content = content) -&gt; sprintf <span class="org-string">"(comment \"%s\")"</span> content
            | _ -&gt; failwith <span class="org-string">"Error: not implemented for %A"</span> this

<span class="org-comment-delimiter">/// </span><span class="org-comment">Get string representation of AST </span>
<span class="org-keyword">let</span> <span class="org-function-name">astToString</span> (<span class="org-variable-name">x</span>: <span class="org-type">ast</span>) =  x.ToStr()


<span class="org-keyword">type</span> <span class="org-type">Tokenizer</span>(<span class="org-variable-name">source</span>: <span class="org-type">string</span>) <span class="org-keyword">as</span> <span class="org-variable-name">self</span> =
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">offset</span>: <span class="org-type">int</span> = 0     
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">line</span>: <span class="org-type">int</span> = 1
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">column</span>: <span class="org-type">int</span> = 1
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">start_offset</span>: <span class="org-type">int</span> = 1 
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">start_line</span>: <span class="org-type">int</span> = 1 
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">start_column</span>: <span class="org-type">int</span> = 1 
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">current</span>: <span class="org-type">char</span> = <span class="org-string">'0'</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">file</span> = <span class="org-string">""</span>
    <span class="org-keyword">let</span> <span class="org-variable-name">nullChar</span> = <span class="org-string">'\000'</span> 

    <span class="org-keyword">do</span> 
        self.Advance()

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Peek</span>(): <span class="org-type">char</span> = 
        current

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Lookahed</span>(<span class="org-variable-name">n</span>: <span class="org-type">int</span>): <span class="org-type">char</span>   = 
        <span class="org-keyword">if</span> offset &gt;= source.Length <span class="org-keyword">then</span> nullChar <span class="org-keyword">else</span> source[n + offset - 1]

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">SetMark</span>() = 
        start_offset &lt;- offset
        start_line   &lt;- line 
        start_column &lt;- column

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Advance</span>() = 
        <span class="org-keyword">if</span> offset &gt;= source.Length 
            <span class="org-keyword">then</span> current &lt;- nullChar 
            <span class="org-keyword">else</span> 
                current &lt;- source[offset]
                column &lt;- column + 1
                <span class="org-keyword">if</span>  current = <span class="org-string">'\n'</span> <span class="org-keyword">then</span> 
                    line   &lt;- line + 1
                    column &lt;- 1                    
                offset &lt;- offset + 1

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsEof</span>() = 
        current = nullChar

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Check</span>(<span class="org-variable-name">c</span>: <span class="org-type">char</span>) = 
        c = current

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">CheckNext</span>(<span class="org-variable-name">c</span>: <span class="org-type">char</span>) = 
        c = this.Lookahed 1

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Match</span>(<span class="org-variable-name">c</span>: <span class="org-type">char</span>) = 
        <span class="org-keyword">if</span> c  = current <span class="org-keyword">then</span> this.Advance(); <span class="org-keyword">true</span> <span class="org-keyword">else</span> <span class="org-keyword">false</span>  

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Return a token with metadata  </span>
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Token</span>(<span class="org-variable-name">kind</span>: <span class="org-type">TokenKind</span>, <span class="org-variable-name">lexeme</span>: <span class="org-type">string</span>) = 
        <span class="org-keyword">let</span> <span class="org-variable-name">_start</span>: <span class="org-type">Position</span> = { Offset = start_offset - 1 ; Line  = start_line; Column = start_column - 1}
        <span class="org-keyword">let</span> <span class="org-variable-name">_end</span>:   <span class="org-type">Position</span> = { Offset = offset - 2; Line  = line ; Column = column - 2}
        <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = <span class="org-keyword">if</span> lexeme.Length = 1 <span class="org-keyword">then</span> _start <span class="org-keyword">else</span> _end 
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span>:    <span class="org-type">Location</span> = { File   = file ; Start = _start ; End = t  }
        <span class="org-keyword">let</span> <span class="org-variable-name">tok</span>:    <span class="org-type">Token</span>    = { Kind   = kind ; Lexeme = lexeme ; Location = loc }
        tok 
    
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Error</span>(<span class="org-variable-name">message</span>: <span class="org-type">string</span>) = 
        this.Token(TokenKind.TErr, message)

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">Expect</span>(<span class="org-variable-name">c</span>: <span class="org-type">char</span>) = 
         <span class="org-keyword">if</span> c = current 
         <span class="org-keyword">then</span> 
            this.Advance()
            this.Token(TokenKind.TEmpty, <span class="org-string">""</span>)
         <span class="org-keyword">else</span> 
            this.Error &lt;| sprintf <span class="org-string">"Expected character '%c', but given '%c'"</span> c current
    
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">IsSpace</span>() = 
        current = <span class="org-string">' '</span> || current = <span class="org-string">'\t'</span> || current = <span class="org-string">'\n'</span> || current = <span class="org-string">'\r'</span>
    
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">IsDigit</span>() = 
        System.Char.IsDigit(current)

    <span class="org-keyword">member</span> <span class="org-keyword">private</span>  <span class="org-variable-name">this</span>.<span class="org-variable-name">IsLetter</span>() = 
        System.Char.IsLetter(current)
    
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">IsAlphaNum</span>() =
        System.Char.IsLetterOrDigit(current)

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Tokens</span>(): <span class="org-type">Token list</span> = 
        <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">tokens</span>: <span class="org-type">Token list</span> = []  
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> &lt;| this.IsEof() <span class="org-keyword">do</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">tok</span> = this.Next()
            tokens &lt;- tokens @ [ tok ]
        tokens

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Return next token in the input string  </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Next</span>(): <span class="org-type">Token</span>  = 
        <span class="org-keyword">while</span> this.IsSpace() &amp;&amp; <span class="org-keyword">not</span> &lt;| this.IsEof() <span class="org-keyword">do</span> this.Advance()
        <span class="org-keyword">if</span> this.IsEof() 
        <span class="org-keyword">then</span> this.Token(TEof, <span class="org-string">""</span>) 
        <span class="org-keyword">else</span> 
            this.SetMark()
            <span class="org-keyword">if</span> this.Check <span class="org-string">'/'</span> &amp;&amp; this.CheckNext <span class="org-string">'/'</span> <span class="org-keyword">then</span> 
                <span class="org-keyword">let</span> <span class="org-variable-name">sb</span> = System.Text.StringBuilder()
                this.Advance()
                this.Advance()
                <span class="org-keyword">while</span> <span class="org-keyword">not</span> &lt;| self.Check(<span class="org-string">'\n'</span>)  &amp;&amp; <span class="org-keyword">not</span> &lt;| this.IsEof()  <span class="org-keyword">do</span> 
                    <span class="org-keyword">let</span> <span class="org-variable-name">ch</span> = this.Peek()
                    sb.Append(ch)
                    this.Advance()
                <span class="org-keyword">let</span> <span class="org-variable-name">tok</span> = this.Token(TComment, sb.ToString())
                ignore &lt;| this.Match <span class="org-string">'\n'</span>
                tok 
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'('</span> <span class="org-keyword">then</span> this.Token(TLpar, <span class="org-string">"("</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">')'</span> <span class="org-keyword">then</span> this.Token(TRpar, <span class="org-string">")"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">','</span> <span class="org-keyword">then</span> this.Token(TComm, <span class="org-string">","</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">';'</span> <span class="org-keyword">then</span> this.Token(TSemicolon, <span class="org-string">";"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'+'</span> <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"+"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'-'</span> <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"-"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'*'</span> <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"*"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'/'</span> <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"/"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'^'</span> <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"^"</span>)
            <span class="org-keyword">elif</span> this.Match <span class="org-string">'='</span> <span class="org-keyword">then</span> 
                <span class="org-keyword">if</span> this.Match <span class="org-string">'='</span> 
                <span class="org-keyword">then</span> this.Token(TOper, <span class="org-string">"=="</span>)
                <span class="org-keyword">else</span> this.Token(TOper, <span class="org-string">"="</span>)
            <span class="org-keyword">elif</span> this.IsDigit() <span class="org-keyword">then</span> this.NextNumber() 
            <span class="org-keyword">elif</span> this.IsLetter() <span class="org-keyword">then</span> this.NextIdentifier()
            <span class="org-keyword">else</span> this.Token(TErr, sprintf <span class="org-string">"Invalid character '%c'"</span> (this.Peek()) )

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">NextIdentifier</span>() = 
        <span class="org-keyword">let</span> <span class="org-variable-name">sb</span> = System.Text.StringBuilder()
        <span class="org-keyword">while</span> this.IsAlphaNum() &amp;&amp; <span class="org-keyword">not</span> &lt;| this.IsEof() <span class="org-keyword">do</span> 
            ignore &lt;| sb.Append(current)
            this.Advance()
        <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = sb.ToString()
        <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = this.Token(TIden, lexeme)
        result 

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">NextNumber</span>(): <span class="org-type">Token</span> = 
        this.SetMark()
        <span class="org-keyword">let</span> <span class="org-variable-name">sb</span> = System.Text.StringBuilder()
        <span class="org-comment-delimiter">// </span><span class="org-comment">if this.Match '-' then ignore &lt;| sb.Append("-"); () </span>
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> &lt;| this.Check <span class="org-string">'.'</span> <span class="org-keyword">then</span>  ignore (sb.Append( this.NextInteger() ))
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> &lt;| this.Check <span class="org-string">'.'</span> &amp;&amp; <span class="org-keyword">not</span> &lt;| this.Check <span class="org-string">'e'</span> &amp;&amp; <span class="org-keyword">not</span> &lt;| this.Check <span class="org-string">'E'</span> <span class="org-keyword">then</span> 
            <span class="org-keyword">if</span> this.IsLetter() 
            <span class="org-keyword">then</span> this.Error(<span class="org-string">"Number cannot terminate with letter"</span>)
            <span class="org-keyword">else</span> this.Token(TInt, sb.ToString())
        <span class="org-keyword">else</span>
            <span class="org-keyword">if</span> this.Match <span class="org-string">'.'</span> <span class="org-keyword">then</span>  ignore &lt;| sb.Append( <span class="org-string">"."</span> + this.NextInteger() )
            <span class="org-keyword">let</span> <span class="org-variable-name">letter</span> = this.Peek()
            <span class="org-keyword">if</span> this.Match <span class="org-string">'e'</span> || this.Match <span class="org-string">'E'</span> <span class="org-keyword">then</span> 
                ignore &lt;| sb.Append(letter)
                <span class="org-keyword">if</span>  <span class="org-keyword">not</span> &lt;| this.Match <span class="org-string">'-'</span> &amp;&amp; <span class="org-keyword">not</span> &lt;| this.IsDigit() <span class="org-keyword">then</span> 
                    this.Error(<span class="org-string">"Invalid floating point number"</span>)
                <span class="org-keyword">else</span> 
                    <span class="org-keyword">if</span> this.Match <span class="org-string">'-'</span> <span class="org-keyword">then</span> ignore &lt;| sb.Append(<span class="org-string">'-'</span>)
                    <span class="org-keyword">if</span> <span class="org-keyword">not</span> &lt;| this.IsDigit() <span class="org-keyword">then</span> 
                        this.Error(<span class="org-string">"Invalid floating point number, expected digit"</span>)
                    <span class="org-keyword">else</span> 
                        ignore &lt;| sb.Append( this.NextInteger() )
                        this.Token(TInt, sb.ToString())
            <span class="org-keyword">elif</span> this.IsLetter() 
            <span class="org-keyword">then</span>  this.Error(<span class="org-string">"Floating point numbers cannot end with letter"</span>)
            <span class="org-keyword">else</span>  
                this.Token(TFlt, sb.ToString())

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">NextInteger</span>(): <span class="org-type">string</span>  = 
        <span class="org-keyword">let</span> <span class="org-variable-name">sb</span> = System.Text.StringBuilder()
        <span class="org-keyword">while</span> this.IsDigit() &amp;&amp; <span class="org-keyword">not</span> &lt;| this.IsEof() <span class="org-keyword">do</span> 
            ignore &lt;| sb.Append(current)
            this.Advance()
        <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = sb.ToString()
        lexeme 
        <span class="org-comment-delimiter">// </span><span class="org-comment">let result = this.Token(TInt, lexeme)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">result </span>

<span class="org-keyword">type</span> <span class="org-type">Arity</span> = ArityUnary | ArityBinary 
<span class="org-keyword">type</span> <span class="org-type">Assoc</span> = AssocLeft | AssocRight 

<span class="org-keyword">type</span> <span class="org-type">Operator</span> = {
    Lexeme:     <span class="org-type">string</span>  
    Precedence: <span class="org-type">int</span> 
    Assoc:      <span class="org-type">Assoc</span>  
    Arity:      <span class="org-type">Arity</span> 
}


<span class="org-comment-delimiter">/// </span><span class="org-comment">Parser component that uses precedence climbing algorithm for parsing infix expressions </span>
<span class="org-keyword">type</span> <span class="org-type">ExprParser</span>(<span class="org-variable-name">source</span>: <span class="org-type">string</span>) <span class="org-keyword">as</span> <span class="org-variable-name">self</span> = 
    <span class="org-keyword">let</span> <span class="org-variable-name">tokenizer</span> = Tokenizer source
    <span class="org-keyword">let</span> <span class="org-variable-name">tokens</span> = tokenizer.Tokens()
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">current</span> = Token.EmptyToken
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">pos</span> = 0
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">operators</span>: <span class="org-type">Operator list</span> = [] 
    <span class="org-comment-delimiter">/// </span><span class="org-comment">List of tuples of predicate, that checks whether a current token matches the expression </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">to be parsed, and a function that parses the primary expression</span>
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">primaryExprList</span>:  ( (<span class="org-variable-name">unit</span> -&gt; <span class="org-variable-name">bool</span>) * (<span class="org-variable-name">unit</span> -&gt; <span class="org-variable-name">ast</span>) ) <span class="org-variable-name">list</span> = []
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">skipComment</span> = <span class="org-keyword">false</span> 

    <span class="org-keyword">do</span> 
       <span class="org-comment-delimiter">// </span><span class="org-comment">self.Advance()</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">Fill database of binary and unary operators. </span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">Any client code can add new operators later </span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">------- Unary Operator -------------- //</span>
       self.AddUnaryOperator <span class="org-string">"-"</span> 90 
       self.AddUnaryOperator <span class="org-string">"+"</span> 90 
       <span class="org-comment-delimiter">// </span><span class="org-comment">------- Binary Operator ---------------//</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">Addition and subtraction </span>
       self.AddBinaryOperator <span class="org-string">"+"</span>  40 AssocLeft
       self.AddBinaryOperator <span class="org-string">"-"</span>  40 AssocLeft
       <span class="org-comment-delimiter">// </span><span class="org-comment">Multiplication and division</span>
       self.AddBinaryOperator <span class="org-string">"*"</span> 50 AssocLeft
       self.AddBinaryOperator <span class="org-string">"/"</span> 50 AssocLeft
       <span class="org-comment-delimiter">// </span><span class="org-comment">Power/exponentiation </span>
       self.AddBinaryOperator <span class="org-string">"^"</span> 70 AssocRight
       <span class="org-comment-delimiter">// </span><span class="org-comment">Equality operator </span>
       self.AddBinaryOperator <span class="org-string">"=="</span> 20 AssocLeft
       <span class="org-comment-delimiter">// </span><span class="org-comment">Assignment operators </span>
       self.AddBinaryOperator <span class="org-string">"="</span>  10 AssocRight
       self.AddBinaryOperator <span class="org-string">"+="</span> 10 AssocRight
       self.AddBinaryOperator <span class="org-string">"-="</span> 10 AssocRight
       self.AddBinaryOperator <span class="org-string">"*="</span> 10 AssocRight
       self.AddBinaryOperator <span class="org-string">"/="</span> 10 AssocRight
       <span class="org-comment-delimiter">// </span><span class="org-comment">-----------------------------------------//</span>

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Parse Expression (Entry Point)</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ParseExpr</span>() =
        <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = this.ParseBinary 0 
        expr 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Intialize parser state </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Initialize</span>() = 
        this.Advance()

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">AddPrimaryExpr</span>(<span class="org-variable-name">predicate</span>: <span class="org-type">unit</span> -&gt; <span class="org-variable-name">bool</span>) (<span class="org-variable-name">parser</span>: <span class="org-type">unit</span> -&gt; <span class="org-variable-name">ast</span>) = 
        primaryExprList &lt;- primaryExprList @ [(predicate, parser) ]

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Add binary operator to the database </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">AddBinaryOperator</span> (<span class="org-variable-name">lexeme</span>: <span class="org-type">string</span>) (<span class="org-variable-name">precedence</span>: <span class="org-type">int</span>) (<span class="org-variable-name">assoc</span>: <span class="org-type">Assoc</span>) =  
        <span class="org-keyword">let</span> <span class="org-variable-name">op</span>: <span class="org-type">Operator</span> = { 
                           Lexeme     = lexeme
                         ; Precedence = precedence
                         ; Assoc      = assoc 
                         ; Arity      = ArityBinary
                         }
        operators &lt;- operators @ [op]

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Add unary operator to the database</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">AddUnaryOperator</span> (<span class="org-variable-name">lexeme</span>: <span class="org-type">string</span>) (<span class="org-variable-name">precedence</span>: <span class="org-type">int</span>) =  
        <span class="org-keyword">let</span> <span class="org-variable-name">op</span>: <span class="org-type">Operator</span> = { 
                           Lexeme     = lexeme
                         ; Precedence = precedence
                         ; Assoc      = AssocLeft
                         ; Arity      = ArityUnary
                         }
        operators &lt;- operators @ [op]

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Get current token</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Peek</span>() = 
        current

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Get lexeme (string representation) of current token</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Lexeme</span>() = 
        current.Lexeme    

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Get location of current token </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Location</span>() = 
        current.Location

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Indicates whether current token is EOF token, </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">indicating that there is no more tokens.</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">EOF - End of FIle</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsEof</span>() = this.Check TEof

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Advance to the next token </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Advance</span>() = 
        <span class="org-keyword">if</span> pos &lt; tokens.Length <span class="org-keyword">then</span> 
            current &lt;- tokens[pos]        
            pos &lt;- pos + 1
            <span class="org-comment-delimiter">// </span><span class="org-comment">Skip comment tokens </span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">if current.Kind = TComment &amp;&amp; skipComment then this.Advance()         </span>


    <span class="org-comment-delimiter">/// </span><span class="org-comment">Check whether current token is comment</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsComment</span>(): <span class="org-type">bool</span> = 
        this.Check TComment

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">SkipComment</span>() = 
        <span class="org-keyword">while</span> this.Match TComment <span class="org-keyword">do</span>
            this.Advance()

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Make AST node containing the current comment</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">ParseComment</span>() = 
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> &lt;| this.Check TComment 
        <span class="org-keyword">then</span> failwith <span class="org-string">"Expected comment token"</span> 
        <span class="org-keyword">else</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">node</span> = AstComment(this.Location(), this.Lexeme())
            this.Advance()
            node 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Loke n tokens ahead of current token without consuming them  </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Lookahead</span>(<span class="org-variable-name">n</span>: <span class="org-type">int</span>): <span class="org-type">Token</span> = 
        <span class="org-keyword">if</span> pos + n &gt; tokens.Length
        <span class="org-keyword">then</span> current
        <span class="org-keyword">else</span> tokens[pos + n - 1]

    <span class="org-comment-delimiter">/// </span><span class="org-comment">If the current token is the same as the argument, consume it and return true.</span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Match</span>(<span class="org-variable-name">kind</span>: <span class="org-type">TokenKind</span>) = 
        <span class="org-keyword">if</span> kind = this.Peek().Kind
        <span class="org-keyword">then</span> 
            this.Advance() 
            <span class="org-keyword">true</span> 
        <span class="org-keyword">else</span> 
            <span class="org-keyword">false</span> 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Return true if the current token is the same as the argument </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Check</span>(<span class="org-variable-name">kind</span>: <span class="org-type">TokenKind</span>) = 
        kind = this.Peek().Kind 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Return true if current token can be a binary operator </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsBinaryOperator</span>() = 
        <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = this.Lexeme()
        <span class="org-keyword">let</span> result= List.exists (<span class="org-keyword">fun</span> <span class="org-variable-name">x</span> -&gt; lexeme = x.Lexeme &amp;&amp; x.Arity = ArityBinary ) operators
        result 

    <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if current token can be a unary operator  </span>
    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">IsUnaryOperator</span>() = 
        <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = this.Lexeme()
        <span class="org-keyword">let</span>  <span class="org-variable-name">result</span> = List.exists (<span class="org-keyword">fun</span> <span class="org-variable-name">x</span> -&gt; lexeme = x.Lexeme &amp;&amp; x.Arity = ArityUnary ) operators
        result  


    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Operator</span>(<span class="org-variable-name">operator</span>: <span class="org-type">string</span>, <span class="org-variable-name">arity</span>: <span class="org-type">Arity</span>) = 
        <span class="org-keyword">let</span>  <span class="org-variable-name">op</span> = List.tryFind (<span class="org-keyword">fun</span> <span class="org-variable-name">x</span> -&gt; operator = x.Lexeme &amp;&amp; x.Arity = arity ) operators
        <span class="org-keyword">if</span> op.IsNone <span class="org-keyword">then</span> failwith &lt;| sprintf <span class="org-string">"Invalid or unregistered operator %s"</span> operator
        <span class="org-keyword">else</span> op.Value

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Operator</span>(<span class="org-variable-name">arity</span>: <span class="org-type">Arity</span>) = 
        <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = this.Lexeme()
        <span class="org-keyword">let</span>  <span class="org-variable-name">op</span> = List.tryFind (<span class="org-keyword">fun</span> <span class="org-variable-name">x</span> -&gt; lexeme = x.Lexeme &amp;&amp; x.Arity = arity ) operators
        <span class="org-keyword">if</span> op.IsNone <span class="org-keyword">then</span> failwith &lt;| sprintf <span class="org-string">"Operator not found %s"</span> lexeme 
        <span class="org-keyword">else</span> op.Value

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Expect</span>(<span class="org-variable-name">kind</span>: <span class="org-type">TokenKind</span>) = 
        <span class="org-keyword">if</span> this.Peek().Kind = kind 
        <span class="org-keyword">then</span>  this.Advance()
        <span class="org-keyword">else</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">t</span> = this.Peek().Kind
            <span class="org-keyword">let</span> <span class="org-variable-name">lexeme</span> = this.Lexeme()
            <span class="org-keyword">let</span> <span class="org-variable-name">loc</span> = this.Location()
            <span class="org-keyword">let</span> <span class="org-variable-name">s</span> = sprintf <span class="org-string">"Token(%A, %s)"</span> t lexeme
            failwith &lt;| sprintf <span class="org-string">"Expected token of type %A at line %d and column %d, but given %s"</span> 
                                 kind loc.Start.Column  loc.Start.Line s


    <span class="org-comment-delimiter">/// </span><span class="org-comment">Parse an expression with binary operator     </span>
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">ParseBinary</span>(<span class="org-variable-name">precedence</span>: <span class="org-type">int</span>): <span class="org-type">ast</span> = 
        <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">lhs</span>: <span class="org-type">ast</span> = this.ParsePrimary()
        <span class="org-comment-delimiter">// </span><span class="org-comment">printfn " [TRACE] ParseBinary() token = %A ; lhs = %A " (this.Lexeme()) lhs</span>
        <span class="org-keyword">while</span> this.IsBinaryOperator() &amp;&amp; this.Operator(ArityBinary).Precedence &gt;= precedence <span class="org-keyword">do</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Get current operator </span>
            <span class="org-keyword">let</span> <span class="org-variable-name">tok</span> = this.Peek()
            <span class="org-keyword">let</span> <span class="org-variable-name">op</span> = this.Operator(ArityBinary)
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn " [TRACE] Enter while loop () =&gt; op = %A " op</span>
            this.Advance()
            <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">prec</span> = 0 
            <span class="org-keyword">if</span> op.Assoc = AssocRight <span class="org-keyword">then</span> prec &lt;- op.Precedence
            <span class="org-keyword">if</span> op.Assoc = AssocLeft  <span class="org-keyword">then</span> prec &lt;- 1 + op.Precedence
            <span class="org-keyword">let</span> <span class="org-variable-name">rhs</span> = this.ParseBinary(prec)
            <span class="org-keyword">let</span> <span class="org-variable-name">loc</span> = mergeLocation (lhs.Location())  (rhs.Location())
            lhs &lt;- AstBinop(loc, tok.Lexeme, lhs, rhs)
        lhs 

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Parse primary expression: Unary operator expression, expression between parenthesis </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">literal expressions (numbers, strings, boolean, null), function call</span>
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">ParsePrimary</span>(): <span class="org-type">ast</span> = 
        <span class="org-keyword">let</span> <span class="org-variable-name">tok</span> = this.Peek()
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span> = tok.Location
        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse expression with unary operator </span>
        <span class="org-keyword">if</span> this.IsUnaryOperator() <span class="org-keyword">then</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">op</span>: <span class="org-type">Operator</span> = this.Operator(ArityUnary)
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn "\n [TRACE] &lt;A&gt; Before =&gt; Unary operator expr = %A " &lt;| this.Peek()</span>
            this.Advance()
            <span class="org-keyword">let</span> <span class="org-variable-name">rhs</span> = this.ParseBinary(op.Precedence)
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = AstUnop( mergeLocation tok.Location (rhs.Location()), tok.Lexeme, rhs)
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn "\n [TRACE] &lt;A&gt; After =&gt; Unary operator expr = %A " &lt;| this.Peek()</span>
            expr
        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse  expression between parenthesis</span>
        <span class="org-keyword">elif</span> this.Check TokenKind.TLpar <span class="org-keyword">then</span>  
            this.Advance()
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = this.ParseBinary 0 
            this.Expect TokenKind.TRpar
            expr 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse integer </span>
        <span class="org-keyword">elif</span> this.Check TokenKind.TInt <span class="org-keyword">then</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">num</span> = int tok.Lexeme
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn "\n [TRACE] Before =&gt; Unary operator expr = %A " &lt;| this.Lexeme()</span>
            this.Advance()
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = AstInt(loc, num)
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn "\n [TRACE] After =&gt; Unary operator expr = %A " &lt;| this.Lexeme()</span>
            expr 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse floating point number </span>
        <span class="org-keyword">elif</span> this.Check TokenKind.TFlt <span class="org-keyword">then</span>     
            <span class="org-keyword">let</span> <span class="org-variable-name">num</span> = float tok.Lexeme
            this.Advance()
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = AstFlt(loc, num)
            expr 
        <span class="org-comment-delimiter">// </span><span class="org-comment">Parse identifier or function call</span>
        <span class="org-keyword">elif</span> this.Check TokenKind.TIden <span class="org-keyword">then</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = <span class="org-keyword">if</span> this.Lookahead(1).Kind &lt;&gt; TLpar 
                         <span class="org-keyword">then</span> 
                            <span class="org-comment-delimiter">// </span><span class="org-comment">parse variable </span>
                            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = AstVar(loc, tok.Lexeme)
                            this.Advance()
                            expr 
                         <span class="org-keyword">else</span> 
                          <span class="org-comment-delimiter">// </span><span class="org-comment">Parse function call</span>
                          this.ParseCall()
            result 
        <span class="org-keyword">else</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = List.tryFind (<span class="org-keyword">fun</span> (<span class="org-variable-name">pred</span>, <span class="org-variable-name">_</span>) -&gt; pred()  ) primaryExprList
            <span class="org-keyword">match</span> p <span class="org-keyword">with</span> 
            | None -&gt; failwith &lt;| sprintf <span class="org-string">"Error: invalid token %A"</span>  tok
            | Some (pred, parser) 
                -&gt;  <span class="org-keyword">let</span> result = parser()
                    result

    <span class="org-comment-delimiter">/// </span><span class="org-comment">Parse function call with the following EBNF schema  </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">call: IDENTIFIER "(" expr ("," expr)* ")"</span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">call: IDENTIFIER LPAR expr (COMMA expr)* RPAR </span>
    <span class="org-comment-delimiter">/// </span>
    <span class="org-comment-delimiter">/// </span><span class="org-comment">So this function parses func(), func(arg0), func(arg0, arg1, ..., argN-1)</span>
    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">ParseCall</span>(): <span class="org-type">ast</span> = 
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span> = this.Location()
        <span class="org-keyword">let</span> <span class="org-variable-name">func</span> = this.Lexeme()
        this.Advance()
        this.Expect(TLpar)
        <span class="org-keyword">if</span> this.Match TRpar <span class="org-keyword">then</span> 
            printfn <span class="org-string">" [TRACE] Call functiion with no arguments."</span>
            <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = AstCall(loc, func, [])
            result 
        <span class="org-keyword">else</span> 
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn " [TRACE] Call function with arguments"</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Parse first function argument </span>
            <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = this.ParseExpr()
            <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">args</span>: <span class="org-type">ast list</span> = [ a ]
            <span class="org-keyword">while</span> this.Match TComm <span class="org-keyword">do</span>  
                <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = self.ParseExpr()
                args &lt;- args @ [a]
            <span class="org-comment-delimiter">// </span><span class="org-comment">printf " [TRACE] args = %A " args</span>
            this.Expect TRpar 
            <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = AstCall(loc, func, args)
            result 


<span class="org-keyword">type</span> <span class="org-type">RecursiveParser</span>(<span class="org-variable-name">input</span>: <span class="org-type">string</span>) <span class="org-keyword">as</span> <span class="org-variable-name">self</span> = 
    <span class="org-keyword">inherit</span> <span class="org-type">ExprParser</span>(<span class="org-variable-name">input</span>)

    <span class="org-keyword">do</span> 
        <span class="org-variable-name">self</span>.<span class="org-variable-name">Initialize</span>()

    <span class="org-keyword">member</span> <span class="org-variable-name">this</span>.<span class="org-function-name">Parse</span>() = 
        this.ParseProgram()

    <span class="org-keyword">member</span> <span class="org-keyword">private</span> <span class="org-variable-name">this</span>.<span class="org-variable-name">ParseProgram</span>() = 
        <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">statements</span>: <span class="org-type">ast list</span> = []
        <span class="org-keyword">let</span> <span class="org-variable-name">startLoc</span> = this.Location()
        <span class="org-keyword">while</span> <span class="org-keyword">not</span> &lt;| this.IsEof() <span class="org-keyword">do</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = <span class="org-keyword">if</span> this.IsComment() 
                       <span class="org-keyword">then</span> this.ParseComment() 
                       <span class="org-keyword">else</span> 
                            <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = this.ParseExpr()
                            this.Expect TSemicolon
                            result     
            <span class="org-comment-delimiter">// </span><span class="org-comment">printfn " [TRACE] (621) expr = %A " expr</span>
            statements &lt;- statements @ [expr]
        <span class="org-keyword">let</span> <span class="org-variable-name">endLoc</span> = this.Location()
        <span class="org-keyword">let</span> <span class="org-variable-name">loc</span> = mergeLocation startLoc endLoc
        <span class="org-keyword">let</span> <span class="org-variable-name">prog</span> = AstProg(loc, statements)
        prog 


<span class="org-comment-delimiter">/// </span><span class="org-comment">Convenient function for encapsulating the parser </span>
<span class="org-keyword">let</span> <span class="org-function-name">parseExpr</span> (<span class="org-variable-name">input</span>: <span class="org-type">string</span>): <span class="org-type">ast</span> = 
    <span class="org-keyword">let</span> <span class="org-variable-name">p</span> = ExprParser input 
    p.Initialize()
    <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = p.ParseExpr()
    expr 

    <span class="org-comment-delimiter">// </span><span class="org-comment">let mutable current = To</span>




<span class="org-comment-delimiter">/// </span><span class="org-comment">Limited Non turing-complete calculator interpreter</span>
<span class="org-keyword">let</span> <span class="org-keyword">rec</span> <span class="org-function-name">eval</span> (<span class="org-variable-name">expr</span>: <span class="org-type">ast</span>): <span class="org-type">float</span> = 
    <span class="org-keyword">match</span> expr <span class="org-keyword">with</span>  
    | AstInt (Val = x) -&gt; float x 
    | AstFlt (Val = x) -&gt; x  
    | AstVar (Val = x) -&gt; failwith <span class="org-string">"Not supported"</span>
    | AstUnop (Opr = opr; Rhs = rhs) -&gt; 
        <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = eval rhs 
        <span class="org-keyword">match</span> opr <span class="org-keyword">with</span> 
        | <span class="org-string">"-"</span>  -&gt;  -e
        | <span class="org-string">"+"</span>  -&gt;  +e
    | AstBinop(Opr = opr; Lhs = lhs; Rhs = rhs) -&gt; 
        <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = eval lhs 
        <span class="org-keyword">let</span> <span class="org-variable-name">b</span> = eval rhs 
        <span class="org-keyword">match</span> opr <span class="org-keyword">with</span> 
        | <span class="org-string">"+"</span>  -&gt; a +  b 
        | <span class="org-string">"-"</span>  -&gt; a -  b 
        | <span class="org-string">"*"</span>  -&gt; a *  b 
        | <span class="org-string">"/"</span>  -&gt; a /  b 
        | <span class="org-string">"^"</span>  -&gt; a ** b 
        |  _ -&gt; failwith <span class="org-string">"Invalid operator"</span>
    | AstCall(Ident = func; Args = args) -&gt; 
        <span class="org-keyword">if</span> args.Length &lt;&gt; 1 
        <span class="org-keyword">then</span> failwith <span class="org-string">"Function with invalid number of arguments"</span> 
        <span class="org-keyword">else</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">e</span> = eval args[0]
            <span class="org-keyword">match</span> func <span class="org-keyword">with</span> 
            | <span class="org-string">"exp"</span>    -&gt; System.Math.Exp(e)
            | <span class="org-string">"log"</span>    -&gt; System.Math.Log(e) 
            | <span class="org-string">"log10"</span> -&gt; System.Math.Log10 e
            | <span class="org-string">"sqrt"</span>  -&gt; System.Math.Sqrt e 
            | <span class="org-string">"sign"</span>      -&gt; System.Math.Sign e
            | _        -&gt; failwith <span class="org-string">"Invalid function"</span>
    | _ -&gt; failwith <span class="org-string">"Not supported"</span>
    

<span class="org-keyword">let</span> <span class="org-function-name">repl</span>() = 
    <span class="org-keyword">let</span> <span class="org-keyword">mutable</span> <span class="org-variable-name">Break</span> = <span class="org-keyword">false</span>
    printfn <span class="org-string">" -------START REPL ----------"</span> 
    <span class="org-keyword">while</span> <span class="org-keyword">not</span> Break <span class="org-keyword">do</span> 
        printf <span class="org-string">" $&gt; "</span>
        <span class="org-keyword">let</span> <span class="org-variable-name">input</span> = System.Console.ReadLine().Trim()
        <span class="org-keyword">if</span> input &lt;&gt; <span class="org-string">""</span> <span class="org-keyword">then</span> 
            <span class="org-keyword">let</span> <span class="org-variable-name">expr</span> = parseExpr input 
            <span class="org-keyword">let</span> <span class="org-variable-name">result</span> = eval expr 
            printfn <span class="org-string">" =&gt; AST = %s "</span> &lt;| expr.ToStr()
            printfn <span class="org-string">" =&gt; result = %f "</span> result
        <span class="org-keyword">else</span> 
            printfn <span class="org-string">""</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-fsharp">$ &gt;&gt; dotnet fsi --use:<span class="org-type">parser.</span>fsx

Microsoft (R) F# Interactive version 12.0.0.0 <span class="org-keyword">for</span> F# 6.0
Copyright (c) Microsoft Corporation. All Rights Reserved.

For help <span class="org-keyword">type</span> <span class="org-keyword">#help</span>;;


&gt;&gt; <span class="org-keyword">let</span> e = parseExpr <span class="org-string">"20 + hypoth(x^2 + 3 * x / z ^ 2, y, z * 2) / k"</span>  ;;

&gt;&gt; e.ToStr() ;;
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">string</span> =
  <span class="org-string">"(+ 20 (/ (CALL hypoth (+ (^ x 2) (/ (* 3 x) (^ z 2))) y (* z 2)) k))"</span>


&gt;&gt; <span class="org-keyword">let</span> e = parseExpr <span class="org-string">"4 + 3 * log(10 + 3 * sqrt(5 * 2 ^ 3 ^ 3 / 100))"</span> ;;

&gt;&gt; e.ToStr() ;;                                                          
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">string</span> =
<span class="org-string">"(+ 4 (* 3 (CALL log (+ 10 (* 3 (CALL sqrt (/ (* 5 (^ 2 (^ 3 3))) 100)))))))"</span>

&gt;&gt; eval e ;;                                                             
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">float</span> = 30.87855699

&gt;&gt; <span class="org-keyword">let</span> e = parseExpr <span class="org-string">"3 * x + 20 * z ^ x ^ 2"</span>  ;;     
<span class="org-keyword">val</span> <span class="org-variable-name">e</span>: <span class="org-type">ast</span> =
  AstBinop
    ({ File = <span class="org-string">""</span>
       Start = { Offset = 0
                 Line = 1
                 Column = 1 }
       End = { Offset = 21
               Line = 1
               Column = 22 } }, <span class="org-string">"+"</span>,
     AstBinop
       ({ File = <span class="org-string">""</span>
          Start = { Offset = 0
                    Line = 1
                    Column = 1 }
          End = { Offset = 4
                  Line = 1
                  Column = 5 } }, <span class="org-string">"*"</span>, AstInt ({ File = <span class="org-string">""</span>
                                                 Start = { Offset = 0
                                                           Line = 1
                                                           Column = 1 }
                                                 End = { Offset = 0
                                                         Line = 1
                                                         Column = 1 } }, 3),
        AstVar ({ File = <span class="org-string">""</span>
                  Start = { Offset = 4
                            Line = 1
                            Column = 5 }
                  End = { Offset = 4
                          Line = 1
                          Column = 5 } }, <span class="org-string">"x"</span>)),
     AstBinop
       ({ File = <span class="org-string">""</span>
          Start = { Offset = 8
                    Line = 1
                    Column = 9 }
          End = { Offset = 21
                  Line = 1
                  Column = 22 } }, <span class="org-string">"*"</span>, AstInt ({ File = <span class="org-string">""</span>
                                                  Start = { Offset = 8
                                                            Line = 1
                                                            Column = 9 }
                                                  End = { Offset = 9
                                                          Line = 1
                                                          Column = 10 } }, 20),
        AstBinop
          ({ File = <span class="org-string">""</span>
             Start = { Offset = 13
                       Line = 1
                       Column = 14 }
             End = { Offset = 21
                     Line = 1
                     Column = 22 } }, <span class="org-string">"^"</span>,
           AstVar ({ File = <span class="org-string">""</span>
                     Start = { Offset = 13
                               Line = 1
                               Column = 14 }
                     End = { Offset = 13
                             Line = 1
                             Column = 14 } }, <span class="org-string">"z"</span>),
           AstBinop
             ({ File = <span class="org-string">""</span>
                Start = { Offset = 17
                          Line = 1
                          Column = 18 }
                End = { Offset = 21
                        Line = 1
                        Column = 22 } }, <span class="org-string">"^"</span>,
              AstVar ({ File = <span class="org-string">""</span>
                        Start = { Offset = 17
                                  Line = 1
                                  Column = 18 }
                        End = { Offset = 17
                                Line = 1
                                Column = 18 } }, <span class="org-string">"x"</span>),
              AstInt ({ File = <span class="org-string">""</span>
                        Start = { Offset = 21
                                  Line = 1
                                  Column = 22 }
                        End = { Offset = 21
                                Line = 1
                                Column = 22 } }, 2)))))



</pre>
</div>

<p>
Test the Recursive descent parser that uses an embedded operator precedence
climbing parser.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-variable-name">s</span> = <span class="org-string">"  </span>
<span class="org-string">         // Comment: compute the value of x </span>
<span class="org-string">         x = 3 * 4 + 5;</span>
<span class="org-string">         // compute the value z </span>
<span class="org-string">         y = 2 * z + x / 10; </span>
<span class="org-string">         // Compute the last dependency z</span>
<span class="org-string">         z = - y + sqrt(- x^2 + y^2 / 5 + 20) * z ^ 2 + log10(x^2 + 3 * x);          </span>
<span class="org-string">        "</span>
<span class="org-keyword">let</span> <span class="org-variable-name">p</span> = RecursiveParser s 
;;


&gt;&gt; p ;;
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">RecursiveParser</span> = FSI_0002+RecursiveParser


<span class="org-comment-delimiter">// </span><span class="org-comment">Get the AST  Abstract Syntax Tree from the sample source code.</span>
&gt;&gt; <span class="org-keyword">let</span> ast = p.Parse() ;;
<span class="org-keyword">val</span> <span class="org-variable-name">ast</span>: <span class="org-type">ast</span> =
  AstProg
    ({ File = <span class="org-string">""</span>
       Start = { Offset = 12
                 Line = 2
                 Column = 10 }
       End = { Offset = 269
               Line = 8
               Column = 7 } },
     [AstComment
        ({ File = <span class="org-string">""</span>
           Start = { Offset = 12
                     Line = 2
                     Column = 10 }
           End = { Offset = 46
                   Line = 3
                   Column = -1 } }, <span class="org-string">" Comment: compute the value of x "</span>);
      AstBinop
        ({ File = <span class="org-string">""</span>
           Start = { Offset = 57
                     Line = 3
                     Column = 10 }
           End = { Offset = 69
       ... ... ... ... ... .. 
       ... ... ... ... ... .. 
       ... ... ... ... ... .. 


&gt;&gt; ast.Location() ;;
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">Location</span> = { File = <span class="org-string">""</span>
                     Start = { Offset = 12
                               Line = 2
                               Column = 10 }
                     End = { Offset = 269
                             Line = 8
                             Column = 7 } }


<span class="org-comment-delimiter">// </span><span class="org-comment">View the AST in a more terse/concise way by using Lisp or S-Expression notation </span>
&gt;&gt; ast.ToStr() ;;
<span class="org-keyword">val</span> <span class="org-variable-name">it</span>: <span class="org-type">string</span> =
  <span class="org-string">"(Program </span>
<span class="org-string">  (comment "</span> Comment: compute the value <span class="org-keyword">of</span> x <span class="org-string">")</span>
<span class="org-string">  (= x (+ (* 3 4) 5))</span>
<span class="org-string">  (comment "</span> compute the value z <span class="org-string">")</span>
<span class="org-string">  (= y (+ (* 2 z) (/ x 10)))</span>
<span class="org-string">  (comment "</span> Compute the last dependency z<span class="org-string">")</span>
<span class="org-string">  (= z (+ (+ (- y) (* (CALL sqrt (+ (+ (^ (- x) 2) (/ (^ y 2) 5)) 20)) (^ z 2))) (CALL log10 (+ (^ x 2) (* 3 x)))))</span>
<span class="org-string">)"</span>



</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2023-08-09 Wed 18:23</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
