#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ - Libraries Bookmarks 
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

* Libraries 
** Boost Libraries 
*** Math 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/index.html][Math Toolkit 2.8.0 - 1.69.0]]
  + Brief: The math toolkit provides the following facilities:
    + Floating Point Utilities
    + Specific Width Floating Point Types
    + *Statistical Distributions* (Gaussian, Poisson, Bernouli...)
    + Mathematical Special Function
    + Root Finding and Function
    + Minimisations, Polynomials and Rational Functions
    + Interpolation
    + Numerical Integration and Differentiation
    + Quaternions and Octonions.   
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/special.html][Chapter 6. Special Functions - 1.69.0]]
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/][uBLAS]] (Linear algebra facilities, linear systems, vector matrices
  and so on.)
  + Brief: "uBLAS provides matrix and vector classes as well as basic
    linear algebra routines. Several dense, packed and sparse storage
    schemes are supported."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/getting_started/overview.html][Boost Odeint]]
  + Library for ordinary differential equations - initial value
    problems.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time.html][Date Time]]
  + Brief: "A set of date-time libraries based on generic programming concepts."
  + Descr: "The motivation for this library comes from working with
    and helping build several date-time libraries on several
    projects. Date-time libraries provide fundamental infrastructure
    for most development projects. However, most of them have
    limitations in their ability to calculate, format, convert, or
    perform some other functionality. For example, most libraries do
    not correctly handle leap seconds, provide concepts such as
    infinity, or provide the ability to use high resolution or
    network time sources. These libraries also tend to be rigid in
    their representation of dates and times. Thus customized policies
    for a project or subproject are not possible."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/chrono.html][Chapter 7. Boost.Chrono 2.0.8 - 1.69.0]] (Time interval computation,
  already in C++11, but it is a good documentation for the STL
  library.) 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/accumulators.html][Accumulators]]
  + Summary: Incremental statistics.
  + Descr: "Boost.Accumulators is both a library for incremental statistical
    computation as well as an extensible framework for incremental
    calculation in general. The library deals primarily with the
    concept of an accumulator, which is a primitive computational
    entity that accepts data one sample at a time and maintains some
    internal state. These accumulators may offload some of their
    computations on other accumulators, on which they
    depend. Accumulators are grouped within an accumulator
    set. Boost.Accumulators resolves the inter-dependencies between
    accumulators in a set and ensures that accumulators are processed
    in the proper order."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html][Boost Multiprecisions]]
  + Brief: "The Multiprecision Library provides integer, rational,
    floating-point, and complex types in C++ that have more range and
    precision than C++'s ordinary built-in types. The big number
    types in Multiprecision can be used with a wide selection of
    basic mathematical operations, elementary transcendental
    functions as well as the functions in Boost.Math. The
    Multiprecision types can also interoperate with the built-in
    types in C++ using clearly defined conversion rules. This allows
    Boost.Multiprecision to be used for all kinds of mathematical
    calculations involving integer, rational and floating-point types
    requiring extended range and precision."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/units/][Units]]
  + Brief: "Zero-overhead dimensional analysis and unit/quantity
    manipulation and conversion."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/user.html][The Boost Multidimensional Array Library (Boost.MultiArray) - 1.69.0]]
  + Brief: Multidimensional arrays, aka tensors. 

*** Parallel Computing 

 + [[https://www.boost.org/doc/libs/1_69_0/doc/html/mpi.html][Chapter 26. Boost.MPI - 1.69.0]]
   + Brief: "Boost.MPI is a library for message passing in high-performance
     parallel applications. A Boost.MPI program is one or more
     processes that can communicate either via sending and receiving
     individual messages (point-to-point communication) or by
     coordinating as a group (collective communication). Unlike
     communication in threaded environments or using a shared-memory
     library, Boost.MPI processes can be spread across many different
     machines, possibly with different operating systems and
     underlying architectures."

 + [[https://www.boost.org/doc/libs/1_69_0/libs/compute/doc/html/index.html][Chapter 1. Boost.Compute - 1.69.0]]
   + Brief: "The Boost Compute library provides a C++ interface to
     multi-core CPU and GPGPU computing platforms based on OpenCL." 
 
*** String Utilities 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html][Chapter 21. Boost.Lexical_Cast 1.0 - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/format/][The Boost Format library - 1.69.0]]
  + The format library provides a class for formatting arguments
    according to a format-string, as does printf, but with two major
    differences : format sends the arguments to an internal stream,
    and so is entirely type-safe and naturally supports all
    user-defined types. The ellipsis (...) can not be used correctly
    in the strongly typed context of format, and thus the function
    call with arbitrary arguments is replaced by successive calls to
    an argument feeding operator%

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo.html][String algo]]
  + Brief: "The String Algorithm Library provides a generic
    implementation of string-related algorithms which are missing in
    STL. It is an extension to the algorithms library of STL and it
    includes trimming, case conversion, predicates and find/replace
    functions. All of them come in different variants so it is easier
    to choose the best fit for a particular need." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]]
  + Brief: Framework for building parsers.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/tokenizer/][Tokenizer]]
  + Brief: "Break of a string or other character sequence into a
    series of tokens."

*** Template Metaprogramming facilities 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/utility/operators.htm][Boost Operators]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/range/][Range]] [BEST]
  + Descr: "A new infrastructure for generic algorithms that builds
    on top of the new iterator concepts."
  + Note: Maybe the future replacement for C++ classical iterators.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hof/doc/html/doc/src/index.html][Boost.HigherOrderFunctions]] (aka Boost.Hof)
  + Brief: Provides many higher order functions. 
  + Descr: HigherOrderFunctions is a header-only C++11/C++14 library that
    provides utilities for functions and function objects, which can
    solve many problems with much simpler constructs than whats
    traditionally been done with metaprogramming.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/mp11/doc/html/mp11.html][Boost.Mp11: A C++11 metaprogramming library - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/fusion/doc/html/fusion/preface.html][Boost Fusion]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hana/doc/html/index.html][Boost.Hana]]
  + Brief: "Hana is a header-only library for C++ metaprogramming
    suited for computations on both types and values."
  + Descr: "The functionality it provides is a superset of what is
    provided by the well established Boost.MPL and Boost.Fusion
    libraries. By leveraging C++11/14 implementation techniques and
    idioms, Hana boasts faster compilation times and runtime
    performance on par or better than previous metaprogramming
    libraries, while noticeably increasing the level of
    expressiveness in the process. Hana is easy to extend in a ad-hoc
    manner and it provides out-of-the-box inter-operation with
    Boost.Fusion, Boost.MPL and the standard library." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/concept_check/][Concept check]]
  + Descr: "Tools for generic programming."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/proto/][Proto]]
  + Brief: "Expression template library and compiler construction
    toolkit for domain-specific embedded languages."

*** Design Patterns and Object Oriented Design Patterns 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_typeerasure.html][Chapter 40. Boost.TypeErasure - 1.69.0]]
  + Brief: "The Boost.TypeErasure library provides runtime
    polymorphism in C++ that is more flexible than that provided by
    the core language. The Boost.TypeErasure library combines the
    superior abstraction capabilities of templates, with the runtime
    flexibility of virtual functions."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/ptr_container.html][Boost Pointer Container Library - 1.69.0]]
  + Brief: "Boost.Pointer Container provides containers for holding
    heap-allocated objects in an exception-safe manner and with
    minimal overhead. The aim of the library is in particular to make
    OO programming easier in C++ by establishing a standard set of
    classes, methods and designs for dealing with OO specific
    problems." 

+ [[https://www.boost.org/doc/libs/release/libs/flyweight/][Boost Flyweight]]
  + Brief: Descr: "Design pattern to manage large quantities of
    highly redundant objects."

  + Descr: "Flyweights are small-sized handle classes granting
    constant access to shared common data, thus allowing for the
    management of large amounts of entities within reasonable memory
    limits. Boost.Flyweight makes it easy to use this common
    programming idiom by providing the class template flyweight<T>,
    which acts as a drop-in replacement for const T."

  + Additional notes:
    + "Learning to use Boost.Flyweight can be accomplished in a matter
      of minutes. When special needs arise, however, an extensive
      customization interface is provided which allows the user to
      control and extend the following aspects:"
    + Type tagging for separation of domains using the same basic flyweight types.
    + Specification and parameterization of the so-called flyweight factory.
    + Control of the factory instantiation procedure.
    + Specification of the internal synchronization mechanisms.
    + Flyweight tracking, allowing for the disposal of stored values
      when no longer referenced by any flyweight object.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/property_tree.html][Chapter 32. Boost.PropertyTree - 1.69.0]]
  + "The Property Tree library provides a data structure that stores
    an arbitrarily deeply nested tree of values, indexed at each
    level by some key. Each node of the tree stores its own value,
    plus an ordered list of its subnodes and their keys. The tree
    allows easy access to any of its nodes by means of a path, which
    is a concatenation of multiple keys." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/functional/factory/doc/html/index.html][Boost.Functional/Factory]]
  + Brief: "The template boost::factory lets you encapsulate a new
    expression as a function object, boost::value_factory
    encapsulates a constructor invocation without new."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/property_map/doc/property_map.html][Property Map Library - 1.69.0]]

*** Command Line Options 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/program_options.html][Chapter 31. Boost.Program_options - 1.69.0]]

*** Debugging, Logging and Assertions 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/log/doc/html/index.html][Chapter 1. Boost.Log v2 - 1.69.0]]
  + Descr: "The application stores all essential information about its
    execution to a log, and when something goes wrong this
    information can be used to analyze the program behavior and make
    the necessary corrections. There are other very useful
    applications of logging, such as gathering statistical
    information and highlighting events (i.e. indicating that some
    situation has occurred or that the application is experiencing
    some problems). These tasks have proved to be vital for many
    real-world industrial applications. This library aims to make
    logging significantly easier for the application developer. It
    provides a wide range of out-of-the-box tools along with public
    interfaces for extending the library. The main goals of the
    library are:"
    + Simplicity. A small example code snippet should be enough to
      get the feel of the library and be ready to use its basic
      features.
    + Extensibility. A user should be able to extend functionality of
      the library for collecting and storing information into logs.
    + Performance. The library should have as little performance
      impact on the user's application as possible.

*** Network - Sockets - TCP/IP

+ [[https://www.boost.org/doc/libs/1_69_0/libs/asio/][Boost Asio]]
  + Descr: "Portable networking and other low-level I/O, including sockets,
    timers, hostname resolution, socket iostreams, serial ports, file
    descriptors and Windows HANDLEs."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/crc.html][Boost CRC]] - CRC (Cyclick Redundancy Checking)
  + Descr: " CRCs (cyclic redundancy codes) is one common technique
    to confirming data integrity after transmission. The Boost.CRC
    library provides access to two styles of CRC computation, one as
    a function template, the other as a function template and two
    computation object class templates, where the two class templates
    differ in speed."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/statechart/][Statechart]]
  + Brief: "Boost.Statechart - Arbitrarily complex finite state
    machines can be implemented in easily readable and maintainable
    C++ code."
  + Note: Many network protocols, embedded systems applications and
    business processes are well described by state machines such as
     [[https://en.wikipedia.org/wiki/Mealy_machine][Mealy state machine]] or [[https://en.wikipedia.org/wiki/Moore_machine][Moore State machine]].

+ [[https://www.boost.org/doc/libs/1_69_0/libs/uuid/][UUID]] - A universally unique identifier.

*** Shared Libraries and Plugins - DLL, DSO, SO

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_dll.html][Boost DLL]]
  + Brief: "This library was designed to simplify plugin development using C++ in a portable cross-platform manner."
  + Descr: "Adding a specific features to an existing software
    applications at runtime could be useful in many cases. Such
    extensions, or plugins, are usually implemented using Dynamic
    Library Modules (DLL,SO/DSO) loaded at runtime."
  + Library provides a portable across platforms way to:
    + load libraries
    + import any native functions and variables
    + make alias names for C++ mangled functions and symbols
    + query libraries for sections and exported symbols
    + self loading and self querying
    + getting program and module location by exported symbol

*** Subprocess and inter process communication - IPC 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]]
  + Brief: "Boost.Interprocess simplifies the use of common
    interprocess communication and synchronization mechanisms and
    offers a wide range of them:"
    + Shared memory.
    + Memory-mapped files.
    + Semaphores, mutexes, condition variables and upgradable mutex
      types to place them in shared memory and memory mapped files.
    + Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.
    + File locking.
    + Relative pointers.
    + Message queues.
  + Additional:
    + Boost.Interprocess also offers higher-level interprocess
      mechanisms to allocate dynamically portions of a shared memory
      or a memory mapped file (in general, to allocate portions of a
      fixed size memory segment). Using these mechanisms,
      Boost.Interprocess offers useful tools to construct C++
      objects, including STL-like containers, in shared memory and
      memory mapped files:

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/process.html#boost_process.introduction][Boost.Process]]
  + Brief: "Boost.Process is a library to manage system processes. It
    can be used to:"
    + create child processes
    + setup streams for child processes
    + communicate with child processes through streams (synchronously
      or asynchronously)
    + wait for processes to exit (synchronously or asynchronously)
    + terminate processes

*** Low level and byte manipulation 

  + [[https://www.boost.org/doc/libs/1_69_0/libs/endian/doc/index.html][Endian Library - 1.69.0]]

** General Purpose Libraries                                        :general:

   + [[http://www.boost.org/][Boost libraries]] - Peer reviewed libraries that can be regarded as
     STL extensions. Many of them eventually get into the C++ standard,
     for instance, C++17 std::file_system comes from Boost.FileSystem,
     std::variant from C++17 comes from Boost.Variant.

   + [[http://stxxl.org/][STLXX]] - Standard Template Library for Extra Large Data Sets
     + "The core of STXXL is an implementation of the C++ standard
       template library STL for external memory (out-of-core)
       computations, i. e., STXXL implements containers and algorithms
       that can process huge volumes of data that only fit on
       disks. While the closeness to the STL supports ease of use and
       compatibility with existing applications, another design priority
       is high performance."

   + [[http://www.stlsoft.org/][STLSOFT]] - "Robust, Lightweight, Cross-platform, Template
     Software. STLSoft is a collection of STL and standard library
     extensions, and facades over operating-system and 3rd-party APIs."

   + [[https://github.com/electronicarts/eastl][EASTL]] - "EASTL stands for Electronic Arts Standard Template
     Library. It is a C++ template library of containers, algorithms,
     and iterators useful for runtime and tool development across
     multiple platforms. It is a fairly extensive and robust
     implementation of such a library and has an emphasis on high
     performance above all other considerations." 

   + [[https://abseil.io/][Abseil]] (Google) - "Allows using new C++ standard features from
     C++14 and C++17 with compilers that does not support those standards".

   + [[http://pocoproject.org/][Poco Framework]]

   + [[https://github.com/bloomberg/bde][Bloomberg BDE]] - Basic Development Environment - a set of
     foundational C++ libraries used at Bloomberg.

   + [[https://github.com/facebook/folly][Folly]] - "Folly (acronymed loosely after Facebook Open Source
     Library) is a library of C++14 components designed with
     practicality and efficiency in mind. Folly contains a variety of
     core library components used extensively at Facebook. In
     particular, it's often a dependency of Facebook's other open source
     C++ efforts and place where those projects can share code."

   + [[https://fcppt.org/][FCppt]] - Freundlich's C++ toolkit - "Freundlich's C++ Toolkit
     (fcppt) is a collection of libraries that aim to improve general
     C++ code through better typing and functional programming."

   + [[http://duneroadrunner.github.io/SaferCPlusPlus/][SaferCPlusPlus]] - "SaferCPlusPlus” is essentially a collection of
     safe data types intended to facilitate memory and data race safe
     C++ programming. This library is intended to work with and be
     complimentary to the Core Guidelines lifetime checker over its
     various stages of development and availability. (Including
     situations where the lifetime checker is not available at all.)"

** General Utility Libraries 

    + [[https://github.com/p-ranav/pprint][p-ranav/pprint]] - Pretty print library that can print many
      containers in a nince-way. Features: Single header, MIT License,
      Requires C++17.

    + [[https://github.com/HowardHinnant/date][HowardHinnant/date]] - "A date and time library based on the
      C++11/14/17 <chrono> header" 

    + [[https://github.com/mandreyel/mio][mandreyel/mio]] - "An easy to use header-only cross-platform C++11
      memory mapping library with an MIT license. mio has been created
      with the goal to be easily includable (i.e. no dependencies) in any
      C++ project that needs memory mapped file IO without the need to
      pull in Boost."

    + [[https://github.com/mobius3/asap][mobius3/asap]] - "A C++ header-only library for creating, displaying,
      iterating and manipulating dates." 

    + [[https://github.com/tplgy/cppcodec][CppCodec]] - "Header-only C++11 library to encode/decode base64,
      base64url, base32, base32hex and hex (a.k.a. base16) as specified in
      RFC 4648, plus Crockford's base32. MIT licensed with consistent,
      flexible API. Supports raw pointers, std::string and (templated)
      character vectors without unnecessary allocations. Cross-platform
      with measured decent performance and without compiler warnings."

    + [[https://github.com/ReactiveX/RxCpp][RxCpp]] - "The Reactive Extensions for C++ (RxCpp) is a library of
      algorithms for values-distributed-in-time. The Range-v3 library
      does the same for values-distributed-in-space."

    + [[https://github.com/solodon4/Mach7][Mach7]] - "Functional programming style pattern-matching library for
      C++ - by Yuriy Solodkyy, Gabriel Dos Reis, Bjarne Stroustrup"

    + [[https://github.com/jll63/yomm2][yomm2]] - "Fast, orthogonal, open multi-methods. Supersedes yomm11."

    + [[https://github.com/mpark/patterns][mpark/patterns]] - "MPark.Patterns is an experimental pattern
      matching library for C++17. It determines whether a given value
      matches a pattern and, if it does, binds the desired portions of
      the value to a handler. Pattern matching has been introduced to
      many programming languages outside of the functional world, and
      this library draws inspiration from languages such as Haskell,
      OCaml, Rust, Scala, and Swift."

    + [[https://github.com/beark/ftl][beark/ftl]] - "C++ template library for fans of functional programming."
      + Some functionality: Curried Function Calling; Expanding The
        Standard Library; Sum/Union Types With Pattern Matching; Applying
        Applicatives; Transformers.

    + [[https://github.com/pfultz2/linq][pfultz2/linq]] - "Linq for list comprehension in C++, provides an
      implementation of linq for C++. Currently it only supports C++
      ranges, but it does support both the extension and query methods
      for linq."

    + [[https://adplug.github.io/libbinio/][libbinio]]  - "The binary I/O stream class library presents a
      platform-independent way to access binary data streams in
      C++. The library is hardware independent in the form that it
      transparently converts between the different forms of
      machine-internal binary data representation. It further employs
      no special I/O protocol and can be used on arbitrary binary data
      sources."
      + https://github.com/adplug/libbinio

    + [[https://plflib.org/colony.htm][PFL::Colony]] - "plf::colony is the highest-performance C++
      template-based data container for high-modification scenarios with
      unordered data. All elements within a colony have a stable memory
      location, meaning that pointers/iterators to non-erased elements
      are valid regardless of insertions/erasures to the
      container. Specifically the container provides better performance
      than other std:: library containers when: Insertion order is
      unimportant;  Insertions and erasures to the container are
      occurring frequently in realtime ie. in performance-critical code;
      and/or Insertions and erasures to the container may not invalidate
      pointers/iterators to non-erased elements."

    + [[https://github.com/bombela/backward-cpp][backward-cpp]] - "Backward is a header only library. So installing
      Backward is easy, simply drop a copy of backward.hpp along with
      your other source files in your C++ project. You can also use a git
      submodule or really any other way that best fits your environment,
      as long as you can include backward.hpp."

** Template Metaprogramming Helpers 

+ [[https://www.boost.org/doc/libs/1_63_0/libs/mpl/doc/index.html][Boost MPL]] - "The Boost.MPL library is a general-purpose, high-level
  C++ template metaprogramming framework of compile-time algorithms,
  sequences and metafunctions. It provides a conceptual foundation
  and an extensive set of powerful and coherent tools that make doing
  explict metaprogramming in C++ as easy and enjoyable as possible
  within the current language."

+ [[https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html][Boost Hana]] - "Hana is a header-only library for C++
  metaprogramming suited for computations on both types and
  values. The functionality it provides is a superset of what is
  provided by the well established Boost.MPL and Boost.Fusion
  libraries. By leveraging C++11/14 implementation techniques and
  idioms, Hana boasts faster compilation times and runtime
  performance on par or better than previous metaprogramming
  libraries, while noticeably increasing the level of expressiveness
  in the process. Hana is easy to extend in a ad-hoc manner and it
  provides out-of-the-box inter-operation with Boost.Fusion,
  Boost.MPL and the standard library." 

+ [[https://github.com/edouarda/brigand][Brigand]] - Brigand Meta-programming library (Lightweight alternative
  to Boost MPL) - "Brigand is a light-weight, fully functional,
  instant-compile time C++ 11 meta-programming library. Everything
  you were doing with Boost.MPL can be done with Brigand. And if
  that's not the case, open an issue!""

+ [[http://loki-lib.sourceforge.net/][Loki]] - Template library developed by Andrei Alexandrescu
  illustrating several generic programming design patterns.

+ [[https://github.com/Microsoft/GSL][GSL - Guidelines SUpport Library]] - "The Guidelines Support Library
  (GSL) contains functions and types that are suggested for use by
  the C++ Core Guidelines maintained by the Standard C++
  Foundation. This repo contains Microsoft's implementation of GSL." 

** Unit Testing Frameworks 

+ *Googletest* - Google Testing and Mocking Framework [MOST USED]
  + https://github.com/google/googletest


+ *Catch2* - A modern, C++-native, header-only, test framework for
  unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or
  C++03 on the Catch1.x branch)
  + https://github.com/catchorg/Catch2

+ *Doctest* - "doctest is a new C++ testing framework but is by far the
  fastest both in compile times (by orders of magnitude) and runtime
  compared to other feature-rich alternatives. It brings the ability
  of compiled languages such as D / Rust / Nim to have tests written
  directly in the production code by providing a fast, transparent
  and flexible test runner with a clean interface." 
  + https://github.com/onqtam/doctest

+ *CppUTest* - "CppUTest unit testing and mocking framework for C/C++ -
  CppUTest is a C /C++ based unit xUnit test framework for unit
  testing and for test-driving your code. It is written in C++ but is
  used in C and C++ projects and frequently used in *embedded systems*
  but it works for any C/C++ project."
  + http://cpputest.github.com
  + https://github.com/cpputest/cpputest

Other Libraries:

 + [[http://www.boost.org/doc/libs/1_38_0/libs/test/doc/html/index.html][Boost.Test]]

 + [[http://unittest-cpp.sourceforge.net/][UnitTest++]]

Mock: 

 + [[https://github.com/rollbear/trompeloeil][trompeloeil]] - "A thread-safe header-only mocking framework for
   C++11/14 using the Boost Software License 1.0" 

 + [[https://app.assembla.com/wiki/show/hippomocks][Hippo Mocks]]

 + [[http://turtle.sourceforge.net/][Boost Turtle]] -  A C++ mock object library for Boost.

 + [[https://github.com/google/googlemock][GoogleMock]] (Deprecated -> Absorbed into Google Test)

** Performance and Benchmark 

  + [[https://github.com/google/benchmark][Google Benchmark]] -  A microbenchmark support library
    + A library to benchmark code snippets, similar to unit tests. 

  + [[https://github.com/DigitalInBlue/Celero][Celero]] - C++ Benchmark Authoring Library/Framework
    + "Developing consistent and meaningful benchmark results for code
      is a complicated task. Measurement tools exist (Intel® VTune™
      Amplifier, SmartBear AQTime, Valgrind, etc.) external to
      applications, but they are sometimes expensive for small teams
      or cumbersome to utilize. This project, Celero, aims to be a
      small library which can be added to a C++ project and perform
      benchmarks on code in a way which is easy to reproduce, share,
      and compare among individual runs, developers, or
      projects. Celero uses a framework similar to that of GoogleTest
      to make its API more natural to use and integrate into a
      project. Make automated benchmarking as much a part of your
      development process as automated testing."

  + [[https://github.com/libnonius/nonius][nonius]] - A C++ micro-benchmarking framework
    + "Nonius is an open-source framework for benchmarking small
      snippets of C++ code. It is very heavily inspired by Criterion,
      a similar Haskell-based tool. It runs your code, measures the
      time it takes to run, and then performs some statistical
      analysis on those measurements. The library is header-only so
      you don’t have to build it. It comes as a single header that you
      can drop somewhere and #include it in your code. Grab that
      header from the releases page"

  + [[https://github.com/nickbruun/hayai][hayai]] - C++ benchmarking framework 
    + "hayai is a C++ framework for writing benchmarks for pieces of
      code along the lines of the normal approach for unit testing
      using frameworks such as googletest. For information on the
      origin of and how to use hayai, please read the introductory
      blog post until I have the time to write a proper README." 

  + [[https://github.com/opcm/pcm][Intel / PCM]] - Processor Counter Monitor (PCM)
    + "Processor Counter Monitor (PCM) is an application programming
      interface (API) and a set of tools based on the API to monitor
      performance and energy metrics of Intel® Core™, Xeon®, Atom™ and
      Xeon Phi™ processors. PCM works on Linux, Windows, Mac OS X,
      FreeBSD and DragonFlyBSD operating systems."
    + PCM provides a number of command-line utilities for real-time monitoring:
      + pcm : basic processor monitoring utility (instructions per
        cycle, core frequency (including Intel(r) Turbo Boost
        Technology), memory and Intel(r) Quick Path Interconnect
        bandwidth, local and remote memory bandwidth, cache misses,
        core and CPU package sleep C-state residency, core and CPU
        package thermal headroom, cache utilization, CPU and memory
        energy consumption)
      + pcm-memory : monitor memory bandwidth (per-channel and per-DRAM DIMM rank)
      + pcm-latency : monitor L1 cache miss and DDR/PMM memory latency
      + pcm-pcie : monitor PCIe bandwidth per-socket
      + pcm-iio : monitor PCIe bandwidth per PCIe device
      + pcm-numa : monitor local and remote memory accesses
      + pcm-power : monitor sleep and energy states of processor,
        Intel(r) Quick Path Interconnect, DRAM memory, reasons of CPU
        frequency throttling and other energy-related metrics 
      + pcm-tsx: monitor performance metrics for Intel(r) Transactional Synchronization Extensions
      + pcm-core and pmu-query: query and monitor arbitrary processor
        core events

** Concurrency and Async IO
*** Threads and concurrency 
 
  + *POSIX Threads*  - Threading C-API defined by POSIX IEEE standard
    which is implemented by many Unix-like operating systems such as
    Linux, MacOSX, iOS, Android, BSD, QNX and so on. Note: This API is
    already encapsulated and wrapped by C++11 standard library. 
    + [[https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html][POSIX thread (pthread) libraries]]
    + [[https://computing.llnl.gov/tutorials/pthreads/][POSIX Threads Programming]]
    + [[http://www.cs.fsu.edu/~baker/realtime/restricted/notes/pthreads.html][POSIX Threads API]]

  + *jthread* - (C++20 Inclusion) - C++ class for a joining and
    cooperative interruptible thread (should become std::jthread) 
    + "C++ class for a joining and cooperative interruptible thread
      (should become std::jthread) with stop_token helper. Draft
      implementation of the C++ paper P0660 https://wg21.link/p0660;
      Authors: Nicolai Josuttis and Lewis Baker".
    + Repository: https://github.com/josuttis/jthread

  + *ICNC - Intel Concurrency Collection* - " CnC makes it easy to write
    C++ programs which take full advantage of the available
    parallelism. Whether run on multicore systems, Xeon Phi™ or
    clusters CnC will seamlessly exploit the performance potential of
    your hardware. Through its portabilty and composability (with
    itself and other tools) it provides future-proof scalability.
    Intel® Concurrent Collections for C++ is a C++ template library
    for letting C++ programmers implement CnC applications which run
    in parallel on shared and distributed memory." 
    + Site: https://icnc.github.io/
    + Repo: https://github.com/icnc/icnc

  + *CAF* - C++ Actor Framework - "CAF is an open source C++11 actor
   model implementation featuring lightweight & fast actor
   implementations, pattern matching for messages, network transparent
   messaging, and more."
    + Site: https://actor-framework.org/
    + Repo: https://github.com/actor-framework/actor-framework
    + Doxygen: http://www.actor-framework.org/doc/

  + *SObjectizer* - "SObjectizer is one of a few cross-platform and
    OpenSource 'actor frameworks' or C++. But SObjectizer supports not
    only Actor Model, but also Publish-Subscribe Model and CSP-like
    channels. The goal of SObjectizer is significant simplification of
    development of concurrent and multithreaded applications in C++."
    + Repo: https://bitbucket.org/sobjectizerteam/sobjectizer/

  + *QP/C++* - "QP/C++™ (Quantum Platform in C++) is a lightweight
    Real-Time Embedded Framework (RTEF) for building modern, responsive
    and modular real-time embedded applications as systems of
    asynchronous event-driven active objects (actors). QP/C++" is a
    member of a larger family of real-time embedded frameworks (RTEFs)
    consisting of QP/C++, QP/C, and QP-nano frameworks, which are all
    strictly quality controlled, thoroughly documented, and available
    under dual licensing model."
    + Site: https://www.state-machine.com/qpcpp/
    + Repo: https://github.com/QuantumLeaps/qpcpp
    + License: GPL for open source, commerical for closed source.

  + *ProXC* [C Library] - "CSP-inspired concurrency library for modern
    C - This is a library for C which enables Communicating Sequential
    Processes (CSP) like structuring of your code. Programming
    languages such as Occam and XC utilizes and builds around this very
    paradigm, but sadly is hardware locked. Many good CSP libraries for
    general purpose programming languages has been made, including both
    for Java (JCSP) and C++ (C++CSP2), but not for C. There does exists
    plenty of libraries for C which implements many features from CSP,
    such as coroutines, channels, etc., but not all in a single
    library. ProXC aims to do this, and with no macro magic!"
    + Site: https://github.com/edvardsp/libproxc  
*** Concurrent Data Structures 

General Data Structures 

  + *Boost.Lockfree*
    + Site: https://www.boost.org/doc/libs/1_71_0/doc/html/lockfree.html
    + Brief: Lock-free data structures provided by Boost Library.

  + *CSD* - Concurrent Data Structures library [LOCK-FREE]
    + Site: http://libcds.sourceforge.net/doc/cds-api/index.html
    + Repo: https://github.com/khizmax/libcds (Mirror)
    + Brief: "Provide many lock-free data structures: stack, queue,
      deque, priority queue, map, set, list and tree." 
    + "This library is a collection of lock-free and lock-based
      fine-grained algorithms of data structures like maps, queues,
      list etc. The library contains implementation of well-known data
      structures and memory reclamation schemas for modern processor
      architectures. The library is written on C++11."

  + *Xenium*
    + Site: https://mpoeter.github.io/xenium/
    + Repo: https://github.com/mpoeter/xenium/
    + Brief: A C++ library providing various concurrent data
      structures and reclamation schemes.
    + "xenium is a collection of concurrent data structures and memory
      reclamation algorithms. The data structures are parameterized so
      that they can be used with various reclamation schemes (similar
      to how the STL allows customization of allocators). The
      documentation provides more details." 

  + *lock_free* [LOCK-FREE] [HEADER-ONLY]
    + Repo: https://github.com/Lingxi-Li/lock_free
    + "A C++17 Lock-Free Data Structure Library. This is a library for
      lock-free data structures with the following features: Written
      purely in standard C++17 with no platform-dependent code;
      Header-only; Designed for low worst-case latency; Designed for
      exception safety; Provides first-class support, like emplace
      construction; for aggregate types."

  + *ASCYLIB(Cpp) + OPTIK*
    + Repo: https://github.com/LPD-EPFL/ASCYLIB-Cpp
    + "ASCYLIB (with OPTIK) is a concurrent data-structure
      library. The original C version (found at
      https://github.com/LPD-EPFL/ASCYLIB) contains over 40
      implementations of linked lists, hash tables, skip lists, binary
      search trees (BSTs), queues, priority queues, and stacks,
      containing sequential, lock-based, and lock-free implementations
      for each data structure." 

  + *Junction* - Concurrent Data Structures in C++
    + Repo: https://github.com/preshing/junction
    + "Junction is a library of concurrent data structures in C++. It
      contains several hash map implementations:
      junction::ConcurrentMap_Crude; junction::ConcurrentMap_Linear;
      junction::ConcurrentMap_Leapfrog and junction::ConcurrentMap_Grampa"

  + *Excess C++*
    + Repo: https://github.com/excess-project/data-structures-library
    + EXCESS C++ Concurrent Data Structures (Adapter) Library

  + *libfds* [C Library]
    + Site: https://liblfds.org/
    + "liblfds, a portable, license-free, lock-free data structure
      library written in C. Lock-free data structures are process,
      thread and interrupt safe (i.e. the same data structure instance
      can be safely used concurrently and simultaneously across cores,
      processes, threads and both inside and outside of interrupt
      handlers), never sleep (and so are safe for kernel use when
      sleeping is not permitted), operate without context switches,
      cannot fail (no need to handle error cases, as there are none),
      perform and scale literally orders of magnitude better than
      locking data structures, and liblfds itself (as of release
      7.0.0) is implemented such that it performs no allocations (and
      so works with NUMA, stack, heap and shared memory) and compiles
      not just on a freestanding C89 implementation, but on a bare C89
      implementation."

Immutable Data Structures: 

  + *Immer* - Immutable concurrent data structures [IMMUTABLE] [FUNCTIONAL PROGRAMMING]
    + Repo: https://github.com/arximboldi/immer
    + "immer is a library of persistent and immutable data structures
      written in C++. These enable whole new kinds of architectures
      for interactive and concurrent programs of striking simplicity,
      correctness, and performance."
    + Why: "In the last few years, there has been a growing interest
      in immutable data structures, motivated by the horizontal
      scaling of our processing power and the ubiquity of highly
      interactive systems. Languages like Clojure and Scala provide
      them by default, and implementations for JavaScript like Mori
      and Immutable.js are widely used, specially in combination with
      modern UI frameworks like React."


Message Queues for thread producer/consumer synchronization

  + *MPMCQueue* (Message Queue, aka Mailbox)
    + Repo: https://github.com/rigtorp/MPMCQueue
    + Brief: A bounded multi-producer multi-consumer lock-free queue
      written in C++11
    + "A bounded multi-producer multi-consumer lock-free queue written
      in C++11. It's battle hardened and used daily in production: In
      the Frostbite game engine developed by Electronic Arts for the
      following games: Anthem (2019); Battlefield V (2018); FIFA 18
      (2017); Madden NFL 18 (2017); Need for Speed: Payback (2017). In
      the low latency trading infrastructure at Charlesworth Research
      and Marquette Partners."
    + It's been cited by the following papers:
      + Peizhao Ou and Brian Demsky. 2018. Towards understanding the
        costs of avoiding out-of-thin-air results. Proc. ACM
        Program. Lang. 2, OOPSLA, Article 136 (October 2018), 29
        pages. DOI: https://doi.org/10.1145/3276506

  + *SPSCQueue* (Message Queue, aka Mailbox)
    + Repo: https://github.com/rigtorp/SPSCQueue
    + Brief: A bounded single-producer single-consumer wait-free and
      lock-free queue written in C++11 
    + SPSCQueue have been cited by the following papers:
      + Peizhao Ou and Brian Demsky. 2018. Towards understanding the
        costs of avoiding out-of-thin-air results. Proc. ACM
        Program. Lang. 2, OOPSLA, Article 136 (October 2018), 29
        pages. DOI: https://doi.org/10.1145/3276506 

Misc - Non Categorized 

  + *Seqlock*
    + Repo: https://github.com/rigtorp/Seqlock
    + "An implementation of Seqlock in C++11. A seqlock can be used as
      an alternative to a readers-writer lock. It will never block the
      writer and doesn't require any memory bus locks."

  + *LibRCU*
    + Site: http://liburcu.org/
    + "liburcu is a LGPLv2.1 userspace RCU (read-copy-update)
      library. This data synchronization library provides read-side
      access which scales linearly with the number of
      cores. liburcu-cds provides efficient data structures based on
      RCU and lock-free algorithms. Those structures include hash
      tables, queues, stacks, and doubly-linked lists."

  + *SimonCqk/booty*
    + Repo: https://github.com/SimonCqk/booty
    + Utility mordern c++ components library in real development.
    + Provides many components for concurrent programming such as:
      thread pools, singla-slot, timestamp, unbounded lock queue, fast
      user-space mutexes, saturing semaphores.

See also: 

 + [[https://github.com/rigtorp/awesome-lockfree][GitHub - rigtorp/awesome-lockfree]]
   + A collection of resources on wait-free and lock-free programming.

 + [[https://github.com/jfuentes/concurrent-data-structures][GitHub - jfuentes/concurrent-data-structures]]
   + Compilation of concurrent data structures with at least lock-free
     or wait-free properties. 

*** Asynchronous I/O Input and Output

  + [[https://github.com/libuv/libuv][libuv]] - "libuv is a multi-platform support library with a focus on
    asynchronous I/O. It was primarily developed for use by Node.js,
    but it's also used by Luvit, Julia, pyuv, and others."
    + Site: https://github.com/libuv/libuv
    + Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
    + Asynchronous TCP and UDP sockets
    + Asynchronous DNS resolution
    + Asynchronous file and file system operations
    + File system events
    + ANSI escape code controlled TTY
    + IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
    + Child processes
    + Thread pool
    + Signal handling
    + High resolution clock
    + Threading and synchronization primitives

  + [[https://github.com/hhggit/uw][hhggit/uw]] - "UW is a single-header C++11 wrapper of libuv."
*** Coroutines, Fibers, Greentrheads
 
  *Coroutines* 


  + *Boost Coroutines 2* - "Boost.Coroutine2 provides templates for
    generalized subroutines which allow suspending and resuming
    execution at certain locations. It preserves the local state of
    execution and allows re-entering subroutines more than once (useful
    if state must be kept across function calls). Coroutines can be
    viewed as a language-level construct providing a special kind of
    control flow. In contrast to threads, which are pre-emptive,
    coroutine switches are cooperative (programmer controls when a
    switch will happen). The kernel is not involved in the coroutine
    switches."
    + https://www.boost.org/doc/libs/1_70_0/libs/coroutine2/doc/html/index.html

  + *Cppcoro* [EXPERIMENTAL] - "This library is an experimental library
    that is exploring the space of high-performance, scalable
    asynchronous programming abstractions that can be built on top of
    the C++ coroutines proposal. It has been open-sourced in the hope
    that others will find it useful and that the C++ community can
    provide feedback on it and ways to improve it. It requires a
    compiler that supports the coroutines TS." 
    + https://github.com/lewissbaker/cppcoro

  *Fibers*    

  + *Boost Fibers* [USER SPACE THREADS] - "Provides a framework for
    micro-/userland-threads (fibers) scheduled cooperatively. The API
    contains classes and functions to manage and synchronize fibers
    similar to boost.thread. A fiber is able to store the current
    execution state, including all registers and CPU flags, the
    instruction pointer, and the stack pointer and later restore this
    state. The idea is to have multiple execution paths running on a
    single thread using a sort of cooperative scheduling (threads are
    preemptively scheduled) - the running fiber decides explicitly when
    it yields to allow another fiber to run (context switching). A
    context switch between threads costs usually thousands of CPU
    cycles on x86 compared to a fiber switch with less than 100
    cycles. A fiber can only run on a single thread at any point in
    time. Boost.fiber requires C++11!"
    + Site: https://www.boost.org/doc/libs/1_67_0/libs/fiber/doc/html/index.html
    + Repo: https://github.com/boostorg/fiber

  + *IOFiber* - "IOFiber is a fiber library built on top of Boost.Context
    and Boost.Asio - This library is not a competitor to
    Boost.Fiber. This library aims to have tight integration with
    Boost.Asio execution engine."
    + https://vinipsmaker.github.io/iofiber/
    + Repo: https://github.com/blinktrade/iofiber

  + *FiberTaskingLib* - "This is a library for enabling task-based
    multi-threading. It allows execution of task graphs with arbitrary
    dependencies. Dependencies are represented as atomic counters. Under
    the covers, the task graph is executed using fibers, which in turn,
    are run on a pool of worker threads (one thread per CPU core). This
    allows the scheduler to wait on dependencies without task chaining
    or context switches. This library was created as a proof of concept
    of the ideas presented by Christian Gyrling in his 2015 GDC Talk
    'Parallelizing the Naughty Dog Engine Using Fibers'" 
    + https://github.com/RichieSams/FiberTaskingLib

** Parallel Computing 
*** Parallel Computing with CPU hardware threads  

  + *Intel TBB - Threading Building Blocks* - "This application is a
    widely used C++ library for shared-memory parallel programming and
    heterogeneous computing (intra-node distributed memory
    programming). The library provides a wide range of features for
    parallel programming, including generic parallel algorithms,
    concurrent containers, a scalable memory allocator, work-stealing
    task scheduler, and low-level synchronization primitives. Threading
    Building Blocks (TBB) is a library only solution for task-based
    parallelism and does not require any special compiler support. It
    ports to multiple architectures including Intel® architectures,
    ARM*, and Power Architecture*."
    + Site: https://software.intel.com/en-us/intel-tbb
    + Repo: https://github.com/intel/tbb

  + *Intel Parallel-STL* - "Parallel STL is an implementation of the C++
    standard library algorithms with support for execution policies, as
    specified in ISO/IEC 14882:2017 standard, commonly called
    C++17. The implementation also supports the unsequenced execution
    policy specified in Parallelism TS version 2 and proposed for the
    next version of the C++ standard in the C++ working group paper
    P1001R1. Parallel STL offers a portable implementation of threaded
    and vectorized execution of standard C++ algorithms, optimized and
    validated for Intel(R) 64 processors. For sequential execution, it
    relies on an available implementation of the C++ standard
    library. The source code in this repository corresponds to the
    releases of Parallel STL with Intel(R) C++ Compiler or with
    Threading Building Blocks."
    + Site: https://software.intel.com/en-us/articles/get-started-with-parallel-stl
    + Site: https://github.com/intel/parallelstl

  + *HPX - High Performance ParalleX* - "HPX is a C++ Standard Library
    for Concurrency and Parallelism. It implements all of the
    corresponding facilities as defined by the C++
    Standard. Additionally, in HPX we implement functionalities
    proposed as part of the ongoing C++ standardization process. We
    also extend the C++ Standard APIs to the distributed case. The
    goal of HPX is to create a high quality, freely available, open
    source implementation of a new programming model for conventional
    systems, such as classic Linux based Beowulf clusters or
    multi-socket highly parallel SMP nodes. At the same time, we want
    to have a very modular and well designed runtime system
    architecture which would allow us to port our implementation onto
    new computer system architectures. We want to use real-world
    applications to drive the development of the runtime system,
    coining out required functionalities and converging onto a stable
    API which will provide a smooth migration path for developers. The
    API exposed by HPX is not only modeled after the interfaces
    defined by the C++11/14/17/20 ISO standard, it also adheres to the
    programming guidelines used by the Boost collection of C++
    libraries. We aim to improve the scalability of today's
    applications and to expose new levels of parallelism which are
    necessary to take advantage of the exascale systems of the
    future."
    + Site: http://stellar-group.org/libraries/hpx/
    + Repo: https://github.com/STEllAR-GROUP/hpx

  + *CPP Taskflow*
    + "Cpp-Taskflow is by far faster, more expressive, and easier for
      drop-in integration than existing parallel task programming
      libraries such as OpenMP Tasking and Intel TBB FlowGraph in
      handling complex parallel workloads. Cpp-Taskflow lets you
      quickly implement task decomposition strategies that incorporate
      both regular and irregular compute patterns, together with an
      efficient work-stealing scheduler to optimize your multithreaded
      performance."
      + Site: https://cpp-taskflow.github.io
      + Repo: https://github.com/cpp-taskflow/cpp-taskflow
*** Parallel Computing with SIMD 

  *SIMD* - Data Parallelism, CPU vector instructions (SIMD) wrappers.

  + [[https://github.com/QuantStack/xsimd][xsimd]] - "Modern, portable C++ wrappers for SIMD intrinsics and
    parallelized, optimized math implementations (SSE, AVX, NEON,
    AVX512). SIMD (Single Instruction, Multiple Data) is a feature of
    microprocessors that has been available for many years. SIMD
    instructions perform a single operation on a batch of values at
    once, and thus provide a way to significantly accelerate code
    execution. However, these instructions differ between
    microprocessor vendors and compilers. xsimd provides a unified
    means for using these features for library authors. Namely, it
    enables manipulation of batches of numbers with the same
    arithmetic operators as for single values. It also provides
    accelerated implementation of common mathematical functions
    operating on batches."
    + Docs: https://xsimd.readthedocs.io/en/latest/
    + See: [[https://serge-sans-paille.github.io/pythran-stories/bye-bye-boostsimd-welcome-xsimd.html][Bye bye boost.simd, welcome xsimd]]

  + [[https://github.com/agenium-scale/nsimd][nsimd]] - "NSIMD is a vectorization library that abstracts SIMD
    programming. It was designed to exploit the maximum power of
    processors at a low development cost. To achieve maximum
    performance, NSIMD mainly relies on the inline optimization pass
    of the compiler. Therefore using any mainstream compiler such as
    GCC, Clang, MSVC, XL C/C++, ICC and others with NSIMD will give
    you a zero-cost SIMD abstraction library. To allow inlining, a lot
    of code is placed in header files. Small functions such as
    addition, multiplication, square root, etc, are all present in
    header files whereas big functions such as I/O are put in source
    files that are compiled as a .so/.dll library. NSIMD provides C89,
    C++98, C++11 and C++14 APIs. All APIs allow writing generic
    code. For the C API this is achieved through a thin layer of
    macros; for the C++ APIs it is achieved using templates and
    function overloading. The C++ API is split in two. The first part
    is a C-like API with only function calls and direct type
    definitions for SIMD types while the second one provides operator
    overloading, higher level type definitions that allows
    unrolling. C++11, C++14 APIs add for instance templated type
    definitions and templated constants."

*** Parallel Computing with GPU                 :hpc:parallel:supercomputing:

Listing of C++ template libraries for general purpose computing on
GPUs using C++11 to C++17 without any extension language such as CUDA,
OpenACC, OpenCL and so on.

 *General Template Libraries - akin to C++ STL*

  + *Boost.Compute* [VENDOR NEUTRAL]
    + Site 1: http://boostorg.github.io/compute/
    + Site 2: https://www.boost.org/doc/libs/1_71_0/libs/compute/doc/html/index.html
    + Repo: https://github.com/boostorg/compute
    + "Boost.Compute is a GPU/parallel-computing library for C++ based
      on OpenCL. The core library is a thin C++ wrapper over the
      OpenCL API and provides access to compute devices, contexts,
      command queues and memory buffers. On top of the core library is
      a generic, STL-like interface providing common algorithms
      (e.g. transform(), accumulate(), sort()) along with common
      containers (e.g. vector<T>, flat_set<T>). It also features a
      number of extensions including parallel-computing algorithms
      (e.g. exclusive_scan(), scatter(), reduce()) and a number of
      fancy iterators (e.g. transform_iterator<>,
      permutation_iterator<>, zip_iterator<>)."
    + See:
      + [[https://www.cycfi.com/2019/04/gpu-dsp-latency/][GPU DSP — Latency – Cycfi Research]] - Joel de Guzman
      + [[https://www.reddit.com/r/cpp/comments/5umcw2/has_anyone_had_success_using_boost_compute_to/][Has anyone had success using Boost Compute to abstract away OpenCL? : cpp]]

  + *TrySYCL* [VENDOR NEUTRAL] [KHRONOS GROUP] [SYCL STANDARD]
    + Brief: Implementation of Khronos Group  [[http://www.khronos.org/sycl][SYCL]] open standard.
    + Site: http://www.khronos.org/sycl
    + Repo: https://github.com/triSYCL/triSYCL
    + "triSYCL is an open source implementation to experiment with the
      specification of the SYCL C++ layer and to give feedback to the
      Khronos Group SYCL and OpenCL C++ 2.2 kernel language committees
      and also to the ISO C++ committee. This SYCL implementation is
      mainly based on C++17 and OpenMP or TBB for execution on the
      CPU, with Boost.Compute for the non single-source OpenCL
      interoperability layer and with LLVM/Clang for the device
      compiler providing full single-source SYCL experience, typically
      targeting a SPIR device. Since in SYCL there is a host
      fall-back, this CPU implementation can be seen as an
      implementation of this fall-back too... For legal reasons, the
      specification used for this open source project is the published
      current provisional specification and not the last one currently
      discussed in the Khronos SYCL committee. If you are a Khronos
      member, you can access to
      https://gitlab.khronos.org/sycl/triSYCL where you might find
      more futuristic branches."
    + See also:
      + [[https://sycl.tech/videos/][Videos | SYCL.tech]]
      + [[https://www.khronos.org/assets/uploads/developers/library/2015-iwocl/Khronos-SYCL-May15.pdf][SYCL for OpenCL - Khronos Group]]

  + *ComputeCPP*  [VENDOR NEUTRAL] [KHRONOS GROUP] [SYCL STANDARD] [COMMERCIAL]
    + Brief: Implementation of Khronos Group  [[http://www.khronos.org/sycl][SYCL]] open standard.
    + Site: https://www.codeplay.com/products/computesuite/computecpp
    + "The SYCL standard from the Khronos™ Group is for developers who
      want to take software written using C++ single-source
      programming models like CUDA® or C++AMP and port to a wide range
      of OpenCL™ devices. The current early-access ComputeCpp
      Community Edition release provides pre-conformance SYCL v1.2
      support for AMD® and Intel® OpenCL GPUs and CPUs. Further
      operating system and device support is on its way. This version
      will let developers work on acceleration of open-source C++
      software such as TensorFlow, Eigen and the C++ 17 Parallel STL."
    + Note: The *community edition* is free.

  + *EasyCL* [VENDOR NEUTRAL] [LOW LEVEL]
    + Repo: https://github.com/hughperkins/EasyCL
    + "Easy to run kernels using OpenCL. (renamed from OpenCLHelper);
      makes it easy to pass input and output arguments; handles much
      of the boilerplate; uses clew to load opencl dynamically"

  + *EasyOpenCL* [VENDOR NEUTRAL]
    + Repo: https://github.com/Gladdy/EasyOpenLC
    + "No exposed low-level C, just the C++ standard
      library. Features: Focus on programming the GPU instead of
      messing about with long C-style OpenCL function calls and manual
      memory management; CMake support for Linux and Mac - No more
      linking problems when you have installed the correct driver;
      Support for scalar values: pass additional structs to your
      kernel, eg. transformation matrices or custom constants; Chain
      kernels together in order to create a true pipeline on your GPU
      in which kernels can depend on multiple others;"
    + See:
      + [[https://news.ycombinator.com/item?id=10103846][EasyOpenCL – The easiest way to get started with GPU programming | Hacker News]]

  + *Chlorine* [VENDOR NEUTRAL]
    + Site: https://polytonic.github.io/Chlorine/
    + Repo: https://github.com/Polytonic/Chlorine
    + "Dead Simple OpenCL. Chlorine is the easiest way to interact
      with OpenCL compatible devices. It is a header-only C++11
      library that allows you to write cross-platform code that runs
      on GPUs without ever touching the complicated OpenCL API,
      leaving you free to write code that matters: kernels that
      process data."

  + *Thrust* [NVidia GPUs ONLY]
    + Site: https://thrust.github.io/
    + Repo: https://github.com/thrust/thrust
    + Note: Only works for Nvidia GPUs 
    + "Thrust is a C++ parallel programming library which resembles
      the C++ Standard Library. Thrust's high-level interface greatly
      enhances programmer productivity while enabling performance
      portability between GPUs and multicore CPUs. Interoperability
      with established technologies (such as CUDA, TBB, and OpenMP)
      facilitates integration with existing software. Develop
      high-performance applications rapidly with Thrust! Thrust is
      distributed with the CUDA Toolkit in addition to GitHub."

  + *HSA-Bolt* [AMD GPUs ONLY]
    + Site: https://github.com/HSA-Libraries/bolt/wiki
    + Repo: https://github.com/HSA-Libraries/Bolt
    + "Bolt is a C++ template library optimized for heterogeneous
      computing. Bolt is designed to provide high-performance library
      implementations for common algorithms such as scan, reduce,
      transform, and sort. The Bolt interface was modeled on the C++
      Standard Template Library (STL). Developers familiar with the
      STL will recognize many of the Bolt APIs and customization
      techniques. The primary goal of Bolt is to make it easier for
      developers to utilize the inherent performance and power
      efficiency benefits of heterogeneous computing. It has
      interfaces that are easy to use, and has comprehensive
      documentation for the library routines, memory management,
      control interfaces, and host/device code sharing. Compared to
      writing the equivalent functionality in OpenCL™, you’ll find
      that Bolt requires significantly fewer lines-of-code and less
      developer effort. Bolt is designed to provide a standard way to
      develop an application that can execute on either a regular CPU,
      or use any available OpenCL™ capable accelerated compute unit,
      with a single code path."

  + *GOOPAX* [COMMERCIAL]
    + Site: http://goopax.com/
    + Example: http://goopax.com/examples

    + "GOOPAX is the world's first language-embedded programming
      solution for GPGPU applications. Our unique programming model
      greatly simplifies the development of GPGPU applications, making
      it featible to use the immense computing power of GPUs even for
      very complex applications. The unique programming model of
      language-embedded programming results in a number of advantages:
      perfect integration of the GPU kernels into the host code;
      programs are compiled with a standard C++ compiler of your
      choice; shorter programs due to code reusability; higher
      performance due to meta-programming, profiling, and just-in-time
      compilation; more reliability: Race conditions and other
      programming errors are detected automatically; cross-platform
      development: Programs written in GOOPAX can run on all major
      target platforms and operating systems; performance portability:
      GOOPAX detects the graphics card at run-time and creates
      tailor-made GPU kernels. Your application runs at maximum
      performance on all hardware."
    + Typical fields of application are:

      + simulations: CFD, weather forecasts, astrophysics, protein
        folding, combustion processes, etc.
      + blockchains, cryptocurrency mining
      + image recognition: quality assurance in manufacturing, face
        recognition, analysis of aereal images, autonomous driving,
        surveilance, etc.
      + CAD, FE, engineering, product optimization
      + planning, classification, text recognition, search engines,
        machine learning, deep learning, AI, financial markets
      + computer games, VR, video processing, video codecs


  *GPU Accelerated Libraries*


  + *CUDA Acclerated Libraries* [NVidia GPUs Only]

    + Site: https://developer.nvidia.com/gpu-accelerated-libraries

    + Brief: Lots of GPU Accelerated libraries for a wide variety of fields
      and applications. The advantage of those GPU accelerated
      libraries is that they can easily replace many non-accelerated
      libraries and free the user from parallelizing  algorithms and
      portingt them to GPUs.

    + "NVIDIA GPU-accelerated libraries provide highly-optimized
      functions that perform 2x-10x faster than CPU-only
      alternatives. Using drop-in interfaces, you can replace CPU-only
      libraries such as MKL, IPP and FFTW with GPU-accelerated
      versions with almost no code changes. The libraries can
      optimally scale your application across multiple
      GPUs. GPU-accelerated libraries for linear algebra, signal
      processing, image and video processing lay the foundation for
      compute-intensive applications in areas such as molecular
      dynamics, computational chemistry, medical imaging and seismic
      exploration. For deep learning, NVIDIA provides specialized
      libraries that are integrated with all the leading deep learning
      frameworks. NVIDIA libraries use optimized precision to maximize
      performance for applications such as computer vision, speech
      processing and natural language processing. Today, NVIDIA’s
      libraries are running from resource constrained IoT devices, to
      self driving cars, to the largest supercomputers on the
      planet. With NVIDIA’s libraries, you get highly efficient
      implementations of algorithms that are regularly extended and
      optimized. Whether you are building a new application or trying
      to speed up an existing application, NVIDIA’s libraries provide
      the easiest way to get started with GPUs. You can download
      NVIDIA libraries as part of the CUDA Toolkit."

    + Accelerated libraries:
      + cuFFT => Fast Forier Transform 
      + cuBLAS => (BLAS = Basic Linear Algebra Subprogram) - for
        linear algebra, matrix and vector computations.
      + cuSPARSE => Sparse Matrix Computations.
      + cuSOLVER => Eingenvalue solver
      + cuDNN => GPU accelerated library of primitives for deep neural networks
      + cuRAND => GPU accelerated random number generator (RNG)
      + cuSOLVER => Dense and sparse direct solvers for Computer
        Vision, CFD, Computational Chemistry, and Linear Optimization
        applications 
      + TensorRT

  + *VexCL*  [VENDOR NEUTRAL]
    + Repo: https://github.com/ddemidov/vexcl
    + Site: https://vexcl.readthedocs.io/en/latest/
    + "VexCL is a vector expression template library for
      OpenCL/CUDA. It has been created for ease of GPGPU development
      with C++. VexCL strives to reduce amount of boilerplate code
      needed to develop GPGPU applications. The library provides
      convenient and intuitive notation for vector arithmetic,
      reduction, sparse matrix-vector products, etc. Multi-device and
      even multi-platform computations are supported. The library
      source code is available under MIT license at
      https://github.com/ddemidov/vexcl."
    + See:
      + [[https://www.youtube.com/watch?v=W8onyk2Rraw][Generating OpenCL/CUDA source code from C++ expressions in VexCL - YouTube]]

  + *ViennaCL* [VENDOR NEUTRAL]
    + Site: http://viennacl.sourceforge.net/
    + "ViennaCL is a free open-source linear algebra library for
      computations on many-core architectures (GPUs, MIC) and
      multi-core CPUs. The library is written in C++ and supports
      CUDA, OpenCL, and OpenMP (including switches at runtime). The
      highlights of the latest 1.7.x release family are: Fast sparse
      matrix-matrix multiplications, outperforming CUBLAS and MKL;
      Fine-grained parallel algebraic multigrid preconditioners for
      CPUs, Xeon Phis, and GPUs; Fine-grained parallel incomplete LU
      factorization preconditioners for CPUs, Xeon Phis, and GPUs." 

  + *ArrayFire* [VENDOR NEUTRAL]
    + Repo: https://github.com/arrayfire/arrayfire
    + "ArrayFire is a general-purpose library that simplifies the
      process of developing software that targets parallel and
      massively-parallel architectures including CPUs, GPUs, and other
      hardware acceleration devices. Several of ArrayFire's benefits
      include: Easy to use, stable, well-documented API; Rigorously
      tested for performance and accuracy; Commercially friendly
      open-source licensing; Commercial support from ArrayFire; Read
      about more benefits on arrayfire.com. ArrayFire provides
      software developers with a high-level abstraction of data which
      resides on the accelerator, the af::array object. Developers
      write code which performs operations on ArrayFire arrays which,
      in turn, are automatically translated into near-optimal kernels
      that execute on the computational device. ArrayFire is
      successfully used on devices ranging from low-power mobile
      phones to high-power GPU-enabled supercomputers. ArrayFire runs
      on CPUs from all major vendors (Intel, AMD, ARM), GPUs from the
      prominent manufacturers (NVIDIA, AMD, and Qualcomm), as well as
      a variety of other accelerator devices on Windows, Mac, and
      Linux."

  + *HPL-Gpu* [VENDOR NEUTRAL] [LINEAR ALGEBRA]
    + Site: https://github.com/davidrohr/hpl-gpu/wiki 
    + Repo: https://github.com/davidrohr/hpl-gpu
    + "High Performance Linpack for GPUs (Using OpenCL, CUDA, CAL).
      This is a largely rewritten version of the traditional High
      Performance Linpack as published on netlib.org. It has been
      modified to make use of modern multi-core CPUs, enhanced
      lookahead and a high performance DGEMM for AMD GPUs. It can  use
      AMD CAL, OpenCL, and CUDA as GPU backend."
  
  + *CLBLast* [VENDOR NEUTRAL] [LINEAR ALGEBRA]
    + Repo: https://github.com/CNugteren/CLBlast
    + Site: "CLBlast is a modern, lightweight, performant and tunable
      OpenCL BLAS library written in C++11. It is designed to leverage
      the full performance potential of a wide variety of OpenCL
      devices from different vendors, including desktop and laptop
      GPUs, embedded GPUs, and other accelerators. CLBlast implements
      BLAS routines: basic linear algebra subprograms operating on
      vectors and matrices. See the CLBlast website for performance
      reports on various devices as well as the latest CLBlast
      news. The library is not tuned for all possible OpenCL devices:
      if out-of-the-box performance is poor, please run the tuners
      first. See below for a list of already tuned devices and
      instructions on how to tune yourself and contribute to future
      releases of the CLBlast library. See also the CLBlast feature
      roadmap to get an indication of the future of CLBlast."

  + *DeepCL* [VENDOR NEUTRAL] [MACHINE LEARNING] [AI]
    + Repo: https://github.com/hughperkins/DeepCL/
    + "OpenCL library to train deep convolutional neural networks."

  + *MACE* [VENDOR NEUTRAL] [MACHINE LEARNING] [AI]
    + Repo: https://github.com/XiaoMi/mace
    + "MACE is a deep learning inference framework optimized for
      mobile heterogeneous computing platforms. Mobile AI Compute
      Engine (or MACE for short) is a deep learning inference
      framework optimized for mobile heterogeneous computing on
      Android, iOS, Linux and Windows devices." 

  + *libclsph* [VENDOR NEUTRAL] [CFD] [ENGINEERING]
    + Repo: https://github.com/libclsph/libclsph
    + "An OpenCL based GPU accelerated SPH fluid simulation
      library. Libclsph was created to explore the possibilty of using
      the power of OpenCL to speed up the simulation of SPH fluid
      mechanics. Smoothed particle hydrodynamics is a fluid simulation
      technique that can be used to produce realistic simulations for
      animation,CGI or videogames."

  + *Sol-R* * [VENDOR NEUTRAL]
    + Repo: https://github.com/cyrillefavreau/Sol-R
    + "Sol-R is a CUDA/OpenCL-based realtime ray-tracer compatible
      with Oculus Rift DK1, Kinect, Razor Hydra and Leap Motion
      devices. Sol-R was used by the Interactive Molecular Visualiser
      project (http://www.molecular-visualization.com) A number of
      videos can be found on my channel:
      https://www.youtube.com/user/CyrilleOnDrums Sol-R was written as
      a hobby project in order to understand and learn more about CUDA
      and OpenCL. Most of the code was written at night and during
      week-ends, meaning that it's probably not the best quality ever
      ;-) The idea was to produce a Ray-Tracer that has its own
      "personality". Most of the code does not rely on any litterature
      about ray-tracing, but more on a naive approach of what rays
      could be used for. The idea was not to produce a physically
      based ray-tracer, but a simple engine that could produce cool
      images interactively." 

*** Parallel Computing - MPI (Distributed computing, clusters) :hpc:parallel:cluster:supercomputing:

  *MPI - Message Passing Interface* 

   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/mpi.html][Boost.MPI]]
     + Brief: "Boost.MPI is a library for message passing in high-performance
       parallel applications. A Boost.MPI program is one or more
       processes that can communicate either via sending and receiving
       individual messages (point-to-point communication) or by
       coordinating as a group (collective communication). Unlike
       communication in threaded environments or using a shared-memory
       library, Boost.MPI processes can be spread across many different
       machines, possibly with different operating systems and
       underlying architectures."

   + [[http://www.mpich.org/][MPICH]] - "MPICH is a high performance and widely portable
     implementation of the Message Passing Interface (MPI)
     standard. MPICH and its derivatives form the most widely used
     implementations of MPI in the world. They are used exclusively on
     nine of the top 10 supercomputers (June 2016 ranking), including
     the world’s fastest supercomputer: Taihu Light."

   + [[https://www.open-mpi.org][Open MPI]] - "A High Performance Message Passing Library. The Open
     MPI Project is an open source Message Passing Interface
     implementation that is developed and maintained by a consortium
     of academic, research, and industry partners. Open MPI is
     therefore able to combine the expertise, technologies, and
     resources from all across the High Performance Computing
     community in order to build the best MPI library available. Open
     MPI offers advantages for system and software vendors,
     application developers and computer science researchers."

   + *Microsoft MPI*
     + Repo: https://github.com/microsoft/Microsoft-MPI
     + "Microsoft MPI (MS-MPI) is a Microsoft implementation of the
       Message Passing Interface standard for developing and running
       parallel applications on the Windows platform. MS-MPI offers
       several benefits: Ease of porting existing code that uses
       MPICH; Security based on Active Directory Domain Services; High
       performance on the Windows operating system; Binary
       compatibility across different types of interconnectivity
       options." 

   + *BigMPI*
     + Repo: https://github.com/jeffhammond/BigMPI
     + "Interface to MPI for large messages, i.e. those where the
       count argument exceeds INT_MAX but is still less than
       SIZE_MAX. BigMPI is designed for the common case where one has
       a 64b address space and is unable to do MPI communication on
       more than 2^31 elements despite having sufficient memory to
       allocate such buffers. BigMPI does not attempt to support
       large-counts on systems where C int and void* are both 32b."

   + *MPL*
     + Site: https://rabauke.github.io/mpl/html/
     + Repo: https://github.com/rabauke/mpl
     + "MPL is a message passing library written in C++11 based on the
       Message Passing Interface (MPI) standard. Since the C++ API has
       been dropped from the MPI standard in version 3.0 it is the aim
       of MPL to provide a modern C++ message passing library for high
       performance computing. MPL will neither bring all functions of
       the C language MPI-API to C++ nor provide a direct mapping of
       the C API to some C++ functions and classes. Its focus lies on
       the MPI core message passing functions, ease of use, type
       safety, and elegance. This library is must useful for
       developers who have at least some basic knowledge of the
       Message Passing Interface and would like to utilize it via a
       more user friendly interface."

   + *Tampi* 
     + Repo: https://github.com/bsc-pm/tampi
     + "The Task-Aware MPI or TAMPI library extends the functionality
       of standard MPI libraries by providing new mechanisms for
       improving the interoperability between parallel task-based
       programming models, such as OpenMP or OmpSs-2, and both
       blocking and non-blocking MPI operations. By following the MPI
       Standard, programmers must pay close attention to avoid
       deadlocks that may occur in hybrid applications (e.g.,
       MPI+OpenMP) where MPI calls take place inside tasks. This is
       given by the out-of-order execution of tasks that consequently
       alter the execution order of the enclosed MPI calls. The TAMPI
       library ensures a deadlock-free execution of such hybrid
       applications by implementing a cooperation mechanism between
       the MPI library and the parallel task-based runtime system."

   + *MMX*
     + Repo: https://github.com/patflick/mxx
     + "mxx is a C++/C++11 template library for MPI. The main goal of
       this library is to provide two things: Simplified, efficient,
       and type-safe C++11 bindings to common MPI operations; A
       collection of scalable, high-performance standard algorithms
       for parallel distributed memory architectures, such as sorting;
       As such, mxx is targeting use in rapid C++ and MPI algorithm
       development, prototyping, and deployment."
     + Features:
       + All functions are templated by type. All MPI_Datatype are
         deducted from the C++ type given to the function. 
       + Custom reduction operations as lambdas, std::function,
         functor, or function pointer. 
       + Send/Receive and Collective operations take size_t sized
         input and automatically handle sizes larger than INT_MAX. 
       + Plenty of convenience functions and overloads for common MPI
         operations with sane defaults (e.g., super easy collectives:
         std::vector<size_t> allsizes = mxx::allgather(local_size)). 
       + Automatic type mapping of all built-in (int, double, etc) and
         other C++ types such as std::tuple, std::pair, and
         std::array. 
       + Non-blocking operations return a mxx::future<T> object,
         similar to std::future. 
       + Google Test based MPI unit testing framework
       + Parallel sorting with similar API than std::sort (mxx::sort) 

   + *WI4MPI*
     + Repo: https://github.com/cea-hpc/wi4mpi
     + "This is WI4MPI, Wrapper Interface For MPI performing a light
       translation between MPI constants and MPI objects from an MPI
       implementation to another one."
 
   + *Mimir*
     + Repo: https://github.com/TauferLab/Mimir
     + "Mimir is a new implementation of MapReduce over MPI. Mimir
       inherits the core principles of existing MapReduce frameworks,
       such as MR-MPI, while redesigning the execution model to
       incorporate a number of sophisticated optimization techniques
       that achieve similar or better performance with significant
       reduction in the amount of memory used."

   + *Splatt*
     + Repo: https://github.com/ShadenSmith/splatt
     + "The Surprisingly ParalleL spArse Tensor Toolkit. SPLATT is a
       library and C API for sparse tensor factorization. SPLATT
       supports shared-memory parallelism with OpenMP and
       distributed-memory parallelism with MPI." 

   + *Dash-project* 
     + Site: http://www.dash-project.org/
     + Repo: https://github.com/dash-project/dash
     + "DASH is a C++ Template Library for Distributed Data Structures
       with Support for Hierarchical Locality for HPC and Data-Driven
       Science. Exascale systems are scheduled to become available in
       the coming years and will be characterized by extreme scale and
       a multilevel hierarchical organization. Efficient and
       productive programming of these systems will be a challenge,
       especially in the context of data-intensive
       applications. Adopting the promising notion of Partitioned
       Global Address Space (PGAS) programming the DASH project
       develops a data-structure oriented C++ template library that
       provides hierarchical PGAS-like abstractions for important data
       containers (multidimensional arrays, lists, hash tables, etc.)
       and allows a developer to control (and explicitly take
       advantage of) the hierarchical data layout of global data
       structures. In contrast to other PGAS approaches such as UPC,
       DASH does not propose a new language or require compiler
       support to realize global address space semantics. Instead,
       operator overloading and other advanced C++ features are used
       to provide the semantics of data residing in a global and
       hierarchically partitioned address space based on a runtime
       system with one-sided messaging primitives provided by MPI or
       GASNet. As such, DASH can co-exist with parallel programming
       models already in widespread use (like MPI) and developers can
       take advantage of DASH by incrementally replacing existing data
       structures with the implementation provided by DASH. Efficient
       I/O directly to and from the hierarchical structures and
       DASH-optimized algorithms such as map-reduce are also part of
       the project. Two applications from molecular dynamics and
       geoscience are driving the project and are adapted to use DASH
       in the course of the project." 

** C Libraries                                                         :clib:
*** General 

  + *libv* - "libv implements common data structures such as linked
    lists, dynamic arrays, binary trees, AVL-trees, maps, hashes,
    stacks, queues and others."
    + Summary: Library that provides common data structures missing in
      C standard library. 
    + Repository/Site: http://libv.sourceforge.net/

  + *tbox* - "TBOX is a glib-like cross-platform C library that is simple
    to use yet powerful in nature. The project focuses on making C
    development easier and provides many modules (.e.g stream,
    coroutine, regex, container, algorithm ...), so that any developer
    can quickly pick it up and enjoy the productivity boost when
    developing in C language." 
    + Site:       https://tboox.org
    + Repository: https://github.com/tboox/tbox

  + *Eina* (Enlightment Project) - "The Eina library is a library which
    implements an API for data types in an efficient way. It also
    provides some useful tools like opening shared libraries, error
    management, type conversion, time accounting and memory pools. This
    library is cross-platform and can be compiled and used on Linux,
    BSD, and Windows."
    + Site: https://www.enlightenment.org/_legacy_embed/eina_main.html

  + *APR - Apache Portable Runtime* - Supporting library for providing
    cross-platform portability to the Apache Web Server. The library
    provides a common API to many different operating systems. It
    provides facilities for: Atomic operations; Dynamic Shared Object
    loading; File I/O; Locks (mutexes, condition variables, etc); Memory
    management (high performance allocators); Memory-mapped files;
    Multicast Sockets; Network I/O; Shared memory; Thread and Process
    management and also may data structures such as tables, hashes,
    priority queues, etc.
    + Web Site: https://apr.apache.org/
    + Mirror Repository: https://github.com/apache/apr
    + Documentation: https://apr.apache.org/docs/apr/1.7/modules.html

  + *SDS - Simple Dynamic Strings library for C* - "SDS is a string
    library for C designed to augment the limited libc string handling
    functionalities by adding heap allocated strings that are: Simpler
    to use; Binary safe; Computationally more efficient; But
    yet... Compatible with normal C string functions."
    + Note: It comes from Redis database.
    + https://github.com/antirez/sds  

  + *ConcurrencyKit* - "Concurrency primitives, safe memory reclamation
    mechanisms and non-blocking (including lock-free) data structures
    designed to aid in the research, design and implementation of high
    performance concurrent systems developed in C99+"
    + http://concurrencykit.org/
    + https://github.com/concurrencykit/ck

  + *CException* - "CException is simple exception handling in C. It is
    significantly faster than full-blown C++ exception handling but
    loses some flexibility. It is portable to any platform supporting
    setjmp/longjmp."
    + https://github.com/ThrowTheSwitch/CException
    + http://www.throwtheswitch.org/cexception

  + *Sokol* - "minimal cross-platform standalone C headers. Minimalistic
    header-only cross-platform libs in C: sokol_gfx.h: 3D-API wrapper
    (GL + Metal + D3D11); sokol_app.h: app framework wrapper (entry +
    window + 3D-context + input); sokol_time.h: time measurement;
    sokol_audio.h: minimal buffer-streaming audio playback;
    sokol_fetch.h: asynchronous data streaming from HTTP and local
    filesystem; sokol_args.h: unified cmdline/URL arg parser for web
    and native apps". 
    + https://github.com/floooh/sokol
    + https://github.com/floooh/sokol-tools

*** Unit Testing Libraries 

  + *MinUnit* - "Minunit is a minimal unit testing framework for C/C++
    self-contained in a single header file. It provides a way to define
    and configure test suites and a few handy assertion types. It
    reports the summary of the number of tests run, number of assertions
    and time elapsed." 
    + https://github.com/siu/minunit

  + *Check* - "Check is a unit testing framework for C. It features a
    simple interface for defining unit tests, putting little in the way
    of the developer. Tests are run in a separate address space, so
    Check can catch both assertion failures and code errors that cause
    segmentation faults or other signals. The output from unit tests can
    be used within source code editors and IDEs." 
    + https://github.com/libcheck/check

  + *LibTap* - "tap is an easy to read and easy to write way of creating
    tests for your software. This library creates functions that can
    be used to generate it for your C programs. It is implemented
    using macros that include file and line info automatically, and
    makes it so that the format message of each test is optional. It
    is mostly based on the Test::More Perl module." 
    + https://github.com/zorgnax/libtap
*** User-space hardware access 

 + [[https://libusb.info/][LibUSB]] (Access USB - Universal Serial Bus) - "A cross-platform user
   library to access USB devices - libusb is a C library that provides
   generic access to USB devices. It is intended to be used by
   developers to facilitate the production of applications that
   communicate with USB hardware. It is portable: Using a single
   cross-platform API, it provides access to USB devices on Linux, OS
   X, Windows, Android, OpenBSD, etc. It is user-mode: No special
   privilege or elevation is required for the application to
   communicate with a device. It is version-agnostic: All versions of
   the USB protocol, from 1.0 to 3.1 (latest), are supported."
   + Repository: https://github.com/libusb/libusb

 + [[https://github.com/OpenSC/OpenSC][OpenSC]] (Access Smart Cards) - "OpenSC provides a set of libraries
   and utilities to work with smart cards. Its main focus is on cards
   that support cryptographic operations, and facilitate their use in
   security applications such as authentication, mail encryption and
   digital signatures. OpenSC implements the standard APIs to smart
   cards, e.g. PKCS#11 API, Windows’ Smart Card Minidriver and macOS
   Tokend."

 + [[http://nfc-tools.org/index.php/Main_Page][LibNFC]] (NFC - Near Field Communication) - "libnfc is a library
   which allows userspace application access to NFC devices."
   + Respository: https://github.com/nfc-tools/libnfc

** Memory Allocators 

 + *Horad* - "The Hoard memory allocator is a fast, scalable, and
   memory-efficient memory allocator that works on a range of
   platforms, including Linux, Mac OS X, and Windows. Hoard is a
   drop-in replacement for malloc that can dramatically improve
   application performance, especially for multithreaded programs
   running on multiprocessors and multicore CPUs. No source code
   changes necessary: just link it in or set one environment variable
   (see Building Hoard, below)." 
   + https://github.com/emeryberger/hoard
   + Open source projects using Hoard include the Asterisk Open Source
     Telephony Project, Bayonne GNU telephony server, the Cilk
     parallel programming language, the GNU Common C++ system, the
     OpenFOAM computational fluid dynamics toolkit, and the SafeSquid
     web proxy. 

 + *Jemalloc* - "jemalloc is a general purpose malloc(3) implementation
   that emphasizes fragmentation avoidance and scalable concurrency
   support. jemalloc first came into use as the FreeBSD libc allocator
   in 2005, and since then it has found its way into numerous
   applications that rely on its predictable behavior. In 2010
   jemalloc development efforts broadened to include developer support
   features such as heap profiling and extensive monitoring/tuning
   hooks. Modern jemalloc releases continue to be integrated back into
   FreeBSD, and therefore versatility remains critical. Ongoing
   development efforts trend toward making jemalloc among the best
   allocators for a broad range of demanding applications, and
   eliminating/mitigating weaknesses that have practical repercussions
   for real world applications."
   + site: http://jemalloc.net/
   + repo: https://github.com/jemalloc/jemalloc

 + *Dmalloc* - "The debug memory allocation or dmalloc library has been
   designed as a drop in replacement for the system's malloc, realloc,
   calloc, free and other memory management routines while providing
   powerful debugging facilities configurable at runtime. These
   facilities include such things as memory-leak tracking, fence-post
   write detection, file/line number reporting, and general logging of
   statistics. The library is reasonably portable having been run
   successfully on at least the following operating systems: AIX,
   BSD/OS, DG/UX, Free/Net/OpenBSD, GNU/Hurd, HPUX, Irix, Linux,
   MS-DOG, NeXT, OSF, SCO, Solaris, SunOS, Ultrix, Unixware, Windoze,
   and even Unicos on a Cray T3E. It also provides support for the
   debugging of threaded programs."
   + site: http://dmalloc.com/
   + repo: https://github.com/j256/dmalloc

 + *Minimmaloc* - "mimalloc (pronounced "me-malloc") is a general
   purpose allocator with excellent performance
   characteristics. Initially developed by Daan Leijen for the
   run-time systems of the Koka and Lean languages." 
   + repo: https://github.com/microsoft/mimalloc

 + *snmalloc* - "Message passing based allocator"
   + repo: https://github.com/microsoft/snmalloc

** Language Binding and tools                                       :binding:
*** Python 

  + [[https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/tutorial/index.html][Boost.Python]]
    + Brief: "The Boost Python Library is a framework for interfacing
      Python and C++. It allows you to quickly and seamlessly expose
      C++ classes functions and objects to Python, and vice-versa,
      using no special tools -- just your C++ compiler. It is designed
      to wrap C++ interfaces non-intrusively, so that you should not
      have to change the C++ code at all in order to wrap it, making
      Boost.Python ideal for exposing 3rd-party libraries to
      Python. The library's use of advanced metaprogramming techniques
      simplifies its syntax for users, so that wrapping code takes on
      the look of a kind of declarative interface definition language
      (IDL)." 

  + [[https://pybind11.readthedocs.io/en/stable/][pybind11]] [BEST]
    + Brief: Allows to create Python modules in native code, aka
      libraries, with C++ >= C++11.

  + [[https://www.riverbankcomputing.com/software/sip/intro][SIP]] [TOOL] [BEST] - Tool for creating python bindings (libraries,
    aka modules) to existing C or C++ libraries. It is a code
    generator tool similar to SWIG that parses the codebase and
    generates the code C or C++ for Python native extension API. SIP
    was used for generating binding to PyQT.

*** Julia 

   * [[https://github.com/JuliaInterop/CxxWrap.jl][CxxWrap]]
     + "This package aims to provide a Boost.Python-like wrapping for
       C++ types and functions to Julia. The idea is to write the code
       for the Julia wrapper in C++, and then use a one-liner on the
       Julia side to make the wrapped C++ library available there. The
       mechanism behind this package is that functions and types are
       registered in C++ code that is compiled into a dynamic
       library. This dynamic library is then loaded into Julia, where
       the Julia part of this package uses the data provided through a C
       interface to generate functions accessible from Julia. The
       functions are passed to Julia either as raw function pointers
       (for regular C++ functions that don't need argument or return
       type conversion) or std::functions (for lambda expressions and
       automatic conversion of arguments and return types). The Julia
       side of this package wraps all this into Julia methods
       automatically."

   * [[https://github.com/JuliaInterop/Cxx.jl][Cxx.jl]]
     + "The Julia C++ Foreign Function Interface (FFI) and REPL. This
       package contains an experimental C++ REPL feature. Using the
       package will automatically add a new pane to your REPL that is
       accessible by pressing the < key."

*** Ruby 

 + [[https://github.com/jasonroelofs/rice][Rice]] - "Rice is a C++ interface to Ruby's C API. It provides a
   type-safe and exception-safe interface in order to make embedding
   Ruby and writing Ruby extensions with C++ easier. It is similar to
   Boost.Python in many ways, but also attempts to provide an
   object-oriented interface to all of the Ruby C API."
   + Doxygen: http://jasonroelofs.github.io/rice/

*** Java 

 + [[https://github.com/bytedeco/javacpp][JavaCPP]] - "JavaCPP provides efficient access to native C++ inside
   Java, not unlike the way some C/C++ compilers interact with
   assembly language. No need to invent new languages such as with
   SWIG, SIP, C++/CLI, Cython, or RPython. Instead, similar to what
   cppyy strives to do for Python, it exploits the syntactic and
   semantic similarities between Java and C++. Under the hood, it uses
   JNI, so it works with all implementations of Java SE, in addition
   to Android, Avian, and RoboVM (instructions)." 

*** C# Csharp .NET 

 + [[https://github.com/mono/CppSharp][CppSharp]] - "CppSharp is a tool and set of libraries which allows
   programmers to use C/C++ libraries with high-level programming
   languages (such as C#). It is a tool that takes C/C++ header and
   library files and generates the necessary glue to surface the
   native API as a managed API. Such an API can be used to consume an
   existing native library in your high-level code or add scripting
   support to a native codebase. The supported target languages at
   present are C# and C++/CLI. It can also be used as a library to
   parse native code into a syntax tree with a rich declaration and
   type information model." 
*** Javascript and NodeJS 
 
 + [[https://github.com/charto/nbind][nbind]]
   + "nbind is a set of headers that make your C++11 library
     accessible from JavaScript. With a single #include statement,
     your C++ compiler generates the necessary bindings without any
     additional tools. Your library is then usable as a Node.js addon
     or, if compiled to asm.js with Emscripten, directly in web pages
     without any plugins. nbind works with the autogypi dependency
     management tool, which sets up node-gyp to compile your library
     without needing any configuration (other than listing your source
     code file names). nbind is MIT licensed and based on templates
     and macros inspired by embind."

 + [[https://github.com/pmed/v8pp][v8pp]]
   + "Header-only library to expose C++ classes and functions into V8
     to use them in JavaScript code. v8pp uses heavy template
     metaprogramming and variadic template parameters which requires
     modern compiler with C++11 support."

*** PHP 

 + [[https://github.com/CopernicaMarketingSoftware/PHP-CPP][PHP-CPP]] - "The PHP-CPP library is a C++ library for developing PHP
   extensions. It offers a collection of well documented and
   easy-to-use classes that can be used and extended to build native
   extensions for PHP. The full documentation can be found on
   http://www.php-cpp.com." 
 
*** Bindings generators 

 + [[https://github.com/google/clif][google/cliff]] - "C++ Language Interface Foundation (CLIF) - CLIF
   provides a common foundation for creating C++ wrapper generators
   for various languages." 

** FFI - Foreign Function Interface                                 :binding:

  + [[https://sourceware.org/libffi/][libffi]] - "A Portable Foreign Function Interface Library. The libffi
    library provides a portable, high level programming interface to
    various calling conventions. This allows a programmer to call any
    function specified by a call interface description at run time. FFI
    stands for Foreign Function Interface. A foreign function interface
    is the popular name for the interface that allows code written in
    one language to call code written in another language. The libffi
    library really only provides the lowest, machine dependent layer of
    a fully featured foreign function interface. A layer must exist
    above libffi that handles type conversions for values passed between
    the two languages. "
    + Repo: https://github.com/libffi/libffi

  + [[https://www.gnu.org/software/libffcall/][libffcall - GNU Project - Free Software Foundation]]
    + "GNU libffcall is a library which can be used to build foreign
      function call interfaces in embedded interpreters."

  + [[http://www.dyncall.org/index][dyncall.org - calling C functions dynamically]]
    + "The dyncall library encapsulates architecture-, OS- and
      compiler-specific function call semantics in a virtual bind
      argument parameters from left to right and then call interface
      allowing programmers to call C functions in a completely dynamic
      manner. In other words, instead of calling a function directly,
      the dyncall library provides a mechanism to push the function
      parameters manually and to issue the call afterwards." 
** Embedded Scripting Languages                                     :binding:

Listing of programming languages designed to be embedded in C or C++
applications and available as libraries. 

 + *Lua* - Dynamically typed scripting language with minimal
   syntax and footprint widely used in Games and as extension or
   scripting language in many applications.
   + C++ Binding libraries:
     + [[https://github.com/ThePhD/sol2][ThePhD/sol2]]
     + [[https://github.com/satoren/kaguya][satoren/kaguya]]
     + [[https://github.com/radiotail/eluna][radiotail/eluna]]

 + *TCL - Tool Command Language* - Old, but is still used by many EDA -
   Electronic Design Automation tools and routers.

 + [[https://wdas.github.io/SeExpr/][SeExpr]] (developed by Disney) 
   + "SeExpr is an embeddable, arithmetic expression language that
     enables flexible artistic control and customization in creating
     computer graphics images. Example uses include procedural
     geometry synthesis, image synthesis, simulation control, crowd
     animation, and geometry deformation. Our library is licensed
     under the Apache License, Version 2.0."
   + Fetures: Arithmetic expression of scalar/vector types; Large
     library of built-in functions; Extensible variables and functions
     (including with DSOs); Simple to embed in any program; High-level
     UI components to manipulate and visualize expressions: an
     expression editor, with auto-completion a panel for control
     widgets, eg, sliders, ramp widgets, color widgets an image
     previewer an expression library browser.
   + Repo: https://github.com/wdas/SeExpr

 + [[http://www.squirrel-lang.org/][Squirrel]] -  "Squirrel is a high level imperative, object-oriented
   programming language, designed to be a light-weight scripting
   language that fits in the size, memory bandwidth, and real-time
   requirements of applications like video games."
  
 + [[https://www.angelcode.com/angelscript/][AngelScript]] - "The AngelCode Scripting Library, or AngelScript as
   it is also known, is an extremely flexible cross-platform scripting
   library designed to allow applications to extend their
   functionality through external scripts. It has been designed from
   the beginning to be an easy to use component, both for the
   application programmer and the script writer."
   + Features: statically typed and syntax similar to C++, code in C++
     which makes the integration easeir.
   + Repo mirror: https://github.com/IngwiePhoenix/AngelScript

 + [[http://chaiscript.com/][ChaiScript]] - "ChaiScript is one of the only embedded scripting
   language designed from the ground up to directly target C++ and
   take advantage of modern C++ development techniques, working with
   the developer how they would expect it to work. Being a native C++
   application, it has some advantages over existing embedded
   scripting languages: It uses a header-only approach, which makes it
   easy to integrate with existing projects; It maintains type safety
   between your C++ application and the user scripts; It supports a
   variety of C++ techniques including callbacks, overloaded
   functions, class methods, and stl containers."
   + Repo: https://github.com/ChaiScript/ChaiScript
   + Problem: Long compile-time due to the library be header-only and
     the usage of C++ regex library. 

 + [[https://duktape.org/][Duktape]] - "Duktape is an embeddable Javascript engine, with a focus
   on portability and compact footprint. Duktape is easy to integrate
   into a C/C++ project: add duktape.c, duktape.h, and duk_config.h to
   your build, and use the Duktape API to call ECMAScript functions
   from C code and vice versa."
   + Repo: https://github.com/svaarala/duktape

 + [[http://www.espruino.com/][Espruino]] - "Espruino is a JavaScript interpreter for
   microcontrollers. It is designed for devices with as little as
   128kB Flash and 8kB RAM."
   + Repo: https://github.com/espruino/Espruino

 + [[https://github.com/jerryscript-project/jerryscript][Jerryscript]] - "JerryScript is a lightweight JavaScript engine for
   resource-constrained devices such as microcontrollers. It can run
   on devices with less than 64 KB of RAM and less than 200 KB of
   flash memory. Key characteristics of JerryScript: Full ECMAScript
   5.1 standard compliance; 160K binary size when compiled for ARM
   Thumb-2; Heavily optimized for low memory consumption; Written in
   C99 for maximum portability; Snapshot support for precompiling
   JavaScript source code to byte code Mature C API, easy to embed in
   applications"
   + Repo: https://github.com/jerryscript-project/jerryscript

 + [[http://www.gmscript.com/][gmscript]] - "GameMonkey is a embedded scripting language that is
   intended for use in game and tool applications. GameMonkey is
   however suitable for use in any project requiring simple scripting
   support. GameMonkey borrows concepts from Lua (www.lua.org), but
   uses syntax similar to C, making it more accessible to game
   programmers. GameMonkey also natively supports multithreading and
   the concept of states."
   + Repo: https://github.com/publicrepo/gmscript

 + [[https://marcobambini.github.io/gravity/#/][Gravity]] - "Gravity is a powerful, dynamically typed, lightweight,
   embeddable programming language written in C without any external
   dependencies (except for stdlib). It is a class-based concurrent
   scripting language with a modern Swift like syntax. Gravity
   supports procedural programming, object-oriented programming,
   functional programming and data-driven programming. Thanks to
   special built-in methods, it can also be used as a prototype-based
   programming language."
   + Repo: https://github.com/marcobambini/gravity

 + [[http://wren.io/][Wren]] - "Wren is a small, fast, class-based concurrent scripting
   language. Think Smalltalk in a Lua-sized package with a dash of
   Erlang and wrapped up in a familiar, modern syntax."
   + Repo:
     + https://github.com/wren-lang/wren
     + https://github.com/Nelarius/wrenpp (C++ Wrapper)

 + [[https://never-lang.readthedocs.io/en/latest/][Never-lang]] - "Never is a simple functional programming
   language. Technically it may be classified as syntactically scoped,
   strongly typed, call by value, functional programming language. In
   practise Never offers basic data types, assignment, control flow,
   arrays, first order functions and some mathematical functions to
   make it useful to calculate expressions. Also it demonstrates how
   functions can be compiled, invoked and passed as parameters or
   results between other functions."
   + Repo: https://github.com/never-lang/never

 + [[https://github.com/mruby/mruby][mruby]] - Embeddedable Ruby Implementation
   * Github: https://github.com/mruby/mruby
   * "mruby is the lightweight implementation of the Ruby language
     complying to (part of) the ISO standard. Its syntax is Ruby 1.9
     compatible. mruby can be linked and embedded within your
     application. We provide the interpreter program "mruby" and the
     interactive mruby shell "mirb" as examples. You can also
     compile Ruby programs into compiled byte code using the mruby
     compiler "mrbc". All those tools reside in the "bin"
     directory. "mrbc" is also able to generate compiled byte code
     in a C source file, see the "mrbtest" program under the "test"
     directory for an example."

 + [[http://synthcode.com/wiki/chibi-scheme][Scheme / Lisp]] (Chibi Scheme Implementation)
   * "Chibi-Scheme [1] is a very small library intended for use as
     an extension and scripting language in C programs. In addition
     to support for lightweight VM-based threads, each VM itself
     runs in an isolated heap allowing multiple VMs to run
     simultaneously in different OS threads."
   * Github: https://github.com/ashinn/chibi-scheme
   * [[http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html][Embedding Scheme for a game mission scripting DSL]]

 + [[https://en.wikipedia.org/wiki/TinyScheme][Scheme / Lisp]] (TinyScheme Implementation)
   * Official Web Site: http://tinyscheme.sourceforge.net/home.html
   * Small embeddable Scheme implementation used by GNU GIMP image
     editor.

** Numerical and General Scientifc Computing               :math:hpc:general:
*** General Purpose

+ [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/overview.html][Boost Math toolkit]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/interpolation.html][Interpolation]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/quadrature.html][Quadrature and Differentiation]]

+ *GNU Scientific Library - GSL* (C-Library) - "The library provides a
  wide range of mathematical routines such as random number
  generators, special functions and least-squares fitting. There are
  over 1000 functions in total with an extensive test suite."
  + Site:
    + https://www.gnu.org/software/gsl/
  + Documentation:
    + https://www.gnu.org/software/gsl/doc/html/index.html
  + Repository:

+ *GLPK* - *GNU Linear Programming Kit* (C and Fortran Library) - "The GLPK (GNU Linear
  Programming Kit) package is intended for solving large-scale linear
  programming (LP), mixed integer programming (MIP), and other
  related problems. It is a set of routines written in ANSI C and
  organized in the form of a callable library."
  + Site: https://www.gnu.org/software/glpk/
  + Example:
    + https://en.wikibooks.org/wiki/GLPK/Using_the_GLPK_callable_library
  + GPLK for Windows: http://winglpk.sourceforge.net/

+ *NAG C Libraries* from Numerical Algorithm Group [COMMERCIAL] - "The
  world’s largest collection of robust, documented, tested and
  maintained numerical algorithms." 
  + Site: https://www.nag.co.uk/nag-c-library
  + [[https://www.nag.com/content/cplusplus-wrappers-nag-c-library][C++ Wrappers]]

+ *IMSL (International Mathematics and Statistics Library) Numeric* *Libraries* [COMMERCIAL] (C and Fortran)
  + "The IMSL Numerical Libraries are a comprehensive set of
    mathematical and statistical functions that programmers can embed
    into their software applications. Using these libraries adds
    performance and quality to an application and saves developers
    time because they don't need to write the functionality
    themselves. IMSL is composed of the following types of functions:
    Matrix Operations, Linear Algebra, Interpolation, Approximation,
    Numerical Quadrature, OPtimization, Special Functions, Finance adn
    Bond Calculation, Statistics, Time Series & Forecatising, Da
    minining, Distribution Functions, Neural Network"
  + See:
    + [[https://software.intel.com/en-us/articles/imsl-licensing-frequently-asked-questions][IMSL Licensing Frequently Asked Questions]]
    + [[https://www.roguewave.com/products-services/imsl-numerical-libraries][IMSL Numerical Libraries]]
  + Documentation:
    + https://docs.roguewave.com/en/imsl/

+ *Intel MKL* - Intel Math Kernel Library - [FREWARE] (C and Fortran
  Library) - "Intel® Math Kernel Library (Intel® MKL) optimizes code
  with minimal effort for future generations of Intel® processors. It
  is compatible with your choice of compilers, languages, operating
  systems, and linking and threading models.". Note: only C shared
  and static libraries are provided, not the source code. 
  + Site: https://software.intel.com/en-us/mkl
  + License:
    + [[https://software.intel.com/en-us/license/intel-simplified-software-license][Intel Simplified Software License (Version April 2018)]]
    + [[https://software.intel.com/en-us/mkl/license-faq][FAQ]]
  + Documentation:
    + https://software.intel.com/en-us/mkl-developer-reference-c
  + Wikipedia:
    + https://en.wikipedia.org/wiki/Math_Kernel_Library
  + Github:
    + https://github.com/intel/mkl-dnn
     
+ *Ceres Solver* "Ceres Solver [1] is an open source C++ library for
  modeling and solving large, complicated optimization problems. It
  can be used to solve Non-linear Least Squares problems with bounds
  constraints and general unconstrained optimization problems. It is
  a mature, feature rich, and performant library that has been used
  in production at Google since 2010. For more, see Why?. "
  + Site: http://ceres-solver.org/
  + Docs: http://ceres-solver.org/tutorial.html
  + Repo: https://github.com/ceres-solver/ceres-solver

+ *ARB* - *C library for arbitrary-precision ball arithmetic*
  + "Arb is a C library for rigorous real and complex arithmetic with
    arbitrary precision. Arb tracks numerical errors automatically
    using ball arithmetic, a form of interval arithmetic based on a
    midpoint-radius representation. On top of this, Arb provides a
    wide range of mathematical functionality, including polynomials,
    power series, matrices, integration, root-finding, and many
    transcendental functions. Arb is designed with efficiency as a
    primary goal, and is usually competitive with or faster than
    other arbitrary-precision packages. The code is thread-safe,
    portable, and extensively tested. Arb is free software
    distributed under the GNU Lesser General Public License (LGPL),
    version 2.1 or later"
  + Site: http://arblib.org/
  + Repo: https://github.com/fredrik-johansson/arb/

+ *Trillinos* (Develped by Sandia National Laboratories) - "The
  Trilinos Project is an effort to develop algorithms and enabling
  technologies within an object-oriented software framework for the
  solution of large-scale, complex multi-physics engineering and
  scientific problems. A unique design feature of Trilinos is its
  focus on packages."
  + Site: https://trilinos.github.io/
  + Repo: https://github.com/trilinos/Trilinos
  + See:
    + https://en.wikipedia.org/wiki/Trilinos

+ *FFTW* - "FFTW is a C subroutine library for computing the discrete
  Fourier transform (DFT) in one or more dimensions, of arbitrary
  input size, and of both real and complex data (as well as of
  even/odd data, i.e. the discrete cosine/sine transforms or
  DCT/DST). We believe that FFTW, which is free software, should
  become the FFT library of choice for most applications." 
  + Site: http://www.fftw.org/

+ *Apophenia* - "Apophenia is an open statistical library for working
  with data sets and statistical models. It provides functions on the
  same level as those of the typical stats package (such as OLS,
  Probit, or singular value decomposition) but gives the user more
  flexibility to be creative in model-building. The core functions
  are written in C, but experience has shown them to be easy to bind
  to in Python/Julia/Perl/Ruby/&c. It is written to scale well, to
  comfortably work with gigabyte data sets, million-step simulations,
  or computationally-intensive agent-based models."
  + Site: http://apophenia.info/
  + Repo: https://github.com/b-k/apophenia

*** CAS - Computer Algebra System, Symbolic Manipulation and Formula Evaluation 

+ *TinyExpr* - tiny recursive descent expression parser, compiler, and
  evaluation engine for math expressions.
  + Site: https://codeplea.com/tinyexpr
  + Repo: https://github.com/codeplea/tinyexpr

+ *SymEngine* - SymEngine is a fast symbolic manipulation library,
  written in C++
  + Site: https://www.sympy.org/en/index.html
  + Repo: https://github.com/symengine/symengine

+ *GiNac* - "GiNaC is a C++ library. It is designed to allow the
  creation of integrated systems that embed symbolic manipulations
  together with more established areas of computer science (like
  computation- intense numeric applications, graphical interfaces,
  etc.) under one roof. It is distributed under the terms and
  conditions of the GNU general public license (GPL). GiNaC is an
  iterated and recursive acronym for GiNaC is Not a CAS, where CAS
  stands for Computer Algebra System." 
  + Site: https://ginac.de/

+ *FORM* - The FORM project for symbolic manipulation of very big
  expressions.
  + Site: https://www.nikhef.nl/~form/aboutform/aboutform.html
  + Repository: https://github.com/vermaseren/form

+ *Exprtk* (Formula parser and evaluator) - "The C++ Mathematical
  Expression Toolkit Library (ExprTk) is a simple to use, easy to
  integrate and extremely efficient run-time mathematical expression
  parser and evaluation engine. ExprTk supports numerous forms of
  functional, logical and vector processing semantics and is very
  easily extendible."
  + Site: http://www.partow.net/programming/exprtk/
  + Repo: https://github.com/ArashPartow/exprtk

+ *IXION* - (Formula/spreadsheet evaluator) - "Ixion is a general
  purpose formula parser & interpreter that can calculate multiple
  named targets, or "cells". The goal of this project is to create a
  library for calculating the results of formula expressions stored in
  multiple named targets, or "cells".  The cells can be referenced
  from each other, and the library takes care of resolving their
  dependencies automatically upon calculation. The caller can run the
  calculation routine either in a single-threaded mode, or a
  multi-threaded mode.  The library also supports re-calculations
  where the contents of one or more cells have been modified since the
  last calculation, and a partial calculation of only the affected
  cells need to be calculated."
  + Site: https://ixion.readthedocs.io/en/latest/cpp/index.html
  + Repo: https://gitlab.com/ixion/ixion

*** Linear Algebra

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/doc/index.html][Boost.Ublas]] - "uBLAS is a C++ template class library that provides
  BLAS level 1, 2, 3 functionality for dense, packed and sparse
  matrices. The design and implementation unify mathematical notation
  via operator overloading and efficient code generation via
  expression templates." 

+ [[http://eigen.tuxfamily.org/index.php?title=Main_Page#Documentation][Eigen]] - "Eigen is a C++ template library for linear algebra:
  matrices, vectors, numerical solvers, and related algorithms."

+ [[http://arma.sourceforge.net/][Armadillo]] - "C++ library for linear algebra & scientific computing"

+ [[https://sourceforge.net/projects/blitz/][Blitz++]] - "Blitz++ is a C++ class library for scientific computing
  which provides performance on par with Fortran 77/90. It uses
  template techniques to achieve high performance. Blitz++ provides
  dense arrays and vectors, random number generators, and small
  vectors (useful for representing multicomponent or vector fields)."

+ [[https://bitbucket.org/blaze-lib/blaze][Blaze]] - "Blaze is an open-source, high-performance C++ math library
  for dense and sparse arithmetic. With its state-of-the-art Smart
  Expression Template implementation Blaze combines the elegance and
  ease of use of a domain-specific language with HPC-grade
  performance, making it one of the most intuitive and fastest C++
  math libraries available."

+ [[https://github.com/wichtounet/etl][ETL]] - Expression Templates Library (ETL) with GPU support

+ [[https://sleef.org/][SLEEF]] - SLEEF Vectorized Math Library - " SLEEF stands for SIMD
  Library for Evaluating Elementary Functions. It implements
  vectorized versions of all C99 real floating point math
  functions. It can utilize SIMD instructions of modern
  processors. SLEEF is designed to fully utilize SIMD computation by
  reducing the use of conditional branches and scatter/gather memory
  access. Our benchmarks show that the performance of SLEEF is
  comparable to that of the best commercial library. Unlike
  vendor-tuned libraries, SLEEF is portable : it can be easily ported
  to other architectures by writing a helper file, which is a thin
  abstraction layer of SIMD intrinsics. SLEEF is also designed to
  work with various operating systems and compilers." 
  + https://github.com/shibatch/sleef
*** Optimization

   + [[https://www.kthohr.com/optimlib.html][Optmlib]] - "OptimLib is a lightweight C++ library of numerical
     optimization methods for nonlinear functions."
     + https://github.com/kthohr/optim

   + [[https://github.com/stevengj/nlopt][NLOpt]] - "NLopt is a free/open-source library for nonlinear
     optimization, providing a common interface for a number of
     different free optimization routines available online as well as
     original implementations of various other algorithms."
     + https://nlopt.readthedocs.io/en/latest/

*** Finite Element Methods 
 
+ *getfem* - "GetFEM++ is an open source library based on collaborative
  development. It aims to offer the most flexible framework for
  solving potentially coupled systems of linear and nonlinear partial
  differential equations with the finite element method. GetFEM++ is
  interfaced with some script languages (Python, Scilab and Matlab)
  so that almost all of the functionalities can be used just writing
  scripts. It works in arbitrary dimension and allow to couple 1D, 2D
  and 3D problems. GetFEM++ can be used to construct very generic
  finite element codes, where finite element methods, integration
  methods and the dimension of the problem are the parameters that
  can be changed very easily. This allows a wide range of
  experiments. Many examples and demos are provided." 
  + Site: http://getfem.org/

+ *MFem* - MFEM is a free, lightweight, scalable C++ library for finite
  element methods.
  + Features
    + Arbitrary high-order finite element meshes and spaces.
    + Wide variety of finite element discretization approaches.
    + Scalable to hundreds of thousands of cores.
  + Site: https://mfem.org/
  + Repo: https://github.com/mfem/mfem

+ *OFELI* - An Object Oriented Finite Element Library
  + "Based on a long experience in the development of finite element
    software, OFELI (Object Finite Element LIbrary) is a framework of
    C++ classes for the development of finite element programs. Its
    main features are:"
    + Various storage schemes of matrices (dense, sparse, skyline).
    + Direct methods of solution of linear systems of equations as well
      as various combinations of iterative solvers and
      preconditioners. 
    + Shape functions of most "popular" finite elements
    + Numerical solution of eigenvalue problems
    + Classes for the solution of most popular problems (Heat
      Transfer, Fluid Flow, Solid Mechanics, Electromagnetics, ...).
  + Site: http://www.ofeli.org/
  
+ *Kratos Multiphysics (A.K.A Kratos)* - A framework for building parallel multi-disciplinary simulation software
  + "A framework for building parallel multi-disciplinary simulation software. Kratos is free under BSD-4 license and can be used even in comercial softwares as it is. Many of its main applications are also free and BSD-4 licensed but each derived application can have its own propietary license. Its
    main features are:"
    + Kratos is multiplatform and available for Windows, Linux (several distros) and macOS.
    + Kratos is OpenMP and MPI parallel and scalable up to thousands of cores.
    + Kratos provides a core which defines the common framework and several application which work like plug-ins that can be extended in diverse fields.
  + Site: https://github.com/KratosMultiphysics/Kratos
** Domain Specific Scientific and Engineering Libraries :math:scientific:technical:hpc:

    + [[https://proj-clhep.web.cern.ch/proj-clhep/][CLHEP]]  - A Class Library for High Energy Physics (CERN)

    + [[https://root.cern.ch/doc/v606/dir_90274118d43186b3dd199f7d2c0e1afe.html][CERN's Root Framework]] (Domain: High Energy Physics)
      + Description: ROOT Framework comprises the Cling C++ interactive
        interpreter; C++ reflection system (reflex); special mathematical
        functions ; plotting tools and GUI.
      + [[http://alicematters.web.cern.ch/?q=content/node/1053][40 Years of Large Scale Data Analysis in HEP: Interview with René Brun | ALICE Matters]]
      + 

    + [[https://cpp.openfoam.org/v6/index.html][OpenFoam]] (Domain: Physics, Mechanical Engineering and Chemical Engineering)
      * Open Source C++ library for CFD (Computational Fluid
        Dynamics) with toolboxes for fluid dynamics, chemical reactions,
        turbulence, heat transfer and so on.
      * More at: https://en.wikipedia.org/wiki/OpenFOAM
      * Doxygen Configuration:
        * https://github.com/OpenFOAM/OpenFOAM-6/tree/master/doc

    + [[http://mechsys.nongnu.org/][Mechsys]] - Multi-physics Simulation Library (Domain: Physics,
      Mechanical and Chemical Engineering) - "MechSys is aprogramming
      library for the implementation of simulation tools in
      mechanics. Its source code is mainly written in C++ with easier to
      use templates for further customization. Potential applications
      include, for instance, *solid mechanics* and the *dynamics of granular*
      materials using the *discrete element method*, and both computational
      *fluid dynamics* and *computational electromagnetics* using the *lattice*
      *Boltzmann method.*"

    + [[http://www.palabos.org/][Palabos]] - [[http://www.palabos.org/documentation/develguide/index.html][Doxygen]] (Domain: Physics, Mechanical/Chemical Engineering CFD)
      * Library for CFD - Computational Fluid Dynamics based on the
        lattice Boltzmann method. 

    + [[http://cantera.github.io/docs/sphinx/html/index.html][Cantera]] - [[http://web.mit.edu/2.62/cantera/doc/html/namespaceCantera.html][Doxygen]] (Domain: Chemical Engineering, Thermodynamics and Transport Processes)
      * "Cantera is an open-source suite of object-oriented software
        tools for problems involving chemical kinetics, thermodynamics,
        and/or transport processes. The software automates the chemical
        kinetic, thermodynamic, and transport calculations so that the
        users can efficiently incorporate detailed chemical
        thermo-kinetics and transport models into their calculations. The
        code utilizes object-oriented concepts for robust yet flexible
        phase models, and algorithms are generalized so that users can
        explore different phase models with minimal changes to their
        overall code. Currently, Cantera can be used from Python and
        Matlab, or in applications written in C/C++ and
        Fortran 90. Cantera also provides a limited number of solvers for
        time-dependent reactor networks and steady one-dimensional
        reacting flows. Cantera is currently used for applications
        including combustion, detonations, electrochemical energy
        conversion and storage, fuel cells, batteries, aqueous
        electrolyte solutions, plasmas, and thin film deposition."

    + [[https://libantioch.github.io/][Antioch]] - C++ Chemical Kinetics, Thermodynaimics, and Transport
      Library - "A New Templated Implementation Of Chemistry for
      Hydrodynamics (Antioch) was initiated to centralize work by some of
      the Antioch authors within the realm of hypersonic aerodynamics,
      based on the libMesh finite element library. In particular,
      although there exist C++ chemistry libraries, such as Cantera, we
      had needs for both thread-safety and high performance. Thus,
      Antioch was born. Antioch originally lived within the PECOS center
      at the Institute for Computational Engineering and Sciences (ICES)
      at The University of Texas at Austin." 
      * Repo: https://github.com/libantioch/antioch
      * [[https://libantioch.github.io/antioch/v0.4.0/html/namespaces.html][Doxygen docs]]

    + [[https://github.com/CoolProp/IF97][CoolProp/IF97]] - (Domain: Mechanical and Chemical Engineering) -
      Open-source C++ implementation of the IAPWS-IF97 equations - IAPWS
      Industrial Formulation 1997 for the Thermodynamic Properties of
      Water and Steam. Note: software for computing water and steam
      thermodynamic properties (Steam tables). 

    + [[https://www.roboticslibrary.org/][Robotics Library]] - [[http://doc.roboticslibrary.org/0.7.0/index.html][Doxygen]] (Domain: Robotics Kinematics, Mechanical Engineering)
      * "The Robotics Library (RL) is a self-contained C++ library for
        robot kinematics, motion planning and control. It covers
        mathematics, kinematics and dynamics, hardware abstraction,
        motion planning, collision detection, and visualization. It is
        being used by several research projects (e.g., JAHIR, JAMES,
        JAST, SMErobotics) and in education, available under a BSD
        license, and free for use in commercial applications."

    + [[https://www.groundai.com/project/the-control-toolbox-an-open-source-c-library-for-robotics-optimal-and-model-predictive-control/][Control Toolbox]] - [[https://adrlab.bitbucket.io/ct/v2.3/ct_doc/doc/html/index.html][Doxygen]] (Domain: Robotics, Control Systems, Mechanical Engineering)
      * "This is the ADRL Control Toolbox ('CT'), an open-source C++
        library for efficient modelling, control, estimation, trajectory
        optimization and model predictive control. The CT is applicable
        to a broad class of dynamic systems, but features additional
        modelling tools specially designed for robotics. This page
        outlines its general concept, its major building blocks and
        highlights selected application examples. The library contains
        several tools to design and evaluate controllers, model dynamical
        systems and solve optimal control problems."

    + [[https://drake.mit.edu/][Drake]] - [[https://drake.mit.edu/doxygen_cxx/index.html#://][Doxygen]] Collection of C++ tools for analysing Robot dynamics and
      building motion control systems.
      * "While there are an increasing number of simulation tools
        available for robotics, most of them function like a black box:
        commands go in, sensors come out. Drake aims to simulate even
        very complex dynamics of robots (e.g. including friction,
        contact, aerodynamics, …), but always with an emphasis on
        exposing the structure in the governing equations (sparsity,
        analytical gradients, polynomial structure, uncertainty
        quantification, …) and making this information available for
        advanced planning, control, and analysis algorithms. Drake
        provides interfaces to high-level languages (MATLAB, Python, …)
        to enable rapid-prototyping of new algorithms, and also aims to
        provide solid open-source implementations for many
        state-of-the-art algorithms. Finally, we hope Drake provides many
        compelling examples that can help people get started and provide
        much needed benchmarks. We are excited to accept user
        contributions to improve the coverage."

    + [[http://jsbsim.sourceforge.net/][JBSim]] - [[https://jsbsim-team.github.io/jsbsim/index.html#intro][Doxygen]] (Domain: Aerospace/Mechanical Engineering)
      * An open source, platform-independent, flight dynamics & control
        software library in C++
      * "JSBSim is an open source flight dynamics model (FDM) that
        compiles and runs under many operating systems, including
        Microsoft Windows, Apple Macintosh, Linux, IRIX, Cygwin (Unix on
        Windows), etc. The FDM is essentially the physics/math model that
        defines the movement of an aircraft, rocket, etc., under the
        forces and moments applied to it using the various control
        mechanisms and from the forces of nature. JSBSim has no native
        graphics. It can be run by itself as a standalone program, taking
        input from a script file and various vehicle configuration
        files. It can also be incorporated into a larger flight simulator
        implementation that includes a visual system."

    + [[https://simtk.org/][simtk]] - [[https://simtk.org/api_docs/opensim/api_docs/index.html][Doxygen]] (Domain: Biomedical research.)

    + [[https://libpf.com/docs/manuals/sdk.html][LIBPF]] - Flexible Process Flowsheeting [Commercial] => Library for
      modelling continous processes. (Chemical Engineering)
      + "LIBPF™: (LIBrary for Process Flowsheeting), library developed in
        C++ language, which includes objects well-known to a process
        engineer (dimensional quantities, material streams, reactions,
        phase separators, heat exchangers, reactors, etc.). This library
        make possible the creation of executable applications specific
        for a particular continuous industrial process. It is oriented to
        a system modeling and not for detailed single unit operation
        modeling." 

    + [[http://kalman.sourceforge.net/][KFilter]] -  KFilter - Free C++ Extended Kalman Filter Library
      * "KFilter is a library implementing an Extended Kalman Filter in
        C++. Configurable template classes are available. Subclassing
        allows to define different matrix contents for the filter to work
        with. Kalman filters are used for some time now, in aeronautics,
        robot vision and robotics in general. It is useful to estimate a
        state vector and correct the estimation by using measures taken
        from sensors. Its main uses is for tracking or data fusion. The
        library is fully operational and has been used in two research
        projects at Ecole Polytechnique de Montreal."

    + [[http://web.mit.edu/drela/Public/web/avl/][AVL]] - "AVL is a program for the aerodynamic and flight-dynamic
      analysis of rigid aircraft of arbitrary configuration. It employs
      an extended vortex lattice model for  the lifting surfaces,
      together with a slender-body model for fuselages and nacelles.
      General nonlinear flight states can be specified. The flight
      dynamic analysis  combines a full linearization of the aerodynamic
      model about any flight state,  together with specified mass
      properties."
      * Note: NOT A LIBRARY, it is an open source program written in C.
      * Video: [[https://www.youtube.com/watch?v=kS9iPD5irIo][Introduction to Aerodynamic Analysis using AVL]]
      * Related Repositories:
        + https://github.com/renoelmendorp/AVLWrapper
        + https://github.com/RobotLocomotion/avl (Fork of Mark Drela's
          AVL software (http://raphael.mit.edu/avl) which builds using
          cmake.)

    + [[http://fdtd.kintechlab.com/en/start][EMTL]] - *Electromagnetic Template Library* (Domain: Electronic
      Engineering and Physics) - is a С++ library forprogramming
      Finite-Difference Time-Domain (FDTD) simulations.
      * "The program is designed for quick and efficient programming of
        FDTD simulations and for extending the available FDTD algorithms
        with new techniques and features. The code implements fully
        functional API including MPI parallelization."
      * Capabilities
        * Calculation of the distribution of electromagnetic fields in a structure;
        * Real-time simulation of the propagation of electromagnetic wave packet through a structure;
        * Calculation of the transmission, reflection, and absorption
          coefficients as functions of incident wavelength and angle for
          periodic structures;
        * Calculation of the scattering cross-section and the angle
          distribution of the scattered wave for objects of arbitrary
          shape;
        * Sensitivity analysis of the impact of defects on the optical
          properties of periodic structures (photonic crystals);
        * Calculation of transfer-matrix (T-matrix) for planar layers of
          arbitrarily shaped scatterers;

    + [[https://github.com/tmolteno/necpp][NECPP]] - Antenna Modelling Library -  rewrite of the Numerical
      Electromagnetics Code (NEC-2) 
      * "NEC2++ is a C++ rewrite of the Numerical Electromagnetics Code
        (NEC-2) with many new features like automatic error detection
        when you specify the structure incorrectly and much faster
        execution. Nec2++ can analyse radiating as well as scattering
        properties of structures. The simulation engine in Nec2++ is
        compiled into a library for easy integration."
      * See:
        * http://elec.otago.ac.nz/w/index.php/Necpp
        * [[https://en.wikipedia.org/wiki/Numerical_Electromagnetics_Code][Numerical Electromagnetics Code]]
        * https://www.nec2.org/

    + [[https://github.com/gnuradio/gnuradio][GNU Radio]] - "GNU Radio is a free & open-source software
      development toolkit that provides signal processing blocks to
      implement software radios. It can be used with readily-available,
      low-cost external RF hardware to create software-defined radios,
      or without hardware in a simulation-like environment. It is
      widely used in hobbyist, academic, and commercial environments to
      support both wireless communications research and real-world
      radio systems."
      * Site: https://www.gnuradio.org/
      * Repo: https://github.com/gnuradio/gnuradio

    + [[https://github.com/kit-cel/gr-radar][gr-radio]] - *GNU Radio Radar Toolbox*
      * Site: https://grradar.wordpress.com/
      * Repo: https://github.com/kit-cel/gr-radar
      * See:
        * [[https://www.rochesterham.org/meetings/2015-12_SDR_Program.pdf][Exploring RF with Software Defined Radio]]
        * [[https://www.youtube.com/watch?v=WeGSCGN8DIo][gr-radar: GUI Demonstration with FSK Radar]]

    + [[https://github.com/jopohl/urh][jopohl/urh]] - Universal Radio Hacker: investigate wireless protocols like a boss.
      + "The Universal Radio Hacker (URH) is a software for
        investigating unknown wireless protocols. Features include:
        hardware interfaces for common Software Defined Radios; easy
        demodulation of signals; assigning participants to keep
        overview of your data; customizable decodings to crack even
        sophisticated encodings like CC1101 data whitening; assign
        labels to reveal the logic of the protocol; ... ..."

    + [[https://liquidsdr.org][liquid-DSP]] - "liquidsdr.org is home to liquid-dsp, a free and
      open-source signal processing library for software-defined radios
      written in C. Its purpose is to provide a set of extensible DSP
      modules that do not rely on external dependencies or cumbersome
      frameworks. The project is now hosted on github."
      + Repo: https://github.com/jgaeddert/liquid-dsp

    + [[http://luaradio.io/][luaradio]] - "LuaRadio is a lightweight, embeddable flow graph signal
      processing framework for software-defined radio. It provides a
      suite of source, sink, and processing blocks, with a simple API for
      defining flow graphs, running flow graphs, creating blocks, and
      creating data types. LuaRadio is built on LuaJIT, has a small
      binary footprint of under 750 KB (including LuaJIT), has no
      external hard dependencies, and is MIT licensed. LuaRadio can be
      used to rapidly prototype software radios, modulation/demodulation
      utilities, and signal processing experiments. It can also be
      embedded into existing radio applications to serve as a user
      scriptable engine for processing samples."

    + [[https://github.com/mossmann/hackrf][hackfr]] - "This repository contains hardware designs and software
      for HackRF, a low cost, open source Software Defined Radio
      platform."

    + [[https://github.com/hmatuschek/libsdr][LIBSDR]] - A simple software defined radio (SDR) library
      * Doxygen: https://hmatuschek.github.io/libsdr/

    + [[https://github.com/vinniefalco/DSPFilters][DSPFilters]] - A Collection of Useful C++ Classes for Digital Signal Processing
      * "Building on the work of cherished luminaries such as Sophocles
        Orfanidis, Andreas Antoniou, Martin Holters, and Udo Zolzer, this
        library harnesses the power of C++ templates to solve a useful
        problem in Digital Signal Processing: the realization of
        multichannel IIR filters of arbitrary order and prescribed
        specifications with various properties such as Butterworth,
        Chebyshev, Elliptic, and Optimum-L (Legendre) responses. The
        library is provided under the MIT license and is therefore fully
        compatible with proprietary usage." 

    + [[http://itpp.sourceforge.net/4.3.1/][ITPP]] - "IT++ is a C++ library of mathematical, signal processing
      and communication classes and functions. Its main use is in
      simulation of communication systems and for performing research in
      the area of communications. The kernel of the library consists of
      generic vector and matrix classes, and a set of accompanying
      routines. Such a kernel makes IT++ similar to MATLAB, GNU Octave or
      SciPy." 

    + [[https://github.com/seqan/seqan][Seqan]] - The Library for Sequence Analysis (Biology)
      * "SeqAn is an open source C++ library of efficient algorithms and
        data structures for the analysis of sequences with the focus on
        biological data. Our library applies a unique generic design that
        guarantees high performance, generality, extensibility, and
        integration with other libraries. SeqAn is easy to use and
        simplifies the development of new software tools with a minimal
        loss of performance."

    + [[https://www.openchemistry.org/][Openchemistry]] 
      + "The Open Chemistry project is a collection of open source, cross
        platform libraries and applications for the exploration, analysis
        and generation of chemical data. The project builds upon various
        efforts by collaborators and innovators in open chemistry such as
        the Blue Obelisk, Quixote and the associated projects. We aim to
        improve the state of the art, and facilitate the open exchange of
        ideas and exchange of chemical data leveraging the best
        technologies ranging from quantum chemistry codes, molecular
        dynamics, informatics and visualization. This repository contains
        git submodules for the Open Chemistry projects: Avogadro,
        MoleQueue and MongoChem. It can be used to download all relevant
        source files as well as building many of the necessary
        dependencies. Please see the documentation in the submodules for
        more details about each project."
        + Repository: https://github.com/cryos/openchemistry

** Machine Learning and Computer Vision

 + [[https://docs.opencv.org/3.4/d4/db1/tutorial_documentation.html][OpenCV]] - Computer Vision / Machine Learning - The most well-known
   computer vision and image processing library. 
   * Repo: https://github.com/opencv/opencv

 + [[http://dlib.net/][Dlib]] - Open source library for deep learning, numerical algorithms,
   networks and image processing.

 + [[http://torch.ch/][Torch]] - "Torch is a scientific computing framework with wide support
   for machine learning algorithms that puts GPUs first. It is easy to
   use and efficient, thanks to an easy and fast scripting language,
   LuaJIT, and an underlying C/CUDA implementation."
   + Repo: https://github.com/torch/torch7

 + [[http://www.csie.ntu.edu.tw/~cjlin/liblinear/][liblinear]]

 + [[http://mlpack.org/][Mlpack]] - Machine Learning Package 

 + [[http://shogun-toolbox.org/][Shogun Toolbox]] - "Shogun is and open-source machine learning
   library that offers a wide range of efficient and unified machine
   learning methods." 

 + [[http://leenissen.dk/fann/wp/][Fann]] - "Fast Artificial Neural Network Library is a free open
   source neural network library, which implements multilayer
   artificial neural networks in C with support for both fully
   connected and sparsely connected networks. Cross-platform execution
   in both fixed and floating point are supported. It includes a
   framework for easy handling of training data sets. It is easy to
   use, versatile, well documented, and fast. Bindings to more than 20
   programming languages are available. An easy to read introduction
   article and a reference manual accompanies the library with
   examples and recommendations on how to use the library. Several
   graphical user interfaces are also available for the library."

** Parsers 
*** Libraries for building parsers 

String Processing Libraries
 
 + [[http://www.partow.net/programming/strtk/][StrTk - C++ String Toolkit Library]] - " The C++ String Toolkit
   Library (StrTk) consists of robust, optimized and portable string
   processing algorithms for the C++ language. StrTk is designed to be
   easy to use and integrate within existing code bases. Furthermore
   the library has a rich set of features that makes light work of any
   kind of string processing task." 

Parser Framework Libraries 

 * [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]] - Framework for building parsers which makes heavy use
   of template metaprogramming.

 * [[https://github.com/taocpp/PEGTL][PEGTL]] - "The Parsing Expression Grammar Template Library (PEGTL) is
   a zero-dependency C++ header-only parser combinator library for
   creating parsers according to a Parsing Expression Grammar (PEG)." 

 * [[https://github.com/r35382/bnflite][Bnflite]] - "BNFLite is a C++ template library for lightweight
   flexible grammar parsers. BNFLite offers creative approach when the
   developer can specify a language for further parsing directly in
   the C++ code. Moreover, such 'specifications' are executable now!
   Once the author participated in the development of some tool which
   was invented to integrate together a lot of proprietary
   modules. There were thousands combinations of command line options,
   poor examples, ambiguous docs. So the command line was not
   compatible from version to version. Up-to-date formal BNF specs of
   the command line language could help but not for projects with
   limited budget. Starting YACC era, there is a solution to support
   some extra executable code describing language specifics. As a
   rule, usage of such means is too heavy because it is extra stuff
   and it is not BNF. BNFLite does not have such drawbacks!"

 * [[https://github.com/TheLartians/Parser][TheLartians/Parser]] - "Build your own programming language! A C++17
   PEG parser generator supporting parser combination, memoization,
   left-recursion and context-dependent grammars. A linear-time C++17
   PEG parser generator supporting memoization, left-recursion and
   context-dependent grammars."

 * [[https://github.com/jwtowner/lug][jwtowner/lug]] - "Parsing expression grammar (PEG) embedded domain
   specific language and parsing machine for C++17."
   + Features:
     + Natural syntax more akin to external parser generator languages
     + Separation of syntatic and lexical rules, with customizable implicit whitespace skipping
     + Direct and indirect left recursion with precedence levels to
       disambiguate subexpressions with mixed left/right recursion
     + Header only library using C++17 language and library features
     + Relatively small with the intent of parser core to remain under 1500 lines of terse code
     + ... and more ... 

 * [[https://panthema.net/2007/stx-exparser/][STX-EXPARSER]] - "The STX Expression Parser provides a C++ framework,
   which can process user-specified expression strings containing
   program-specific variables. It can be integrated into applications
   to allow user-customized data selection and filtering. The
   expresssion strings are intuitive SQL-like WHERE-clauses and can
   contain arbitrarily complex arithmetic. At the same time the parse
   tree evaluation speed is guaranteed to be fast enough to safely
   iterate over larger data sets. The framework uses the Boost.Spirit
   parser library combined with a versatile custom scalar value
   class. The expression parser can process arbitrarily complex
   arithmetic expressions like those seen below. To access
   application-defined data, functions and variables may be included
   in the expression. An expression can be used as a boolean filter by
   using comparison and logic operators." 

 * [[https://github.com/grievejia/pcomb][PCOMB]] - "A lightweight parser combinator library written in
   C++14. Efficiency is not the goal of this library. After all,
   parsing is almost never a perfomrance bottleneck of a program
   analysis system. That being said, I try to avoid using heap
   allocation as much as possible. Most part of the parser is
   implemented with template metaprogramming and a small part is
   implemented using class inheritance. "

 * [[https://github.com/FrancoisChabot/abulafia][Abulafia]] - "A standalone C++ parsing framework - Abulafia is a C++
   expression templates library that generates parsers. The idea is to
   let programs contain ABNF-like grammars embedded directly within
   the code. It's heavily inspired by Boost::spirit::QI, but differs
   fundamentally from it in a number of respects. WARNING: Abulafia is
   still in early development. While many features work as intended,
   there are still a LOT of work to be done before it can be
   considered usable in a real environment."

Parser Code Generator 

 * [[https://www.antlr.org/][ANTLR]] - "ANTLR (ANother Tool for Language Recognition) is a
   powerful parser generator for reading, processing, executing, or
   translating structured text or binary files. It's widely used to
   build languages, tools, and frameworks. From a grammar, ANTLR
   generates a parser that can build and walk parse trees."
   + Note: Tool similar to flex/bison. It is Java application (jar
     executable) that can generate parser code for many programming
     languages including C++, C# (CSharp), Java, Python and ECMaScript
     (+JavaScript)+.
   + See:
     + https://tomassetti.me/getting-started-antlr-cpp/
     + https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md
     + https://github.com/antlr/grammars-v4 - Colleciton of Antlr 4 Grammars.

*** XML - Extensible Markup Language

Types of XML Parser Libraries: 
 
 + DOM  (Document Object Model) based => Parses the XML building an
   tree data structure in the memory.

 + [[https://en.wikipedia.org/wiki/Simple_API_for_XML][SAX]] (Simple API for XML) based => Event driven API that works by
   defining callbacks that are called when the tree is parsed. The
   advantage is that the XML is not loaded entirely in the memory at
   once which gives a small memory footprint. 

 + [[https://en.wikipedia.org/wiki/XPath][XPath]]  based => The XML is parsed directly using XPATH query language.

Some XML Libraries 

 + [[http://rapidxml.sourceforge.net/][RapidXML]]

 + [[http://xmlsoft.org/][Libxml2]]

 + [[http://xerces.apache.org/xerces-c/][Xerces C++]]

 + [[http://pugixml.org/][Pugixml]]

 + [[http://www.grinninglizard.com/tinyxml/][TinyXML]]
*** JSON - JavaScript Object Notation

 + [[https://github.com/Tencent/rapidjson/][RapidJSON]] - [HEADER ONLY] "A fast JSON parser/generator for C++
   with both SAX/DOM style API. RapidJSON is a JSON parser and
   generator for C++. It was inspired by RapidXml." 
   * Documentation: http://rapidjson.org/
   * Developed by: Tencent 
   * RapidJSON is small but complete. It supports both SAX and DOM
     style API. The SAX parser is only a half thousand lines of code.
   * RapidJSON is fast. Its performance can be comparable to
     strlen(). It also optionally supports SSE2/SSE4.2 for
     acceleration.
   * RapidJSON is self-contained and header-only. It does not depend
     on external libraries such as BOOST. It even does not depend on
     STL.
   * RapidJSON is memory-friendly. Each JSON value occupies exactly 16
     bytes for most 32/64-bit machines (excluding text string). By
     default it uses a fast memory allocator, and the parser allocates
     memory compactly during parsing.
   * RapidJSON is Unicode-friendly. It supports UTF-8, UTF-16, UTF-32
     (LE & BE), and their detection, validation and transcoding
     internally. For example, you can read a UTF-8 file and let
     RapidJSON transcode the JSON strings into UTF-16 in the DOM. It
     also supports surrogates and "\u0000" (null character).

 + [[https://github.com/taocpp/json][taoJSON]] [Requires C++17] - "taoJSON is a zero-dependency C++
   header-only JSON library that provides a generic Value Class, uses
   Type Traits to interoperate with C++ types, uses an Events
   Interface to convert from and to JSON, JAXN, CBOR, MsgPack and
   UBJSON, and much more..."

 + [[https://github.com/dropbox/json11][JSON11]] - "json11 is a tiny JSON library for C++11, providing JSON
   parsing and serialization."
   + Developed by: Dropbox
   + Maintenance note: "This repo is stable but no longer
     actively maintained. No further development is planned, and no
     new feature PRs will be merged. Bug fixes may be merged on a
     volunteer basis. If you have questions or want to talk to other
     users of Djinni, you can join the Slack community via the link at
     the end of this document."

 + [[https://github.com/nlohmann/json][Github - nlohmann/json]] - "JSON for Modern C++"
   * Doxygen: https://nlohmann.github.io/json/

 + [[https://github.com/kazuho/picojson][PicoJSON]]  - "PicoJSON is a tiny JSON parser / serializer for C++
   with following properties: header-file only, no external
   dependencies (only uses standard C++ libraries), STL-frendly
   (arrays are represented by using std::vector, objects are
   std::map), provides both pull interface and streaming (event-based)
   interface."

 + [[https://github.com/lloyd/yajl][YAJL]] [C Library] - "A fast streaming JSON parsing library in C."
   + Site: http://lloyd.github.io/yajl/
   + "YAJL is data representation independent - BYODR!  Many JSON
     libraries impose a structure based data representation on you.
     This is a benefit in some cases and a drawback in others. YAJL
     uses callbacks to remain agnostic of the in-memory
     representation. So if you wish to build up an in-memory
     representation, you may do so using YAJL, but you must bring the
     code that defines and populates the in memory structure."
   + "AJL supports stream parsing - This means you do not need to hold
     the whole JSON representation in textual form in memory.  This
     makes YAJL ideal for filtering projects, where you're converting
     YAJL from one form to another (i.e. XML).  The included JSON
     pretty printer is an example of such a filter program."
   + "YAJL is fast - Minimal memory copying is performed.  YAJL, when
     possible, returns pointers into the client provided text
     (i.e. for strings that have no embedded escape chars, hopefully
     the common case).  I've put a lot of effort into profiling and
     tuning performance, but I have ignored a couple possible
     performance improvements to keep the interface clean, small, and
     flexible.  My hope is that YAJL will perform comparably to the
     fastest JSON parser out there." 

*** CSV - Comma Separated Value Files 

 * [[https://github.com/d99kris/rapidcsv/][rapidcsv]]  - "Rapidcsv is a C++ header-only library
   for CSV parsing. While the name admittedly was inspired by the
   rapidjson project, the objectives are not the same. The goal of
   rapidcsv is to be an easy-to-use CSV library enabling rapid
   development. For optimal performance (be it CPU or memory usage) a
   CSV parser implemented for the specific use-case is likely to be
   more performant."
   + License: BSD-3  

 * [[https://github.com/awdeorio/csvstream/][csvstream]] - "An easy-to-use CSV file parser for C++."
   + License: MIT

 * [[https://github.com/ben-strasser/fast-cpp-csv-parser][fast-cpp-csv-parser]] - "This is a small, easy-to-use and fast
   header-only library for reading comma separated value (CSV)
   files."
   * License: BSD-3 
   * Features:
     + Automatically rearranges columns by parsing the header line.
     + Disk I/O and CSV-parsing are overlapped using threads for efficiency.
     + Parsing features such as escaped strings can be enabled and
       disabled at compile time using templates. You only pay in speed
       for the features you actually use.
     + Can read multiple GB files in reasonable time.
     + Support for custom columns separators (i.e. Tab separated value
       files are supported), quote escaped strings, automatic space
       trimming.
     + Works with *nix and Windows newlines and automatically ignores
       UTF-8 BOMs.
     + Exception classes with enough context to format useful error
       messages. what() returns error messages ready to be shown to a
       user. 

*** TOML - Configuration File Format 
**** Overview 

TOML is a minimal human-readable and human-friendly configuration file
based on Windows INI file format. 

Specification: 
  + https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.5.0.md

Example of a TOML file: 

#+BEGIN_SRC conf 
  # This is a TOML document.

  title = "TOML Example"

  [owner]
  name = "Tom Preston-Werner"
  dob = 1979-05-27T07:32:00-08:00 # First class dates

  [database]
  server = "192.168.1.1"
  ports = [ 8001, 8001, 8002 ]
  connection_max = 5000
  enabled = true

  [servers]

    # Indentation (tabs and/or spaces) is allowed but not required
    [servers.alpha]
    ip = "10.0.0.1"
    dc = "eqdc10"

    [servers.beta]
    ip = "10.0.0.2"
    dc = "eqdc10"

  [clients]
  data = [ ["gamma", "delta"], [1, 2] ]

  # Line breaks are OK when inside arrays
  hosts = [
    "alpha",
    "omega"
  ]
#+END_SRC

**** Libraries 

 + [[https://github.com/skystrife/cpptoml][cpptompl]] - "cpptoml is a header-only library for parsing TOML."

 + [[https://github.com/ToruNiina/toml11][toml11]] - "toml11 is a C++11 header-only toml parser/encoder
   depending only on C++ standard library. compatible to the latest
   version of TOML v0.5.0 after version 2.0.0. " 

 + [[https://github.com/brglng/libtoml][libtoml]] - "Very tiny TOML parser and encoder in C. To build this
   library, compiler with C99 support is required."

 + [[https://github.com/mayah/tinytoml][tinytoml]] - "A header only C++11 library for parsing TOML. This
   parser is based on TOML v0.4.0. This library is distributed under
   simplified BSD License. tinytoml is a tiny TOML parser for C++11
   with following properties:"
   + header file only
   + C++11 library friendly (array is std::vector, table is std::map,
     time is std::chrono::system_clock::time_point).
   + no external dependencies (note: we're using cmake for testing,
     but it's not required to use this library). 

*** HCON - Human-Optimized Config Object Notation

 *Overview:*

HCON is a configuration file-format that is more ligthweight and
readable than JSON. The syntax looks like JSON and QT's QML. 

 + Specification:
   https://github.com/lightbend/config/blob/master/HOCON.md

 *Parsers* 

 + [[https://github.com/puppetlabs/cpp-hocon][cpp-hcon]] - A C++ port of the Typesafe Config library.

** Libraries for Parsing C++ code 

  + [[https://bitbucket.org/verateam/vera/src/master/][vera++]] - "Vera++ is a programmable tool for verification, analysis
    and transformation of C++ source code. Vera++ is mainly an engine
    that parses C++ source files and presents the result of this
    parsing to scripts in the form of various collections - the
    scripts are actually performing the requested tasks." 
** REPL/SHELL - Interactive Command Line Interface - Terminal 

  + *replxx* - "A readline and libedit replacement that supports UTF-8,
    syntax highlighting, hints and Windows and is BSD licensed." 
    + repo: https://github.com/AmokHuginnsson/replxx

  + *Cli* - "A library for interactive command line interface in modern C++"
    + repo: https://github.com/daniele77/cli

  + *EditLine* (C Library) - "This is a small line editing library. It can
    be linked into almost any program to provide command line editing
    and history functions. It is call compatible with the FSF readline
    library, but at a fraction of the size, and as a result fewer
    features. It is also distributed under a much more liberal
    License. The small size (<30k), lack of dependencies (ncurses not
    needed!), and the free license should make this library interesting
    to many embedded developers." 
    + Site:  https://troglobit.com/projects/editline/
    + Repo: https://github.com/troglobit/editline

** Reflection 

  * [[https://www.rttr.org/][RTRR]] - *Runtime Type Reflection* - "RTTR stands for Run Time Type
    Reflection. It describes the ability of a computer program to
    introspect and modify an object at runtime. It is also the name of
    the library itself, which is written in C++ and released as open
    source library. The goal of this project is to provide an easy and
    intuitive way to use reflection in C++."
    + repo: https://github.com/rttrorg/rttr

  * [[https://www.cpgf.org][CPGF]] - "cpgf library is a cross platform C++ library for callback,
    reflection, serialization and script binding. It's written in
    standard C++ and doesn't require any preprocessor or tools. cpgf
    library is a cross platform C++ library for callback, reflection,
    serialization and script binding. It's written in standard C++ and
    doesn't require any preprocessor or tools."
    * Repo: https://github.com/cpgf/cpgf
    * Components in CPFG Library:
      * "cpgf reflection. Add runtime introspection and meta data
        reflection feature to C++. Have you ever envied the reflection
        system in C# and Java? Now we have it in C++!"
      * "cpgf serialization. Save C++ data and objects to persistent
        storage and then load back. Want the same serialization system
        that is in C# and Java? Try cpgf!"
      * "cpgf script binding. A script binding engine to connect Lua,
        Google V8 JavaScript, Python and Mozilla SpiderMonkey to
        C++. Now script binding in C++ is a piece of cake!"
      * "cpgf callback. A callback library to implement
        signal/slot/callback in C++. Want signal and slot without extra
        preprocessor? Try cpgf!"
      * 

  * [[https://github.com/Manu343726/ctti][CTTI]] - *Compile Time Type Information for C++* - "We know C++ is a
    statically typed compiled language, but it's disappointing that we
    cannot even get the name of a C++ type at compile time, having to
    use RTTI (Run Time Type Information) which introduces a lot of
    overhead. In fact, that's one of the most feared features of C++,
    usually disabled in performance dependent scenarios such as
    videogames programming. This library aims to provide features
    similar to RTTI std::type_info at compile-time, currently
    constexpr type name and a constexpr replacement of std::type_index
    for indexing maps with types."

  * [[https://github.com/Celtoys/clReflect][clReflect]] - "C++ Reflection using clang. clReflectTest is an
    up-to-date test of the clReflect library, showing how to build a
    database and load it at runtime. C++ primitives are not reflected
    by default and need to be marked by clcpp_reflect Reflection Specs
    or using reflect attributes." 

  * [[https://github.com/jhenstridge/gobject-cpp-reflection][gobject-cpp-reflection]] - "GObject oriented experiments with C++
    Static Reflection. This repository contains a few utility
    functions that make use of the draft C++ Static Reflection
    standard. Sadly this feature hasn't been included in the C++17
    standard, but an implementation for Clang is available as the
    reflexpr branch of the following repository:
    https://github.com/matus-chochlik/clang"

  * [[https://bitbucket.org/dwilliamson/reflectabit/src/default/][Reflectabit]] - "A minimal, registration-based C++ Reflection
    library." 

  * [[http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/][Mirror Reflection Utilities]] - "The aim of the Mirror library is to
    provide both compile-time and run-time meta-data describing C++
    constructs like namespaces, types typedef-ined types, enums,
    classes with their base classes, member variables, constructors,
    member functions, etc. and to provide uniform and generic
    interfaces for their introspection. Because standard C++ provides
    only a very limited set of meta-information to build upon, a
    potential drawback of this library is, that namespaces, types,
    classes, etc. need to be registered before they can be
    reflected. However Mirror tries to make the process of registering
    simple by providing a set of user-friendly registering macros and
    has the native and many of the other common types, classes,
    templates and namespaces pre-registered. Furthermore, a portable
    tool for automatic / semi-automatic registering is being worked
    on. Once registered the meta-data can be reused in a large number
    of situations. Mirror is designed with the principle of
    stratification in mind and tries to be as less intrusive as
    possible. New or existing classes do not need to be designed to
    directly support Mirror and no Mirror-related code is necessary in
    the class' definition, as far as some general guidelines are
    followed. This allows you to do reflection even on third-party
    code that you cannot modify."

  * [[https://github.com/martong/access_private][martong/access_private]] - "This library is a collection of macros
    with which we can access private members. Why would you need this?
    Testing. There are some cases when we want to test a class, but we
    can't or don't want to modify it. The reasons behind that might be
    the following: It is part of a third party software package and;
    Our build system would overwrite the changes we made; We don't
    want to maintain our own version; Touching the internals would
    require tremendous amount of recompilation of client codes, which
    might not be desired."

** Spreadsheet                                       :math:excel:spreadsheet:

   + [[http://xlw.sourceforge.net/][XLW]] - Wrapper for Excel native extension C-API (XLL) which allows to make
     Excel extensions in C++.
     + Fork of XLW for using with CMake: [[https://github.com/caiorss/xlw-cmake-fork][xlw-cmake-fork]]

   + [[http://keyvalue.sourceforge.net/][KeyValue]] (C++ Wrapper for Excel native extension C-API XLL and Libreoffice Calc)
     + "KeyValue is a cross-platform library for making C++ objects
       accessible through LibreOffice Calc, Excel and other
       front-ends. Experience of spreadsheet users is enhanced by an
       object model and a handy key-value based interface. Actually,
       KeyValue does more than just help creating spreadsheet
       functions. The object model allows end-users to build C++ objects
       through the front-ends. These objects are stored in a repository
       for latter use at user's request. Additionally, KeyValue provides
       a set of services for an effective use of these objects. The
       library is named after one of its main features: The key-value
       based interface. Parameters are passed to functions (or, more
       precisely, processors) through key-value pairs in contrast to the
       standard positional interfaces of LibreOffice Calc, Excel, C/C++,
       etc."
     + Features:
       + Cross platform: Compilable by GCC for GNU/Linux and MSVC for Windows.
       + Front-ends: LibreOffice Calc (GNU/Linux and Windows) and Excel
         2007 add-ins are provided. (XML parser planned.)
       + Flexibility: KeyValue does not impose strong constraints on the
         design of libraries it is supposed to help. Therefore, existing
         libraries can use KeyValue without big code refactoring.
       + Loggers: Results, errors and general information can be reported
         in different types of loggers including consoles and files. 

   + [[https://github.com/tfussell/xlnt][XLNT]] - "Cross-platform user-friendly xlsx library for C++14 - xlnt
     is a modern C++ library for manipulating spreadsheets in memory and
     reading/writing them from/to XLSX files as described in ECMA 376
     4th edition. The first public release of xlnt version 1.0 was on
     May 10th, 2017. Current work is focused on increasing
     compatibility, improving performance, and brainstorming future
     development goals. For a high-level summary of what you can do with
     this library, see the feature list. Contributions are welcome in
     the form of pull requests or discussions on the repository's Issues
     page."

   + [[https://github.com/pyxll/xlfparser][Xlfparser]] - "Header only C++ library for tokenizing Excel formulas"

   + *IXION* - (Formula/spreadsheet evaluator) - "Ixion is a general
     purpose formula parser & interpreter that can calculate multiple
     named targets, or "cells". The goal of this project is to create a
     library for calculating the results of formula expressions stored in
     multiple named targets, or "cells".  The cells can be referenced
     from each other, and the library takes care of resolving their
     dependencies automatically upon calculation. The caller can run the
     calculation routine either in a single-threaded mode, or a
     multi-threaded mode.  The library also supports re-calculations
     where the contents of one or more cells have been modified since the
     last calculation, and a partial calculation of only the affected
     cells need to be calculated."
     + Site: https://ixion.readthedocs.io/en/latest/cpp/index.html
     + Repo: https://gitlab.com/ixion/ixion

** GUI - Graphical User Interface 

 *TUI - Terminal User Interface*

  + [[https://www.gnu.org/software/ncurses/][Ncurses]] - A (TUI) terminal user interface written in C. Provides
    many terminal widgets.

  + [[http://www.clifford.at/stfl/][STFL]] - Structured Terminal Forms Language/Library
    + "STFL is a library which implements a curses-based widget set
      for text terminals. The STFL API can be used from C, SPL,
      Python, Perl and Ruby. Since the API is only 14 simple function
      calls big and there are already generic SWIG bindings it is very
      easy to port STFL to additional scripting languages. A special
      language (the Structured Terminal Forms Language) is used to
      describe STFL GUIs. The language is designed to be easy and fast
      to write so an application programmer does not need to spend
      ages fiddling around with the GUI and can concentrate on the
      more interesting programming tasks."

  + [[https://invisible-island.net/cdk/][CDK]] - "Curses development kit provides predefined curses widget for apps"
    + https://github.com/ThomasDickey/cdk-snapshots


 *GUI - Graphical User Interface*

  + [[https://www.qt.io/][QT Toolkit]] (QT Framework) [BEST] - Not only a GUI toolkit, but also a
    full-fledge C++ framework with cross platform libraries for
    network, sockets, database access ... and so on.

  + [[http://www.wxwidgets.org/][WxWidgets]] 

  + [[http://www.gtkmm.org/][Gtkmm]] - Gtk (Written in C) + C++ interface
    + GTK is a GUI library derived from GIMP toolkit.
    + Drawback: Hard to use on Windows.

  + [[http://www.fltk.org/][Fltk]] - lightweight GUI library.

  + [[https://github.com/wjakob/nanogui][nanogui]] - "NanoGUI is a minimalistic cross-platform widget
    library for OpenGL 3.x or higher. It supports automatic layout
    generation, stateful C++11 lambdas callbacks, a variety of useful
    widget types and Retina-capable rendering on Apple devices thanks
    to NanoVG by Mikko Mononen. Python bindings of all functionality
    are provided using pybind11." 

  + [[http://cegui.org.uk/][Cegui]] - Crazy Eddie's GUI System.

  + [[http://nanapro.org/en-us/][Nana]]

  + [[https://bitbucket.org/chromiumembedded/cef][CEF]] - Chromium Embedded Framework - "The Chromium Embedded
    Framework (CEF) is a simple framework for embedding Chromium-based
    browsers in other applications." 

  + [[https://sourceforge.net/projects/owlnext/][OWLNext C++ GUI]] [WINDOWS ONLY] - "An extensive update of Borland's Object Windows
    Library (OWL) for writing GUI applications in standard C++ on
    Microsoft Windows." 

  + [[https://juce.com/][Juce]]  [COMMERCIAL]

  + [[https://github.com/ocornut/imgui][Imgui]] - Immediate mode GUI Library for games

  *Windows System*

  + [[https://github.com/ghaerr/microwindows][microwindows]] - Microwindows or the Nano-X Window System
    + "Microwindows or Nano-X is a small graphical windowing system
      that implements both Win32 and Nano-X (X11-like) APIs for
      clipped graphics drawing in windows on Linux, Mac OS X,
      EMSCRIPTEN, Android and other platforms. It is Open Source and
      licenced under the the Mozilla Public License. For creating
      GUIs, the Nuklear immediate mode GUI, Win32 builtin controls,
      and TinyWidget's controls based on Nano-X are included. FLTK can
      be used with the X11 compability library NX11."
    + Platform support: Currently supported platforms include Linux,
      Mac OS X, Android, EMSCRIPTEN, Nuklear GUI, Windows, Raspberry
      Pi, DOS DJGPP, RTEMS, ECOS, Sony PSP, Nintendo DS and
      more. Currently supported screen drivers include Memory-mapped
      framebuffer, X11, SDL 2, Allegro 5, Windows and an X11 based
      framebuffer emulator. Support for cross-compiler toolchains on
      x86, x86_64, ARM, PowerPC and MIPS, big- and little-endian, and
      other processors. 

** GUI - Plotting Libraries and data visualization 

+ [[https://qwt.sourceforge.io/][Qwt]] (QT Framework Widgets) - Qt Widgets for Technical Applications*
  + License: LGPL

+ [[http://qwtplot3d.sourceforge.net/][Qwtplot3d]] - "QwtPlot3D is not a  program, but a feature-rich
  Qt/OpenGL-based C++ programming library, providing essentially a
  bunch of 3D-widgets for programmers. The library is zlib licensed."

+ [[http://cneben.github.io/QuickQanava/index.html][QuickQanava]] - "QuickQanava is a C++14 library designed to display
  graphs and relational content in a QtQuick application. QuickQanava
  provide QML components and C++ classes to visualize medium-sized
  directed graphs in a C++/QML application. QuickQanava does not
  provide advanced layout algorithms, but rather focus on displaying
  relational content in advanced dynamic user interfaces (with DnD
  support, resizable content, visual connection of nodes)."

+ [[https://www.gnu.org/software/plotutils/][GNU Plotutils]] - " The GNU plotutils package contains software for
  both programmers and technical users. Its centerpiece is libplot, a
  powerful C/C++ function library for exporting 2-D vector graphics
  in many file formats, both vector and bitmap. On the X Window
  System, it can also do 2-D vector graphics animations." 

+ [[http://www.openscenegraph.org/][OpenSceneGraph]] - "The OpenSceneGraph is an open source high
  performance 3D graphics toolkit, used by application developers in
  fields such as visual simulation, games, virtual reality,
  scientific visualization and modelling. Written entirely in
  Standard C++ and OpenGL it runs on all Windows platforms, OSX,
  GNU/Linux, IRIX, Solaris, HP-Ux, AIX and FreeBSD operating
  systems. The OpenSceneGraph is now well established as the world
  leading scene graph technology, used widely in the vis-sim, space,
  scientific, oil-gas, games and virtual reality industries." 

** GUI RAD - Rapid Application Development 

RAD Frameworks are a combination of library, IDE and GUI builder where
it is possible to build GUI applications by dragging and dropping user
interface elements in the and combining components in the same fashion
as Visual Basic or Delphi.

 + *Visual Studio* + Windows MFC (Microsft Foundation Classes) - Note:
   Windows only. 

 + *QT Creator* + QT Widgets or QTQuick/QML  - Note: QT Creator has a
   user interface designer.

 + [[https://www.ultimatepp.org/][Ultimate++]] - Ultimate++ is a C++ cross-platform rapid application
   development framework. 
   + License: BSD 

 + [[https://www.embarcadero.com/products/cbuilder][Embarcadero C++ Builder]] (Old Borland C++ Builder) - [Commercial]
** QT Framework - Widgets and QtQuick/QML                        :qt:qml:gui:

 + [[https://github.com/mikalv/awesome-qt-qml][Awesome Qt]]

 + [[https://github.com/benlau/qtci][QT-CI]] - "Collection of scripts to build Qt application in command
   line environment" 

 + [[https://github.com/jorgen/yat][YAT]] - "Yat (yet another terminal) is a VT100-emulating terminal
   written with Qt Quick."

 + [[https://www.qxorm.com/qxorm_en/home.html][QXORM]] - "QxOrm (the engine) + QxEntityEditor (the graphic editor) =
   the best solution to manage your persistent data layer in C++/Qt" 

 + [[https://bitbucket.org/michalmotyczko/qtadb/src/master/][QTADB]] - "QtADB is an app based on adb. It requires working android
   sdk (command “adb devices” listing your device), Qt libs version
   4.7, ROOT and busybox installed on phone."
   + Site: https://qtadb.wordpress.com/download/

 + [[https://github.com/equalsraf/neovim-qt][neovim-qt]] - "Neovim client library and GUI, in Qt5."

 + [[https://github.com/Kaffeine/telegram-qt][telegram-qt]] - "Qt-based library for Telegram network"

 + [[https://github.com/frankosterfeld/qtkeychain][QtKeyChain]] - "Platform-independent Qt API for storing passwords securely."

 + [[https://github.com/kypeli/kQOAuth][kQOAuth]] - "kQOAuth is a library written in C++ for Qt that
   implements the OAuth 1.0 authentication specification RFC 5849
   (http://tools.ietf.org/html/rfc5849). Greetings go to Dominik
   Kapusta for writing the original OAuth library using Qt, QOAuth
   (http://blog.ayoy.net/2009/6/24/oauth). However, I wanted to
   improve on the QOAuth’s approach in some ways. kQ…"

 + [[https://github.com/vogel/injeqt][InjectQt]] - "Simple dependency injection framework for Qt"

 + [[https://github.com/KDAB/GammaRay][GammaRay]] [TOOL]
   + "GammaRay is a software introspection tool for Qt applications
     developed by KDAB. Leveraging the QObject introspection mechanism
     it allows you to observe and manipulate your application at
     runtime. This works both locally on your workstation and remotely
     on an embedded target. Augmenting your instruction-level
     debugger, GammaRay allows you to work on a much higher level,
     with the same concepts as the frameworks you use. This is
     especially useful for the more complex Qt frameworks such as
     model/view, state machines or scene graphs."
   + Site: https://www.kdab.com/development-resources/qt-tools/gammaray/

** Microsft Windows OS only 

  + MFC - Microsft Foundation Libraries
    + Framework for developing Windows GUI Applications.

  + ATL - Active Template Library
    + Template library for developing COM components.

  + WTL - Windows Template Library

  + [[https://github.com/alamaison/comet][COMET]] - "Modern (idiomatic) binding between COM and C++"

** Image Processing 
 
+ [[https://www.boost.org/doc/libs/1_38_0/libs/gil/doc/index.html][Boost.Gil]] - Generic Image Library

+ [[http://easybmp.sourceforge.net/][EasyBMP]]

+ [[http://cimg.sourceforge.net/][Cimg]] - "The CImg Library is a small, open-source, and modern C++
  toolkit for image processing http://cimg.eu"

+ [[https://itk.org/][ITK]] - National Library of Medicine Insight Segmentation and
  Registration Toolkit (ITK)

+ [[http://freeimage.sourceforge.net/][FreeImage]]

+ [[https://vtk.org/][VTK]] - Visualization Toolkit - library for scientific visualization.
  + See more at: https://en.wikipedia.org/wiki/VTK

+ [[https://opencv.org/][OpenCV]] - Computer Vision Framework.

** Logging 

+ [[http://www.pantheios.org/][Pantheios]]

+ [[http://logging.apache.org/log4cxx/index.html][log4cxx]]

+ [[http://boost-log.sourceforge.net/libs/log/doc/html/index.html][Boost.Log]]

** Network socket, web server, web socket and RPC libraries
*** General Network Socket Libraries 

   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_asio.html][Boost Asio]] - "Boost.Asio is a cross-platform C++ library for
     network and low-level I/O programming that provides developers with
     a consistent asynchronous model using a modern C++ approach." 

   + [[http://download.dre.vanderbilt.edu/][ACE]] - Adaptive Communication Environment - "The ADAPTIVE
     Communication Environment (ACE) is a freely available, open-source
     object-oriented (OO) framework that implements many core patterns
     for concurrent communication software. ACE provides a rich set of
     reusable C++ wrapper facades and framework components that perform
     common communication software tasks across a range of OS
     platforms. The communication software tasks provided by ACE include
     event demultiplexing and event handler dispatching, signal
     handling, service initialization, interprocess communication,
     shared memory management, message routing, dynamic
     (re)configuration of distributed services, concurrent execution and
     synchronization. ACE is targeted for developers of
     high-performance and real-time communication services and
     applications. It simplifies the development of OO network
     applications and services that utilize interprocess communication,
     event demultiplexing, explicit dynamic linking, and concurrency. In
     addition, ACE automates system configuration and reconfiguration by
     dynamically linking services into applications at run-time and
     executing these services in one or more processes or threads."

   + [[https://github.com/Qihoo360/evpp][evpp]] - "evpp is a modern C++ network library for developing high
     performance network services using TCP/UDP/HTTP protocols. evpp
     provides a TCP Server to support multi-threaded nonblocking
     event-driven server and also a HTTP, UDP Server to support HTTP
     and UDP protocols."
     + Note: Also provides *HTTP server* classes.
     + Features: Modern C++11 interface; Modern functional/bind style
       callback instead of C-style function pointer; Multi-core
       friendly and thread-safe; A nonblocking multi-threaded TCP
       server; A nonblocking TCP client; A nonblocking multi-threaded
       HTTP server based on the buildin http server of libevent; A
       nonblocking HTTP client; A nonblocking multi-threaded UDP
       server; Async DNS resolving; EventLoop/ThreadPool/Timer; Well
       tested — evpp is well tested with unit tests and stress tested
       daily in production. It has been used in production and
       processes 1000+ billions networking communications every day in
       our production; Easy install — evpp can be packaged as a deb,
       rpm, tar.gz with a single command for straight forward
       distribution and integration.

   + [[https://github.com/networkprotocol/yojimbo][yojimbo]] [GAMES] - "A network library for client/server games with
     dedicated servers. yojimbo is a network library for client/server
     games with dedicated servers. It's designed around the networking
     requirements of competitive multiplayer games like first person
     shooters. It has the following features: Cryptographically secure
     authentication via connect tokens; Client/server connection
     management and timeouts; Encrypted and signed packets sent over
     UDP; Reliable-ordered messages and data blocks; Packet
     fragmentation and reassembly; Estimates of packet loss, latency
     and bandwidth usage. yojimbo is stable and well tested having
     been used in AAA game projects for over 2 years now." 

   + [[http://zeromq.org/][ZeroMQ]] - Framework fro building distributed message systems or
     message brokers.

   + [[http://sourcey.com/libsourcey/][libsourcey]] - "LibSourcey is a collection of cross platform C++11
     modules and classes that provide developers with an arsenal for
     rapidly developing high performance network based p2p and media
     streaming applications. Think of it as the power of libuv combined
     with the features of FFmpeg, OpenCV and WebRTC, all integrated with
     the ease and readability of the stl (C++ Standard Library)."

   + [[https://lcm-proj.github.io/][LCM]] - Lightweight Communications and Marshalling (LCM)
     + "LCM is a set of libraries and tools for message passing and data
       marshalling, targeted at real-time systems where high-bandwidth
       and low latency are critical. It provides a publish/subscribe
       message passing model and automatic marshalling/unmarshalling
       code generation with bindings for applications in a variety of
       programming languages."
     + Features: Low-latency inter-process communication; Efficient
       broadcast mechanism using UDP Multicast; Type-safe message
       marshalling; User-friendly logging and playback; No centralized
       "database" or "hub" – peers communicate directly; No daemons; Few
       dependencies.
     + Note: LCM was originally developed in 2006 for the MIT DARPA
       Urban Challenge team, and has since been used in many robotic and
       autonomous systems, in both research and production environments.  

   + [[http://research.edm.uhasselt.be/jori/page/CS/Jrtplib.html][Jrtplib]] - (RTP Protocol) "JRTPLIB is an object-oriented RTP library
     written in C++. It was first developed for my thesis at the School
     for Knowledge Technology (or 'School voor Kennistechnologie' in
     Dutch), a cooperation between the Hasselt University and the
     Maastricht University."
*** Network Client 

   + [[http://www.curlpp.org/][Curlpp]] - [HTTP] [MULTI-PROTOCOL CLIENT]
     + "cURLpp is a C++ wrapper for ibcURL. libcURL is described as: a
       free and easy-to-use client-side URL transfer library, supporting
       FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE and
       LDAP. libcurl supports HTTPS certificates, HTTP POST, HTTP PUT,
       FTP uploading, kerberos, HTTP form based upload, proxies,
       cookies, user+password authentication, file transfer resume, http
       proxy tunneling and more!"

   + [[https://cpp-netlib.org][cpp-netlib]] - [BOOST NAMESPACE] A collection of open-source
     libraries for high level network programming. 
     + "cpp-netlib is a collection of network-related
       routines/implementations geared towards providing a robust
       cross-platform networking library. cpp-netlib offers the
       following implementations: Common Message Type -- A generic
       message type which can be used to encapsulate and store
       message-related information, used by all network
       implementations as the primary means of data exchange; Network
       protocol message parsers -- A collection of parsers which
       generate message objects from strings; Adapters and Wrappers --
       A collection of Adapters and wrappers aimed towards making the
       message type STL friendly; Network protocol client and server
       implementations -- A collection of network protocol
       implementations that include embeddable client and server
       types."

*** Http Servers and Web Frameworks 

 + [[https://github.com/corvusoft/restbed][restbed]] - "Restbed is a comprehensive and consistent programming
   model for building applications that require seamless and secure
   communication over HTTP, with the ability to model a range of
   business processes, designed to target mobile, tablet, desktop and
   embedded production environments. It's akin to embedding NGINX into
   your companies own product line. -- Solutions Architect, Bellrock
   Technology"
   + Features: WebSockets; Server-Sent Events; SSL/TSL; HTTP
     Pipelining; Path Parameters; Logging; Compression; Rules
     Engines.
   + License: Dual - AGPL or Commercial.

 + [[https://github.com/emweb/wt][Wt, Web Toolkit]] - "Wt is a C++ library for developing web
   applications. It consists of: libwt, a widget/rendering library;
   libwthttp, an (async I/O) HTTP/WebSockets server; libwtfcgi, a
   FastCGI connector library (Unix); libwtisapi, an ISAPI connector
   library (Windows); libwttest, a test connector environment. It also
   contains a C++ ORM, which can be used in a web application
   (obviously), but can also be used on its own: libwtdbo, a C++ ORM;
   libwtdbopostgres, PostgreSQL backend; libwtdbosqlite3, Sqlite3
   backend; libwtdbomysql, MySQL and MariaDB backend;
   libwtdbomssqlserver, Microsoft SQL Server backend;
   libwtdbofirebird, Firebird backend."
   + Note: Provides Widgets with an API similar to Desktop user
     interface GUI toolkits such as WxWidgets or Qt Framework.
   + Web Site: https://www.webtoolkit.eu/wt

 + [[http://www.reasoning.biz/index.htm][Reason C++ framework]] - "Reason is a cross platform Web framework
   designed to bring the ease of use of Java, .Net, or Python to
   developers who require the performance and strength of C++."
   + License: Dual license GPL v2.0 and commercial.

 + [[https://www.boost.org/doc/libs/1_69_0/libs/beast/doc/html/index.html][Boost.Beast]] - "Beast is a C++ header-only library serving as a
   foundation for writing interoperable networking libraries by
   providing low-level HTTP/1, WebSocket, and networking protocol
   vocabulary types and algorithms using the consistent asynchronous
   model of Boost.Asio."

 + [[http://siliconframework.org/][Silicon Framework]] - "A high performance, middleware oriented C++14
   http web framework"
   + Repo: https://github.com/matt-42/silicon

 + [[https://github.com/meltwater/served][served]] - "Served is a C++ library for building high performance
   RESTful web servers. Served builds upon Boost.ASIO to provide a
   simple API for developers to create HTTP services in C++. Features:
   HTTP 1.1 compatible request parser; Middleware / plug-ins; Flexible
   handler API; Cross-platform compatible".

 + [[https://github.com/cesanta/mongoose][Mongoose]] - "Mongoose Embedded Web Server Library - Mongoose is more
   than an embedded webserver. It is a multi-protocol embedded
   networking library with functions including TCP, HTTP client and
   server, WebSocket client and server, MQTT client and broker and
   much more. Mongoose is ideal for embedded environments. It has been
   designed for connecting devices and bringing them online. On the
   market since 2004, used by vast number of open source and
   commercial products - it even runs on the International Space
   station! Mongoose makes embedded network programming fast, robust,
   and easy."
   + Note: GPL 2.0 License and commercial license for closed source.

 + [[https://github.com/zaphoyd/websocketpp][WebSocketpp, aka WebSocket++]] - [WEB SOCKET SERVER] "WebSocket++ is
   a header only C++ library that implements RFC6455 The WebSocket
   Protocol. It allows integrating WebSocket client and server
   functionality into C++ programs. It uses interchangeable network
   transport modules including one based on raw char buffers, one
   based on C++ iostreams, and one based on Asio (either via Boost or
   standalone). End users can write additional transport policies to
   support other networking or event libraries as needed."

 + [[https://www.genivia.com/dev.html][gSOAP]] - "Our gSOAP toolkit allows C/C++ developers to focus on
   application logic instead of infrastructure, resulting in reduced
   development time, fewer bugs, and faster time to market."

 + [[https://github.com/daedric/httpp][Httpp]] - "Micro http server and client written in C++"

 + [[http://siliconframework.org/][Silicon C++ Web Framework]] - "Write Fast and Robust Web APIs with C++"

 + [[https://github.com/loentar/ngrest][Ngrest]] - "Fast and easy C++  RESTful WebServices framework"
*** RPC - Remote Procedure Call

 + [[http://rpclib.net/][RPCLIB]] - "rpclib is a RPC library for C++, providing both a client
   and server implementation. It is built using modern C++14, and as
   such, requires a recent compiler. Main highlights: Expose functions
   of your program to be called via RPC (from any language
   implementing msgpack-rpc); Call functions through RPC (of programs
   written in any language); No IDL to learn; No code generation step
   to integrate in your build, just C++."
   + Repository: https://github.com/rpclib/rpclib

 + [[https://capnproto.org/][CAPNPROTO]] - RPC system with a Cap'n proto serialziation format
   which the library page claims to be much faster than JSON and
   protocol buffers.
   + Repository: https://github.com/capnproto/capnproto
   + Features:
     + "The Cap’n Proto encoding is appropriate both as a _data_
       _interchange format_ and an _in-memory representation_, so once
       your structure is built, you can simply write the bytes
       straight out to disk!"
     + "mmap: Read a large Cap’n Proto file by memory-mapping it. The
       OS won’t even read in the parts that you don’t access."
     + "Inter-language communication: Calling C++ code from, say, Java
       or Python tends to be painful or slow. With Cap’n Proto, the
       _two languages can easily operate on the same in-memory data_
       _structure_."
     + "_Inter-process communication_: Multiple processes running on the
       same machine can share a Cap’n Proto message via shared
       memory. No need to pipe data through the kernel. Calling
       another process can be just as fast and easy as calling another
       thread."

 + [[https://zeroc.com/products/ice][ICE]] - "Ice is a comprehensive RPC framework with support for C++,
   C#, Java, JavaScript, Python, and more."
   + License: GPLv2 for open source projects, any commercial project
     requires buying a proper [[https://zeroc.com/licensing][license]].
*** Raw Sockets 

 *Low level socket manipulation and raw socket*

 + [[https://libtins.github.io/][Libtins]] - "libtins is a high-level, multiplatform C++ network
   packet sniffing and crafting library. Its main purpose is to
   provide the C++ developer an easy, efficient, platform and
   endianness-independent way to create tools which need to send,
   receive and manipulate network packets."

 + [[http://seladb.github.io/PcapPlusPlus-Doc/][PcapPlusPlus]] - "PcapPlusPlus is a multiplatform C++ network
   sniffing and packet parsing and crafting framework. It's meant to
   be lightweight, efficient and easy to use."

** Inteprocess Communication 

List of libraries for interprocess communication (IPC) on local
machine, without explicitly dealing with sockets, through buses such
as DBus or operating system IPC primitives such as shared memory,
message passing and IPC synchronization primitives (mutex, semaphore,
...).

 *Types of IPC - Interprocess Communication:*

  + Shared Memory + Process/thread synchronization primitives (mutex, semaphore)
    + Allows processes to share memory without any copy which makes
      shared memory more efficient than sockets. 

  + Memory Mapped Files
    + Maps files on disk to process virtual memory and address space,
      allows reading a file just like a memory. Good for processing
      large files and sharing them with multiple processes without
      incurring on multiple copy overhead. 

  + Message Passing

  + Linux-specific:
    + DBus  

  + Windows-Specific:
    + Named Pipes 

 *Libraries:*

  + [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]]
    + Brief: "Boost.Interprocess simplifies the use of common
      interprocess communication and synchronization mechanisms and
      offers a wide range of them:"
      + Shared memory.
      + Memory-mapped files.
      + Semaphores, mutexes, condition variables and upgradable mutex
        types to place them in shared memory and memory mapped files.
      + Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.
      + File locking.
      + Relative pointers.
      + Message queues.
    + Additional:
      + Boost.Interprocess also offers higher-level interprocess
        mechanisms to allocate dynamically portions of a shared memory
        or a memory mapped file (in general, to allocate portions of a
        fixed size memory segment). Using these mechanisms,
        Boost.Interprocess offers useful tools to construct C++
        objects, including STL-like containers, in shared memory and
        memory mapped files:

  + [[http://download.dre.vanderbilt.edu/][ACE]] - Adaptive Communication Environment - "The ADAPTIVE
    Communication Environment (ACE) is a freely available, open-source
    object-oriented (OO) framework that implements many core patterns
    for concurrent communication software. ACE provides a rich set of
    reusable C++ wrapper facades and framework components that perform
    common communication software tasks across a range of OS
    platforms. The communication software tasks provided by ACE include
    event demultiplexing and event handler dispatching, signal
    handling, service initialization, _interprocess communication_,
    shared memory management, message routing, dynamic
    (re)configuration of distributed services, concurrent execution and
    synchronization. ACE is targeted for developers of
    high-performance and real-time communication services and
    applications. It simplifies the development of OO network
    applications and services that utilize interprocess communication,
    event demultiplexing, explicit dynamic linking, and concurrency. In
    addition, ACE automates system configuration and reconfiguration by
    dynamically linking services into applications at run-time and
    executing these services in one or more processes or threads."

  + [[https://capnproto.org/][CAPNPROTO]] - RPC system with a Cap'n proto serialziation format
    which the library page claims to be much faster than JSON and
    protocol buffers.
    + Repository: https://github.com/capnproto/capnproto
    + Features:
      + "The Cap’n Proto encoding is appropriate both as a _data_
        _interchange format_ and an _in-memory representation_, so once
        your structure is built, you can simply write the bytes
        straight out to disk!"
      + "mmap: Read a large Cap’n Proto file by memory-mapping it. The
        OS won’t even read in the parts that you don’t access."
      + "Inter-language communication: Calling C++ code from, say, Java
        or Python tends to be painful or slow. With Cap’n Proto, the
        _two languages can easily operate on the same in-memory data_
        _structure_."
      + "_Inter-process communication_: Multiple processes running on the
        same machine can share a Cap’n Proto message via shared
        memory. No need to pipe data through the kernel. Calling
        another process can be just as fast and easy as calling another
        thread."

  + [[http://www.naughter.com/npipe.html][npipe]] - [WINDOWS-ONLY] "CNamedPipe v1.14 A C++ class to
    encapsulate Named Pipes. The class encapsulates the Named Pipe
    Inter Process Communication mechanism as provided in Win32. The
    class provides a thin veneer of the SDK API meaning that all the
    richness the SDK provides is available through the class. The
    class also provides auto cleanup and is UNICODE enabled with build
    configurations provided."

  + [[https://github.com/mandreyel/mio][mandreyel/mio]] - [MEMORY MAPPED FILE] "An easy to use header-only
    cross-platform C++11 memory mapping library with an MIT
    license. mio has been created with the goal to be easily
    includable (i.e. no dependencies) in any C++ project that needs
    memory mapped file IO without the need to pull in Boost."

  + [[https://doc.qt.io/qt-5/qsharedmemory.html][QSharedMemory]] (QT Framework) [SHARED MEMORY] - QSharedMemory
    provides access to a shared memory segment by multiple threads and
    processes. It also provides a way for a single thread or process
    to lock the memory for exclusive access.

  + [[https://doc.qt.io/qt-5/qtdbus-module.html][Qt D-Bus]] (QT Framework) - "The Qt D-Bus module is a Unix-only
    library that you can use to perform Inter-Process Communication
    using the D-Bus protocol. Applications using the Qt D-Bus module
    can provide services to other, remote applications by exporting
    objects, as well as use services exported by those applications by
    placing calls and accessing properties. The Qt D-Bus module
    provides an interface that extends the Qt Signals and Slots
    mechanism, allowing one to connect to a signal emitted remotely as
    well as to connect a local signal to remote slot."

** Subprocess and process control 

  + [[https://www.boost.org/doc/libs/1_71_0/doc/html/process.html][Boost.Process]]
    + "Boost.Process is a library to manage system processes. It can
      be used to: create child processes; setup streams for child
      processes; communicate with child processes through streams
      (synchronously or asynchronously); wait for processes to exit
      (synchronously or asynchronously) and terminate processes."

  + [[https://github.com/arun11299/cpp-subprocess][cpp-subprocess]]
    + "The only goal was to develop something that is as close as
      python2.7 subprocess module in dealing with processes. Could not
      find anything similar done for C++ and here we are. This library
      had these design goals: Intuitive Interface. Using modern C++
      features, made the API usage as simple as that in python in most
      cases and even better in some (See pipiing example);
      Correctness. Dealing with processes is not a simple job. It has
      many low level details that needs to be taken care of. This
      library takes care of dealing with those low level details
      making it easier to launch processes; Error Handling. Currently
      the error handling is achieved via the use of exceptions. It is
      important that no errors are ignored silently. I am working
      towards achieving this goal, but most of the error conditions
      have been taken care of."
    + See: [[http://templated-thoughts.blogspot.com/2016/03/sub-processing-with-modern-c.html][From Mordor, with love: Sub-processing with modern C++]]

  + *QT Framework - Sub-process libraries*
    + [[https://doc.qt.io/qt-5/qprocess.html][QProcess Class | Qt Core 5.13.1]]
    + [[https://doc.qt.io/qt-5/qcommandlineparser.html][QCommandLineParser Class | Qt Core 5.13.1]]

** Compression and Archive 

  + [[https://libzip.org/][libzip]] - "libzip is a C library for reading, creating, and
    modifying zip archives. Files can be added from data buffers,
    files, or compressed data copied directly from other zip
    archives. Changes made without closing the archive can be
    reverted. The API is documented by man pages."
    + https://github.com/nih-at/libzip/

  + [[http://libarchive.org][libarchive]] - Multi-format archive and compression library
    + "Reads a variety of formats, including tar, pax, cpio, zip, xar,
      lha, ar, cab, mtree, rar, and ISO images. Writes tar, pax, cpio,
      zip, xar, ar, ISO, mtree, and shar archives. Automatically
      handles archives compressed with gzip, bzip2, lzip, xz, lzma, or
      compress. Unique format conversion feature."
    + Github: https://github.com/libarchive/libarchive/
    + Wiki: https://github.com/libarchive/libarchive/wiki

  + [[https://icculus.org/physfs/][physfs]] - "PhysicsFS is a library to provide abstract access to
    various archives. It is intended for use in video games, and the
    design was somewhat inspired by Quake 3's file subsystem. The
    programmer defines a "write directory" on the physical
    filesystem. No file writing done through the PhysicsFS API can
    leave that write directory, for security. For example, an embedded
    scripting language cannot write outside of this path if it uses
    PhysFS for all of its I/O, which means that untrusted scripts can
    run more safely. Symbolic links can be disabled as well, for added
    safety. For file reading, the programmer lists directories and
    archives that form a "search path". Once the search path is
    defined, it becomes a single, transparent hierarchical
    filesystem. This makes for easy access to ZIP files in the same
    way as you access a file directly on the disk, and it makes it
    easy to ship a new archive that will override a previous archive
    on a per-file basis. Finally, PhysicsFS gives you
    platform-abstracted means to determine if CD-ROMs are available,
    the user's home directory, where in the real filesystem your
    program is running, etc."
    + Github: https://github.com/criptych/physfs (Mirror)

** Database engines and database connectors 
 
Database Connectors 

  + [[https://tangentsoft.com/mysqlpp/home][MySqL++]] - "MySQL++ is a C++ wrapper for MySQL’s C API. It is built
    around the same principles as the Standard C++ Library, to make
    dealing with the database as easy as dealing with STL
    containers. In addition, MySQL++ provides facilities that let you
    avoid the most repetitive sorts of SQL within your own code,
    providing native C++ interfaces for these common tasks."

  + [[http://pqxx.org/development/libpqxx/][libpqxx]] - "libpqxx is the official C++ client API for ​PostgreSQL,
    the enterprise-strength open-source relational database. (If
    "PostgreSQL" is too verbose, call it by its shorter name,
    postgres)." 

  + [[https://github.com/rbock/sqlpp11][SQLPP11]] - A type safe embedded domain specific language for SQL
    queries and results in C++.
    + "sqlpp11 is a templated library representing an embedded domain
      specific language (EDSL) that allows you to define types
      representing tables and columns; construct type safe queries
      checked at compile time for syntax errors type errors, name
      errors and even some semantic errors, interpret results by
      iterating over query-specific structs with appropriately named
      and typed members."

  + [[https://github.com/soci/soci][SOCI]] - "SOCI - The C++ Database Access Library" 
    + "Originally, SOCI was developed by Maciej Sobczak at CERN as
      abstraction layer for Oracle, a Simple Oracle Call
      Interface. Later, several database backends have been developed
      for SOCI, thus the long name has lost its
      practicality. Currently, if you like, SOCI may stand for Simple
      Open (Database) Call Interface or something similar."
    + Site: http://soci.sourceforge.net/ 

  + [[https://github.com/paulftw/hiberlite][hiberlite]]
    + "C++ object-relational mapping with API inspired by the awesome
      Boost.Serialization - that means almost no API to learn."

Embedded Databases (File database akin to SQLite with Engine available as a library)

  + [[https://github.com/cruppstahl/upscaledb][upscaledb]] - (C Library) "upscaledb is an embedded key/value
    database with blazingly fast analytical functions. A simple and
    self-documenting API; extensive documentation and a tutorial are
    provided. APIs for C/C++, Java, Python, .NET (i.e. C#, VB.NET),
    Erlang/Elixir and PHP are available. Applications using upscaledb
    are deployed on tens of millions of desktops, but also on cloud
    instances, cell phones and other embedded devices."

  + [[https://github.com/symisc/vedis][vedis]] - A file database, aka embedded databa however based on Redis 
    + "Vedis is an embeddable datastore C library built with over 70
      commands similar in concept to Redis but without the networking
      layer since Vedis run in the same process of the host
      application. Unlike most other datastores (i.e. memcache,
      Redis), Vedis does not have a separate server process. Vedis
      reads and writes directly to ordinary disk files. A complete
      database with multiple collections, is contained in a single
      disk file. The database file format is cross-platform, you can
      freely copy a database between 32-bit and 64-bit systems or
      between big-endian and little-endian architectures. Vedis is a
      self-contained C library without dependency. It requires very
      minimal support from external libraries or from the operating
      system. This makes it well suited for use in embedded devices
      that lack the support infrastructure of a desktop computer. This
      also makes Vedis appropriate for use within applications that
      need to run without modification on a wide variety of computers
      of varying configurations."

  + [[https://github.com/google/leveldb][LevelDB]]
    + Embedded NO-SQL database library (not server) which is a
      fast key-value storage library written at Google that provides an
      ordered mapping from string keys to string values.
    + More:
      + https://dbdb.io/db/leveldb
      + https://en.wikipedia.org/wiki/LevelDB

  + [[http://lmdbxx.sourceforge.net/][LMDB++]]  

  + [[http://otl.sourceforge.net/][OTL]]

Standalone Databases  

** Computer Graphics, Data Visualization and Game Engines 
*** Fundamental 

   + [[https://github.com/glfw/glfw][glfw]] - "GLFW is an Open Source, multi-platform library for OpenGL,
     OpenGL ES and Vulkan application development. It provides a simple,
     platform-independent API for creating windows, contexts and
     surfaces, reading input, handling events, etc. GLFW natively
     supports Windows, macOS and Linux and other Unix-like systems. On
     Linux both X11 and Wayland is supported. GLFW is licensed under the
     zlib/libpng license."
     + Web Site: https://www.glfw.org

   + [[https://glm.g-truc.net/0.9.9/index.html][GLM - OpenGL Mathematics]] - "OpenGL Mathematics (GLM) is a header only C++
     mathematics library for graphics software based on the OpenGL
     Shading Language (GLSL) specifications."

   + [[https://github.com/bkaradzic/bgfx][bgx]] - "Cross-platform, graphics API agnostic, "Bring Your Own
     Engine/Framework" style rendering library. Supported rendering
     backends: Direct3D 9; Direct3D 11; Direct3D 12; Metal; OpenGL
     2.1; OpenGL 3.1+; OpenGL ES 2; OpenGL ES 3.1; Vulkan; WebGL 1.0; WebGL 2.0"
     + Summary: Open-GL like library that abstract over many different
       GPU computer-graphics APIs such as OpenGL, DirectX and Metal
       (Apple).
     + See:
       + Documentation: https://bkaradzic.github.io/bgfx/overview.html

   + [[https://github.com/matus-chochlik/oglplus][oogplus]] - C++ Wrapper for OpenGL 
     + "OGLplus is a collection of open-source, cross-platform
       libraries which implement an object-oriented facade over the
       OpenGL® (version 3 and higher) and also OpenAL® (version 1.1) and
       EGL (version 1.4) C-language APIs. It provides wrappers which
       automate resource and object management and make the use of these
       libraries in C++ safer and more conve… http://oglplus.org/" 

   + [[https://github.com/cginternals/glbinding][glbinding]] - "glbinding leverages C++11 features like enum
     classes, lambdas, and variadic templates, instead of relying on
     macros; all OpenGL symbols are real functions and variables. It
     provides type-safe parameters, per feature API header, lazy
     function resolution, multi-context and multi-thread support,
     global and local function callbacks, meta information about the
     generated OpenGL binding and the OpenGL runtime, as well as tools
     and examples for quick-starting your projects. Based on the
     OpenGL API specification (gl.xml) glbinding is generated using
     python scripts and templates that can be easily adapted to fit
     custom needs."
     + Site: https://glbinding.org

   + [[http://glew.sourceforge.net/][Glew]] - The OpenGL Extension Wrangler Library - " The OpenGL
     Extension Wrangler Library (GLEW) is a cross-platform open-source
     C/C++ extension loading library. GLEW provides efficient run-time
     mechanisms for determining which OpenGL extensions are supported on
     the target platform. OpenGL core and extension functionality is
     exposed in a single header file. GLEW has been tested on a variety
     of operating systems, including Windows, Linux, Mac OS X, FreeBSD,
     Irix, and Solaris."

   + [[https://github.com/google/mathfu][mathfu]]
     + "MathFu is a C++ math library developed primarily for games
       focused on simplicity and efficiency. It provides a suite of
       vector, matrix and quaternion classes to perform basic geometry
       suitable for game developers. This functionality can be used to
       construct geometry for graphics libraries like OpenGL or
       perform calculations for animation or physics systems. The
       library is written in portable C++ with SIMD compiler
       intrinsics and has been tested on the following platforms:
       Android; Linux (x86_64); OS X and Windows"

*** Game Engine 

   + [[https://github.com/godotengine/godot][godot]] - "Godot Engine is a feature-packed, cross-platform game
     engine to create 2D and 3D games from a unified interface. It
     provides a comprehensive set of common tools, so that users can
     focus on making games without having to reinvent the wheel. Games
     can be exported in one click to a number of platforms, including
     the major desktop platforms (Linux, Mac OSX, Windows) as well as
     mobile (Android, iOS) and web-based (HTML5) platforms."
     + Site:    https://godotengine.org/
     + Twitter: https://twitter.com/godotengine?lang=en
     + Reddit:  https://www.reddit.com/r/godot/

   + [[https://www.ogre3d.org/][Ogre3D]] - Object-Oriented Graphics Rendering Engine
     + API Docs: https://ogrecave.github.io/ogre/api/latest/

   + [[http://www.libsdl.org/][SDL]] - "Simple DirectMedia Layer is a cross-platform development
     library designed to provide low level access to audio, keyboard,
     mouse, joystick, and graphics hardware via OpenGL and Direct3D. It
     is used by video playback software, emulators, and popular games
     including Valve's award winning catalog and many Humble Bundle
     games."

   + [[https://sourceforge.net/projects/alleg/][Allegro]] - "Allegro is a cross-platform library intended for use in
     computer games and other types of multimedia programming."

   + [[https://www.sfml-dev.org/][SFML]] - "SFML provides a simple interface to the various components
     of your PC, to ease the development of games and multimedia
     applications. It is composed of five modules: system, window,
     graphics, audio and network."

   + [[https://www.raylib.com/][raylib]] - "raylib is a simple and easy-to-use library to enjoy
     videogames programming. raylib is highly inspired by Borland BGI
     graphics lib and by XNA framework."
     + https://github.com/raysan5/raylib

   + [[https://magnum.graphics/][Magnum Engine]] - "Lightweight and modular C++11/C++14 graphics
     middleware for games and data visualization." 

   + [[https://libcinder.org/about][Cinder]] - "Cinder is a C++ library for programming with aesthetic
     intent - the sort of development often called creative coding. This
     includes domains like graphics, audio, video, and computational
     geometry. Cinder is cross-platform, with official support for
     macOS, Windows, Linux, iOS, and Windows UWP." 

   + [[https://bkaradzic.github.io/bgfx/index.html][Bgfx]] - Cross-platform, graphics API agnostic, “Bring Your Own
     Engine/Framework” style rendering library, licensed under
     permissive BSD-2 clause open source license.  

   + [[https://openframeworks.cc/][Openframeworks]] - "openFrameworks is an open source C++ toolkit for
     creative coding."

*** Plotting, Scene Graph and CAD/CAM Engines 

   + [[http://plplot.sourceforge.net/][Plplot]] - "PLplot is a cross-platform software package for
     creating scientific plots whose (UTF-8) plot symbols and text are
     limited in practice only by what Unicode-aware system fonts are
     installed on a user's computer. The PLplot software, which is
     primarily licensed under the LGPL, has a clean architecture that
     is organized as a core C library, separate language bindings for
     that library, and separate device drivers that are dynamically
     loaded by the core library which control how the plots are
     presented in noninteractive and interactive plotting
     contexts. The PLplot core library can be used to create standard
     x-y plots, semi-log plots, log-log plots, contour plots, 3D
     surface plots, mesh plots, bar charts and pie charts. Multiple
     graphs (of the same or different sizes) may be placed on a single
     page, and multiple pages are allowed for those device formats
     that support them."
     + Repository: https://github.com/PLplot/PLplot (Mirror)

   + [[https://github.com/Kitware/VTK][Kitware/VTK]] [Scientific visualization] - "VTK is an open-source
     software system for image processing, 3D graphics, volume
     rendering and visualization. VTK includes many advanced
     algorithms (e.g., surface reconstruction, implicit modelling,
     decimation) and rendering techniques (e.g., hardware-accelerated
     volume rendering, LOD control). VTK is used by academicians for
     teaching and research; by government research institutions such
     as Los Alamos National Lab in the US or CINECA in Italy; and by
     many commercial firms who use VTK to build or extend
     products. The origin of VTK is with the textbook "The
     Visualization Toolkit, an Object-Oriented Approach to 3D
     Graphics" originally published by Prentice Hall and now published
     by Kitware, Inc. (Third Edition ISBN 1-930934-07-6). VTK has
     grown (since its initial release in 1994) to a world-wide user
     base in the commercial, academic, and research communities."
     + Site: https://vtk.org/
     + https://en.wikipedia.org/wiki/VTK

   + [[http://www.openscenegraph.org/][OpenSceneGraph]] (Scene Graph)
     + "The OpenSceneGraph is an open source high performance 3D
       graphics toolkit, used by application developers in fields such
       as visual simulation, games, virtual reality, scientific
       visualization and modelling. Written entirely in Standard C++
       and OpenGL it runs on all Windows platforms, OSX, GNU/Linux,
       IRIX, Solaris, HP-Ux, AIX and FreeBSD operating systems. The
       OpenSceneGraph is now well established as the world leading
       scene graph technology, used widely in the vis-sim, space,
       scientific, oil-gas, games and virtual reality industries."

   + [[https://www.opencascade.com/content/overview][OpenCascade]] (CAD/CAM Engine)
     + "Open CASCADE Technology (OCCT) is an object-oriented C++ class
       library designed for rapid production of sophisticated
       domain-specific CAD/CAM/CAE applications. OCCT library is
       designed to be truly modular and extensible, providing C++
       classes for: Basic data structures (geometric modeling,
       visualization, interactive selection and application specific
       services); Modeling algorithms; Working with mesh (faceted)
       data; Data interoperability with neutral formats (IGES, STEP);"

   + [[https://github.com/buserror/libc3][buserror/libc3]] (Scene Graph) [C Library]
     + "WARNING This API is not your nanny. It is made to be lean,
       mean, efficient with no frill, no asserts, no bounds checking,
       no sugar coating. On the other hand it's fast, reasonably clean
       and is a micro-fraction of the other giganormous 'scene graphs'
       or 'game engine' libraries around. It's vaguely inspired by
       THREE.js funnily enough, because it allows you to hack around
       and quickly get stuff on screen with the minimal amount of
       effort."

*** Entity Component System - ECS 

   + [[https://github.com/skypjack/entt][entt]] - "EnTT is a header-only, tiny and easy to use library for
     game programming and much more written in modern C++, mainly
     known for its innovative entity-component-system (ECS)
     model. Among others, it's used in Minecraft by Mojang and the
     ArcGIS Runtime SDKs by Esri. Open an issue or submit a PR if you
     don't see your project in the list!"
     + https://github.com/skypjack/entt/wiki

   + [[https://github.com/alecthomas/entityx][entityx]] - "EntityX - A fast, type-safe C++ Entity-Component system"

   + [[https://github.com/miguelmartin75/anax][anax]] - "anax is an open source C++ entity system designed to be
     portable, lightweight and easy to use. It is aimed toward Game
     Development, however it would be possible to use it for other
     projects."

*** Misc - Non Categorized 

   * [[https://github.com/assimp/assimp][assimp]] - Open Asset Import Library (assimp) 
     + Brief: Library for importing a broad range of game assets.
     + "Official Open Asset Import Library Repository. Loads 40+ 3D
       file formats into one unified and clean data
       structure. http://www.assimp.org"

   * [[https://github.com/Dav1dde/glad][glad]] -  Multi-Language Vulkan/GL/GLES/EGL/GLX/WGL
     Loader-Generator based on the official
     specs. https://glad.dav1d.de/

   * [[https://github.com/wjakob/nanogui][nanogui]] - "NanoGUI is a minimalistic cross-platform widget
     library for OpenGL 3.x or higher. It supports automatic layout
     generation, stateful C++11 lambdas callbacks, a variety of useful
     widget types and Retina-capable rendering on Apple devices thanks
     to NanoVG by Mikko Mononen. Python bindings of all functionality
     are provided using pybind11." 

   * [[https://github.com/ocornut/imgui][Imgui]] - Imediate mode GUI Library for games

   * [[https://github.com/i42output/neogfx][neogfx]] - Cross-platform GPU-oriented C++ application/game framework
     + "neoGFX is a cross-platform GPU-oriented C++ application/game
       framework. neoGFX is still a work in progress (incomplete) so
       is not yet suitable for making apps or games. Currently neogfx
       has only been built for and tested on Windows."
     + Site: https://neogfx.org/
     + Features:
       + clean modern C++ design including full exception safety
         supporting various widget allocation patterns (stack, member
         variable or free store);
       + use of standard non-proprietary C++ data types including
         using standard string classes (UTF-8 encoding) and containers
         from the C++ standard library;
       + scripting engine, neos, that will be able to support a wide
         range of scripting languages (on release: neoscript,
         JavaScript and Lua);
       + Pure ECS (Entity-component-system) usable by both games and apps;
       + support for OpenGL, DirectX and Vulkan.

   * [[https://github.com/memononen/nanovg][nanovg]] - NanoVG is small antialiased vector graphics rendering
     library for OpenGL. It has lean API modeled after HTML5 canvas
     API. It is aimed to be a practical and fun toolset for building
     scalable user interfaces and visualizations. 

   * [[https://vis.uni-koeln.de/visionaray.html][Visionary]] - Visionaray - A C++ ray tracing template library
     + https://github.com/szellmann/visionaray

   * [[https://github.com/apitrace/apitrace][apitrace]] [TOOL, APP] - "apitrace consists of a set of tools to:
     trace OpenGL, OpenGL ES, Direct3D, and DirectDraw APIs calls to a
     file; replay OpenGL and OpenGL ES calls from a file; inspect
     OpenGL state at any call while retracing; visualize and edit
     trace files."
** Dependency Injection

+ [[http://wallaroolib.sourceforge.net/][Wallaroo]] - "Wallaroo is a dependency injection library for C++
  released under the BOOST software license. With wallaroo, you can
  easily separate the object graph from the class implementation. You
  can create objects and wire them using strings so that you can load
  the "object graph" from a configuration file."

+ [[https://github.com/ybainier/Hypodermic][Hypodermic]] - "Hypodermic is an IoC container for C++. It provides
  dependency injection to your existing design. Hypodermic is a
  non-intrusive header only IoC container for C++. It provides
  dependency injection to your existing design by managing the
  creation of your components and their dependencies in the right
  order, sparing you the trouble of writing and maintaining boiler
  plate code."   
** Crypto, hash and secure socket SSL / TSL 

 *Crypto Hashes and base64 - file signatures => MD5, SHA1, SHA-256*

  + [[https://github.com/tplgy/cppcodec][CppCodec]] - "Header-only C++11 library to encode/decode base64,
    base64url, base32, base32hex and hex (a.k.a. base16) as specified in
    RFC 4648, plus Crockford's base32. MIT licensed with consistent,
    flexible API. Supports raw pointers, std::string and (templated)
    character vectors without unnecessary allocations. Cross-platform
    with measured decent performance and without compiler warnings." 

 *General Crypto Libraries:*

  + [[https://www.cryptopp.com/][Crypto++]] - (Cryptopp) "Crypto++ Library is a free C++ class library
    of cryptographic schemes."

  + [[https://www.libtom.net/][Libtom]] - "LibTomCrypt is a fairly comprehensive, modular and
    portable cryptographic toolkit that provides developers with a vast
    array of well known published block ciphers, one-way hash
    functions, chaining modes, pseudo-random number generators, public
    key cryptography and a plethora of other routines."
    + https://github.com/libtom/libtomcrypt

  + [[https://github.com/bitcoin-core/secp256k1][secp256k1]] - "Optimized C library for EC operations on curve
    secp256k1. This library is a work in progress and is being used to
    research best practices. Use at your own risk."

 *Secure Communication SSL (Socket Secure Layer) / TSL (Transport Secure Layer)*

  + [[https://www.openssl.org/][OpenSSL]] - [REFERENCE IMPLEMENTATION] "OpenSSL is a robust,
    commercial-grade, and full-featured toolkit for the Transport
    Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It
    is also a general-purpose cryptography library."
    + See: OpenSSL criticism
      + [[https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations][Comparison of TLS implementations - Wikipedia]]
      + Criticism: https://www.peereboom.us/assl/assl/html/openssl.html

  + [[https://www.gnutls.org/][GNU TLS]] - The GnuTLS Transport Layer Security Library

  + [[https://www.libressl.org/][LibreSSL]] - "LibreSSL is a version of the TLS/crypto stack forked
    from OpenSSL in 2014, with goals of modernizing the codebase,
    improving security, and applying best practice development
    processes. Primary development occurs inside the OpenBSD source tree
    with the usual care the project is known for. On a regular basis the
    code is re-packaged for portable use by other operating systems
    (Linux, FreeBSD, Windows, etc)."

  + [[https://www.wolfssl.com/][WolfSSL]] (GPL 2.0) - "The wolfSSL embedded SSL library is a
    lightweight, portable, C-language-based SSL/TLS library targeted
    at IoT, embedded, and RTOS environments primarily because of its
    size, speed, and feature set. It works seamlessly in desktop,
    enterprise, and cloud environments as well. wolfSSL supports
    industry standards up to the current TLS 1.3 and DTLS 1.2, is up
    to 20 times smaller than OpenSSL, offers a simple API, an OpenSSL
    compatibility layer, OCSP and CRL support, is backed by the robust
    wolfCrypt cryptography library, and much more."
    + Github: https://github.com/wolfssl

  + [[https://botan.randombit.net/][Botan]] - "Botan’s goal is to be the best option for cryptography in
    C++ by offering the tools necessary to implement a range of
    practical systems, such as TLS protocol, X.509 certificates, modern
    AEAD ciphers, PKCS#11 and TPM hardware support, password hashing,
    and post quantum crypto schemes."
** Embedded Systems 
*** General

  * [[https://www.etlcpp.com/][ETLCPP]] - Embedded Template Library

  * [[https://github.com/sendyne/cppreg][CPPREG]] - "cppreg is a header-only C++11 library to facilitate the
    manipulation of MMIO registers (i.e., memory-mapped I/O registers)
    in embedded devices. The idea is to provide a way to write
    expressive code and minimize the likelihood of ill-defined
    expressions when dealing with hardware registers on a MCU
    (Microcontroller Unit)."

  * [[https://uavcan.org/][LIVUAVCAN]] - "Portable reference implementation of the UAVCAN
    protocol stack in C++ for embedded systems and Linux. UAVCAN is a
    lightweight protocol designed for reliable communication in
    aerospace and robotic applications via CAN bus."
    * Site: https://uavcan.org/
    * Repos:
      * https://github.com/UAVCAN/libuavcan
      * https://github.com/UAVCAN/libuavcan_stm32

  * [[http://cpputest.github.com][CppUtest]] - "CppUTest unit testing and mocking framework for C/C++ -
    CppUTest is a C /C++ based unit xUnit test framework for unit
    testing and for test-driving your code. It is written in C++ but is
    used in C and C++ projects and frequently used in *embedded systems*
    but it works for any C/C++ project."
    + http://cpputest.github.com
    + https://github.com/cpputest/cpputest

  * [[https://github.com/cesanta/mongoose][Mongoose]] - "Mongoose Embedded Web Server Library - Mongoose is more
    than an embedded webserver. It is a multi-protocol embedded
    networking library with functions including TCP, HTTP client and
    server, WebSocket client and server, MQTT client and broker and
    much more. Mongoose is ideal for embedded environments. It has been
    designed for connecting devices and bringing them online. On the
    market since 2004, used by vast number of open source and
    commercial products - it even runs on the International Space
    station! Mongoose makes embedded network programming fast, robust,
    and easy."
    + Note: GPL 2.0 License and commercial license for closed source.

  * [[https://github.com/tianocore/edk2][tianocore/edk2]]
    * "A modern, feature-rich, cross-platform firmware development
      environment for the UEFI and PI specifications from
      www.uefi.org. The majority of the content in the EDK II open
      source project uses a BSD-2-Clause Plus Patent License. The EDK
      II open source project contains the following components that
      are covered by additional licenses: ..."

  * [[https://www.arduinolibraries.info/libraries][Arduino Library List]] - "A list of the 2303 libraries registered in
    the Arduino Library Manager."

*** Operating Systems for IOT 

 + [[http://www.contiki-os.org/#why][Contiki]] - "Contiki is an open source operating system for the
   Internet of Things. Contiki connects tiny low-cost, low-power
   microcontrollers to the Internet. Contiki is a powerful toolbox for
   building complex wireless systems.  Contiki is developed by a
   world-wide team of developers with contributions from Atmel, Cisco,
   ETH, Redwire LLC, SAP, Thingsquare, and many others, led by Adam
   Dunkels of Thingsquare."
   + Repository: https://github.com/contiki-os/contiki

 + [[https://www.zephyrproject.org][Zephyr]]  - "The Zephyr Project is a scalable real-time operating
   system (RTOS) supporting multiple hardware architectures, optimized
   for resource constrained devices, and built with security in
   mind. The Zephyr OS is based on a small-footprint kernel designed
   for use on resource-constrained systems: from simple embedded
   environmental sensors and LED wearables to sophisticated smart
   watches and IoT wireless gateways. The Zephyr kernel supports
   multiple architectures, including ARM Cortex-M, Intel x86, ARC,
   Nios II, Tensilica Xtensa, and RISC-V, and a large number of
   supported boards."
   + Repository: https://github.com/zephyrproject-rtos/zephyr

*** RTOS - Real Time Operating Systems 

+ [[http://sourceforge.net/projects/qpc/files/QP_C%252B%252B/4.5.04/][QP/C++]] -  RTOS kernel - License: dual GPL. Closed source
  applications require a commercial license.

+ [[http://distortos.org/][distortos]] - object-oriented C++ RTOS for microcontrollers

+ [[https://www.freertos.org/][FreeRTOS Kernel]] / RTOS

+ [[https://xenomai.org/][Linux Xenomai]] - " Xenomai brings POSIX and traditional RTOS APIs for
  porting time-critical applications to Linux-based platforms. When
  the native Linux kernel cannot meet the response time requirements
  of the application, Xenomai supplements it with Cobalt, a small
  real-time infrastructure which schedules time-critical activities
  independently from the main kernel logic." 
  + Repository: https://gitlab.denx.de/Xenomai/xenomai
  + See:
    + [[https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here][Xenomai Wiki]]
    + [[https://elinux.org/images/7/76/Kiszka.pdf][Xenomai 3 - An Overview of the Real-Time Framework for Linux]]
    + [[http://linuxgizmos.com/real-time-linux-explained/][Real Time Linux explained, and constrated with Xenomai adn RTAI]]

+ [[https://www.rtems.org/][RTEMS]] / RTOS - Real-Time Executive for Multiprocessor Systems 
  + "The Real-Time Executive for Multiprocessor Systems or RTEMS is an
    open source Real Time Operating System (RTOS) that supports open
    standard application programming interfaces (API) such as
    POSIX. It is used in space flight, medical, networking and many
    more embedded devices using processor architectures including ARM,
    PowerPC, Intel, Blackfin, MIPS, Microblaze and more. Commercial
    support is available from US and European companies, and free
    support comes via the active global community."
  + Comes from: Aerospace Industry 
  + See:
    + [[https://blog.qt.io/blog/2018/05/03/qt-microncontrollers-mcu/][Qt on Microcontrollers (MCU)]]
    + [[http://rtemsramblings.blogspot.com/2010/02/nasa-solar-dynamic-observatory-launched.html][NASA Solar Dynamic Observatory Launched]]

+ [[http://ecos.sourceware.org/][eCOS]] / RTOS - Open Source Real Time Operating System
  + "eCos is a free open source real-time operating system intended
    for embedded applications. The highly configurable nature of
    eCos allows the operating system to be customised to precise
    application requirements, delivering the best possible run-time
    performance and an optimised hardware resource footprint. A
    thriving net community has grown up around the operating system
    ensuring on-going technical innovation and wide platform
    support."
  + Comes from: Automotive Industry 
*** Robot Control Software Frameworks
 
 * [[http://www.orocos.org/][Orocos]] - *Open Robot Control Software* - Set of libraries for
   implementing robot control software. 
   + Repositories:
     + https://github.com/orocos-toolchain/
     + https://github.com/orocos

 * [[https://www.ros.org/][ROS]] - *Robot Operating System* - "Set of software libraries and tools
   that help you build robot applications. From drivers to
   state-of-the-art algorithms, and with powerful developer tools, ROS
   has what you need for your next robotics project. And it's all open
   source." 

*** Modbus Protcol 

 + [[https://libmodbus.org/][libmodbus]] - "A Modbus library for Linux, Mac OS X, FreeBSD, QNX and Win32"

 + [[https://sourceforge.net/projects/qmodmaster/][QModMaster]] -  Modbus TCP,RTU Master Software - "QModMaster is a
   free Qt-based implementation of a ModBus master application. A
   graphical user interface allows easy communication with ModBus RTU
   and TCP slaves. QModMaster also includes a bus monitor for
   examining all traffic on the bus."

 + [[https://github.com/fanzhe98/modbuspp][modbuspp]] - A C++ Library for Modbus TCP Protocol
*** HMI and SCADA 

 + [[https://community.kde.org/Incubator/Projects/CuteHMI][CuteHMI]]  
   + "CuteHMI is meant to be a set of software components (libraries
     and executables) targeted at building *HMI* ( *Human Machine*
     *Interface*) applications. These components aim to fill the gap,
     between open-source editions of Qt and commercial software
     targeted at physical computing (*HMI / SCADA / IoT / BMS / RMS /
     etc*) build around it, thus providing complete open-source suite
     for such types of applications for home and industrial
     use. Example use case is to create user interface that can be
     used to communicate with PLC (programmable logic controller) to
     turn on air conditioning in the building for example."
   + Web Site:
     + https://cutehmi.kde.org/
   + Repository:
     + https://invent.kde.org/kde/cutehmi
   + Github Mirror:
     + https://github.com/michpolicht/CuteHMI

 + [[https://github.com/IndeemaSoftware/QSimpleScada][QSimpleScada]]
   + "Qt/C++ based simple SCADA framework, with dashboard, static and
     dynamic components. By using QSimpleScada framework you can build
     complex SCADA uis for your needs." 
     
*** GUI - Graphical User Interface 

  + *QT Framework*
    + See: [[https://blog.qt.io/blog/2018/05/03/qt-microncontrollers-mcu/][Qt on Microcontrollers (MCU)]]

  + [[https://github.com/ghaerr/microwindows][microwindows]] - Microwindows or the Nano-X Window System
    + "Microwindows or Nano-X is a small graphical windowing system
      that implements both Win32 and Nano-X (X11-like) APIs for
      clipped graphics drawing in windows on Linux, Mac OS X,
      EMSCRIPTEN, Android and other platforms. It is Open Source and
      licenced under the the Mozilla Public License. For creating
      GUIs, the Nuklear immediate mode GUI, Win32 builtin controls,
      and TinyWidget's controls based on Nano-X are included. FLTK can
      be used with the X11 compability library NX11."
    + Platform support: Currently supported platforms include Linux,
      Mac OS X, Android, EMSCRIPTEN, Nuklear GUI, Windows, Raspberry
      Pi, DOS DJGPP, RTEMS, ECOS, Sony PSP, Nintendo DS and
      more. Currently supported screen drivers include Memory-mapped
      framebuffer, X11, SDL 2, Allegro 5, Windows and an X11 based
      framebuffer emulator. Support for cross-compiler toolchains on
      x86, x86_64, ARM, PowerPC and MIPS, big- and little-endian, and
      other processors. 

*** Embedded Linux Libraries and tools 
 
   * [[https://busybox.net/][BusyBox]] (Application - GPL v2.0)
     * "BusyBox combines tinyversions of many common UNIX utilities
       into a single small executable.  It provides minimalist
       replacements for most of the utilities you usually find in
       bzip2, coreutils, dhcp, diffutils, e2fsprogs, file, findutils,
       gawk, grep, inetutils, less, modutils, net-tools, procps, ed,
       shadow, sysklogd, sysvinit, tar, util-linux, and vim.  The
       utilities in BusyBox often have fewer options than their
       full-featured cousins; however, the options that are included
       provide the expected functionality and behave very much like
       their larger counterparts. BusyBox has been written with
       size-optimization and limited resources in mind, both to
       produce small binaries and to reduce run-time memory
       usage. Busybox is also extremely modular so you can easily
       include or exclude commands (or features) at compile time.
       This makes it easy to customize embedded systems; to create a
       working system, just add /dev, /etc, and a Linux kernel.
       Busybox (usually together with uClibc) has also been used as a
       component of "thin client" desktop systems, live-CD
       distributions, rescue disks, installers, and so on."
     * Official GIT Repo: https://git.busybox.net/busybox/
     * Mirror Repository: https://github.com/mirror/busybox
     * Busybox for Android: https://github.com/meefik/busybox

   * [[http://landley.net/toybox/][ToyBox]] (BusyBox Clone with BSD License)
     * "Toybox combines common Linux command line utilities together
       into a single BSD-licensed executable that's simple, small,
       fast, reasonably standards-compliant, and powerful enough to
       turn Android into a development environment."
     * Site: http://landley.net/toybox/
     * Repo: https://github.com/landley/toybox

   * [[https://01.org/ell][ELL]] - Embedded Linux Library
     * "The Embedded Linux* Library (ELL) provides core, low-level
       functionality for system daemons. It typically has no
       dependencies other than the Linux kernel, C standard library,
       and libdl (for dynamic linking). While ELL is designed to be
       efficient and compact enough for use on embedded Linux
       platforms, it is not limited to resource-constrained systems."
     * Features:
       * Event loop that may run standalone or be integrated with another event loop
       * D-Bus client
       * Generic Netlink client
       * Timeout handling
       * Signal handling
       * Runtime plugins
       * Asynchronous/non-blocking I/O framework
       * Data structures: Queues (linked list), hash tables, ring buffers
       * String handling
       * Base64 encode/decode
       * File parsing (PEM, hwdb, settings)
       * Symmetric ciphers (kernel support required)
       * RSA cryptography (kernel support required)
       * Key handling

*** Linux CRT - Linux C-Runtime and C++-Runtime Libraries :clib:embedded:linux:

 Note: Listing of alternative Linux C-runtime libraries to the GLIBC (GNU LibC / GPL).

  * [[http://www.musl-libc.org/][MUSL]]
    + License: MIT 
    + Musl is a lightweight Linux C-runtime library suitable for
      generating portable static-linked self-contained executables.
    + "musl is a “libc”, an implementation of the standard library
      functionality described in the ISO C and POSIX standards, plus
      common extensions, intended for use on Linux-based
      systems. Whereas the kernel (Linux) governs access to hardware,
      memory, filesystems, and the privileges for accessing these
      resources, the C library is responsible for providing the actual
      C function interfaces userspace applications see, and for
      constructing higher-level buffered stdio, memory allocation
      management, thread creation and synchronization operations, and
      so on using the lower-level interfaces the kernel provides, as
      well as for implementing pure library routines of the C language
      like strstr, snprintf, strtol, exp, sqrt, etc."
    + Repository Mirror: https://github.com/ifduyue/musl

  * [[https://www.fefe.de/dietlibc/][DietLibc]]
    * "The diet libc is a libc that is optimized for small size. It
      can be used to create small statically linked binaries for Linux
      on alpha, arm, hppa, ia64, i386, mips, s390, sparc, sparc64, ppc
      and x86_64." 

  * [[https://uclibc-ng.org/][ULIBC]] 
    * License: LGPL-2.1
    * "uClibc-ng is a small C library for developing embedded Linux
      systems. It is much smaller than the GNU C Library, but nearly
      all applications supported by glibc also work perfectly with
      uClibc-ng."
    * Web Sites:
      * https://uclibc-ng.org/
      * https://uclibc.org/

  * [[https://en.wikipedia.org/wiki/Bionic_(software)][Bionic]] - Android CRT C-Runtime Library created by Google for
    Android Operating System. Unlike most Linux distribution built on
    top of Linux Kernel which uses the GLIBC (GNU C Library) as CRT,
    Android uses Bionic C library which is based on BSD C Library.
    * License: BSD-3
    * Repository: https://android.googlesource.com/platform/bionic

  * [[https://cxx.uclibc.org/][uClibC++]] (C++ Runtime Library)
    * "This is the page for the uClibc++ C++ library. It is currently
      in development and might as well be called alpha
      software. Nonetheless is it quite usable. More testing is needed,
      as always. For more information, check out the About, FAQ or
      Status pages to the left."

  * [[http://www.eglibc.org/home][EGLIBC]] [DISCONTINUED]
    * License: LGPL-2.1 
    * " Embedded GLIBC (EGLIBC) was a variant of the GNU C Library
      (GLIBC) that was designed to work well on embedded
      systems. EGLIBC strived to be source and binary compatible with
      GLIBC. EGLIBC's goals included reduced footprint, configurable
      components, better support for cross-compilation and
      cross-testing."

  * [[https://github.com/lpsantil/rt0][RT0]] - "A minimal C runtime for Linux i386 & x86_64"

  *See also:*

 Comparison between Linux C-Runtime Libraries:
  + http://www.etalabs.net/compare_libcs.html

 C Library Comparison:
  + https://wiki.osdev.org/C_Library

 Choosing System C Library:
  + https://events.static.linuxfound.org/sites/events/files/slides/libc-talk.pdf

 C library system-call wrappers, or the lack thereof
  + https://lwn.net/Articles/771441/
