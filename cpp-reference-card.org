#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

- [[wiki:index][Index]]

* STL Reference Card 
** STL Components 

 - *Containers* - standard collections or data structures, they are a
   fundamental building block of most programming languages, in C++
   the addition benefit is that most of them abstracts away the memory
   allocation as they can grow or shrink during the program runtime.
   * Sequential
     + *vector*
     + *deque*
     + array
     + list
     + forward list 
     + valarray [DEPRECATED] - It would provide a Fortran-like fixed
       size array for linear algebra. But the STL implementation is incomplete.
   * Associative
     + Ordered Associative Container 
       + *map* - key-value data structure, also known as dictionary. A
         map always have unique keys. 
         hash-map, hash table and so on.
       + *set* - A set is data structure which cannot have any repeated
         values. 
       + multimap - A multimap can have repeated keys. 
       + multiset
     + Unordered Associative Containers
       + ~unordered_map~
       + ~unordered_set~
 - *Iterators*
 - *Algorithms*
 - *Adapters*
   - Queue
   - Stack 

** Bookmarks 

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/containers.html][Helsinki - university - STL Containers]]

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/algorithms.html][Helsinki University - STL Algorithms]]

** STL Sequential Container Methods - Cheat Sheet  
*** Use Cases 

Use Cases: 
 + _vector_
   + Operations where the vector size is known in advance and it is
     necessary constant access time for random access to any
     element. Example of use case: linear algebra and numerical
     algorithms. Insertion of elements at end or at the front is
     efficient, however it less efficient than the deque container and
     whenever a new element is added. Vectors are not ideal for
     operations where the number of elements is not known because its
     elements are stored in C-array allocated in the heap, as result,
     all elements are reallocated whenever a new element is added or
     removed.
   + Use cases:
     + General sequential container
     + Linear algebra and numerical algorithms 
     + C++ replacement for C-arrays 
     + C-arrays interoperability
 + _deque_
   + Operations with requires fast random access time and fast
     insertion or deletion of elements at both ends. Unlike vectors,
     deque is not stored internally as a C-array and unlike vectors,
     whenever an element is inserted, any reallocation happens which
     means that deques are more efficient than vectors when the size
     of container is not known in advance.
   + Use Case:
     + General sequential container
     + Fast random access
     + Number of elements aren't known in advance.
*** Member Functions / Methods reference table 

| Method of Container<T> | Return type | Description                                              | vector | deque | list | array |
|------------------------+-------------+----------------------------------------------------------+--------+-------+------+-------|
| *Element Access*         |             |                                                          |        |       |      |       |
| operator[](int n)      | T&          | return nth-element, doesn't throw exception.             | yes    | yes   | no   | yes   |
| at(int n)              | T&          | return nth-element, but throws exception.                | yes    | yes   | no   | yes   |
| front()                | T&          | return first element                                     | yes    | yes   | yes  | yes   |
| back()                 | T&          | return last element                                      | yes    | yes   | yes  | yes   |
| data()                 | T*          | Return pointer to first element of container.            | yes    | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Capacity*               |             |                                                          |        |       |      |       |
| size()                 | size_t      | Return number of container elements.                     | yes    | yes   | yes  | yes   |
| max_size()             | size_t      | Return maximum container size.                           | yes    | yes   | yes  | yes   |
| empty()                | bool        | Return true if container is empty                        | yes    | yes   | yes  | yes   |
| reserve(size_t n)      | void        | Reserve a minimum storage for vectors.                   | yes    | no    | no   | no    |
| resize(size_t n)       | void        | Resize container to n elements.                          | yes    | yes   | yes  | no    |
|                        |             |                                                          |        |       |      |       |
| *Modifiers*              |             |                                                          |        |       |      |       |
| ~push_back(T t)~         | void        | Add element at the end of container                      | yes    | yes   | yes  | no    |
| ~push_front(T t)~        | void        | Add element at the beggining of container.               | yes    | yes   | yes  | no    |
| ~pop_back()~             | void        | Delete element at the end of container.                  | yes    | yes   | yes  | no    |
| ~pop_front()~            | void        | Delete element at beginning of container.                | yes    | yes   | yes  | no    |
| emplace_back           | void        | Construct and insert element at the end without copying. | yes    | yes   | yes  | no    |
| clear()                | void        | Remove all elements.                                     | yes    | yes   | yes  | no    |
| fill(T t)              | void        | Fill all elements                                        | no     | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Iterator*               |             |                                                          |        |       |      |       |
| begin()                | iterator    | Return iterator to beggining                             |        |       |      |       |
| end()                  | iterator    | Return iterator to end                                   |        |       |      |       |
| rbegin()               | iterator    | Return reverse iterator to beggining                     |        |       |      |       |
| rend()                 | iterator    | Return reverse iterator to end                           |        |       |      |       |
| cbegin()               | iterator    | Return const iterator to beginning                       |        |       |      |       |
| cend()                 | iterator    | Return const iterator to end                             |        |       |      |       |
| crebegin()             | iterator    | Return const iterator to beginning                       |        |       |      |       |
| crend()                | iterator    | Return const iterator to end                             |        |       |      |       |
    
*** Constructors 

Vector constructors: 

#+BEGIN_SRC cpp 
  // Empty vector 
  >> std::vector<double> xs1
  (std::vector<double> &) {}

  // Intialize vector with a given size
  >> std::vector<double> xs2(5, 3.0)
  (std::vector<double> &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }

  // Constructor with uniform initialization 
  >> std::vector<double> xs4 {1.0, -2.0, 1.0, 10 }
  (std::vector<double> &) { 1.0000000, -2.0000000, 1.0000000, 10.000000 }

  // =========== Constructors with C++11 auto keyword =============//

  >> auto xs1 = vector<double>()
  (std::vector<double, std::allocator<double> > &) {}
  >> 
  >> auto xs2 = vector<double>(5, 3.0)
  (std::vector<double, std::allocator<double> > &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }
  >> 
  >> auto xs3 = vector<double>{1, -2, 1, 1}
  (std::vector<double, std::allocator<double> > &) { 1.0000000, -2.0000000, 1.0000000, 1.0000000 }
  >> 
#+END_SRC

Deque constructors: 

#+BEGIN_SRC cpp 
  >> std::deque<int> ds1
  (std::deque<int> &) {}
  >> 
  >> std::deque<int> ds2(5, 2)
  (std::deque<int> &) { 2, 2, 2, 2, 2 }
  >> 
  >> std::deque<int> ds3 {2, -10, 20, 100, 20}
  (std::deque<int> &) { 2, -10, 20, 100, 20 }
  >> 
  // ======== Constructors with auto type inference ========== //
  >> auto ds1 = std::deque<int>()
  (std::deque<int, std::allocator<int> > &) {}
  >> 
  >> auto ds2 = std::deque<int>(5, 2)
  (std::deque<int, std::allocator<int> > &) { 2, 2, 2, 2, 2 }
  >> 
  >> auto ds3 = std::deque<int>{2, -10, 20, 100, 20}
  (std::deque<int, std::allocator<int> > &) { 2, -10, 20, 100, 20 }
  >> 
#+END_SRC

References: 
 + [[http://www.cplusplus.com/reference/vector/vector/][vector - C++ Reference]]  
 + [[http://www.cplusplus.com/reference/stl/][Containers - C++ Reference]] 
 + [[https://embeddedartistry.com/blog/2017/9/11/choosing-the-right-stl-container-sequential-containers][Choosing the Right Container: Sequential Containers — Embedded Artistry]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/containers_sequential.html][STL Sequential Container Member Function Summary]] 
	 
*** Tips and tricks 
**** Pass containers by reference or const reference

If the intent of the operation is not modify the container, it is
preferrable to pass it by const reference in order to avoid copying
overhead. 

For instance, the function: 

#+BEGIN_SRC cpp 
  double computeNorm(std::vector<double> xs)
  {
   // The vector xs is copied here, if it has 1GB of memory.
   // It will use 2GB instead of 1GB!
    ... ... 
  }
#+END_SRC

Should be written as: 

#+BEGIN_SRC cpp 
  double computeNorm(const std::vector<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::list<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::deque<double>& xs)
  {
    ... ... 
  }
#+END_SRC
**** Use the member function emplace_back to avoid uncessary copies.

Example: 

 - file: stl-emplace.cpp

#+BEGIN_SRC cpp :export both :results code
  #include <iostream>
  #include <ostream>
  #include <iomanip>
  #include <string>
  #include <vector>
  #include <deque>

  struct Product{
          std::string  name;	
          int          quantity;
          double       price;
          Product(){
                  std::cerr << " [TRACE] - Empty constructor invoked\n";
          }
          Product(const std::string& name, int quantity, double price):
                  name(name),
                  quantity(quantity),
                  price(price){
                  std::cerr << " [TRACE] - Product created as " << *this << "\n" ;
          }
          // The compiler generate an copy constructor automatically,
          // but this one was written to instrument C++ value semantics
          // and check when copies happen.
          Product(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy constructor invoked -> copied = " << *this << "\n";
          }
          // Copy assignment-operator
          void operator=(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy assignment operator invoked = " << *this << "\n";		
          }
          // Make class printable 
          friend std::ostream& operator<< (std::ostream& os, const Product& p)
          {
                  int size1 = 10;
                  int size2 = 2;
                  return os << " Product{ "
                                    << std::setw(1) << " name = "       << p.name
                                    << std::setw(10) << "; quantity  = "  << std::setw(size2) << p.quantity
                                    << std::setw(size1) << "; price = "      << std::setw(size2) << p.price
                                    << " }";
          }
  };


  int main(){
          auto inventory = std::deque<Product>();

          // Using push_back
          std::cerr << "====== Experiment .push_back() ======\n";
          std::cerr << " [INFO] - Adding orange with .push_back\n";
          inventory.push_back(Product("Orange - 1kg", 10, 3.50));
          std::cerr << " [INFO] - Adding rice with .push_back \n";
          inventory.push_back({"Rice bag", 20, 0.80});

          // Using emlace_back
          std::cerr << "====== Experiment .emplace_back() ======\n";	
          std::cerr << " [INFO] - Adding baccon with .emplace_back \n";
          inventory.emplace_back("Fresh tasty bacon", 50, 30.25);
          std::cerr << " [INFO] - Adding soft drink with .emplace_back \n";
          inventory.emplace_back("Soft drink", 100, 2.50);

          std::cerr << " ====== Inventory =======\n";
          // Print inventory
          int nth = 0;
          for(const auto& p: inventory){
                  std::cout << "product " << nth << " = " << p << "\n";
                  nth++;
          }	
          return 0;
  }

#+END_SRC

Running:

 - It can be seen in the program output that ~.emplace_back~ doen't
   invoke the copy constructor, so it has less overhead than
   ~.emplace_back~ which copies the passed element.

#+BEGIN_SRC txt
  $ clang++ stl-emplace.cpp -o stl-emplace.bin -g -std=c++11 -Wall -Wextra && ./stl-emplace.bin

  ====== Experiment .push_back() ======
   [INFO] - Adding orange with .push_back
   [TRACE] - Product created as  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [INFO] - Adding rice with .push_back 
   [TRACE] - Product created as  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  ====== Experiment .emplace_back() ======
   [INFO] - Adding baccon with .emplace_back 
   [TRACE] - Product created as  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
   [INFO] - Adding soft drink with .emplace_back 
   [TRACE] - Product created as  Product{  name = Soft drink; quantity  = 100; price = 2.5 }
   ====== Inventory =======
  product 0 =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
  product 1 =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  product 2 =  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
  product 3 =  Product{  name = Soft drink; quantity  = 100; price = 2.5 }

#+END_SRC
** Methods of C++ STL Vetor<T>


| Vector Class Member               | Description                                                                  |
|-----------------------------------+------------------------------------------------------------------------------|
| *Constructors*                      |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>(int size)               | Create a vector of size n                                                    |
| vector<a>(int size, a init)       | Create a vector of size n with all elements set to _init_                      |
| vector<a>(a [])                   | Intialize vector with an C-Array.                                            |
|                                   |                                                                              |
| *Methods*                           |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>[i]                      | Get the element i of a vector. i ranges from 0 to size - 1                   |
| int  vector<a>::size()            | Get vector size                                                              |
| a    vector<a>::at(i)             | Get the nth element of a vector and checks if the index is within the bounds |
| bool vector<a>::empty()           | Returns true if vector is empty and false, otherwise.                        |
| void vector<a>::resize(int N)     | Resize vector to N elements.                                                 |
| void vector<a>::clear()           | Remove all elements and sets the vector size to 0.                           |
| ~void vector<a>::push_back(elem a)~ | Insert element at the end of v.                                              |
| a    vector<a>::begin()           | Returns first element.                                                       |
| a    vector<a>::end()             | Returns last element                                                         |
| ~void vector<a>::pop_back()~        | Remove last element of vector.                                               |
|                                   |                                                                              |
|                                   |                                                                              |

** Associative Container - Map methods 

Documentation: 
 + [[http://www.cplusplus.com/reference/map/map/][map - C++ Reference]]

| Method of map<K, V>          | Return type          |                                                                              |
|------------------------------+----------------------+------------------------------------------------------------------------------|
| *Capacity*                     |                      |                                                                              |
| empty()                      | bool                 | Return true if container empty                                               |
| size()                       | size_t               | Return number of elements                                                    |
| max_size()                   | sizet_t              | Return maximum number of elements                                            |
|                              |                      |                                                                              |
| *Element Access*               |                      |                                                                              |
| operator[](K k)              | V&                   | Return value associated to key k. It doesn't throw exception.                |
| at(K k)                      | V&                   | Return value associated to key k. Note: it can throw exception.              |
| find(const K& k)             | iterator             | Search for an element and returns map::end if it doesn't find the given key. |
| count(const K& k)            | size_t               | Count number of elements with a given key.                                   |
|                              |                      |                                                                              |
| *Modifiers*                    |                      |                                                                              |
| clear()                      | void                 | Remove all elements.                                                         |
| insert(std::pair<K, V> pair) | void                 | Insert a new key-value pair.                                                 |
| emplace(Args&&& ... args)    | pair<iterator, bool> |                                                                              |
|                              |                      |                                                                              |
|                              |                      |                                                                              |

Map example: 

 - File: *map-container.cpp*

#+BEGIN_SRC cpp 
  #include<iostream>
  #include<string>
  #include<map>
  #include <iomanip>

  struct Point3D{
          double x;
          double y;
          double z;
          Point3D(): x(0), y(0), z(0){}
          Point3D(double x, double y, double z): x(x), y(y), z(z){}
          /* Copy constructor 
       ,* -> Implement redundant copy constructor for logging purposes and 
       ,* detect when copy happens. 
       ,*/
          Point3D(const Point3D& p){		
                  std::cerr << " I was copied" << std::endl;
                  this->x = p.x;
                  this->y = p.y;
                  this->z = p.z;
          }
          ~Point3D() = default;
  };

  std::ostream& operator<< (std::ostream& os, const Point3D& p){
          os << std::setprecision(3) << std::fixed;
          return os << "Point3D{"
                            << "x = "  << p.x
                            << ",y = " << p.y
                            << ", z = "<< p.z
                            << "}";
  }

  int main(){	
          auto locations = std::map<std::string, Point3D>();
          locations["point1"] = Point3D(2.0, 3.0, 5.0);
          locations["pointX"] = Point3D(12.0, 5.0, -5.0);
          locations["pointM"] =  {121.0, 4.0, -15.0};
          locations["Origin"] = {}; // Point32{} or Point3D()
	
          // Invokes copy constructor
          std::cerr << "  <== Before inserting" << "\n";
          locations.insert(std::pair<std::string, Point3D>("PointO1", Point3D(0.0, 0.0, 0.0)));
          std::cerr << "  <== After inserting" << "\n";
	
          // operator[] doesn't throw exception 
          std::cout << "point1 = " << locations["point1"] << "\n";
          std::cout << "pointX = " << locations.at("pointX") << "\n";
          std::cout << "pointM = " << locations.at("pointM") << "\n";

          // Safer and uses exception 
          try {
                  std::cout << "pointY = " << locations.at("pointY") << "\n";
          } catch(const std::out_of_range& ex){
                  std::cout << "Error - not found element pointY. MSG = " << ex.what() << "\n";
          }

          if(auto it = locations.find("pointX"); it != locations.end())
                  std::cout << " [INFO]= => Location pointX found =  " << it->second << "\n";

          if(locations.find("pointMAS") == locations.end())
                  std::cout << " [ERROR] ==> Location pointMAS  not found" << "\n";
	
          std::cout << "Key-Value pairs " << "\n";
          std::cout << "-------------------------" << "\n";
          for (const auto& x: locations)
                  std::cout << x.first << " : " << x.second << "\n";
          std::cout << '\n';

          return 0;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ map-container.cpp -o map-container.bin -std=c++1z -Wall -Wextra  && ./map-container.bin

    <== Before inserting
   I was copied
   I was copied
    <== After inserting
  point1 = Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointX = Point3D{x = 12.000,y = 5.000, z = -5.000}
  pointM = Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointY = Error - not found element pointY. MSG = map::at
   [INFO]= => Location pointX found =  Point3D{x = 12.000,y = 5.000, z = -5.000}
   [ERROR] ==> Location pointMAS  not found
  Key-Value pairs 
  -------------------------
  Origin : Point3D{x = 0.000,y = 0.000, z = 0.000}
  PointO1 : Point3D{x = 0.000,y = 0.000, z = 0.000}
  point1 : Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointM : Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointX : Point3D{x = 12.000,y = 5.000, z = -5.000}

#+END_SRC

* General C++ Reference Card 
** Types of Parameter Passing 

| Parameter Passing | Alternative | Parameter t passed by                                    |
|-------------------+-------------+----------------------------------------------------------|
| T t               |             | by value                                                 |
| T* t              | T *t        | pased by pointer                                         |
| const T* t        | const T* t  |                                                          |
| T& t              | T &t        | by reference or *L-value reference*                        |
| const T& t        | const T &t  | by const reference or const *L-value reference.*           |
| const T&& t       | const T &&t | by r-value reference                                     |
| T t []            | T* t        | by pointer, this notation is used for C-array parameters |
|-------------------+-------------+----------------------------------------------------------|

Notes: 

 + Function here means both member function (class methods) or free
   functions (aka ordinary functions).

 + _Parameters passed by value cannot be modified within the function_
   as they are _copied_. It happens for all C++ types, including
   instances of classes what is different from most OO languages like
   Java, C#, Python and etc.

 + When an object is passed by value, its _copy constructor_ is invoked,
   as a result a copy is created.

 + Prefere passing large objects such large matrices or arrays by
   _reference or const_ reference when the function is not supposed to
   modify the parameter in order to avoid memory overhead due to
   copy.

 + I is better to pass objects instantiated on the heap (dynamic
   memory) with _new_ operator using *smart pointers* (~unique_ptr~,
   ~shared_ptr~) in order to avoid memory leaks.

** C++ Standard Library Reference

*C++ Standards* ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html][Source]])

 - *C++ is standardized as ISO/IEC 14882.* Currently, there are two
   versions:

   - _C++98 (ISO/IEC 14882:1998)_ 1st standard version of C++.
   - _C++03 (ISO/IEC 14882:2003)_ minor "bug-fix" to C++98 with no change
     to the language. Commonly refer to as C++98/C++03 or First C++
     standard.
 - _C++11 (ISO/IEC 14882:2011)_ 2nd standard version of C++.


*C++ Libraries* 

 + STL (Standard Template Library) Containers, Iterators and Function objects.
   + Sequence
     + vector  -> <vector>
     + list    -> <list>
     + dequee  -> <deque>
     + array   -> <array>

   + Associative Sequence
     + set
     + map (Hashmap or hash table).
     + multiset
     + multimap
     + ~unordered_set~
     + ~unordered_map~

 + C++ Libraries ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
   + <ios>, <iostream>, <istream>, <ostream>, <fstream>, <sstream>
   + <iomanip> 
   + <string>  - C++ Strings.
   + <regex>
   + <random>
   + <limits>
   + <stdexcept>, <exception>
   + <complex>, <tuple>, <valarray>
   + <locale>
   + <typeinfo>
   + <chrono>

   + Other: <codecvt>, <new>, <ratio>, <system_error>, <type_traits>

 + Useful non-standard C++ Libraries 
   + Boost C++ libaries
   + QT toolkit / GUI - Toolkit

 + C Compatibility
   + Standard ANSI C libaries ported to C++ are prefixed with "c"
     without ".h". For instance, "#include <math.h>" form C becomes
     "#include <cmath>" in C++.

   + C Libraries. ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
     + <cmath> - (math.h) - Standard mathematical functions such as
       sin, cos, sqrt and so on.
     + <cctypes> - (ctypes.h) - Checking character types (isalpha,
       isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl,
       isgraph, isprint, ispunct, isxdigit) and character conversion
       (toupper, tolower).
     + <climits>, <cfloat>: Size and limit of integer types (INT_MAX,
       INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX
       for long, LLONG_XXX for long long, CHAR_XXX for char) and
       floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP,
       DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double).

     + <ctime>: time, difftime, clock, gmttime, localtime, and etc.
     + <cstdio>: C's IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)
     + <cassert>, <cerrno>, <csignal>: Diagnostics and error
     + <clocale>: localizaton
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
** Math Functions and Constants in <cmath>

Documentation: [[https://en.cppreference.com/w/cpp/header/cmath][Standard library header <cmath> - cppreference.com]]

 *Numerical Constants*

| Constant                    |      Value | Description                                                                   |
|-----------------------------+------------+-------------------------------------------------------------------------------|
| *IEE754 Float Point Contants* |            |                                                                               |
| NAN                         |          - | (Since C++11) Constant not a number, used to indicate an invalid float point. |
| INFINITY                    |          - | (Since C++11) Positive infinity.                                              |
| -INFINITY                   |          - | (Since C++11) Negative infinity.                                              |
|                             |            |                                                                               |
| *General Math Constants*      |            |                                                                               |
| ~M_E~                         |  2.7182818 | Euler's number or exp(1)                                                      |
| ~M_LN2~                       | 0.69314718 | Natural logarithm of 2 or log(2)                                              |
| ~M_LN10~                      |  2.3025851 | Natural logarithm of 10 or log(10)                                            |
|                             |            |                                                                               |
| ~M_LOG10E~                    | 0.43429448 | Log of E (Euler's number) at base 10                                          |
| ~M_LOG2E~                     |  1.4426950 | Log of E (Euler's number) at base 2                                           |
|                             |            |                                                                               |
| ~M_SQRT2~                     |  1.4142136 | Square root of 2 or sqrt(2)                                                   |
| ~M_SQRT1_2~                   | 0.70710678 | Square root of 1/2 or sqrt(1/2) or 1/sqrt(2)                                  |
|                             |            |                                                                               |
| ~M_PI~                        |  3.1415927 | PI number                                                                     |
| ~M_PI_2~                      |  1.5707963 | PI/2                                                                          |
| ~M_PI_4~                      | 0.78539816 | PI/3                                                                          |
| ~M_1_PI~                      | 0.31830989 | 1/PI                                                                          |
| ~M_2_PI~                      | 0.63661977 | 2/PI                                                                          |
| ~M_2_SQRTPI~                  |  1.1283792 | 2/sqrt(PI)                                                                    |
|                             |            |                                                                               |
|                             |            |                                                                               |

See: 

 + P0631R2 Math Constants - Document P0631R2 - *Math Constants* -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0631r2.pdf>

 + [[https://en.cppreference.com/w/cpp/numeric/math/INFINITY][INFINITY - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/numeric/math/NAN][NAN - cppreference.com]]
** Compiler flags and invocation 
*** Overview

 *Search Path and Library Linking Flags* 

 * -l[linalg]
   + => Links to shared library or shared object - Specifically, it
     links to linalg.dll on Windows, liblinalg.so (on Unix-like oses like
     Linux, BSD, AIX, ...) or linalg.dylib on MacOSX.
 * -L[/path/to/shared-libraries]
   + => Add search path to shared libraries, directory containing
     *.so, *.dll or *.dlyb files such as libLinearAlgebra.so depending
     on the current operating system.
 * -I[/path/to/header-files]
   * Add search path to header files (.h) or (.hpp).
 * -D[FLAG] or -D[FLAG]=VALUE
   * Pass preprocessor flag #if FLAG ... 


 *GCC and Clang* Most common compiler flags: 

 + std - Specify the C++ version 
   + -std=c++11
   + -std=c++14
   + -std=c++20
   + -std=gnu++
 + Verbosity - [W]arning 
   + -Wall
   + -Wextra
   + -pendantic
   + -Wconversion
   + -Wcast-align
   + -Wunnused
   + -Wshadow
   + -Wold-style-cast
   + -Wpointer-arith -Wcast-qual -Wmissing-prototypes -Wno-missing-braces 
 + Output file: -o <outputfile>
   + g++ file.cpp -o file.bin
 + Common library flags
   + -lm
   + -lpthread  - Compile against Posix threads shared library
 + Include Path - Directories containing headers files.
   + -I/path/to/include1 -I/path/to/include2 ... 
 + Compilation flags -D<flag name>
   + ~-DMYSOFTWARE_COMPILATION_VARIABLE~ -> Enable flag ~MYSOFTWARE_COMPILATION_VARIABLE~
   + ~-DDO_SOMETHING=1~
   + ~-DDISABLE_DEPRECATED_FUNCTIONS=0~
 + Optmization - [[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html][docs]]
   + -O2 
   + -O3
   + -OFast
     + Enables higher level of optmization than (-O3). It enables lots
       of flags as can be seen [[https://stackoverflow.com/questions/3005564/gcc-options-for-fastest-code][src]] (-ffloat-store, -ffsast-math,
       -ffinite-math-only, -O3 ...)
   + -finline-functions
   + -m64
   + -funroll-loops
   + -fvectorize
   + -fprofile-generate
 + Misc
   + -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4

 *Files Generated by the Compiler* 
 + Object Files
   + *.o -> Generated on *NIX - Linux, MacOSX ... by GCC or Clang
   + *.obj -> Windows
 + Binary Native Executable - Object Code
   + *NIX: Linux, MacOSX, FreeBSD -> Without extension.
   + Windows: *.exe
   + *.hex -> Extension of many compiled firmwares generated by
     embedded systems compilers such as proprietary compilers for
     Microcontrollers.  
 + Shared Objects - Shared Libraries
   + *.dll -> Called dynamic linked libraries on Windows -> libplot.dll
   + *.so  -> Called shared Object on Linux -> libplot.so
   + *.dylib -> Extension used on MacOSX.
 + Static Library
   + *.a - extension 

Review See: 

 + [[https://gist.github.com/gubatron/32f82053596c24b6bec6][Things to remember when compiling and linking C/C++ programs · GitHub]]

 + [[https://msdn.microsoft.com/en-us/library/y0zzbyt4.aspx][Linker Options]]

C++ Compiler Online: 

 + http://rextester.com/FCCXK65881

*** Compiler invokation examples
**** Example - Build executable with unified compilation

Compile file1.cpp, file.cpp, file2.cpp into the executable app.bin 

 - Option 1: Compile and link once in a single command. The
   disadvantage of this way is the slower compile time rather than
   separate compilation and linking. 

#+BEGIN_SRC sh 
  # CC=gcc 
  CC=clang++

  $ clang++ file1.cpp file2.cpp file3.cpp \
    -std=c++14  -o app.bin -O3 -g \
    -Wall -Wextra -pendantic \
    -lpthread -lblas -lboost_system -lboost_filesystem \
    -I./include/path1/with/headers1 -I./include2 -L./path/lib1 -L./pathLib2
#+END_SRC
 
Explanation: 

 + -std=c++14 -> Set the C++ version. This flag can be C++11, C++14,
   C++17, C++20 ... 
 + -o app.bin -> Set the output native executable file ot app.bin
 + -I./include/path1/with/headers
   + Directory with header files
 + -g Produce executable with debug symbols
 + -Wall -Wextra -Wshadow 
   + Warning flags - enable more verbosity which helps to catch bugs
     earlier.
 + -O3 - Use optmization of level 3 - the disadvantage of using
   optmization is the slower compile time. So this flag should only be
   enabled on production builds.
 + -lpthread -lblas ~-lboost_system~ ~-lboost_filesystem~
   + Link against shared libraries (extensions: *.so - Unix, *.dylib
     or *.dll on Windows) pthread, blas, ~boost_system~ ...

**** Compile source with static Linking

#+BEGIN_SRC sh 
 $ gcc -static example.o -lgsl -lgslcblas -lm
#+END_SRC
**** Release / Debug building 

Compiler: 

 + GCC and CLANG
   + Debug: No optmized, but faster building time.
     * -OO -g  
   + Release:
     * -O3 -s -DNDEBUG [-march=native] [-mtune=native]
     * -O2 -s -DNDEBGU
 + MSVC:
   + Debug:
     * /MDd /Zi /Ob0 /Od /RTC1
   + Release:
     * /MD /O1 /Ob1 /DNDEBUG
Note: 
 - For GCC and Clang
   + -OO means no optmization
   + -g - adds debugging symbols to executable.
   + -DNDEBUG - disable assertions


References: 

 + [[https://stackoverflow.com/questions/1534912/how-to-build-in-release-mode-with-optimizations-in-gcc][c++ - How to build in release mode with optimizations in GCC? - Stack Overflow]]

 + 
** Common Acronyms and abbreviations 

|----------------------+--------------------------------------------------------------------------|
| Acronym or name      | Description                                                              |
|----------------------+--------------------------------------------------------------------------|
| IEEE                 | Institute of Electrical and Electronics Engineers                        |
| ISO                  | International Organization for Standardization                           |
|                      |                                                                          |
| TMP                  | Template Meta Programming                                                |
| GP                   | Generic Programming                                                      |
| CTOR                 | Constructor                                                              |
| DTOR                 | Destructor                                                               |
| RAAI                 | Resource Acquisition Is Initialization                                   |
| SFINAE               | Substitution Is Not An Error                                             |
| RVO                  | Return Value Optmization                                                 |
| EP                   | Expression Template                                                      |
| CRTP                 | Curious Recurring Template Pattern                                       |
| PIMPL                | Pointer to Implementation                                                |
| RTTI                 | Runtime Type Identification                                              |
| STL                  | Standard Template Library                                                |
| MSVC                 | Microsoft Visual C++ Compiler                                            |
| VC++                 | Microsoft Visual C++ Compiler                                            |
|                      |                                                                          |
| POSIX                | Portable Operating System Interface (POSIX)                              |
|                      |                                                                          |
| PE, PE32 and PE64    | Portable Executable format - Windows object code format.                 |
| ELF, ELF32 and ELF64 | Executable Linkable Format - [U]-nix object code format.                 |
|                      |                                                                          |
| DLL                  | Dynamic Linked Library - Windows shared library format.                  |
| SO                   | Shared Object - [U]-nix, Linux, BSD, AIX, Solaris shared library format. |
| DSO                  | Dynamic Shared Object, [U]-nix shared library format.                    |
|                      |                                                                          |
|----------------------+--------------------------------------------------------------------------|
