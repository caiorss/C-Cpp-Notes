#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Notes - Ref Card 
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

- [[wiki:index][Index]]

* Standard Library Reference Card 
** Standard Library Map 
*** Containers / Collections

 + [[https://en.cppreference.com/w/cpp/container][Container Library]]

 + Sequential 
   * [[https://en.cppreference.com/w/cpp/container/vector][std::vector]]
   * [[https://en.cppreference.com/w/cpp/container/array][std::array]]
   * [[https://en.cppreference.com/w/cpp/container/deque][std::deque]]
   * [[https://en.cppreference.com/w/cpp/container/list][std::list]] 

 + Ordered Associative
   + Note: provides sorting which is less efficient than  non-sorted
     containers. 
   + [[https://en.cppreference.com/w/cpp/container/set][std::set]]
   + [[https://en.cppreference.com/w/cpp/container/map][std::map]]
   + [[https://en.cppreference.com/w/cpp/container/multiset][std::multiset]]
   + [[https://en.cppreference.com/w/cpp/container/multimap][std::multimap]]

 + Unordered Associative (without sorting)
   + [[https://en.cppreference.com/w/cpp/container/unordered_set][std::unordered_set]]
   + [[https://en.cppreference.com/w/cpp/container/unordered_map][std::unordered_map]]
   + [[https://en.cppreference.com/w/cpp/container/unordered_multiset][std::unordered_multiset]]
   + [[https://en.cppreference.com/w/cpp/container/unordered_multimap][std::unordered_multimap]]

 + Container Adaptors
   + [[https://en.cppreference.com/w/cpp/container/stack][std::stack]]
   + [[https://en.cppreference.com/w/cpp/container/queue][std::queue]]
   + [[https://en.cppreference.com/w/cpp/container/priority_queue][std::priority_queue]]
*** Lambda function utilities and functiona programming

Header: [[https://en.cppreference.com/w/cpp/header/functional][<functional>]]

 + [[https://en.cppreference.com/w/cpp/utility/functional/function][std::function]] - Polymorphic function wrapper, it works with
   function pointers, lambda functions and "functors" (C++
   function-objects).

 + [[https://en.cppreference.com/w/cpp/utility/functional/bind][std::bind]] - Function wrapper, it generates lambda functions out of
   ordinary functions of multiple arguments, pointer to member
   functions and pointer to member variables.

 + [[https://en.cppreference.com/w/cpp/utility/functional/placeholders][std::placeholders]] (Namespace) - provides the placeholders, _1, _2,
   _3 and etc which are useful to generate lambda functions with
   std::bind. To use the placeholders, add the line:
   + _using namespace std::placeholders;_

 + [[https://en.cppreference.com/w/cpp/utility/functional/ref][std::ref and std::cref]] - Reference wrappers used with std::bind.

 + [[https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper][std::reference_wrapper]] - Allows to store references to objects in
   STL containers. 

 + [[https://en.cppreference.com/w/cpp/utility/functional/invoke][std::invoke]] (C++17) - Provides a convenient way to call anything callable
   such as function pointers, member function pointers, functors and
   lambda functions. It means that the same syntax is used for invoking
   everything callable.

 + Function Objects: 
   + [[https://en.cppreference.com/w/cpp/utility/functional/plus][std::plus]], [[https://en.cppreference.com/w/cpp/utility/functional/minus][std::minus]], [[https://en.cppreference.com/w/cpp/utility/functional/multiplies][std::multiplies]], ... 
*** Smart Pointers and Memory Management
 
Header: [[https://en.cppreference.com/w/cpp/header/memory][<memory>]]

 + [[https://en.cppreference.com/w/cpp/memory/unique_ptr][std::unique_ptr]] - Single ownership smart pointer, has less overhead
   than the std::shared_ptr. 

 + [[https://en.cppreference.com/w/cpp/memory/shared_ptr][std::shared_ptr]] - Reference counted smart pointer with multiple
   memory ownership. It works as a quasi-reference counted gabarge
   collector.

 + [[https://en.cppreference.com/w/cpp/memory/weak_ptr][std::weak_ptr]]

 + Casting functions:
   + [[https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast][std::static_pointer_cast, std::dynamic_pointer_cast, std::const_pointer_cast, std::reinterpret_pointer_cast - cppreference.com]]
*** Pointer arithmetic and array index

 + [[https://en.cppreference.com/w/cpp/types/size_t][std::size_t]] - Integer which represents the size of a given type in
   bytes. Use cases: type size, number of items in a
   container/collection, array size, array index and so on.

 + [[https://en.cppreference.com/w/cpp/types/integer][std::uintptr_t]] (Header: [[https://en.cppreference.com/w/cpp/header/cstdint][<cstdint>]]) - Unsigned integer capable of
   storing the address of a pointer regardless of the current
   platform. Note: The size in bytes of types int, long, unsigned long
   depends on the platform, so it is not safe to store a memory
   address in any of those types.

 + _std::intptr_t_ (Header: [[https://en.cppreference.com/w/cpp/header/cstdint][<cstdint>]]) - Similar to std::uintptr_t,
   however it is a signed integer.

 + [[https://en.cppreference.com/w/cpp/types/ptrdiff_t][std::ptrdiff_t]] (Header: [[https://en.cppreference.com/w/cpp/header/cstdint][<cstdint>]]) - Type-safe integer for pointer
   arithmetic, pointer offset and array index in a platform-indepedent
   way.

 *Fixed Size Integers* 

 + Header: [[https://en.cppreference.com/w/cpp/header/cstdint][<cstdint>]] - Provides several unsigned and signed integer
   types with fixed size independent of current platform. As the size
   in bytes of types int, long and char are platform-dependent, it is
   not possible to rely on their sizes.
 + Types: int8_t, uint8_t, int16_t, int32_t and so on. 
 + Use cases:
   + Network protocols
   + Embedded systems
   + Binary serialization
   + Raw binary data
*** Strings and text parsing 

 + Types:
   + [[http://www.cplusplus.com/reference/string/string/][std::string]]
   + [[http://www.cplusplus.com/reference/istream/istream/][std::istream]]
     + => Base class of all input streams. 
   + [[http://www.cplusplus.com/reference/sstream/stringstream/][std::stringstream]]
     + => Stream class used for parsing strings.
   + [[https://en.cppreference.com/w/cpp/regex][regex]] and ([[http://www.cplusplus.com/reference/regex/][ref2]]) => Available since C++11.
     + => Regular expression library. 

 + Functions to parse string to numeric value (note those functions
   throws exception.)
   + [[http://www.cplusplus.com/reference/string/stoi/][std::stoi]]
   + [[http://www.cplusplus.com/reference/string/stod/][std::stod]]
   + [[http://www.cplusplus.com/reference/string/stof/][std::stof]]

 + Function to turn a numeric value into a string
   + [[http://www.cplusplus.com/reference/string/to_string/][std::to_string]]  

 + Functions to process IO Streams
   + [[http://www.cplusplus.com/reference/string/string/getline/][std::getline]] -> Read a line from some input stream.
   + [[https://en.cppreference.com/w/cpp/io/manip/quoted][std::quoted]]  -> Extract quoted string from stream. Use case:
     parse CSV files (C++17).
*** Concurrency 

 *C++11 Concurrency Features* ( [[https://en.cppreference.com/w/cpp/thread][Thread support library]])

Header: [[https://en.cppreference.com/w/cpp/header/thread][<thread>]] - C++11 Concurrency 

 + [[https://en.cppreference.com/w/cpp/thread/thread][std::thread]] - Class, runs a computation into a new thread. 

 + [[https://en.cppreference.com/w/cpp/thread/promise][std::promise]]

 + [[https://en.cppreference.com/w/cpp/thread/future][std::future]]

 + [[https://en.cppreference.com/w/cpp/thread/async][std::async]]

 + [[https://en.cppreference.com/w/cpp/thread/mutex][std::mutex]]

 + [[https://en.cppreference.com/w/cpp/thread/shared_mutex][std::shared_mutex]]

 + [[https://en.cppreference.com/w/cpp/thread/yield][std::yield]]

 + [[https://en.cppreference.com/w/cpp/thread/get_id][std::get_id]] - ID of current thread

 + [[https://en.cppreference.com/w/cpp/thread/sleep_for][std::sleep_for]] - Pause current thread.
*** C++17 Library Additions

 + [[https://en.cppreference.com/w/cpp/utility/optional][std::optional]] - A container which allows returning a value or
   returning nothing. It solves the problem of expressing that a
   function may return nothing in a more concise and type-safe way
   than usual approaches such as returning a null pointer, returning
   an empty object (null object pattern), throwing an exception or
   returning a tuple with boolean and a value. A common problem of the
   null pointer approach is that one may forget to check whether the
   value returned by the pointer is null. It may cause the
   null-dereference undefined behavior, which is similar to the null
   pointer exception problem that still haunts many languages like
   Java, C# and Python.

   + This type is similar to OCaml's Option,  Scala's Option and
     Haskell's Maybe.

 + [[https://en.cppreference.com/w/cpp/utility/variant][std::variant]] - Container which works in a similar way to a sum type
   or disjoint-union. It is basically a type-safe C-union.
   + Use cases:
     + Visitor design pattern with little boilerplate.
     + Quasi pattern matching from functional languages (std::visit)
     + Represent AST - Abstract Syntax Tree

 + [[https://en.cppreference.com/w/cpp/utility/any][std::any]] - Container which can store value of any type.

 + [[https://en.cppreference.com/w/cpp/experimental/fs][Filesystem library]] [OPTIONAL] - Operating-system indepedent file
   system access. Operations possible: list directories, list files,
   check file type and permissions.
*** Numerical Computing

All numeric libraries: 
 + https://en.cppreference.com/w/cpp/numeric

Headers: 

 + [[https://en.cppreference.com/w/cpp/header/cmath][<cmath>]] - C++ version of the C-header <math.h>. Contains basic
   trasncedental functions, sin, cos, tan and so on.
   + C++11 Float point classification functions:
     + [[https://en.cppreference.com/w/cpp/numeric/math/isnan][std::isnan]]
     + [[https://en.cppreference.com/w/cpp/numeric/math/isfinite][std::isfinite]]
   + Widely used trasncedental functions: (C++11)
     + [[https://en.cppreference.com/w/cpp/numeric/math/erf][std::erf]] - Error functions, can be used for computing normal
       function.
     + [[https://en.cppreference.com/w/cpp/numeric/math/erfc][std::erfc]] - Complementary error function.
     + [[https://en.cppreference.com/w/cpp/numeric/math/tgamma][std::tgamma]] - Gamma function. 
   + Special math functions: (C++17)
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/assoc_laguerre][std::assoc_laguerre]] - Associated Laguerre polynomials of the
       degree n, order m, and argument x.
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/beta][std::beta]]
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/expint][std::expint]] - Exponential integral.

 + [[https://en.cppreference.com/w/cpp/header/complex][<complex>]] - Complex number library.

 + [[https://en.cppreference.com/w/cpp/header/random][<random>]] - High quality C++11 random generator library. Provides
   lots of distributions and random number engines.

 + [[https://en.cppreference.com/w/cpp/header/limits][<limits>]] - Provides numeric limits of all C++ numeric types. For
   instance, minimum value, maximum value, number of digits, precision
   and episilon values of a given numeric type.

 + [[https://en.cppreference.com/w/cpp/header/ratio][<ratio>]] - Compile-time rational arithmetic library.

 + [[http://www.cplusplus.com/reference/numeric/][<numeric>]] - Numerical "algorithms" or numerical functions for
   processing containers. std::accumulate, std::iner_product,
   std::partial_sum and std::iota.
*** Generic Programming / Template Metaprogramming

 + [[http://www.cplusplus.com/reference/type_traits/][<type_traits>]]  Type traits (aka metafunctions) - utilities for
   querying, transforming and manipulating types at compile-time.

 + [[https://en.cppreference.com/w/cpp/iterator][iterator library]]

 + [[https://en.cppreference.com/w/cpp/iterator/iterator_tags][iterator tags]] - std::input_iterator_tag, std::output_iterator_tag,
   std::forward_iterator_tag  

 + [[https://en.cppreference.com/w/cpp/types/decay][std::decay]] - Remove cv-qualifiers, turns int& into int, int&& int
   int, char* into char, int[2] into int*, and so on.

 + [[https://en.cppreference.com/w/cpp/iterator/iterator][std::iterator]]

 + [[https://en.cppreference.com/w/cpp/iterator/end][std::end, std::cend]]

 + [[https://en.cppreference.com/w/cpp/iterator/iterator_traits][std::iterator_traits]]

 + [[https://en.cppreference.com/w/cpp/language/constexpr][constexpr]] (C++11) - Compile-time computations. 

 + [[https://en.cppreference.com/w/cpp/types/enable_if][std::enable_if]] - Allows to restrict a function overload,
   alternative implementation of a function with different signature,
   based on a type predicate. For instance, it can be used to define a
   function overload which is selected only when the type predicate
   [[https://en.cppreference.com/w/cpp/types/is_integral][std::is_integral]] is evaluates to true (the type is any of int,
   long, short and so on.). Another overload, which only applies to
   float point types, can be defined by using the type predicate
   [[https://en.cppreference.com/w/cpp/types/is_floating_point][std::is_floating_point]].
   + Summary: Allows to define function overloads which matches a
     given type predicate metafunction (type trait).

 + [[https://en.cppreference.com/w/cpp/types/conditional][std::conditional]] 

 + [[https://en.cppreference.com/w/cpp/language/parameter_pack][parameter_pack]] -> Variadic template arguments.

 + [[https://en.cppreference.com/w/cpp/language/sizeof...][sizeof... operator]] -> Get size of parameter pack (arguments of
   variadic template.)

 + [[https://en.cppreference.com/w/cpp/language/fold][fold expression]] (C++17) - Allows unpacking template variadic
   paremeters in a easier way without complicated recursion
   boilerplate.

 + [[https://en.cppreference.com/w/cpp/language/if][if constexpr]] (C++17)
   + See:
     * Paper which proposed [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0128r1.html][constexpr if]]
     * [[https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/constexpr-if][constexpr
       if - 7 Features of C++17 that will simplify your code]]
*** Value Types - lvalue, rvalue and so on.

 + [[https://en.cppreference.com/w/cpp/language/value_category][Value categories]] - Covers lvalues, rvalues, xvalues, prvalues and so on.

 + [[https://en.cppreference.com/w/cpp/language/move_constructor][Move constructors]]

 + [[https://en.cppreference.com/w/cpp/language/move_assignment][Move assignment operator]]

 + [[https://en.cppreference.com/w/cpp/language/copy_elision][Copy elision]] 



** STL Components 

 + *Containers* - standard collections or data structures, they are a
   fundamental building block of most programming languages, in C++
   the addition benefit is that most of them abstracts away the memory
   allocation as they can grow or shrink during the program runtime.
   * Sequential
     + *vector*
     + *deque*
     + array
     + list
     + forward list 
     + valarray [DEPRECATED] - It would provide a Fortran-like fixed
       size array for linear algebra. But the STL implementation is incomplete.
   * Associative
     + Ordered Associative Container 
       + *map* - key-value data structure, also known as dictionary. A
         map always have unique keys. 
         hash-map, hash table and so on.
       + *set* - A set is data structure which cannot have any repeated
         values. 
       + multimap - A multimap can have repeated keys. 
       + multiset
     + Unordered Associative Containers
       + ~unordered_map~
       + ~unordered_set~

 + *Iterators*

 + *Algorithms*

 + *Adapters*
   - Queue
   - Stack  

 + *Functors* - Function-objects or objects that can be called like a
   function. Functors have several use cases in the STL, for instance
   many STL containers and algorithms expects functors as arguments or
   optional arguments and also the STL provides many standard
   functors in the header [[https://en.cppreference.com/w/cpp/header/functional][<functional>]]
   + Standard functors:
     + [[https://en.cppreference.com/w/cpp/utility/functional/plus][plus<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/minus][minus<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/multiplies][multiplies<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/divides][divides<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/modulus][modules<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/equal_to][equal_to<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/not_equal_to][not_equal_to<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/greater][greater<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/greater_equal][greater_equal<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/less][less<T>]] 
     + [[https://en.cppreference.com/w/cpp/utility/functional/less_equal][less_equal<T>]] 

 + *Allocators*

Further references: 
 + [[https://en.cppreference.com/w/cpp/header/functional][Standard library header <functional> - cppreference.com]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/function_objects.html][STL Function Objects (Functors)]]

See:

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/containers.html][Helsinki - university - STL Containers]]

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/algorithms.html][Helsinki University - STL Algorithms]]

** STL Sequential Container Methods - Cheat Sheet  
*** Use Cases 

Use Cases: 
 + _vector_
   + Operations where the vector size is known in advance and it is
     necessary constant access time for random access to any
     element. Example of use case: linear algebra and numerical
     algorithms. Insertion of elements at end or at the front is
     efficient, however it less efficient than the deque container and
     whenever a new element is added. Vectors are not ideal for
     operations where the number of elements is not known because its
     elements are stored in C-array allocated in the heap, as result,
     all elements are reallocated whenever a new element is added or
     removed.
   + Use cases:
     + General sequential container
     + Linear algebra and numerical algorithms 
     + C++ replacement for C-arrays 
     + C-arrays interoperability
 + _deque_
   + Operations with requires fast random access time and fast
     insertion or deletion of elements at both ends. Unlike vectors,
     deque is not stored internally as a C-array and unlike vectors,
     whenever an element is inserted, any reallocation happens which
     means that deques are more efficient than vectors when the size
     of container is not known in advance.
   + Use Case:
     + General sequential container
     + Fast random access
     + Number of elements aren't known in advance.
*** Member Functions / Methods reference table 

| Method of Container<T> | Return type | Description                                              | vector | deque | list | array |
|------------------------+-------------+----------------------------------------------------------+--------+-------+------+-------|
| *Element Access*         |             |                                                          |        |       |      |       |
| operator[](int n)      | T&          | return nth-element, doesn't throw exception.             | yes    | yes   | no   | yes   |
| at(int n)              | T&          | return nth-element, but throws exception.                | yes    | yes   | no   | yes   |
| front()                | T&          | return first element                                     | yes    | yes   | yes  | yes   |
| back()                 | T&          | return last element                                      | yes    | yes   | yes  | yes   |
| data()                 | T*          | Return pointer to first element of container.            | yes    | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Capacity*               |             |                                                          |        |       |      |       |
| size()                 | size_t      | Return number of container elements.                     | yes    | yes   | yes  | yes   |
| max_size()             | size_t      | Return maximum container size.                           | yes    | yes   | yes  | yes   |
| empty()                | bool        | Return true if container is empty                        | yes    | yes   | yes  | yes   |
| reserve(size_t n)      | void        | Reserve a minimum storage for vectors.                   | yes    | no    | no   | no    |
| resize(size_t n)       | void        | Resize container to n elements.                          | yes    | yes   | yes  | no    |
|                        |             |                                                          |        |       |      |       |
| *Modifiers*              |             |                                                          |        |       |      |       |
| ~push_back(T t)~         | void        | Add element at the end of container                      | yes    | yes   | yes  | no    |
| ~push_front(T t)~        | void        | Add element at the beggining of container.               | yes    | yes   | yes  | no    |
| ~pop_back()~             | void        | Delete element at the end of container.                  | yes    | yes   | yes  | no    |
| ~pop_front()~            | void        | Delete element at beginning of container.                | yes    | yes   | yes  | no    |
| emplace_back           | void        | Construct and insert element at the end without copying. | yes    | yes   | yes  | no    |
| clear()                | void        | Remove all elements.                                     | yes    | yes   | yes  | no    |
| fill(T t)              | void        | Fill all elements                                        | no     | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Iterator*               |             |                                                          |        |       |      |       |
| begin()                | iterator    | Return iterator to beggining                             |        |       |      |       |
| end()                  | iterator    | Return iterator to end                                   |        |       |      |       |
| rbegin()               | iterator    | Return reverse iterator to beggining                     |        |       |      |       |
| rend()                 | iterator    | Return reverse iterator to end                           |        |       |      |       |
| cbegin()               | iterator    | Return const iterator to beginning                       |        |       |      |       |
| cend()                 | iterator    | Return const iterator to end                             |        |       |      |       |
| crebegin()             | iterator    | Return const iterator to beginning                       |        |       |      |       |
| crend()                | iterator    | Return const iterator to end                             |        |       |      |       |
    
*** Constructors 

Vector constructors: 

#+BEGIN_SRC cpp 
  // Empty vector 
  >> std::vector<double> xs1
  (std::vector<double> &) {}

  // Intialize vector with a given size
  >> std::vector<double> xs2(5, 3.0)
  (std::vector<double> &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }

  // Constructor with uniform initialization 
  >> std::vector<double> xs4 {1.0, -2.0, 1.0, 10 }
  (std::vector<double> &) { 1.0000000, -2.0000000, 1.0000000, 10.000000 }

  // =========== Constructors with C++11 auto keyword =============//

  >> auto xs1 = vector<double>()
  (std::vector<double, std::allocator<double> > &) {}
  >> 
  >> auto xs2 = vector<double>(5, 3.0)
  (std::vector<double, std::allocator<double> > &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }
  >> 
  >> auto xs3 = vector<double>{1, -2, 1, 1}
  (std::vector<double, std::allocator<double> > &) { 1.0000000, -2.0000000, 1.0000000, 1.0000000 }
  >> 
#+END_SRC

Deque constructors: 

#+BEGIN_SRC cpp 
  >> std::deque<int> ds1
  (std::deque<int> &) {}
  >> 
  >> std::deque<int> ds2(5, 2)
  (std::deque<int> &) { 2, 2, 2, 2, 2 }
  >> 
  >> std::deque<int> ds3 {2, -10, 20, 100, 20}
  (std::deque<int> &) { 2, -10, 20, 100, 20 }
  >> 
  // ======== Constructors with auto type inference ========== //
  >> auto ds1 = std::deque<int>()
  (std::deque<int, std::allocator<int> > &) {}
  >> 
  >> auto ds2 = std::deque<int>(5, 2)
  (std::deque<int, std::allocator<int> > &) { 2, 2, 2, 2, 2 }
  >> 
  >> auto ds3 = std::deque<int>{2, -10, 20, 100, 20}
  (std::deque<int, std::allocator<int> > &) { 2, -10, 20, 100, 20 }
  >> 
#+END_SRC

References: 
 + [[http://www.cplusplus.com/reference/vector/vector/][vector - C++ Reference]]  
 + [[http://www.cplusplus.com/reference/stl/][Containers - C++ Reference]] 
 + [[https://embeddedartistry.com/blog/2017/9/11/choosing-the-right-stl-container-sequential-containers][Choosing the Right Container: Sequential Containers â€” Embedded Artistry]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/containers_sequential.html][STL Sequential Container Member Function Summary]] 
	 
*** Tips and tricks 
**** Pass containers by reference or const reference

If the intent of the operation is not modify the container, it is
preferrable to pass it by const reference in order to avoid copying
overhead. 

For instance, the function: 

#+BEGIN_SRC cpp 
  double computeNorm(std::vector<double> xs)
  {
   // The vector xs is copied here, if it has 1GB of memory.
   // It will use 2GB instead of 1GB!
    ... ... 
  }
#+END_SRC

Should be written as: 

#+BEGIN_SRC cpp 
  double computeNorm(const std::vector<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::list<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::deque<double>& xs)
  {
    ... ... 
  }
#+END_SRC
**** Use the member function emplace_back to avoid uncessary copies.

Example: 

 - file: stl-emplace.cpp

#+BEGIN_SRC cpp :export both :results code
  #include <iostream>
  #include <ostream>
  #include <iomanip>
  #include <string>
  #include <vector>
  #include <deque>

  struct Product{
          std::string  name;	
          int          quantity;
          double       price;
          Product(){
                  std::cerr << " [TRACE] - Empty constructor invoked\n";
          }
          Product(const std::string& name, int quantity, double price):
                  name(name),
                  quantity(quantity),
                  price(price){
                  std::cerr << " [TRACE] - Product created as " << *this << "\n" ;
          }
          // The compiler generate an copy constructor automatically,
          // but this one was written to instrument C++ value semantics
          // and check when copies happen.
          Product(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy constructor invoked -> copied = " << *this << "\n";
          }
          // Copy assignment-operator
          void operator=(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy assignment operator invoked = " << *this << "\n";		
          }
          // Make class printable 
          friend std::ostream& operator<< (std::ostream& os, const Product& p)
          {
                  int size1 = 10;
                  int size2 = 2;
                  return os << " Product{ "
                                    << std::setw(1) << " name = "       << p.name
                                    << std::setw(10) << "; quantity  = "  << std::setw(size2) << p.quantity
                                    << std::setw(size1) << "; price = "      << std::setw(size2) << p.price
                                    << " }";
          }
  };


  int main(){
          auto inventory = std::deque<Product>();

          // Using push_back
          std::cerr << "====== Experiment .push_back() ======\n";
          std::cerr << " [INFO] - Adding orange with .push_back\n";
          inventory.push_back(Product("Orange - 1kg", 10, 3.50));
          std::cerr << " [INFO] - Adding rice with .push_back \n";
          inventory.push_back({"Rice bag", 20, 0.80});

          // Using emlace_back
          std::cerr << "====== Experiment .emplace_back() ======\n";	
          std::cerr << " [INFO] - Adding apple with .emplace_back \n";
          inventory.emplace_back("Fresh tasty apple", 50, 30.25);
          std::cerr << " [INFO] - Adding soft drink with .emplace_back \n";
          inventory.emplace_back("Soft drink", 100, 2.50);

          std::cerr << " ====== Inventory =======\n";
          // Print inventory
          int nth = 0;
          for(const auto& p: inventory){
                  std::cout << "product " << nth << " = " << p << "\n";
                  nth++;
          }	
          return 0;
  }

#+END_SRC

Running:

 - It can be seen in the program output that ~.emplace_back~ doen't
   invoke the copy constructor, so it has less overhead than
   ~.emplace_back~ which copies the passed element.

#+BEGIN_SRC txt
  $ clang++ stl-emplace.cpp -o stl-emplace.bin -g -std=c++11 -Wall -Wextra && ./stl-emplace.bin

  ====== Experiment .push_back() ======
   [INFO] - Adding orange with .push_back
   [TRACE] - Product created as  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [INFO] - Adding rice with .push_back 
   [TRACE] - Product created as  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  ====== Experiment .emplace_back() ======
   [INFO] - Adding apple with .emplace_back 
   [TRACE] - Product created as  Product{  name = Fresh tasty apple; quantity  = 50; price = 30.25 }
   [INFO] - Adding soft drink with .emplace_back 
   [TRACE] - Product created as  Product{  name = Soft drink; quantity  = 100; price = 2.5 }
   ====== Inventory =======
  product 0 =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
  product 1 =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  product 2 =  Product{  name = Fresh tasty apple; quantity  = 50; price = 30.25 }
  product 3 =  Product{  name = Soft drink; quantity  = 100; price = 2.5 }

#+END_SRC
** Methods of C++ STL Vetor<T>


| Vector Class Member               | Description                                                                  |
|-----------------------------------+------------------------------------------------------------------------------|
| *Constructors*                      |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>(int size)               | Create a vector of size n                                                    |
| vector<a>(int size, a init)       | Create a vector of size n with all elements set to _init_                      |
| vector<a>(a [])                   | Intialize vector with an C-Array.                                            |
|                                   |                                                                              |
| *Methods*                           |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>[i]                      | Get the element i of a vector. i ranges from 0 to size - 1                   |
| int  vector<a>::size()            | Get vector size                                                              |
| a    vector<a>::at(i)             | Get the nth element of a vector and checks if the index is within the bounds |
| bool vector<a>::empty()           | Returns true if vector is empty and false, otherwise.                        |
| void vector<a>::resize(int N)     | Resize vector to N elements.                                                 |
| void vector<a>::clear()           | Remove all elements and sets the vector size to 0.                           |
| ~void vector<a>::push_back(elem a)~ | Insert element at the end of v.                                              |
| a    vector<a>::begin()           | Returns first element.                                                       |
| a    vector<a>::end()             | Returns last element                                                         |
| ~void vector<a>::pop_back()~        | Remove last element of vector.                                               |
|                                   |                                                                              |
|                                   |                                                                              |

** Associative Container - Map methods 

Map is a data structure similar to a hash map, also known as
dictionary hash table or dictionary. However, stl std::map is not
implemented as true hash table as all data inserted in std::map are
sorted. Due to the implementation and sorting, std::map is less
performant than std::unordered_map, which is implemented as true hash
table, therefore in most cases std::unordered_map is better choice
than std::map.

Documentation: 
 + [[http://www.cplusplus.com/reference/map/map/][map - C++ Reference]]

| Method of map<K, V>          | Return type          |                                                                              |
|------------------------------+----------------------+------------------------------------------------------------------------------|
| *Capacity*                     |                      |                                                                              |
| empty()                      | bool                 | Return true if container empty                                               |
| size()                       | size_t               | Return number of elements                                                    |
| max_size()                   | sizet_t              | Return maximum number of elements                                            |
|                              |                      |                                                                              |
| *Element Access*               |                      |                                                                              |
| operator[](K k)              | V&                   | Return value associated to key k. It doesn't throw exception.                |
| at(K k)                      | V&                   | Return value associated to key k. Note: it can throw exception.              |
| find(const K& k)             | iterator             | Search for an element and returns map::end if it doesn't find the given key. |
| count(const K& k)            | size_t               | Count number of elements with a given key.                                   |
|                              |                      |                                                                              |
| *Modifiers*                    |                      |                                                                              |
| clear()                      | void                 | Remove all elements.                                                         |
| insert(std::pair<K, V> pair) | void                 | Insert a new key-value pair.                                                 |
| emplace(Args&&& ... args)    | pair<iterator, bool> |                                                                              |
|                              |                      |                                                                              |
|                              |                      |                                                                              |

Map example: 

 - File: *map-container.cpp*

#+BEGIN_SRC cpp 
  #include<iostream>
  #include<string>
  #include<map>
  #include <iomanip>

  struct Point3D{
          double x;
          double y;
          double z;
          Point3D(): x(0), y(0), z(0){}
          Point3D(double x, double y, double z): x(x), y(y), z(z){}
          /* Copy constructor 
       ,* -> Implement redundant copy constructor for logging purposes and 
       ,* detect when copy happens. 
       ,*/
          Point3D(const Point3D& p){		
                  std::cerr << " I was copied" << std::endl;
                  this->x = p.x;
                  this->y = p.y;
                  this->z = p.z;
          }
          ~Point3D() = default;
  };

  std::ostream& operator<< (std::ostream& os, const Point3D& p){
          os << std::setprecision(3) << std::fixed;
          return os << "Point3D{"
                            << "x = "  << p.x
                            << ",y = " << p.y
                            << ", z = "<< p.z
                            << "}";
  }

  int main(){	
          auto locations = std::map<std::string, Point3D>();
          locations["point1"] = Point3D(2.0, 3.0, 5.0);
          locations["pointX"] = Point3D(12.0, 5.0, -5.0);
          locations["pointM"] =  {121.0, 4.0, -15.0};
          locations["Origin"] = {}; // Point32{} or Point3D()
	
          // Invokes copy constructor
          std::cerr << "  <== Before inserting" << "\n";
          locations.insert(std::pair<std::string, Point3D>("PointO1", Point3D(0.0, 0.0, 0.0)));
          std::cerr << "  <== After inserting" << "\n";
	
          // operator[] doesn't throw exception 
          std::cout << "point1 = " << locations["point1"] << "\n";
          std::cout << "pointX = " << locations.at("pointX") << "\n";
          std::cout << "pointM = " << locations.at("pointM") << "\n";

          // Safer and uses exception 
          try {
                  std::cout << "pointY = " << locations.at("pointY") << "\n";
          } catch(const std::out_of_range& ex){
                  std::cout << "Error - not found element pointY. MSG = " << ex.what() << "\n";
          }

          if(auto it = locations.find("pointX"); it != locations.end())
                  std::cout << " [INFO]= => Location pointX found =  " << it->second << "\n";

          if(locations.find("pointMAS") == locations.end())
                  std::cout << " [ERROR] ==> Location pointMAS  not found" << "\n";
	
          std::cout << "Key-Value pairs " << "\n";
          std::cout << "-------------------------" << "\n";
          for (const auto& x: locations)
                  std::cout << x.first << " : " << x.second << "\n";
          std::cout << '\n';

          return 0;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ map-container.cpp -o map-container.bin -std=c++1z -Wall -Wextra  && ./map-container.bin

    <== Before inserting
   I was copied
   I was copied
    <== After inserting
  point1 = Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointX = Point3D{x = 12.000,y = 5.000, z = -5.000}
  pointM = Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointY = Error - not found element pointY. MSG = map::at
   [INFO]= => Location pointX found =  Point3D{x = 12.000,y = 5.000, z = -5.000}
   [ERROR] ==> Location pointMAS  not found
  Key-Value pairs 
  -------------------------
  Origin : Point3D{x = 0.000,y = 0.000, z = 0.000}
  PointO1 : Point3D{x = 0.000,y = 0.000, z = 0.000}
  point1 : Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointM : Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointX : Point3D{x = 12.000,y = 5.000, z = -5.000}

#+END_SRC

** Associative Contaienr - Unordered map 

The unordered map, introduced in C++11, is generally faster for
insertion and deletion of elements since the unordered map is
implemented as a true hash table, unlike the std::map which is
implemented as tree. The downside of unordered_map this data structure
is the loss of elements sorting.

 - Header: [[http://www.cplusplus.com/reference/unordered_map/unordered_map/][<unordered_map>]]

Benefits: 
 + True hash table.
 + Faster for insertion, retrieval and removal of elements that the
   map.

Downsides: 
 + Loss of elements insertion order. 

 *Example:* 

Constructors: 

#+BEGIN_SRC cpp 
  std::unordered_map<std::string, int> m1;

  auto m2 = std::unordered_map<std::string, int>{};

  // Uniform initialization 
  //--------------------------
  >> std::unordered_map<std::string, int> m3 {{"x", 200}, {"z", 500}, {"w", 10}, {"pxz", 70}}
   { "pxz" => 70, "w" => 10, "z" => 500, "x" => 200 }

  //  More readable 
  >> auto m4 = std::unordered_map<std::string, int> {{"x", 200}, {"z", 500}, {"w", 10}, {"pxz", 70}}
   { "pxz" => 70, "w" => 10, "z" => 500, "x" => 200 }
#+END_SRC

Insert Elements: 

#+BEGIN_SRC cpp 
  >> auto m = std::unordered_map<std::string, int>{}

  >> m["x"] = 100
  (int) 100
  >> m["x"] = 100;
  >> m["z"] = 5;
  >> m["a"] = 6710;
  >> m["hello"] = -90;
  >> m["sword"] = 190;

  >> m
  { "sword" => 190, "hello" => -90, "a" => 6710, "x" => 100, "z" => 5 }

#+END_SRC

Insert element using stl::pair:

#+BEGIN_SRC cpp 
  >> auto mm = std::unordered_map<std::string, int>{};

  >> mm.insert(std::make_pair("x", 200));
  >> mm.insert(std::make_pair("z", 500));
  >> mm.insert(std::make_pair("w", 10));

  >> mm["x"]
  (int) 200
  >> mm["w"]
  (int) 10
  >> 
#+END_SRC

Number of elements: 

#+BEGIN_SRC cpp 
  >> m.size()
  (unsigned long) 6
  >>
#+END_SRC

Retrieve elements: 

#+BEGIN_SRC cpp 
  >> m["x"]
  (int) 100
  >> m["sword"]
  (int) 190
  >>
  // Doesn't  throw exception if element is not found 
  >> m["sword-error"]
  (int) 0
  >> 

  // Throw exception if element is not found
  >> m.at("x")
  (int) 100
  >> m.at("sword")
  (int) 190
  >> m.at("sword error")
  Error in <TRint::HandleTermInput()>: std::out_of_range caught: _Map_base::at
  >> 
  >> 
#+END_SRC

Find element: 

#+BEGIN_SRC cpp 
  // -------- Test 1 -----------//
  auto it = m.find("sword");
  if(it != m.end()) {
          std::cout << "Found Ok. => {"
                    << "key = " << it->first
                    << " ; value = " << it->second
                    << " }"
                    << "\n";
	
  } else {
          std::cout << "Error: key not found." << "\n";
  }
  // Output: 
  Found Ok. => {key = swordvalue = 190 }
  > 

  // -------- Test 1 -----------//

  auto it = m.find("this key will not be found!");
  if(it != m.end()) {
       std::cout << "Found Ok. => {"
                 << "key = "      << it->first
                 << " ; value = " << it->second
                 << " }"
                 << "\n";
  } else {
      std::cout << "Error: key not found." << "\n";
  }
  // ----- Output: ----------//
  Error: key not found.
  >> 
#+END_SRC

Loop over container elements: 

#+BEGIN_SRC cpp 
  for(const auto& p: m) {
           std::cout << std::setw(5) << "key = " << std::setw(6) << p.first
                     << std::setw(8) << " value = " << std::setw(5) << p.second
                     << "\n";
  }

  // Output: 
  key =  sword value =   190
  key =  hello value =   -90
  key =      a value =  6710
  key =      x value =   100
  key =      z value =     5
#+END_SRC
 
Loop with iterator and stl "algorithm" std::for_each.

#+BEGIN_SRC cpp 
  std::for_each(m.begin(), m.end(),
                 [](const std::pair<std::string, int>& p){
                         std::cout << std::setw(5)  << p.first
                                   << std::setw(10) << p.second
                                   << "\n";									  
                 });
  // Output:
  sword       190
  hello       -90
      a      6710
      x       100
      z         5
#+END_SRC
** Associative Container - Multimap 

The container std::multimap is similar to map, however it allows
repeated keys.

Header: <map> 

Documentation: 
 + [[https://en.cppreference.com/w/cpp/container/multimap][std::multimap - cppreference.com]]

Examples: 

 + Initialize std::multimap 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <map>

  std::multimap<std::string, int> dict;

  >> dict
  (std::multimap<std::string, int> &) {}
  >> 

  // Insert pair object 
  dict.insert(std::make_pair("x", 100));
  dict.insert(std::make_pair("status", 30));
  dict.insert(std::make_pair("HP", 250));
  dict.insert(std::make_pair("stamina", 100));
  dict.insert(std::make_pair("stamina", 600));
  dict.insert(std::make_pair("x", 10));
  dict.insert(std::make_pair("x", 20));

  >> dict
  { "HP" => 250, "stamina" => 100, "stamina" => 600, "status" => 30, "x" => 100, "x" => 10, "x" => 20 }
  >> 
#+END_SRC

Find all pair with a given key

#+BEGIN_SRC cpp 
  // Find elements:
  >> auto it = dict.find("x"); // Iterator
  >> 
  for(auto it = dict.find("x"); it != dict.end(); it++){ 
    std::printf(" ==> it->first = %s ; it->second = %d\n", it->first.c_str(), it->second); 
  }
  /** Output: 
    ==> it->first = x ; it->second = 100
    ==> it->first = x ; it->second = 10
    ==> it->first = x ; it->second = 20
   ,*/

#+END_SRC

Count all elements with a given key

#+BEGIN_SRC cpp 
  >> dict.count("x")
  (unsigned long) 3

  >> dict.count("stamina")
  (unsigned long) 2

  >> dict.count("HP")
  (unsigned long) 1

  >> dict.count("")
  (unsigned long) 0

  >> dict.count("wrong")
  (unsigned long) 0
  >> 

#+END_SRC

Iterate over multimap: 

#+BEGIN_SRC cpp 
  for(const auto& pair : dict){ 
    std::printf(" ==> key = %s ; value = %d\n", pair.first.c_str(), pair.second); 
  }
  /** Output: 
     ==> key = HP ; value = 250
     ==> key = stamina ; value = 100
     ==> key = stamina ; value = 600
     ==> key = status ; value = 30
     ==> key = x ; value = 100
     ==> key = x ; value = 10
     ==> key = x ; value = 20
 */
#+END_SRC

Clear multimap object: 

#+BEGIN_SRC cpp 
  >> auto dict2 = std::multimap<std::string, int> { {"x", 100}, {"y", 10}, {"x", 500}, {"z", 5}};
  >> dict2
   { "x" => 100, "x" => 500, "y" => 10, "z" => 5 }

  >> dict2.size()
  (unsigned long) 4

  >> dict2.clear();

  >> dict2
  {}

  >> dict2.size()
  (unsigned long) 0
#+END_SRC

** Associative Container - Sets 

Set [[https://en.cppreference.com/w/cpp/container/set][std::set]] is an associative container implementing the mathematical
concept of finite set. This container stores _sorted_ unique values and
any attempt to insert a repeated value will discard the value to be
inserted.

 + Header: [[http://www.cplusplus.com/reference/set/set/][<set>]]
 + Implementation: Binary search tree. 
 + Note: as this collection has sorting, its unordered version,
   without sorting, [[https://en.cppreference.com/w/cpp/container/unordered_set][std::unordered_set]] performs better.

 *Example: Set constructors*

 + Instantiate a set object with a _default constructor_ (constructor
   with empty parameters): 

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <string>
  #include <set>

  std::set<int> s1;

  >> s1.insert(10);
  >> s1.insert(20);
  >> s1.insert(20);
  >> s1.insert(30);
  >> s1.insert(40);
  >> s1
  (std::set<int> &) { 10, 20, 30, 40 }
  >> s1.insert(40);
  >> s1
  (std::set<int> &) { 10, 20, 30, 40 }
#+END_SRC

 + Instantiate a set with _initializer list constructor_: 

#+BEGIN_SRC cpp 
  >> auto s2 = std::set<std::string>{ 
      "hello", "c++", "c++", "hello", "world", "world", 
       "c++11", "c++", "c++17", "c++17"
     };
  >> s2
  { "c++", "c++11", "c++17", "hello", "world" }
  >> 

  // Any repeated element is discarded 
  >> s2.insert("c++");
  >> s2
  { "c++", "c++11", "c++17", "hello", "world" }
#+END_SRC

 + Instantiate a set with _range constructor_ or iterator pair constructor:

#+BEGIN_SRC cpp 
  >> std::vector<int> numbers {-100, 1, 2, 10, 2, 1, 3, 15, 3, 5, 4, 4, 3, 3, 2};

  >> std::set<int> sa1(numbers.begin(), numbers.end());
  >> sa1
  (std::set<int> &) { -100, 1, 2, 3, 4, 5, 10, 15 }


  >> auto sa2 = std::set<int>{numbers.begin() + 4, numbers.end() - 2};
  >> sa2
  { 1, 2, 3, 4, 5, 15 }
#+END_SRC

 + Instantiate a set with copy constructor.
   + std::set<T>(const T&)

#+BEGIN_SRC cpp 
  >> std::set<int> xs{1, 1, 10, 1, 2, 5, 10, 4, 4, 5, 1};
  >> xs
  { 1, 2, 4, 5, 10 }

  >> std::set<int> copy1(xs);
  >> copy1
  (std::set<int> &) { 1, 2, 4, 5, 10 }

  >> auto copy2 = xs;
  >> copy2
  { 1, 2, 4, 5, 10 }

  >> auto copy3 = std::set<int>{xs};
  >> copy3
  { 1, 2, 4, 5, 10 }

  >> if(&copy1 != &xs){ std::puts(" => Not the same"); }
   => Not the same

  >> if(&copy2 != &xs){ std::puts(" => Not the same"); }
   => Not the same
  
  >> if(&copy3 != &xs){ std::puts(" => Not the same"); }
   => Not the same
#+END_SRC

 + Instantiating a set with a move constructor.
   + std::set<T>(T&&)

#+BEGIN_SRC cpp 
  >> std::set<int> xs1{1, 1, 10, 1, 2, 5, 5, 6, 10, 4, 4, 5, 1, 6, 7, 7};

  >> xs1
  { 1, 2, 4, 5, 6, 7, 10 }

  // Move constructor:  
  >> std::set<int> m1(std::move(xs1));
  >> m1
  (std::set<int> &) { 1, 2, 4, 5, 6, 7, 10 }
  >> xs1
  (std::set<int> &) {}
  >>

  >> std::set<int> xs2{1, 1, 10, 1, 2, 5, 5, 6, 10, 4, 4, 5, 1, 6, 7, 7};
  >> xs2
  (std::set<int> &) { 1, 2, 4, 5, 6, 7, 10 }

  // ========  Move constructor ===================
  >> auto m2 = std::move(xs2);
  >> m2
  { 1, 2, 4, 5, 6, 7, 10 }
  >> xs2
  (std::set<int> &) {}
  >> 
#+END_SRC

 *Operations on sets:*

Instantiating sample set:

#+BEGIN_SRC cpp 
  >> auto aset = std::set<int> {1, 1, 10, 1, 2, 5, 5, 6, 10, 4, 4, 5, 1, 6, 7, 7};
  >> aset
  { 1, 2, 4, 5, 6, 7, 10 }   
#+END_SRC

Count number of elements:

#+BEGIN_SRC cpp 
  >> aset.size()
  (unsigned long) 7
  >> 
#+END_SRC

Clear set (remove all elements):

#+BEGIN_SRC cpp 
  >>  auto asetb = std::set<int> {1, 1, 10, 1, 2, 5, 5, 6, 10, 4, 4, 5, 1, 6, 7, 7};
  >> asetb
  { 1, 2, 4, 5, 6, 7, 10 }

  >> asetb.clear();
  >> asetb
  {}

  >> asetb.empty()
  (bool) true
#+END_SRC

Check whether an element is in the set without iterator: 

#+BEGIN_SRC cpp 
  >> aset.count(10)
  (unsigned long) 1
  >> aset.count(100)
  (unsigned long) 0
  >> aset.count(1)
  (unsigned long) 1
  >> aset.count(-12)
  (unsigned long) 0
  >> 
  >> if(aset.count(10) != 0 ) { std::puts("Element in the set."); }
  Element in the set.
  >> if(aset.count(10)) { std::puts("Element in the set."); }
  Element in the set.
  >> if(aset.count(25) != 0 ) { std::puts("Element in the set."); }
  >> if(aset.count(25)) { std::puts("Element in the set."); }
  >> 

#+END_SRC

Check if element is in the set with iterator: 

#+BEGIN_SRC cpp 
  >> aset
  { 1, 2, 4, 5, 6, 7, 10 }

  >> aset.find(10)
  (std::set<int, std::less<int>, std::allocator<int> >::iterator) @0x22f1ff0
  >> 

  std::set<int>::iterator it;
  >> if((it = aset.find(10)) != aset.end()) std::printf(" ==> Found element = %d\n", *it)
   ==> Found element = 10

  >> if((it = aset.find(2)) != aset.end()) std::printf(" ==> Found element = %d\n", *it) 
   ==> Found element = 2

  >> if((it = aset.find(-100)) != aset.end()) std::printf(" ==> Found element = %>> ", *it)

  // Or: ----------------------------------------------------
  >> auto itr = aset.find(7);
  >> if(itr == aset.end()) std::puts("Element not found");
  >> if(itr != aset.end()) std::puts("Element  found");
  Element  found
  >> int element = *itr
  (int) 7
  >> 
#+END_SRC

Remove element from set:

#+BEGIN_SRC cpp 
  >> aset
  { 1, 2, 4, 5, 6, 7, 10 }

  >> auto itr2 = aset.find(10);
  // Remove element using iterator.
  >> aset.erase(itr2);

  >> aset
  { 1, 2, 4, 5, 6, 7 }
  
  // Segmentation fault!! 
  >> aset.erase(aset.find(-10));
  free(): invalid pointer
#+END_SRC

Iterate over a set: 

#+BEGIN_SRC cpp 
  int i = 0;
  for(const auto& x: aset){  std::printf(" element[%d] = %d\n", ++i, x); }

  // For-range based loop
  >> for(const auto& x: aset){  std::printf(" element[%d] = %d\n", ++i, x); }
   element[1] = 1
   element[2] = 2
   element[3] = 4
   element[4] = 5
   element[5] = 6
   element[6] = 7
   element[7] = 10

  // Iterator based loop 
  int j = 0;
  for(auto it = aset.begin(); it != aset.end(); it++){  std::printf(" element[%d] = %d\n", ++j, *it); }

  >> for(auto it = aset.begin(); it != aset.end(); it++){  std::printf(" element[%d] = %d\n", ++j, *it); }
   element[1] = 1
   element[2] = 2
   element[3] = 4
   element[4] = 5
   element[5] = 6
   element[6] = 7
   element[7] = 10
#+END_SRC

** Bitset Container
Class template for representing a sequence of N bits.
  + Header: [[https://en.cppreference.com/w/cpp/utility/bitset][<bitset>]] 

Default Constructor: 

#+BEGIN_SRC cpp 
  #include <bitset>

   >> #include <bitset>

   >> std::bitset<4> b;

   >> std::cout << " b = " << b << std::endl;
    b = 0000
#+END_SRC

Test bits;

#+BEGIN_SRC cpp 
   // Set bit 0 
   >> b.set(0)
   (std::bitset<4UL> &) @0x7f92db9c7010

   >> b
   (std::bitset<4> &) @0x7f92db9c7010
   >> std::cout << " b = " << b << std::endl;
    b = 0001

   // Set bit 1 and 3 
   >> b.set(1).set(3)
   (std::bitset<4UL> &) @0x7f92db9c7010

   >> std::cout << " b = " << b << std::endl;
    b = 1011
#+END_SRC

Test bits:

#+BEGIN_SRC cpp
   // Check whether bit 0 is set  (equal to 1)
   >> b.test(0)
   (bool) true

   // Check whether bit 1 is set
   >> b.test(1)
   (bool) true

   // Check whether bit 1 is set
   >> b.test(2)
   (bool) false

   // Check whether bit 1 is set
   >> b.test(3)
   (bool) true
   >> 

   // Clear bit 0 
   >> b.set(0, false);
   >> b.test(0)
   (bool) false
#+END_SRC

Create a bitset initialized with some integer value:

#+BEGIN_SRC cpp 
   >> std::bitset<8> b1{0xAE};

   >> std::cout << "b1 = " << b1 << std::endl;
   b1 = 10101110

   // Test bits 
   >> b1.test(0)
   (bool) false
   >> b1.test(1)
   (bool) true
   >> b1.test(7)
   (bool) true
   >> b1.test(6)
   (bool) false
   >> 

   // Number of bits 
   >> b1.size()
   (unsigned long) 8
   >> 
#+END_SRC

Convert to numerical value: 

#+BEGIN_SRC cpp 
  // Convert to numerical value 
  >> b1.to_ulong()
  (unsigned long) 174

  >> 0xAE
  (int) 174
#+END_SRC

Flip bitset: 

#+BEGIN_SRC cpp 
  >> b1.flip()
  (std::bitset<8UL> &) @0x7f92db9c7018

  >> b1.to_ulong()
  (unsigned long) 81

  >> std::cout << "b1 flipped = " << b1 << std::endl;
  b1 flipped = 01010001
  >> 
#+END_SRC

Create bitset from binary string:

#+BEGIN_SRC cpp 
   >> auto bb = std::bitset<8>("01010001");

   >> bb
   (std::bitset<8> &) @0x7f92db9c7020

   >> std::cout << " bb = " << bb << "\n";
    bb = 01010001

   >> bb.to_ulong()
   (unsigned long) 81
   >> 

   >> bb.test(0)
   (bool) true

   >> bb.test(1)
   (bool) false
#+END_SRC

Getting individual bits:

#+BEGIN_SRC cpp 
  >> std::cout << "bit0 = " << bb[0] << " ; bit1 = " << bb[1] << " ; bit2 = " << bb[2] << "\n";
  bit0 = 1 ; bit1 = 0 ; bit2 = 0
  >> 

  >> if(bb[1]){ std::puts("bit is set"); } else { std::puts("bit is cleared"); }
  bit is cleared

  >> if(bb[2]){ std::puts("bit is set"); } else { std::puts("bit is cleared"); }
  bit is cleared

  >> if(bb[3]){ std::puts("bit is set"); } else { std::puts("bit is cleared"); }
  bit is cleared

  >> if(bb[5]){ std::puts("bit is set"); } else { std::puts("bit is cleared"); }
  bit is cleared

  >> if(bb[6]){ std::puts("bit is set"); } else { std::puts("bit is cleared"); }
  bit is set
  >> 
#+END_SRC

Getting reference to individual bit:

#+BEGIN_SRC cpp 
  >> auto gpio0 = bb[0]
  (std::bitset<8>::reference &) @0x7f92db9c7038

  >> (int) gpio0
  (int) 1

  >> gpio0 = true;
  >> (int) gpio0
  (int) 1

  >> gpio0 = false;
  >> (int) gpio0
  (int) 0

  >> (bool) gpio0
  (bool) false
#+END_SRC

Bitset to string:

#+BEGIN_SRC cpp 
  >> auto ba = std::bitset<8>("01010101");
  >> ba
  (std::bitset<8> &) @0x7f92db9c7058

  >> std::string repr(ba.to_string('0', '1'));
  >> repr
  (std::string &) "01010101"
  >> 

#+END_SRC

See: 
 + [[https://www.quora.com/Is-there-any-advantage-to-C-style-bit-manipulation-over-std-bitset-in-C++-I-test-it-But-in-many-famous-blog-they-use-C-style-bit-manipulation][Is there any advantage to C-style bit manipulation over std: :bitset in C++?]]
 + [[https://accu.org/index.php/journals/1606][One Approach to Using Hardware Registers in C++]]
** Math 
*** Standard library Math-releated headers

 - C++ Numeric Library Overview
   + [[https://en.cppreference.com/w/cpp/numeric][Numerics library - cppreference.com]]
 - *<cmath>* - Math functions, sin, cos, tan, exp, log, ... 
   + [[https://en.cppreference.com/w/cpp/header/cmath][Standard library header <cmath> - cppreference.com]]
 - *<cfloat>* - Float Point Constants such as ~FLT_RADIX~, ~DBL_RADIX~, ~FLT_MIN~,  ~DBL_EPS~ ... 
   + [[http://www.cplusplus.com/reference/cfloat/][<cfloat> (float.h) - C++ Reference]]
 - *<limits>* - Allows querying numeric types information such as radix,
   machine  precision eps, number of decimal digits and so on. 
   + [[https://en.cppreference.com/w/cpp/types/numeric_limits][std::numeric_limits - cppreference.com]]
 - *<random>* - C++11 Random number generator.
   + [[https://en.cppreference.com/w/cpp/header/random][Standard library header <random> - cppreference.com]]

*** Numerical Constants

Notes: Those constants are defined at the header <cmath>

#+CAPTION: C++ Numerical constants in header <cmath>
|-----------------------------+-----------+-------------------------------------------------------------------------------|
| Constant                    |     Value | Description                                                                   |
|-----------------------------+-----------+-------------------------------------------------------------------------------|
| *IEE754 Float Point Contants* |           |                                                                               |
| NAN                         |         - | (Since C++11) Constant not a number, used to indicate an invalid float point. |
| INFINITY                    |         - | (Since C++11) Positive infinity.                                              |
| -INFINITY                   |         - | (Since C++11) Negative infinity.                                              |
|                             |           |                                                                               |
| *General Math Constants*      |           |                                                                               |
| ~M_E~                         | 2.7182818 | Euler's number or exp(1)                                                      |
| ~M_LN2~                       | 0.6931472 | Natural logarithm of 2 or log(2)                                              |
| ~M_LN10~                      | 2.3025851 | Natural logarithm of 10 or log(10)                                            |
|                             |           |                                                                               |
| ~M_LOG10E~                    | 0.4342945 | Log of E (Euler's number) at base 10                                          |
| ~M_LOG2E~                     | 1.4426950 | Log of E (Euler's number) at base 2                                           |
|                             |           |                                                                               |
| ~M_SQRT2~                     | 1.4142136 | Square root of 2 or sqrt(2)                                                   |
| ~M_SQRT1_2~                   | 0.7071068 | Square root of 1/2 or sqrt(1/2) or 1/sqrt(2)                                  |
|                             |           |                                                                               |
| ~M_PI~                        | 3.1415927 | PI number                                                                     |
| ~M_PI_2~                      | 1.5707963 | PI/2                                                                          |
| ~M_PI_4~                      | 0.7853982 | PI/3                                                                          |
| ~M_1_PI~                      | 0.3183099 | 1/PI                                                                          |
| ~M_2_PI~                      | 0.6366197 | 2/PI                                                                          |
| ~M_2_SQRTPI~                  | 1.1283792 | 2/sqrt(PI)                                                                    |
|                             |           |                                                                               |
|-----------------------------+-----------+-------------------------------------------------------------------------------|

Example in CERN's Root REPL:

#+BEGIN_SRC cpp 
  >> M_PI
  (double) 3.1415927

  >> sin(M_PI)
  (double) 1.2246468e-16

  >> cos(M_PI)
  (double) -1.0000000

  >> cos(M_PI_2)
  (double) 6.1232340e-17

  >> sin(M_PI_2)
  (double) 1.0000000
  >> 
#+END_SRC

See: 

 + P0631R2 Math Constants - Document P0631R2 - *Math Constants* -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0631r2.pdf>
 + [[https://en.cppreference.com/w/cpp/numeric/math/INFINITY][INFINITY - cppreference.com]]
 + [[https://en.cppreference.com/w/cpp/numeric/math/NAN][NAN -   cppreference.com]]
* General C++ Reference Card 
** Data Types 

Numeric Types 

| Type                |   Size |    Size | Description                            | Maximum number of |
|                     | (bits) | (bytes) |                                        |    decimal digits |
|---------------------+--------+---------+----------------------------------------+-------------------|
| *Fixed-width integer* |        |         |                                        |                   |
| int8_t              |      8 |       1 | 8-bits signed int                      |                 2 |
| uint8_t             |     16 |       2 | 8-bits unisgned int (positive)         |                 2 |
| int16_t             |     16 |       2 | 16-bits signed int                     |                 4 |
| uint16_t            |     32 |       4 | 16-bits unsigned int                   |                 4 |
| int32_t             |     32 |       4 | 32-bits signed int                     |                 9 |
| uint32_t            |     32 |       4 | 32-bits unsigned int                   |                 9 |
| int64_t             |     64 |       8 | 64-bits signed int                     |                18 |
| uint64_t            |     64 |       8 | 64-bits unsigned int                   |                18 |
|                     |        |         |                                        |                   |
| *Integers*            |        |         |                                        |                   |
| short               |     16 |       2 | 16-bits signed int                     |                 4 |
| unsigned short      |     16 |       2 | 16-bits unsigned int                   |                 4 |
| int                 |     32 |       4 | 32-bits signed int                     |                 9 |
| unsigned int        |     32 |       4 |                                        |                 9 |
|                     |        |         |                                        |                   |
| long                |     64 |       8 | 64-bits signed int                     |                18 |
| unsigned long       |     64 |       8 | 64-bits unsigned int                   |                19 |
| long long           |     64 |       8 | 64-bits unsigned int (in this machine) |                19 |
|                     |        |         |                                        |                   |

Float Point Numebers 

| Type         | Size (bits) | Size (bytes) | Description                             |
|--------------+-------------+--------------+-----------------------------------------|
| *Float Points* |             |              |                                         |
| float        |          32 |            4 | Single-precision IEEE754 float point    |
| double       |          64 |            8 | Double-precision IEEE754 float point    |
| long float   |         128 |           16 | Quadruple-precision IEEE754 float point |


 *Sample code for showing numeric limits:*

File:
 + [[file:src/numeric-limits.cpp][file:src/numeric-limits.cpp]]
 + Online Compiler: https://rextester.com/BBXAM15894

#+BEGIN_SRC cpp :tangle src/numeric-limits.cpp 
  /*******************************************************************************************
   ,* File: numeric-limits.cpp 
   ,* Brief: Shows the numeric limits for all possible numerical types.  
   ,* Author: Caio Rodrigues
   ,*****************************************************************************************/

  #include <iostream>
  #include <limits>    // Numeric limits 
  #include <iomanip>   // setw, and other IO manipulators 
  #include <string>    // std::string 
  #include <cstdint>   // uint8_t, int8_t, ...
  #include <functional>

  struct RowPrinter{
          int m_left;  // Left alignment 
          int m_right; // Right alignment  
          RowPrinter(int left, int right): m_left(left), m_right(right){
                  // Print bool as 'true' or 'false' instead of 0 or 1.
                  std::cout << std::boolalpha;
          }
	
          template<class A>
          auto printRow(const std::string& label, const A& value) const -> void {
                  std::cout << std::setw(m_left)  << label
                                    << std::setw(m_right) << value << "\n";
          }
  };

  #define SHOW_INTEGER_LIMITS(numtype) showNumericLimits<numtype>(#numtype)
  #define SHOW_FLOAT_LIMITS(numtype)   showFloatPointLimits<numtype>(#numtype)

  template <class T>
  void showNumericLimits(const std::string& name){
          RowPrinter rp{30, 25};	
          std::cout << "Numeric limits for type: " << name << "\n";
          std::cout << std::string(60, '-') << "\n";
          rp.printRow("Type:",                    name);
          rp.printRow("Is integer:",              std::numeric_limits<T>::is_integer);
          rp.printRow("Is signed:",               std::numeric_limits<T>::is_signed);
          rp.printRow("Number of digits 10:",     std::numeric_limits<T>::digits10);
          rp.printRow("Max Number of digits 10:", std::numeric_limits<T>::max_digits10);

          // RTTI - Run-Time Type Information 
          if(typeid(T) == typeid(uint8_t)
             || typeid(T) == typeid(int8_t)
             || typeid(T) == typeid(bool)
             || typeid(T) == typeid(char)
             || typeid(T) == typeid(unsigned char)
                  ){
                  // Min Abs - samllest positive value for float point numbers 
                  rp.printRow("Min Abs:",         static_cast<int>(std::numeric_limits<T>::min()));
                  // Smallest value (can be negative)
                  rp.printRow("Min:",             static_cast<int>(std::numeric_limits<T>::lowest()));
                  // Largest value  
                  rp.printRow("Max:",             static_cast<int>(std::numeric_limits<T>::max()));	
          } else {
                  rp.printRow("Min Abs:",         std::numeric_limits<T>::min());
                  rp.printRow("Min:",             std::numeric_limits<T>::lowest());
                  rp.printRow("Max:",              std::numeric_limits<T>::max());
          }
          rp.printRow("Size in bytes:",       sizeof(T));
          rp.printRow("Size in bits:",        8 * sizeof(T));
          std::cout << "\n";
  }

  template<class T>
  void showFloatPointLimits(const std::string& name){
          RowPrinter rp{30, 25};	
          showNumericLimits<T>(name);
          rp.printRow("Epsilon:",        std::numeric_limits<T>::epsilon());
          rp.printRow("Min exponent:",   std::numeric_limits<T>::min_exponent10);
          rp.printRow("Max exponent:",   std::numeric_limits<T>::max_exponent10);
  }

  int main(){
          SHOW_INTEGER_LIMITS(bool);
          SHOW_INTEGER_LIMITS(char);
          SHOW_INTEGER_LIMITS(unsigned char);
          SHOW_INTEGER_LIMITS(wchar_t);

          // Standard integers in <cstdint>
          SHOW_INTEGER_LIMITS(int8_t);
          SHOW_INTEGER_LIMITS(uint8_t);
          SHOW_INTEGER_LIMITS(int16_t);
          SHOW_INTEGER_LIMITS(uint16_t);
          SHOW_INTEGER_LIMITS(int32_t);
          SHOW_INTEGER_LIMITS(uint32_t);
          SHOW_INTEGER_LIMITS(int64_t);
          SHOW_INTEGER_LIMITS(uint64_t);

          SHOW_INTEGER_LIMITS(short);
          SHOW_INTEGER_LIMITS(unsigned short);
          SHOW_INTEGER_LIMITS(int);
          SHOW_INTEGER_LIMITS(unsigned int);
          SHOW_INTEGER_LIMITS(long);
          SHOW_INTEGER_LIMITS(unsigned long);
          SHOW_INTEGER_LIMITS(long long);
          SHOW_INTEGER_LIMITS(unsigned long long);
	
          SHOW_FLOAT_LIMITS(float);
          SHOW_FLOAT_LIMITS(double);
          SHOW_FLOAT_LIMITS(long double);
	
      return 0;
  }

#+END_SRC

Output: 

#+BEGIN_SRC text 
   $ clang++ numeric-limits.cpp -o numeric-limits.bin -g -std=c++11 -Wall -Wextra && ./numeric-limits.bin
   Numeric limits for type: bool
   ------------------------------------------------------------
                            Type:                     bool
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        0
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                        1
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: char
   ------------------------------------------------------------
                            Type:                     char
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                     -128
                             Min:                     -128
                             Max:                      127
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: unsigned char
   ------------------------------------------------------------
                            Type:            unsigned char
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                      255
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: wchar_t
   ------------------------------------------------------------
                            Type:                  wchar_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: int8_t
   ------------------------------------------------------------
                            Type:                   int8_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                     -128
                             Min:                     -128
                             Max:                      127
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: uint8_t
   ------------------------------------------------------------
                            Type:                  uint8_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                      255
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: int16_t
   ------------------------------------------------------------
                            Type:                  int16_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                   -32768
                             Min:                   -32768
                             Max:                    32767
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: uint16_t
   ------------------------------------------------------------
                            Type:                 uint16_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                    65535
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: int32_t
   ------------------------------------------------------------
                            Type:                  int32_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: uint32_t
   ------------------------------------------------------------
                            Type:                 uint32_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:               4294967295
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: int64_t
   ------------------------------------------------------------
                            Type:                  int64_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: uint64_t
   ------------------------------------------------------------
                            Type:                 uint64_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: short
   ------------------------------------------------------------
                            Type:                    short
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                   -32768
                             Min:                   -32768
                             Max:                    32767
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: unsigned short
   ------------------------------------------------------------
                            Type:           unsigned short
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                    65535
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: int
   ------------------------------------------------------------
                            Type:                      int
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: unsigned int
   ------------------------------------------------------------
                            Type:             unsigned int
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:               4294967295
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: long
   ------------------------------------------------------------
                            Type:                     long
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: unsigned long
   ------------------------------------------------------------
                            Type:            unsigned long
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: long long
   ------------------------------------------------------------
                            Type:                long long
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: unsigned long long
   ------------------------------------------------------------
                            Type:       unsigned long long
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: float
   ------------------------------------------------------------
                            Type:                    float
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                        6
         Max Number of digits 10:                        9
                         Min Abs:              1.17549e-38
                             Min:             -3.40282e+38
                             Max:              3.40282e+38
                   Size in bytes:                        4
                    Size in bits:                       32

                         Epsilon:              1.19209e-07
                    Min exponent:                      -37
                    Max exponent:                       38
   Numeric limits for type: double
   ------------------------------------------------------------
                            Type:                   double
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                       15
         Max Number of digits 10:                       17
                         Min Abs:             2.22507e-308
                             Min:            -1.79769e+308
                             Max:             1.79769e+308
                   Size in bytes:                        8
                    Size in bits:                       64

                         Epsilon:              2.22045e-16
                    Min exponent:                     -307
                    Max exponent:                      308
   Numeric limits for type: long double
   ------------------------------------------------------------
                            Type:              long double
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                       21
                         Min Abs:             3.3621e-4932
                             Min:           -1.18973e+4932
                             Max:            1.18973e+4932
                   Size in bytes:                       16
                    Size in bits:                      128

                         Epsilon:               1.0842e-19
                    Min exponent:                    -4931
                    Max exponent:                     4932
#+END_SRC

** Numeric Literals 

| Literal            | Suffix   | Type          | Description                                                                    | Sizeof Bytes |
|--------------------+----------+---------------+--------------------------------------------------------------------------------+--------------|
| 2001               | -        | int           | signed integer                                                                 |            4 |
| 20u                | u or U   | unsingned int |                                                                                |            4 |
| 0xFFu              | u or U   | unsigned int  | unsingned int literal in hexadecimal (0xff = 255)                              |            4 |
|                    |          |               |                                                                                |              |
| 100l or 100L       | l or L   | long          |                                                                                |            8 |
| 100ul or 100UL     | ul or UL | unsigned long |                                                                                |            8 |
| 0xFAul or 0xFAUL   |          | unsigned long | unsigned long literal in hexadecimal format (0xfa = 250)                       |            8 |
|                    |          |               |                                                                                |              |
| 100.23f or 100.23F | f or F   | float         | 32 bits IEEE754 Float Point number mostly used in games and computer graphics. |            8 |
| 20.12   (default)  |          | double        | 64 bits IEEE754 Float Point number commonly used in scientific computing.      |            4 |
|                    |          |               |                                                                                |              |
|                    |          |               |                                                                                |              |

** Types of Parameter Passing 

| Parameter Passing                 | Alternative | Parameter t passed by                                               |
|-----------------------------------+-------------+---------------------------------------------------------------------|
| *Value*                             |             |                                                                     |
| T t                               |             | by value                                                            |
| const T* t                        | const T* t  |                                                                     |
|-----------------------------------+-------------+---------------------------------------------------------------------|
| *Pointer*                           |             |                                                                     |
| T* t                              | T *t        | pased by pointer                                                    |
| T t []                            | T* t        | by pointer, this notation is used for C-array parameters            |
|-----------------------------------+-------------+---------------------------------------------------------------------|
| *Reference*                         |             |                                                                     |
| T& t                              | T &t        | by reference or *L-value reference*                                   |
| const T& t                        | const T &t  | by const reference or const *L-value reference.*                      |
| T const& t                        | -           | by const reference - alternative notation                           |
| T&& t                             | T &&t       | by r-value reference                                                |
| template<class T> function(T&& t) | -           | Universal reference can become either L-value or R-value reference. |
|-----------------------------------+-------------+---------------------------------------------------------------------|

Notes: 

 + Function here means both member function (class methods) or free
   functions (aka ordinary functions).

 + _Parameters passed by value cannot be modified within the function_
   as they are _copied_. It happens for all C++ types, including
   instances of classes what is different from most OO languages like
   Java, C#, Python and etc.

 + When an object is passed by value, its _copy constructor_ is invoked,
   as a result a copy is created.

 + Prefere passing large objects such large matrices or arrays by
   _reference or const_ reference when the function is not supposed to
   modify the parameter in order to avoid memory overhead due to
   copy.

 + I is better to pass objects instantiated on the heap (dynamic
   memory) with _new_ operator using *smart pointers* (~unique_ptr~,
   ~shared_ptr~) in order to avoid memory leaks.

** C++ Standard Library Reference

*C++ Standards* ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html][Source]])

 - *C++ is standardized as ISO/IEC 14882.* Currently, there are two
   versions:

   - _C++98 (ISO/IEC 14882:1998)_ 1st standard version of C++.
   - _C++03 (ISO/IEC 14882:2003)_ minor "bug-fix" to C++98 with no change
     to the language. Commonly refer to as C++98/C++03 or First C++
     standard.
 - _C++11 (ISO/IEC 14882:2011)_ 2nd standard version of C++.


*C++ Libraries* 

 + STL (Standard Template Library) Containers, Iterators and Function objects.
   + Sequence
     + vector  -> <vector>
     + list    -> <list>
     + dequee  -> <deque>
     + array   -> <array>

   + Associative Sequence
     + set
     + map (Hashmap or hash table).
     + multiset
     + multimap
     + ~unordered_set~
     + ~unordered_map~

 + C++ Libraries ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
   + <ios>, <iostream>, <istream>, <ostream>, <fstream>, <sstream>
   + <iomanip> 
   + <string>  - C++ Strings.
   + <regex>
   + <random>
   + <limits>
   + <stdexcept>, <exception>
   + <complex>, <tuple>, <valarray>
   + <locale>
   + <typeinfo>
   + <chrono>

   + Other: <codecvt>, <new>, <ratio>, <system_error>, <type_traits>

 + Useful non-standard C++ Libraries 
   + Boost C++ libaries
   + QT toolkit / GUI - Toolkit

 + C Compatibility
   + Standard ANSI C libaries ported to C++ are prefixed with "c"
     without ".h". For instance, "#include <math.h>" form C becomes
     "#include <cmath>" in C++.

   + C Libraries. ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
     + <cmath> - (math.h) - Standard mathematical functions such as
       sin, cos, sqrt and so on.
     + <cctypes> - (ctypes.h) - Checking character types (isalpha,
       isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl,
       isgraph, isprint, ispunct, isxdigit) and character conversion
       (toupper, tolower).
     + <climits>, <cfloat>: Size and limit of integer types (INT_MAX,
       INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX
       for long, LLONG_XXX for long long, CHAR_XXX for char) and
       floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP,
       DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double).

     + <ctime>: time, difftime, clock, gmttime, localtime, and etc.
     + <cstdio>: C's IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)
     + <cassert>, <cerrno>, <csignal>: Diagnostics and error
     + <clocale>: localizaton
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
** Operators and operator overload 
*** Summary Table 

| Description                                             | Operator               | Class operator overload declaration  |
|---------------------------------------------------------+------------------------+--------------------------------------|
| Equal to                                                | a == b                 |                                      |
| Logical not                                             | !a, !false, !true      |                                      |
| Logical and                                             | a && b                 |                                      |
| Logical or                                              | a \vert\vert b         |                                      |
|                                                         |                        |                                      |
| Pre increment (prefix)                                  | ++i                    |                                      |
| Post increment                                          | i++                    |                                      |
| Pre decrement                                           | ++i                    |                                      |
| Post increment                                          | i--                    |                                      |
|                                                         |                        |                                      |
| Addition assignment        ~(+=)~                         | a += b ; a <- a + b    |                                      |
| Subtraction assignment     ~(-=)~                         | a -= b ; a <- a - b    |                                      |
| Multiplication assignment  ~(*=)~                         | a *= b ; a <- a * b    |                                      |
| Division assignment       ~(/=)~                          | a /= b ; a <- a / b    |                                      |
|                                                         |                        |                                      |
| Subscript, array index                                  | a[b]                   | ~A C::operator [](S index)~            |
| Indirection - defeference                               | ~*a~                     | ~A C::operator *()~                    |
| Address or reference                                    | &a                     | ~A* C::operator &()~                   |
| Structure dereference                                   | a->memberFunction(x)   |                                      |
| Structure reference (.)                                 | a.memberFunction(x)    | - N/A                                |
|                                                         |                        |                                      |
| Function call (function-object declaration)             | A(p0, p1, p2)          | R C::operator()(P0 p0, P1 p1, P2 p2) |
| Ternary conditional - similar to if x = (if cond 10 20) | a ? b : c              | - N/A                                |
| Scope resolution operator                               | Class::staticMethod(x) | - N/A                                |
| Sizeof - returns size of type at compile-time           | sizeof(type)           | - N/A                                |
|                                                         |                        |                                      |
|                                                         |                        |                                      |
|                                                         |                        |                                      |

For more details check out: 

 - [[https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B][Operators in C and C++ - Wikipedia]]
*** Operator Overload Snippet 1 

#+BEGIN_SRC cpp 
  class SomeClass{
  private:
      // ---->> Private data here <------
  public:
      SomeClass(){}
      SomeClass(double x, double y){
          m_x = x;
          m_y = y;
      }
      // Copy assignment operator 
      SomeClass& operator=(const SomeClass& other){
          //  ...  ......
      }
      // Equality operator - check whether current object is equal to
      // the other.
      //-----------------------------------------------
      bool operator==(const SomeClass& p){
          return this->x == p.x && this->y == p.y;
      }
      // Not equal operator - checks whether current object is not equal to
      // the other.
      //-----------------------------------------------
      bool operator!=(const SomeClass& p){
          return this->x != p.x || this->y != p.y;
      }
      // Not logical operator (!) Exclamation mark.
      // if(!obj){ ... }
      //-----------------------------------------------
      bool operator! (){
          return this->m_data != nullptr;
      }
      // Operator ++obj
      //-----------------------------------------------
      SomeClass& operator++(){
          this->m_counter += 1;
          return *this;
      }

      // Operator (+)
      // SomeClass a, b;
      // SomeClass c = a + b;
      SomeClass operator+(SomeClass other){
          SomeClass res;
          res.x = m_x + other.x;
          res.y = m_y + other.y;
          return res;
      }
      // Operator (+)
      SomeClass operator+(double x){
          SomeClass res;
          res.x = m_x + x
          res.y = m_y + x
          return res;
      }
      // Operator (*)
      SomeClass operator*(double x){
          SomeClass res;
          res.x = res.x * x;
          res.y = res.y * x;
          return res;
      }

      // Operator (+=)
      // SomeClass cls;
      // cls += 10.0;
      SomeClass& operator +=(double x){
          m_x += x;
          m_y += y;
          return *this;
      }
      // Operator index -> obj[2]
      // SomeClass cls;
      // double z = cls[2];
      //-----------------------------------------------
      double operator[](int idx){
          return this->array[idx];
      }
      // Function application operator
      // SomeClass obj;
      // double x = obj();
      //-----------------------------------------------
      double operator()(){
          return m_counter * 10;
      }
      // Function application operator
      // SomeClass obj;
      // double x = obj(3.4, "hello world");
      //-----------------------------------------------
      double operator()(double x, std::string msg){
          std::cout << "x = " << x << " msg  = " << msg;
          return 3.5 * x;                                       
      }
      // Operator string insertion, allows printing the current object 
      // SomeClass obj;
      // std::cout << obj << std::enl;
      //-----------------------------------------------
      friend std::ostream& operator<<(std::ostream &os, const SomeClass& cls){
          // Print object internal data structure 
          os << cls.m_x << cls.m_y  ;
          return os;
      }
  };
#+END_SRC
*** Operator Overload Snippet 2 

File: SomeClass.hpp - Header file. 

#+BEGIN_SRC cpp 
  class SomeClass{
  private:
      // ---->> Private data here <------
  public:
      SomeClass(){}
      SomeClass(double x, double y);
      bool operator==(const SomeClass& p);
      bool operator!=(const SomeClass& p);
      bool operator! ();
      SomeClass& operator++();
      SomeClass operator+(SomeClass other);
      SomeClass operator+(double x);
      SomeClass operator*(double x);
      SomeClass& operator +=(double x);
      double operator[](int idx);
      double operator()();
      double operator()(double x, std::string msg);
      friend std::ostream& operator<<(std::ostream &os, const SomeClass& cls);
  };
#+END_SRC

File: SomeClass.cpp - implementation

#+BEGIN_SRC cpp 
  SomeClass::SomeClass(){}

  SomeClass::SomeClass(double x, double y){
          m_x = x;
          m_y = y;
      }
      
  // Equality operator - check whether current object is equal to
  // the other.
  //-----------------------------------------------
  bool SomeClass::operator==(const SomeClass& p){
      return this->x == p.x && this->y == p.y;
  }

  // Not equal operator - checks whether current object is not equal to
  // the other.
  //-----------------------------------------------
  bool SomeClass::operator!=(const SomeClass& p){
      return this->x != p.x || this->y != p.y;
  }
      
  // Not logical operator (!) Exclamation mark.
  // if(!obj){ ... }
  //-----------------------------------------------
  bool SomeClass::operator! (){
      return this->m_data != nullptr;
  }
      
  // Operator ++obj
  //-----------------------------------------------
  SomeClass& SomeClass::operator++(){
      this->m_counter += 1;
      return *this;
  }

  // Operator (+)
  // SomeClass a, b;
  // SomeClass c = a + b;
  SomeClass SomeClass::operator+(SomeClass other){
      SomeClass res;
      res.x = m_x + other.x;
          res.y = m_y + other.y;
          return res;
  }
  // Operator (+)
  SomeClass SomeClass::operator+(double x){
      SomeClass res;
      res.x = m_x + x;
      res.y = m_y + x;
      return res;
  }
  // Operator (*)
  SomeClass SomeClass::operator*(double x){
      SomeClass res;
      res.x = res.x * x;
      res.y = res.y * x;
          return res;
  }

  // Operator (+=)
  // SomeClass cls;
  // cls += 10.0;
  SomeClass& SomeClass::operator +=(double x){
      m_x += x;
      m_y += y;
      return *this;
  }
      
      
  // Operator index -> obj[2]
  // SomeClass cls;
  // double z = cls[2];
  //-----------------------------------------------
  double SomeClass::operator[](int idx){
      return this->array[idx];
  }
      
  // Function application operator
  // SomeClass obj;
  // double x = obj();
  //-----------------------------------------------
  double SomeClass::operator()(){
      return m_counter * 10;
  }

  // Function application operator
  // SomeClass obj;
  // double x = obj(3.4, "hello world");
  //-----------------------------------------------
  double SomeClass::operator()(double x, std::string msg){
      std::cout << "x = " << x << " msg  = " << msg;
      return 3.5 * x;                                       
  }

  // Operator string insertion, allows printing the current object 
  // SomeClass obj;
  // std::cout << obj << std::enl;
  //-----------------------------------------------
  friend std::ostream& SomeClass::operator<<(std::ostream &os, const SomeClass& cls){
      // Print object internal data structure 
      os << cls.m_x << cls.m_y  ;
      return os;
  }

#+END_SRC
*** Array index operator overload 

This example how to overload the operator array index to allow
returning a value or performing an assignment operation. 

File: *array-index-overload.cpp* 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>

  class Container{
  private:
          std::vector<double> xs =  { 1.0, 2.0, 4.0, 6.233, 2.443};
  public:
      Container(){}
      double& operator[](int index){
          return xs[index];
      }
  };

  int main(){
      Container t;
      std::cout << "t[0] = " << t[0] << std::endl;
      std::cout << "t[1] = " << t[1] << std::endl;
      std::cout << "t[2] = " << t[2] << std::endl;
      std::cout << "\n--------\n";
      t[0] = 3.5;
      std::cout << "t[0] = " << t[0] << std::endl;
      t[2] = -15.684;
      std::cout << "t[2] = " << t[2] << std::endl;    
      return 0;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
$ cl.exe array-index-overload.cpp /EHsc /Zi /nologo /Fe:out.exe && out.exe
t[0] = 1
t[1] = 2
t[2] = 4

--------
t[0] = 3.5
t[2] = -15.684

#+END_SRC
*** Conversion Operators and user-defined type conversion 

Conversion operators allow to convert a class to any type implicitly
or explicitly with type-cast operator ~static_cast<T>~. 

Example: 
 
 - ROOT Script File: _conversion-operator.cpp_

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>

  #define LOGFUNCTION(type)  std::cerr << "Convert to: [" << type << "] => Called: line " \
          << __LINE__ << "; fun = " << __PRETTY_FUNCTION__ << "\n"

  // Or: struct Dummy { 
  class Dummy{
  public:
          bool flag = false;

          // Type conversion operator which converts an instance
          // of dummy to double.	
          explicit operator double() {
                  LOGFUNCTION("double");
                  return 10.232;
          }	
          #if 1
          // Implicit conversion to int is not allowed, it is only possible to convert
          // this object explicitly with static_cast. 	
          explicit operator int() const {
                  LOGFUNCTION("int");
                  return 209;
          }	
          explicit operator long() const {
                  LOGFUNCTION("long");
                  return 100L;
          }
          operator std::string() const {
                  LOGFUNCTION("std::string");
                  return "C++ string std::string";
          }
          explicit operator const char*() const {
                  LOGFUNCTION("const char*");
                  return "C string";
          }		
          operator bool() const {
                  LOGFUNCTION("bool");
                  std::cerr << " Called " << __FUNCTION__ << "\n";
                  return flag;
          }
          #endif 
  };
#+END_SRC

Testing: 

 - C-style casting

#+BEGIN_SRC cpp 
  >> .L conversion-operator.cpp 
  >> Dummy d;  

  >> (double) d
  Convert to: [double] => Called: line 15; fun = double Dummy::operator double()
  (double) 10.232000

  >> (int) d
  Convert to: [int] => Called: line 22; fun = int Dummy::operator int() const
  (int) 209

  >> (long) d
  Convert to: [long] => Called: line 26; fun = long Dummy::operator long() const
  (long) 100

  >> (std::string) d
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string) "C++ string std::string"
  >> 
#+END_SRC

 + C++ style casting:

#+BEGIN_SRC cpp 

  >> static_cast<int>(d)
  Convert to: [int] => Called: line 22; fun = int Dummy::operator int() const
  (int) 209
  >> 
  >> static_cast<long>(d)
  Convert to: [long] => Called: line 26; fun = long Dummy::operator long() const
  (long) 100
  >> 
  >> static_cast<double>(d)
  Convert to: [double] => Called: line 15; fun = double Dummy::operator double()
  (double) 10.232000

  >> static_cast<std::string>(d)
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string) "C++ string std::string"
  >> 

  >> static_cast<bool>(d)
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (bool) false
  >> 

  >> d.flag = true
  (bool) true

  >> static_cast<bool>(d)
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (bool) true
  >> 

#+END_SRC
 
 + Simulating implicit conversion:
   + Note: implicitly assignment type conversion is not allowed for
     operators annotated with explicit. So it is not possible to
     perform the assignment: const char* s = d 

#+BEGIN_SRC cpp 
  // Implicit conversion 
  >> std::string message = d
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string &) "C++ string std::string"
  >> 
  >> std::cout << "text = " << message << "\n";
  text = C++ string std::string
  >> 
  >> 

  >> const char* s = d
  ROOT_prompt_16:1:13: error: no viable conversion from 'Dummy' to 'const char *'
  const char* s = d
              ^   ~
  // Conversion operators marked as explicit can only casted using C-style cast or 
  // or static_cast<T>
  >> const char* s = static_cast<const char*>(d)
  Convert to: [const char*] => Called: line 34; fun = const char *Dummy::operator const char *() const
  (const char *) "C string"

  >> d ? "true" : "false";
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool

  >> d ? "true" : "false"
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (const char *) "true"

  >> d.flag = false;

  >> d ? "true" : "false"
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (const char *) "false"
  >> 
#+END_SRC

 + Bool type conversion in conditional statements.

#+BEGIN_SRC cpp 
  >> d.flag = true;

  >> if(d) { std::cout << "Flag is true OK" << std::endl; }
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  Flag is true OK

  >> d.flag = false;

  >> if(!d) { std::cout << "Flag is false OK" << std::endl; }
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  Flag is false OK
  >> 
  >> 
#+END_SRC


 - Note: The macro ~__PRETTY_FUNCTION__~ is only available in GCC or
   CLANG, in MSVC use ~__FUNCSIG__~


Further Reading:  
 + [[https://msdn.microsoft.com/en-us/library/ts48df3y.aspx][Cast Operator: ()]]
 + [[https://docs.microsoft.com/en-us/cpp/cpp/user-defined-type-conversions-cpp?view=vs-2017][User-Defined Type Conversions (C++) | Microsoft Docs]]
 + [[https://stackoverflow.com/questions/1307876/how-do-conversion-operators-work-in-c][How do conversion operators work in C++? - Stack Overflow]]
 + Explicit Conversion Operators -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1592.pdf>
** Preprocessor and macros 
*** General Predefined Macros  

C++ Provides some useful predefined macros for debugging, logging,
compiler identification and detecting the version of C++ standard the
compiler is using. 

| Macro               | Description                                                   | Compiler                                  |
|---------------------+---------------------------------------------------------------+-------------------------------------------|
| ~__LINE__~            | Contains current line number of the program.                  | all                                       |
| ~__FILE__~            | Name of current file.                                         | all                                       |
| ~__DATE__~            | Date in the format month/day/year                             | all                                       |
| ~__TIME__~            | Contains a string in the format hour:minute:second            | all                                       |
|                     |                                                               |                                           |
| ~__cplusplus~         | Contains C++ standard Version string                          |                                           |
|                     |                                                               |                                           |
| =__FUNCTION__=        | Print name of current function or method (member function)    | all                                       |
| =__PRETTY_FUNCTION__= | Print name of current function or method with type signature. | GGC/G++, Mingw(GCC for Windows) and Clang |
| =__FUNCSIG__=         | Print name of current function with type signature.           | MSVC(aka VC++)                            |
|                     |                                                               |                                           |

The macro: ~__cplusplus~ is useful for identifying if the code is being
compiled with C or C++ compiler and also get the version C++ standard
the code is being compiled. 

|----------------------------+---------------------------------------------------|
| Value of Macro ~__cplusplus~ | C++ Version                                       |
|----------------------------+---------------------------------------------------|
| Not defined.               | N/A the code is being compiled with a C-compiler. |
| 199711L                    | C++98/C++03                                       |
| 201103L                    | C++11                                             |
| 201402L                    | C++14                                             |
| 201703L                    | C++17                                             |
| N/A                        | C++20  - Still waiting                            |
| N/A                        | C++ with module system? - Only gosh knows!        |
| N/A                        | C++ with a standardized ABI - "Keep on dreaming!" |
|----------------------------+---------------------------------------------------|

Example: 

#+BEGIN_SRC cpp 
  cout << " time = " << __TIME__
       << " file = " << __FILE__
       << " line = " << __LINE__
       << "  variable  = " << value
       << endl;
#+END_SRC

*** Macros for detecting platform or operating system 

The preprocessor macros can be used for cross platform compilation,
creating cross platform libraries and isolating platform-specific 
code. 

*Macros for detecting Operating System and Platform* 

| Operating System               | OS Family | Macro                          | Description                                                    |
|--------------------------------+-----------+--------------------------------+----------------------------------------------------------------|
|                                |           |                                |                                                                |
| Windows 32 and 64-bits         | WinNT     | ~_WIN32~                         | Defined when compiling on Windows with Msvc(Visual C++) or Gcc |
| Windows 64 bits                | WinNT     | ~_WIN64~                         | Windows 64 bits.                                               |
| Windows CE                     | WinCE     | ~_WIN32_WCE~                     | Windows CE Kernel for embedded systems.                        |
| MSDOS                          |           | MSDOS or ~__MSDOS__~             |                                                                |
| OS2                            |           | OS2 or ~_OS2~ or ~__OS2__~         | IBM's old OS2 Operating System.                                |
|                                |           |                                |                                                                |
| Unix-like                      | Unix      | ~__unix__~                       | Check whether OS is unix-like (Linux, BSD-variant), Mac OSX)   |
| Linux                          | Unix      | ~__linux__~                      | Defined when compiling on Linux with Gcc or Clang              |
| Android                        | Unix      | ~__ANDROID__~                    | Android NDK.                                                   |
| MacOSX and IOS (Darwin Kernel) | Unix      | ~__apple__~, ~__APPLE__~, ~__MACH__~ | -                                                              |
| BSD                            | Unix      | ~__bsd__~                        | -                                                              |
| Free BDS                       | Unix      | ~__FreeBSD__~                    |                                                                |
| Net BSD                        | Unix      | ~__NetBSD__~                     |                                                                |
| QNX                            | Unix      | ~__QNX__~                        |                                                                |
| VxWorks                        | -         | ~__VXWORKS__~ or ~__vxworks~       |                                                                |
| Minix                          | Unix      | ~__minix~                        |                                                                |
| NaCL                           |           | ~__native_client__~              |                                                                |
| AsmJS                          |           | ~__asmjs__~                      |                                                                |
|                                |           |                                |                                                                |
|                                |           |                                |                                                                |

Usage example: 

#+BEGIN_SRC cpp 
  void makeDirectory(std::string path){
      #if defined __linux__ || defined __apple__ || defined __bsd__
        mkdir(path.c_str(), 0777);
      #elif _WIN32
        wchar_t* wtext = winUtils::stringToLPWSTR(path);
      CreateDirectoryW(wtext, NULL);
        delete [] wtext;
      #else
        #error "Unknown platform"
      #endif
  }
#+END_SRC

*** Macros for detecting compiler 

Compiler detection: 

| Macro                       | Compiler                                                          |
|-----------------------------+-------------------------------------------------------------------|
| *Compiler*                    |                                                                   |
| ~__GNUC__~                    | GNU C/C++ Compiler.                                               |
| ~__MINGW32__~                 | Mingw or GNU C/C++ Compiler ported for Windows NT.                |
| ~__MINGW64__~                 | Mingw or GNU C/C++ Compiler ported for Windows NT - 64 bits only. |
| ~__GFORTRAN__~                | Fortran / GNU Fortran Compiler                                    |
|                             |                                                                   |
| ~__clang__~                   | Clang / LLVM Compiler                                             |
|                             |                                                                   |
| ~_MSC_VER~                    | Microsoft Visual Studio Compiler MSVC                             |
| ~_MANAGED~ or ~__cplusplus_cli~ | Compilation to C++/CLI .NET (CLR) bytecode                        |
|                             |                                                                   |
| ~__INTEL_COMPILER~            | Intel C/C++ Compiler                                              |
| ~__PGI~ or ~__PGIC__~           | Portland Group C/C++ Compiler                                     |
|                             |                                                                   |
| ~__BORLANDC__~                | Borland C++ Compiler [DEPRECATED]                                 |
|                             |                                                                   |
| ~__EMSCRIPTEN__~              | emscripten (asm.js - web assembly)                                |
| ~__asmjs__~                   | asm.js                                                            |
| ~__wasm__~                    | WebAssembly                                                       |
| ~__NVCC__~                    | NVCC                                                              |
|                             |                                                                   |
| ~__CLING__~                   | CERN's ROOT Cling C++ Interactive Shell                           |
|                             |                                                                   |
|                             |                                                                   |
| *C/C++-library*               |                                                                   |
| ~__GLIBCXX__~                 | Libstdc++                                                         |
| ~_LBCPP_VERSION~              | LibC++                                                            |
| ~_MSC_VER~                    | MSVC C++ Library (Runtime)                                        |
| ~__GLIBC__~                   | GNU LibC runtime                                                  |
| ~__BIONIC__~                  | Bionic LibC runtime. (Android's C-library modified from BSD)      |
|                             |                                                                   |
|                             |                                                                   |


See also: 

 + GCC - [[https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html][The C Preprocessor: Common Predefined Macros]]
 + [[https://sourceforge.net/p/predef/wiki/OperatingSystems/][Pre-defined Compiler Macros / Wiki / OperatingSystems]]
 + [[https://abseil.io/docs/cpp/platforms/macros][abseil / Platform Check Macros]]
 + [[https://stackoverflow.com/questions/142508/how-do-i-check-os-with-a-preprocessor-directive][c - How do I check OS with a preprocessor directive? - Stack Overflow]]
 + [[https://msdn.microsoft.com/en-us/library/468x0ea1.aspx][How to: Detect -clr Compilation]]
 + [[https://stackoverflow.com/questions/9976194/find-programmatically-if-under-c-or-c-cli][compilation - Find programmatically if under C++ or C++/CLI - Stack Overflow]]

*** Useful macros for debugging and tracing 

Usage: Put this block at the top of the file to debug or log or in a
separate header file and compile with the flag ~-DDEBUG_MODE~, for
instance. _$ g++ file1.cpp fil2.cpp -DDEBUG_MODE_ 

#+BEGIN_SRC cpp 
#if defined(DEBUG_MODE)
  #define disp(expr)  std::cerr << __FILE__ << ":" << __LINE__ << ":" \
      << " ; " <<  #expr << " = " << (expr)  <<  std::endl

  #define dbgloc(msg)  std::cerr << __FILE__ << ":" << __LINE__ << ":" << msg 
  #define dbgline __FILE__ << ":" << __LINE__ << ":" <<
  #define dbgtrace(msg) std::cerr << __FILE__ << ":" << __LINE__ << ": TRACING " << msg << "\n";
#else
  #define disp(expr) 
  #define dbgloc(msg)  
  #define dbgline 
  #define dbgtrace(msg) 
#endif 
#+END_SRC


Note: the program's stdout output is clickable in Emacs which allows
to go quickly to the code location that generated the output. To
compile and run a c++ program in Emacs use: 

 $ ~M-x compile g++ program1.cpp program2.cpp -o out.bin -DDEBUG_MODE && ./out.bin~

 *Macro dbgtrace*

The macro dbgtrace creates the message shown in the following code
block displaying the file and the line where the message was
generated:  

Sample usage:

 - dbtrace("invoking copy constructor")

Output example: 

#+BEGIN_SRC sh 
   gslLinalg.cpp:46: TRACING invoking copy constructor
#+END_SRC

 *Macro disp*

The macro disp displays any expression in the way it is written, it is
useful to create C++ code demonstration and creating proof-of-concept
programs. 

Sample usage: 

 - disp(x * x + 10);

Output example: 

#+BEGIN_SRC sh 
   math1.cpp:10: ; x * x + 10 = 19
#+END_SRC
*** Macros for Assertion 

Example: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cassert>

  #define ASSERTION_ENABLED

  // Requires header: <cassert>
  #ifdef  ASSERTION_ENABLED
    #define ASSERT(condition, text)    \
                { if (!(condition)) {	 \
                                 std::cerr << " [ASSERTION] " <<  __FILE__ << ":" << __LINE__ << ": " \
                               << text << "\n" ;  \
                                 assert(condition);   }}
  #else
    #define ASSERT(condition, text)
  #endif

  int main(){
          int x = 100;
          ASSERT(x > 200, "Assumption: x > 200");

          return 0;
  }
#+END_SRC

When the assertion fails, it prints the message: 

#+BEGIN_SRC sh 
  g++ scractch.cpp -o scractch.bin -g -std=c++1z -Wall -Wextra && ./scractch.bin
   [ASSERTION] scractch.cpp:33: Assumption: x > 200
  scractch.bin: scractch.cpp:33: int main(): Assertion `x > 200' failed.

#+END_SRC

*** Tips and guidelines for writing macros 
**** DO NOT Use macros for defining constants

Unlike in C, in C++ is preferable to use const keyword approach for
defining constants instead of preprocessor define macros.

For instance, use: 

#+BEGIN_SRC cpp 
  // PI Number
  const double PI = 3.141592653589793; 
  // Euler's number 
  const double  E = 2.718281828459045;
  // Buffer size in bytes 
  const size_t BUFFER_SIZE = 1024; 
#+END_SRC

Instead of: 

#+BEGIN_SRC cpp 
  #define PI 3.141592653589793
  #define E  2.718281828459045
  #define BUFFER_SIZE 1024
#+END_SRC

**** Use parenthesis within macros around parameter names

Reference:  [[https://wiki.sei.cmu.edu/confluence/display/c/PRE01-C.+Use+parentheses+within+macros+around+parameter+names][PRE01-C. Use parentheses within macros around parameter names - SEI CERT C Coding Standard - Confluence]]

Example: The following code fails, if the macro argument is an
experession such as 2 + 1.

#+BEGIN_SRC cpp 
  #define CUBE(x) (x * x * x)
#+END_SRC

So, the result of the followign invokation will be: 

#+BEGIN_SRC cpp 
  // Expected value 81 / 3^3 = 81/27 = 3
  int k = 81 / CUBE(2 + 1); 
  // Remember the macro just does text substitution. 
  int k = 81 / ( 2 + 1 * 2 + 1 * 2 + 1 );
  int k = 81 / ( 2 + 2 + 2 + 1 ) = 81/7 = 11;
  // Expected k = 3, but got k = 11 
  int k = 11;
#+END_SRC

The correct way to define this macro is to enclose the references to
the macro's arguments in its body. 

#+BEGIN_SRC cpp 
  #define CUBE(x) ((x) * (x) * (x))
#+END_SRC

Now, it works: 

#+BEGIN_SRC cpp 
  int k = 81 / CUBE(2 + 1); 
  int k = 81 / ((2 + 1) * (2 + 1) * (2 + 1));
  int k = 81 / 27;
  int k = 3;
#+END_SRC

**** Dump all GCC's preprocessor defines 

Reference: 
 + [[https://stackoverflow.com/questions/2224334/gcc-dump-preprocessor-defines][g++ - GCC dump preprocessor defines - Stack Overflow]]
 + [[http://nadeausoftware.com/articles/2011/12/c_c_tip_how_list_compiler_predefined_macros][C/C++ tip: How to list compiler predefined macros | Nadeau Software]]

#+BEGIN_SRC sh 
   $ gcc -dM -E - < /dev/null
   #define __DBL_MIN_EXP__ (-1021)
   #define __FLT32X_MAX_EXP__ 1024
   #define __UINT_LEAST16_MAX__ 0xffff
   #define __ATOMIC_ACQUIRE 2
   #define __FLT128_MAX_10_EXP__ 4932
   #define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
   #define __GCC_IEC_559_COMPLEX 2
   #define __UINT_LEAST8_TYPE__ unsigned char
   #define __SIZEOF_FLOAT80__ 16
   #define __INTMAX_C(c) c ## L
   #define __CHAR_BIT__ 8
   #define __UINT8_MAX__ 0xff
   ... ... ... ..
   #define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
   #define __GCC_ATOMIC_SHORT_LOCK_FREE 2
   #define __INT_LEAST64_WIDTH__ 64
   #define __UINT_FAST8_TYPE__ unsigned char
   #define __ATOMIC_ACQ_REL 4
   #define __ATOMIC_RELEASE 3
#+END_SRC

**** Dump all preprocessor macros from a given header file 

Reference: [[https://stackoverflow.com/questions/2224334/gcc-dump-preprocessor-defines][g++ - GCC dump preprocessor defines - Stack Overflow]]

 + GCC (C-Compiler) Dump

#+BEGIN_SRC sh 
   $ echo "#include <sys/socket.h>" | gcc -E -dM - | tail -n 10
   #define SOL_LLC 268
   #define __DBL_MIN_EXP__ (-1021)
   #define AF_LLC PF_LLC
   #define __FLT32X_MAX_EXP__ 1024
   #define AF_MAX PF_MAX
   #define __UINT_LEAST16_MAX__ 0xffff
   #define __ATOMIC_ACQUIRE 2
   #define CMSG_NXTHDR(mhdr,cmsg) __cmsg_nxthdr (mhdr, cmsg)
   #define __FLT128_MAX_10_EXP__ 4932
   #define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F

      ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ... 

   #define __P(args) args
   #define PF_LOCAL 1
   #define __ATOMIC_ACQ_REL 4
   #define __ATOMIC_RELEASE 3
   #define __fsblkcnt_t_defined 
   #define _BITS_UIO_H 1
#+END_SRC

 +  G++ (C++ Compiler) Dump 

#+BEGIN_SRC sh 
   $ echo "#include <cmath>" | gcc -x c++ -std=c++11 -dD -E - | head -n 10
   # 1 "<stdin>"
   # 1 "<built-in>"
   #define __STDC__ 1
   #define __cplusplus 201103L
   #define __STDC_UTF_16__ 1
   #define __STDC_UTF_32__ 1
   #define __STDC_HOSTED__ 1
   #define __GNUC__ 7
   #define __GNUC_MINOR__ 3
   #define __GNUC_PATCHLEVEL__ 1

   .. ... ... .. ... ... .. ... ... 

   $ echo "#include <cmath>" | gcc -x c++ -std=c++11 -dD -E - | tail -n 40
     constexpr float
     tgamma(float __x)
     { return __builtin_tgammaf(__x); }

     constexpr long double
     tgamma(long double __x)
     { return __builtin_tgammal(__x); }



     template<typename _Tp>
       constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                 double>::__type
       tgamma(_Tp __x)
       { return __builtin_tgamma(__x); }



     constexpr float
     trunc(float __x)
     { return __builtin_truncf(__x); }

     constexpr long double
     trunc(long double __x)
     { return __builtin_truncl(__x); }



     template<typename _Tp>
       constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                 double>::__type
       trunc(_Tp __x)
       { return __builtin_trunc(__x); }



   }
   # 1917 "/usr/include/c++/7/cmath" 3
   }
   # 1 "<stdin>" 2

#+END_SRC
** General C++ Terminology and Concepts 
 
 + *Design Principles*

   + Performance Oriented 
     + Zero-cost abstractions.
     + Avoid runtime cost.
     + Value speed over safety. 
     + Don't pay for what you don't use.
   + Backward compatibility - avoid breaking old code.
     + Backward compatibility with C
     + Backward compatibility with old versions of C++.
   + Explicit is Better than implicit (Python lemma). For instance,
     explicit conversion with C++-style casting operators static_cast
     or reinterpret_pointer are better and safer than C implicit
     conversion.
   + Type-safety: Compile-time errors are always better than run-time
     errors as compile-timer errors can be caught earlier and doesn't
     cause bad surprises if it is deployed elsewhere.

 + *Pointers*

   - _Pointer_: A variable which holds the address of another
     variable. It is used for indirect access of variables, accessing
     memory mapped IO in embedded systems or in low-level software and
     also for referencing heap-allocated objects. All C++ ordinary
     pointers (not function pointers or pointer to member functions)
     have the same size and store a numeric address of some memory
     location, the only difference between pointers of different type
     is the type of memory location that they reference.

   - _Types of Pointers_
     + Ordinary pointers: int*, const char*, Object* ...
     + Pointer to function, aka function pointer
     + Pointer to member function (pointer to class method)
     + Pointer to member variable (pointer to class variable or field)
     + Smart "pointers": (they are not pointers) Stack-allocated
       objects used for managing heap-allocated objects through RAAI
       and pointer emulation.

   - _Wild pointer_
     + Non-intialized pointer.

   - _Dangling pointer_
     + A pointer which points to an object that was deleted or to a
       non-valid memory address. Segmentation faults crashes can
       happen if one attempts to delete a dangling pointer or invoke
       object's method through a dangling pointer. 

   - _Null pointer_
     + A pointer set to null (0), NULL or nullptr. It is safe to
       delete a null pointer, however attempting to invoke an object's
       method through the pointer (null pointer deference) has
       undefined behavior and may cause _segmentation fault_.
       + [[https://stackoverflow.com/questions/1823721/how-to-catch-the-null-pointer-exception][c++ - How to catch the null pointer exception? - Stack Overflow]]

   - _Void pointer_ void*
     + A pointer without any specific type associated. A pointer to
       any type can be converted to void pointer and void pointer can
       be coverted back to any type. A void pointer also cannot be
       used before being casted.
     + Can point to:
       + To primitive types int, float, char and so on.
       + To class instances.
       + To functions. Function pointers can be casted to void*
     + Cannot point to:
       + _member functions_ or class methods. So, pointers to member
         functions cannot be casted to void*.
       + _member variables_ or pointer to class variables. So, pointers
         to member variables cannot be casted to void*.
     + Use cases:
       + Root class. C++ doesn't have a root class from which all
         classes inherites like Java's Object class. A root class
         allows unrelated types to be stored in the same data
         structure or collection and perform type erasure. Void*
         pointer can work as "pseudo" root class as the pointer to any
         class can be coverted to it.
       + Type erasure of pointer to primitive types, pointer to
         classes and pointer to member functions.
       + Type erasure in C-APIs, for instance, malloc and C-API
         GetProcAddress from Windows which returns a function pointer
         to a function exported by a DLL casted as void*.

   - _Owning X Non-owning pointers_
     - An owning pointer is _responsible to release some allocated_
       _memory for a heap-allocated object_. In general, raw pointers
       should not be used as owning pointer as they provide no
       indication if they point to a heap-allocated object or
       stack-allocated object or to an heap-allocated array. Another
       problem, is that every _Type ptr* = new Type_ statement needs to
       be matched by an delete statement and it is easy to forget to
       track all possible execution paths. Besides that, raw pointers
       aren't _exception safe_ since a matching delete statement may not
       be executed if an exception occurs. In modern C++, only smart
       pointers should be used as owning pointers.

   - _Opaque pointer, also called handler_
     + This technique is widely used in C for emulating
       object-oriented programming features such as abstraction and
       encapsulation. This approach consists of a pointer to forward
       declared class or struct and a set of functions which takes the
       pointer to struct or class as argument. The client code is only
       allowed to manipulate the data structure by using a set of
       defined functions since the class or struct declaration is not
       exposed in the header files.
     + Uses cases:
       + C++ programming
         + => Pimpl - Pointer to Implementation, idiom for improving
           binary compatibility, reducing compilation time or
           obfuscating the implementation in the header.
         + => Creating C-APIs for C++ classes with extern "C" for
           allowing calling the C++ code from C or any foreign
           function-interface based on LibFFI (example: Java's JNA,
           Python's ctypes or Ruby's Ruby-FFI) or programming the
           language C-API such as Python C-API.
       + C Programming
         + => Decrease compile-time. 
         + => Improving binary compatibility. The client code doesn't
           have to be recompiled if the implementation changes as all
           pointers in C have the same size and the client program
           doens't have any access to the implementation.
         + => Implementation obfuscation.
         + => Emulating object oriented programming: As the client
           code cannot access the data structure directly without
           predefined functions, the implementation can be changed
           without disrupted the client code. In addition, this
           approach improves binary compatibility.
           + Examples:
             + C's FILE data structure is not exposed and it is only
               possible to manipulate pointers to FILE (FILE*) with
               the functions fopen (works as a constructor), fread
               (works as a accessor method), fprintf and fclose (works
               as a destructor) and so on. Those functions emulates
               object-oriented methods and the opaque pointers works
               as an object or class instance.  
             + Windows API and Windows' Kernel "Objects" with the type
               HANDLE.
       + See:
         + [[https://msdn.microsoft.com/en-us/library/ms810501.aspx][Give Me a Handle, and I'll Show You an Object]]
         + [[http://www.drdobbs.com/article/print?articleId=184402190&siteSectionName=][Object Oriented Programming in C]]
         + [[http://blog.aaronballman.com/2011/07/opaque-data-pointers/][Opaque Data Pointers | Ruminations]] 
         + [[https://lwn.net/Articles/446317/][Object-oriented design patterns in the kernel, part 2]]
         + [[https://stackoverflow.com/questions/2301454/what-defines-an-opaque-type-in-c-and-when-are-they-necessary-and-or-useful][What defines an opaque type in C, and when are they necessary and/or useful? - Stack Overflow]]
         + [[http://verplant.org/oo_programming_in_c.shtml][Object-oriented programming in C - Florian octo Forster's Homepage]]
         + [[http://www.alejandrosegovia.net/2011/05/16/opaque-type-oriented-programming-in-c/][Opaque Type Oriented Programming in C | Alejandro Segovia Azapian]]
         + [[https://docs.legato.io/14_07/c__a_p_is.html][Legato: C APIs]] 
         + https://www.cs.princeton.edu/courses/archive/fall04/cos217/lectures/06adts.pdf
         + https://en.wikipedia.org/wiki/Libffi
         + Book: [[https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413][C interfaces and implementation techniques: Techniques for creating reusable software]]

   - _Pointer "this"_
     + Every class has a pointer _this_ of type Class* which points to
       the current object. The pointer this is similar to Java's _this_
       keyword inside classes.
     + Use cases:
       + Return a reference or pointer to current object.
       + Ambiguity resolution, for instance, if a function has a
         parameter named count, and a class member has the same name,
         the ambiguity in assignment operation can be solved with
         _this->count = count;_
       + Make it explicit and indicate that a class method is being
         invoked, for instance, this->method(arg0, arg1, arg2) is more
         explicit than using method(arg0, arg1, arg2), which could be
         an external function instead of a class' member function.

 + *Classes*

   + _struct_ SomeName { ... }
     + A struct is just a class and equivalent to a class with member
       variables and member public by default. So, unlike in C,
       structs can have methods, constructor and destructor in C++.  

   + _Polymorphic class_
     + A class with at least one virtual member function.

   + _Abstract class_
     + A class with at least one pure virtual member function
       (abstract method.)

   + _Pure abstract class or interface class_
     * For short: a class with only 
     * As C++ doesn't have the _interface_ keyword, it can be emulated
       using with only pure virtual member functions (abstract
       method).

   + _POD - Plain Old Data_
     + Any C-compatible type that can serialized or copied with the
       C-function std::memcpy (in the header <cstring> or
       <string.h>). A POD can be a int, double, char, pointer, array,
       union, struct or class without any constructor, destructor,
       virtual functions and so on.
       + See:
       + [[https://en.cppreference.com/w/cpp/named_req/PODType][C++ named requirements: PODType - cppreference.com]]
       + [[https://en.cppreference.com/w/cpp/types/is_pod][std::is_pod - cppreference.com]]
       + [[https://stackoverflow.com/questions/146452/what-are-pod-types-in-c][What are POD types in C++? - Stack Overflow]]
       + [[https://en.wikipedia.org/wiki/Passive_data_structure][Passive data structure - Wikipedia]]
       + https://snipplr.com/view/10148/
       + http://www.math.ucla.edu/~wgoakley/Spring2018/04-12.pdf

 + *Member Functions*

   - _member function_
     + C++ terminology for class method. 

   - _virtual member function_ (aka virtual function or virtual method)
     + For short: _Method that can be overriden_, in other words,
       derived classes can replace the base class implementation.
     + Any class' member function (aka method) which can be overriden by
       derived classes. Only methods annotated with virtual can be
       overriden.

   - _pure virtual member function_
     + For short: _Abstract method_. A derived class must provide an implementation. 
     + A member function from base class annotated as virtual, however
       without any implementation. It is the same as an abstract method
       that should be implemented by derived classes.

   - _static member function_
     + For short: static method.
     + A class method that can be called without any instance.

   - _special member functions_
     + Destructor
     + Constructors
       - Default constructor 
       - Copy constructor
       - Move constructor
     + Copy assignment operator
     + Move assignment operator

   - _Common constructors_

     + _Default / Empty constructor_
       - Signature: CLASS()
       - Constructor without arguments used for default
         initialization. If this constructor is not defined, the
         compiler generates it by default. Without this constructor,
         it is not possible _to store a instances of a particular class_
         by value in STL containers.

     + _Conversion Constructor_
       - Signature: Class(T value)
       - Constructor with a single argument or callable with a single
         argument. This type of constructor instantiates an object
         with implicit conversion by assignment or when an instance of
         type T is passed to a function expecting an object of the
         underlying class. For instance, this constructor allows
         intialization as:
         - Class object = value; // Value has type T
         - Class object = 100;   // Calls constructor Class(int x).
       - To forbid this implicit conversion use the keyword _explicit_.
         - _explicit Class(T value)_

     + _List initializer constructor_
       - Signature: CLASS(std::intializer_list<T>)
       - Constructor which takes an [[https://en.cppreference.com/w/cpp/utility/initializer_list][initializer list]] as argument. This
         constructor makes possible to initialize an object with:
         + CLASS object {value0, value1, value2, value3 ... };
         + auto object = CLASS {value0, value1, value2, value3 ... };

     + _Range constructor_
       - Signature: CLASS(beginIterator, endInterator)
       - Constructor which takes an iterator pair as arguments. It
         allows to instantiate objects from STL container iterators.

 + *Types of polymorphism in C++*
   + _Dynamic - Resolution at runtime_
     + AKA: subtyping polymorphism. 
     + Inheritance and virtual functions. 

   + _Static - Resolution at compile-time_
     + Function overload - multiple functions with different
       signatures sharing the same name.
     + Templates (Parametric polymorphism)

 + *Polymorphism Binding*
   + _Early Binding_
     + The class method (aka member function) to be called is resolved
       at compile-time. 
   + _Late Binding_
     + The calss method to be called is resolved at runtime, rather
       than at compile-time. Late binding is only possible with inheritance
       and member functions marked as virtual.
     + Drawbacks:
       + Performance cost.
       + Compilers cannot inline virtual member functions.

 + *Linkage*

   + _External Linkage_ (Default)
     + Variables and functions are accessible from all compilation
       units (source files) through the whole program. All global
       variables and functions definitions without the _static keyword_
       or outside an _anonymous namespace_ have external linkage.
     + Multiple symbols (variable or function) cannot have the same name. 

   + _Internal Linkage_
     + Global variables or functions only acessible in the compilation
       unit (source file) they are defined. Such variables and
       functions are defined with _static_ (C-style) keyword
       annotatation or are defined inside an _anonymos namespace_
       (preferable in C++).
     + Multiple symbols can have the same.
     + Symbols with default internal linkage:
       + const objects, constexpr objects, typedefs and objects
         annoated with static keyword. 

   + _No linkage_
     + Local variables in functions or member functions. They are only
       accessible in the scope they are defined or stack-allocated
       variables.

   + References:
     + [[https://docs.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=vs-2017][Programs and Linkage (C++) | Microsoft Docs]]
     + [[https://stackoverflow.com/questions/48217270/what-is-the-point-of-internal-linkage-in-c][What is the point of internal linkage in C++ - Stack Overflow]]
     + [[https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr020.htm][IBM Knowledge Center - Language linkage (C++ only)]]

 + *Undefined Behavior X Unspecified Behavior*

   + _Undefined Behavior_: The C++ ISO Standard provides no gurantees
     about the program behavior under a particular condition. It means
     that anything can happen such as runtime crashing, returning an
     invalid or random value and so on. Undefined behavior should be
     avoided in order to ensure that the program can work with all
     possible compilers and platforms.

     + Example:

       + Delete a pointer to heap-allocated object twice.

       + Dereference or access a null, wild (non initialized) or
         dangling pointer.

       + Go out of bounds of a std::vector, std::deque or an C-array.

       + Arithmetic erros, for instance, division by zero.

       + Deference a pointer to a non-initialized heap-object.

       + Signed integer overflow.

       + Call pure virtual-functions on destructors or constructor.

     + See:
       + [[https://en.cppreference.com/w/cpp/language/ub][Undefined behavior - cppreference.com]]
       + [[https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a][What are all the common undefined behaviours that a C++ programmer should know about? - Stack Overflow]]
       + [[https://blog.regehr.org/archives/226][A Guide to Undefined Behavior in C and C++, Part 2 â€“ Embedded in Academia]]
       + [[https://spin.atomicobject.com/2014/05/19/c-undefined-behaviors/][4 Undefined Behaviors in C that You've Run into without Knowing It]]

   + _Unspecified Behavior_
     + It is basically "implementation defined behavior", the C++ ISO
       standard requires the behavior to be well defined by a
       compliant compiler. 
 
 + *Compilation*

   + _Cross-compilation_ -> Compiling a source code for a different
     processor architecture or operating system than the compiler was
     run (host operating system). Cross compilation is common for
     embedded systems, example: compiling an a program/app or firmware
     on Windows / x64 for an ARM 32 bits processor.  
** Common Acronyms, abbreviations and technologies

|--------------------------------+--------------------------------------------------------------------------------------------------|
| Acronym, name or technology    | Description                                                                                      |
|--------------------------------+--------------------------------------------------------------------------------------------------|
| *Organizations*                  |                                                                                                  |
| ANSI                           | American National Standards Institute                                                            |
| NIST                           | National Institute of Standards and Technology                                                   |
| ISO                            | International Organization for Standardization                                                   |
| IEEE                           | Institute of Electrical and Electronics Engineers                                                |
| IEC                            | International Electrotechnical Commission                                                        |
| CERN                           | European Organization for Nuclear Research                                                       |
| MISRA                          | Motor Industry Software Reliability Association                                                  |
|                                |                                                                                                  |
| *Technical Standards*            |                                                                                                  |
| _ISO/IEC 14882_ - C++            | C++ Programming Language Standard and Specification used by most compiler vendors.               |
| IEE754                         | Float Point technical standard                                                                   |
| ISO-8601                       | Date and time standard widely used on computers and internationalization.                        |
|                                |                                                                                                  |
| *General - C++*                  |                                                                                                  |
| CPP                            | C++ Programming Language                                                                         |
| TMP                            | Template Meta Programming                                                                        |
| STL                            | Standard Template Library                                                                        |
| ODR                            | One Definition Rule                                                                              |
| ADL                            | Argument Dependent Lookup                                                                        |
| ASM                            | Assembly                                                                                         |
|                                |                                                                                                  |
| GP                             | Generic Programming                                                                              |
| CTOR                           | Constructor                                                                                      |
| DTOR                           | Destructor                                                                                       |
| RAAI                           | Resource Acquisition Is Initialization                                                           |
| SFINAE                         | Substitution Is Not An Error                                                                     |
| RVO                            | Return Value Optmization                                                                         |
| EP                             | Expression Template                                                                              |
| CRTP                           | Curious Recurring Template Pattern                                                               |
| PIMPL                          | Pointer to Implementation                                                                        |
| RTTI                           | Runtime Type Identification                                                                      |
| MSVC                           | Microsoft Visual C++ Compiler                                                                    |
| VC++                           | Microsoft Visual C++ Compiler                                                                    |
| AST                            | Abstract Syntax Tree                                                                             |
| RPC                            | Remote Procedure Call                                                                            |
| rhs                            | right-hand side                                                                                  |
| lhs                            | left-hand side                                                                                   |
|                                |                                                                                                  |
| *Operating Systems Technologies* |                                                                                                  |
| IPC                            | Interprocess Communication                                                                       |
| COM                            | Component Object Model - (Microsoft Technology)                                                  |
| OLE                            | Object Linking and Embedding (Windows/COM)                                                       |
| IDL                            | Interface Description Language                                                                   |
| MIDL                           | Microsft Interface Description Language - used for create COM components                         |
| DDE                            | Dynamic Data Exchange - Windows shared memory protocol                                           |
| RTD                            | Real Time Data (Excel)                                                                           |
|                                |                                                                                                  |
| U-NIX like                     | Any operating based on UNIX (Opengroup trademark) such as Linux, Android, BSD, MacOSX, iOS, QNX. |
| BLOB                           | Binary Large Object                                                                              |
| GOF (Gang of Four)             | Book: Design Patterns: Elements of Reusable Object-Oriented Software                             |
| POSIX                          | Portable Operating System Interface (POSIX)                                                      |
|                                |                                                                                                  |
| *Network Protocols*              |                                                                                                  |
| RFC                            | Internet Taskforce - Request for Comment                                                         |
| ARP                            | Address Resolution Protocol                                                                      |
| DHCP                           | Dynamic Host Configuration Protocol                                                              |
| IP                             | Internet Protocol (Sockets)                                                                      |
| TCP                            | Transmissiion Control Protocol (Sockets)                                                         |
| UDP                            | User Datagram Protocol                                                                           |
| DNS (UDP Protocol)             | Domain Name System                                                                               |
| ICMP                           | Internet Control Message Protocol - Ping Protocol                                                |
| HTTP                           | Hyper Text Transfer Protocol                                                                     |
| FTP                            | File Transfer Protcol                                                                            |
| CAN Bus                        | Controller Area Network - distributed network used in cars and embedded systems.                 |
| [[https://en.wikipedia.org/wiki/Modbus][Modbus]]                         | Network protocol used by PLCs                                                                    |
|                                |                                                                                                  |
| *Executable Binary Formats*      |                                                                                                  |
| PE, PE32 and PE64              | Portable Executable format - Windows object code format.                                         |
| ELF, ELF32 and ELF64           | Executable Linkable Format - [U]-nix object code format.                                         |
| MachO                          | Binary format for executables and shared libraries used by the operating systems iOS and OSX.    |
|                                |                                                                                                  |
| DLL                            | Dynamic Linked Library - Windows shared library format.                                          |
| SO                             | Shared Object - [U]-nix, Linux, BSD, AIX, Solaris shared library format.                         |
| DSO                            | Dynamic Shared Object, [U]-nix shared library format.                                            |
|                                |                                                                                                  |
| *Cryptography*                   |                                                                                                  |
| HMAC                           | Keyed-Hash Message Authentication Code                                                           |
| MAC                            | Message Authentication Code                                                                      |
| *Crypto Hash Functions*          |                                                                                                  |
| MD5                            |                                                                                                  |
| SHA1                           |                                                                                                  |
| SHA256                         |                                                                                                  |
|                                |                                                                                                  |
| *Processor Architectures*        |                                                                                                  |
| CISC                           | Complex Instruction Set Computer                                                                 |
| RISC                           | Reduced Instruction Set Computer                                                                 |
| _SIMD_                           | Single Instruction, Multiple Data                                                                |
| Havard Architechture           | Used mostly in DSPs, Microcontrollers and embedded systems.                                      |
| Von-Neumann Architechture      | Used mostly in conventional processors.                                                          |
|                                |                                                                                                  |
| *Architechture Features*         |                                                                                                  |
| [[https://en.wikipedia.org/wiki/Direct_memory_access][DMA]]                            | Direct Memory Access                                                                             |
|                                |                                                                                                  |
| *Hardware and processors*        |                                                                                                  |
| CPU                            | Central Processing Unit                                                                          |
| FPU                            | Floating Point Unit                                                                              |
| DSP                            | Digital Signal Processor                                                                         |
| MPU                            | Micro Processor Unit                                                                             |
| MCU                            | Microcontroller Unit                                                                             |
| SOC                            | System On Chip                                                                                   |
| GPU                            | Graphics Processing Unit                                                                         |
| FPGA                           | Field Programmable Gate Array                                                                    |
| ASIC                           | Application-Specific Integrated Circuit                                                          |
| ECU                            | Engine Control Unit or Electronic Control Unit - Car's embedded computer.                        |
|                                |                                                                                                  |
| *Peripherals*                    |                                                                                                  |
| RAM                            | Random Access Memory                                                                             |
| ROM                            | Read-Only Memory                                                                                 |
| EPROM                          | Erasable Programmable Read-only Memory                                                           |
| EEPROM                         | Electrically Erasable Programmable Read-Only Memory                                              |
| GPIO                           | General Purpose IO                                                                               |
| ADC                            | Analog to Digial Converter                                                                       |
| DAC                            | Digital to Analog Converter                                                                      |
| PWM                            | Pulse Width Modulation                                                                           |
| Serial interface I2C           |                                                                                                  |
| Serial interface SPI           | Seria Peripheral Interface                                                                       |
| Serial interface UART          | Serial communication similar to the old computer serial interface RS232                          |
| Serial interface Ethernet      |                                                                                                  |
| Bus CAN                        | Controller Area Network - Widely used BUS in the automotive industry.                            |
| [[https://en.wikipedia.org/wiki/Display_Serial_Interface][DSI]]                            | Display Serial Interface                                                                         |
| [[https://en.wikipedia.org/wiki/Microelectromechanical_systems][MEMs]]                           | Microelectromechanical Systems - mechanical sensors implemented in silicon chips.                |
|--------------------------------+--------------------------------------------------------------------------------------------------|

** Bits, bytes, sizes and numerical ranges

Bits by position:

#+BEGIN_SRC text 
   MSB                                LSB 
  (Most significant bit)         (Least significant bit)
     |                                  |
   | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |         Bit Decimal    Bit shift    Multiplier
   +----|----+----+----+----+----+----+----+           Value         Operation
     |    |    |    |    |   |     |     |             ........     ........     ........
     |    |    |    |    |   |     |     \---------->> b0 x 2^0   =  b0 << 0     1  
     |    |    |    |    |   |      \--------------->> b1 x 2^1   =  b1 << 1     2
     |    |    |    |    |    \--------------------->> b2 x 2^2   =  b2 << 2     4
     |    |    |    |     \------------------------->> b3 x 2^3   =  b3 << 3     8
     |    |    |    \------------------------------->> b4 x 2^4   =  b3 << 4    16
     |    |    \------------------------------------>> b5 x 2^5   =  b5 << 5    32
     |    \----------------------------------------->> b6 x 2^6   =  b6 << 6    64
     \---------------------------------------------->> b7 x 2^7   =  b7 << 7   128
#+END_SRC

Example: 

#+BEGIN_SRC text 
  Binary number: 0b10100111 = 0b1010.0111 = 167 = 0xA7
  1010 => Upper nibble in the hex table is equal to 'A'
  0111 => Lower nibble in the hex table is equal to '7'

  | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |  
  +----+----+----+----+----+----+----+----+
  | 1  |  0 | 1  | 0  | 0  | 1  | 1  |  1 |

  Decimal Value = Î£ b[i] x 2^i 
                = b0 x 2^0 + b1 x 2^1 + b2 x 2^2 + b3 x 2^3 + b4 x 2^4 + b5 x 2^5 + b6 x 2^6 + b7 x 2^7
                = 1  x 2^0 + 1  x 2^1 + 1  x 2^2 + 0  x 2^3 + 0  x 2^4 +  1 x 2^5 + 0  x 2^6 + 1  x 2^7
                = 1  x 1   + 1  x 2   + 1  x 4   + 0  x 8   + 0  x 16  +  1 x 32  + 0  x 64  + 1  x 128
                = 1 + 2 + 4 + 0 + 0 + 32 + 0 + 128
                = 167
#+END_SRC



Decimal / Hexadecimal and Octal Octal table.

| Decimal | Hexadecimal | Binary |  Octal |
| Base 10 |     Base 16 | Base 2 | Base 8 |
|---------+-------------+--------+--------|
|       0 |           0 |   0000 |     00 |
|       1 |           1 |   0001 |     01 |
|       2 |           2 |   0010 |     02 |
|       3 |           3 |   0011 |     03 |
|       4 |           4 |   0100 |     04 |
|       5 |           5 |   0101 |     05 |
|       6 |           6 |   0110 |     06 |
|       7 |           7 |   0111 |     07 |
|       8 |           8 |   1000 |     10 |
|       9 |           9 |   1001 |     11 |
|      10 |           A |   1010 |     12 |
|      11 |           B |   1011 |     13 |
|      12 |           C |   1100 |     14 |
|      13 |           D |   1101 |     15 |
|      14 |           E |   1110 |     16 |
|      15 |           F |   1111 |     17 |
|---------+-------------+--------+--------|

Bits, bytes, .... 

|-----------------+-----------------+-------------+-----------+---------------+--------------|
| Unit            | In bits         | In bytes    | In Kbytes | In Mega Bytes | In Gigabytes |
|-----------------+-----------------+-------------+-----------+---------------+--------------|
| bit             | 1               | -           | -         | -             | -            |
| byte            | 8               | 1           | -         | -             | -            |
| Kbyte (kb)      | 1024 x 8        | 1024        | 1         | -             | -            |
| Mega Byte (MB)  | 1024 x 1024 x 8 | 1024 x 1024 | 1024      | 1             | -            |
| Giga Bytes (GB) | -               | -           | -         | 1024          | -            |
| Tera Bytes      | -               | -           |           | -             | 1024         |
|-----------------+-----------------+-------------+-----------+---------------+--------------|

Numerical Ranges for Unsigned Integers of N bits

|--------+-----+--------------------------------+--------------------+------------------|
| N bits | Min | Max                            | Max in Hexadecimal | Number of values |
|--------+-----+--------------------------------+--------------------+------------------|
|      8 |   0 | 2^8 - 1  = 255                 |             0x00FF |              256 |
|     10 |   0 | 2^10 - 1 = 1023                |             0x03FF |             1024 |
|     12 |   0 | 2^12 - 1 = 4095                |             0x0FFF |             4096 |
|     16 |   0 | 2^15 - 1 = 65535               |             0xFFFF |            65536 |
|     32 |   0 | 2^32 - 1 =~ 1E9 =~ 10 billions |                  - |             2^32 |
|     64 |   0 | 2^64 - 1 =~ 1E19               |                  - |             2^64 |
|--------+-----+--------------------------------+--------------------+------------------|

Numerical Ranges for Signed Integers of N bits

|--------+----------------------+--------------------|
| N bits |                  Min |                Max |
|--------+----------------------+--------------------|
|      8 |                 -127 |                128 |
|     10 |                 -511 |                512 |
|     12 |                -2047 |               2048 |
|     16 |               -32767 |               3768 |
|     32 |          -2147483647 |        +2147483648 |
|     64 | ~ -1E19 = -1 x 10^19 | ~ 1E19 = 1 x 10^19 |
|--------+----------------------+--------------------|

 + min = -(2^{N - 1} - 1)
 + max = 2^{N - 1}


** Quotes 

 + Bjarne Stroustrup, The C++ Programming Language 

#+BEGIN_QUOTE
  There are only two kinds of languages: the ones people complain
  about and the ones nobody uses.
#+END_QUOTE

 + Bjarne Stroustrup -- http://www.stroustrup.com/bs_faq.html#really-say-that

#+BEGIN_QUOTE
 C makes it easy to shoot yourself in the foot; C++ makes it harder,
 but when you do it blows your whole leg off.
#+END_QUOTE

 + Bjarne Stroustrup -- [[https://www.technologyreview.com/s/406923/the-problem-with-programming/][Mit tech review]]

#+BEGIN_QUOTE
   C++ has indeed become too "expert friendly" at a time where the degree
   of effective formal education of the average software developer has
   declined. However, the solution is not to dumb down the programming
   languages but to use a variety of programming languages and educate
   more experts. There has to be languages for those experts to use-- and
   C++ is one of those languages.

   What I did do was to design C++ as first of all a systems programming
   language: I wanted to be able to write device drivers, embedded
   systems, and other code that needed to use hardware directly. Next, I
   wanted C++ to be a good language for designing tools. That required
   flexibility and performance, but also the ability to express elegant
   interfaces. My view was that to do higher-level stuff, to build
   complete applications, you first needed to buy, build, or borrow
   libraries providing appropriate abstractions. Often, when people have
   trouble with C++, the real problem is that they don't have appropriate
   libraries--or that they can't find the libraries that are available.
#+END_QUOTE
