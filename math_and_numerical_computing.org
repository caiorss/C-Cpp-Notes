#+INCLUDE: theme/style.org 
#+TITLE: CPP/C++ Math and Numerical Computing 
#+DESCRIPTION: cpp/c++ stl math numerical methods apis random 
#+STARTUP: content 


* Math and Numerical Computing 
** Numerical Libraries and Headers

All numeric libraries: 
 + https://en.cppreference.com/w/cpp/numeric

Headers: 

 + [[https://en.cppreference.com/w/cpp/header/cmath][<cmath>]] - C++ version of the C-header <math.h>. Contains basic
   trasncedental functions, sin, cos, tan and so on.
   + C++11 Float point classification functions:
     + [[https://en.cppreference.com/w/cpp/numeric/math/isnan][std::isnan]]
     + [[https://en.cppreference.com/w/cpp/numeric/math/isfinite][std::isfinite]]
   + Widely used trasncedental functions: (C++11)
     + [[https://en.cppreference.com/w/cpp/numeric/math/erf][std::erf]] - Error functions, can be used for computing normal
       function.
     + [[https://en.cppreference.com/w/cpp/numeric/math/erfc][std::erfc]] - Complementary error function.
     + [[https://en.cppreference.com/w/cpp/numeric/math/tgamma][std::tgamma]] - Gamma function. 
   + Special math functions: (C++17)
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/assoc_laguerre][std::assoc_laguerre]] - Associated Laguerre polynomials of the
       degree n, order m, and argument x.
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/beta][std::beta]]
     + [[https://en.cppreference.com/w/cpp/numeric/special_math/expint][std::expint]] - Exponential integral.

 + [[https://en.cppreference.com/w/cpp/header/complex][<complex>]] - Complex number library.

 + [[https://en.cppreference.com/w/cpp/header/random][<random>]] - High quality C++11 random generator library. Provides
   lots of distributions and random number engines.

 + [[https://en.cppreference.com/w/cpp/header/limits][<limits>]] - Provides numeric limits of all C++ numeric types. For
   instance, minimum value, maximum value, number of digits, precision
   and episilon values of a given numeric type.

 + [[https://en.cppreference.com/w/cpp/header/ratio][<ratio>]] - Compile-time rational arithmetic library.

 + [[http://www.cplusplus.com/reference/numeric/][<numeric>]] - Numerical "algorithms" or numerical functions for
   processing containers. std::accumulate, std::iner_product,
   std::partial_sum and std::iota.
** Float Points Numerical Limits and IEE754 Parameters

 *Technical Standards for Float Points*

  + IEEE 754:1985 - Standard for Binary Float-Point Arithmetic

  + IEEE 754:1987 - Standard for Radix-Indenpendet Float-Point Arithmetic

  + IEEE 754:2008 - Standard for Floating-Point Arithmetic
    + ISO standard ISO/IEC/IEEE 60559:2011

 *Float Point Types*

|-------------+-----------+------+---+----+-----+-------+----------------------------------------|
| C++ Type    | Name      | Bits | S |  E |   M |     B | Description                            |
|-------------+-----------+------+---+----+-----+-------+----------------------------------------|
| float       | Binary32  |   32 | 1 |  8 |  23 |   127 | IEE754 single precision float point    |
| double      | Binary64  |   64 | 1 | 11 |  52 |  1023 | IEE754 double precision float point    |
| long double | Binary128 |  128 | 1 | 15 | 112 | 32767 | IEE754 quadruple precision float point |
|-------------+-----------+------+---+----+-----+-------+----------------------------------------|

 + S => Sign bits => 0 for positive numbers and 1 for negative numbers.
 + E => Exponent bits
 + M => Mantiassa Bits (aka Fraction or _significand_)
 + B => Exponent Bias

 *Storage Layout*

|------------------+------+---------+------------+-----------|
| Float Point Type | Bits | Sign    | Exponent   | Mantissa  |
|------------------+------+---------+------------+-----------|
| float            |   32 | 1 [31]  | 8  [23-30] | 32 [0-22] |
| double           |   64 | 1 [63]  | 11 [52-62] | 51 [0-51] |
| long double      |  128 | 1 [127] |            |           |

  + 1 [31] - Means that sign bit of the float point is the 31th bit.
  + 8 [23-30] - Means that the exponents bits are are all bits between
    23th and 30th bit (including both sides).

 *Representation of Float Points* 

 + General Format:

#+BEGIN_SRC text
                 Sign    E
   Value :=  (-1)     X R  X Mantissa
#+END_SRC

 + Single Precision (float)
   + Where:
     + S - sign bit - 0 for positive number, 1 for negative
     + E - Exponent bits
     + M - Mantissa bits
     + Radix (base) 2
     + Bias: 127 

#+BEGIN_SRC text 
                 S      (E - 127)
   Value :=  (-1)   X  2         X (1.M)
            -----    ------        ------
            Sign     Exponent     Mantissa 
#+END_SRC

 + Double Precision (double)

#+BEGIN_SRC 
                 S      (E - 1023)
   Value :=  (-1)   X  2         X (1.M)
#+END_SRC


 *Special Values for Single Precision float point number in Hexadecimal* (float type)

|-------------------+----------+--------------|
| Case              |     Case | Bytes Values |
|-------------------+----------+--------------|
| Positive Zero     |     +0.0 |   0x00000000 |
| Negative Zero     |     -0.0 |   0x80000000 |
| Positive Infinity |     +INF |   0x7F800000 |
| Negative Infinity |     -INF |   0xFF800000 |
| Positive NaN      |     +NaN |   0x7FC00000 |
| Negative NaN      |     -NaN |   0xFFC00000 |
|-------------------+----------+--------------|
| Maximum positive  |  3.40E38 |   0x7F7FFFFF |
| Minimum negative  | -3.40E38 |   0xFF7FFFFF |
|-------------------+----------+--------------|


 *Float Point IEEE754 Parameters and Constants* 

 + Header: [[https://en.cppreference.com/w/cpp/header/limits][<limits>]]

#+CAPTION: C++ Float Point Parameters and Special Values in header <limits> 
|-----------------------------------------+------------------------------------------------------------------------|
| Constant                                | Description                                                            |
|-----------------------------------------+------------------------------------------------------------------------|
|                                         |                                                                        |
| std::numeric_limits<T>::max()           | Maximum absolute value that a float can represent.                     |
| std::numeric_limits<T>::min()           | Minimum absolute value that a float can represent.                     |
| std::numeric_limits<T>::lowest()        | Minimum negative value that a float can represent.                     |
|                                         |                                                                        |
| std::numeric_limits<T>::epsilon()       | Machine epsilon - maximum difference between two representable values. |
| std::numeric_limits<T>::quiet_NaN()     | *NaN* - _Not a Number_ float point value                                   |
| std::numeric_limits<T>::signaling_NaN() | *NaN* - _Not a Number_ float point value                                   |
| std::numeric_limits<T>::infinity()      | *inf* - Maximum positive infinity                                        |
| -std::numeric_limits<T>::infinity()     | *-inf* - Miminum negative infinity                                       |
|                                         |                                                                        |
|-----------------------------------------+------------------------------------------------------------------------|

Notes: 

  + eps _(epsilon)_ is defined as the positive number x, such that x +
    1.0 is not equal to 1.0. Two numbers X and Y, cannot be
    distinguished if ||X - Y|| < eps.

  + The *eps* is the highest precision or the smallest tolerance tha any
    numerical algorithm or numerical method implementation can
    achieve.

  + *NaN* is a special float error value indicating that the value
    cannot be represented. Any computation with NaN yields a NaN that
    is propagated to all other computations. This value is returned
    from operations such as dividing zero by zero, taking a square
    root of a negative number ... and so on. 

 *Examples in CERN's Root REPL - Float point parameters.*

EPS (Epsilon) value for several float point types. 

#+BEGIN_SRC cpp 
  // IEEE754 - Float Point - 32 bits - single precision 
  >> std::numeric_limits<float>::epsilon()
  (float) 1.19209e-07f

  // IEEE754 - Float Point - 64 bits - double precision 
  >> std::numeric_limits<double>::epsilon()
  (double) 2.2204460e-16

  // IEE754 - Float point 128 bits - quadruple precision 
  >> std::numeric_limits<long double>::epsilon()
  (long double) 1.0842022e-19L
#+END_SRC

Testing float point equality machine precision *EPS* - epsilon. 

#+BEGIN_SRC cpp 
  // Machine precison. 
  >> constexpr auto eps = std::numeric_limits<double>::epsilon()
  (const double) 2.2204460e-16

  >> 10.0 == 10.0
  (bool) true

  // Two numbers are almost equal if their difference is less than or equal than the 
  // EPS - epsilon or the machine precison. 
  >> 10.0 == 10.0 + eps
  (bool) true
  >> 

  // =======>>> Double - 64 bits float point <<================

  >> 10.0 == 10.000000000000001
  (bool) false

  >> .000000000000001 < std::numeric_limits<double>::epsilon()
  (bool) false

  // Cannot distinguish 10.0 and 10.00000000000000001 since the difference 
  // between them is less than the EPSILON for double precision float points.
  >> 10.0 == 10.00000000000000001
  (bool) true

  >> .00000000000000001 < std::numeric_limits<double>::epsilon()
  (bool) true
  >> 
  >> .00000000000000001 < eps
 (bool) true

  // =======>>> float - 32 bits float point <<================ 

  >> 10.0f == 10.000001f
  (bool) false

  >> 0.000001f < std::numeric_limits<float>::epsilon()
  (bool) false

  // No longer can distinguish 10.0f and 10.0000001f since 
  // the difference between them is less than EPSILON for float points. 
  >> 10.0f == 10.0000001f
  (bool) true
  
  >> .0000001f < std::numeric_limits<float>::epsilon()
  (bool) true

#+END_SRC

Float Point Equality is Misleading: 

#+BEGIN_SRC cpp 
  >> 0.1 + 0.1 + 0.1 == 0.3
  (bool) false

  >> 0.2 + 0.1 == 0.3
  (bool) false

  >> 1.0 / 3.0
  (double) 0.33333333
  >> 
  >> 1.0 / 3.0 == 0.333333333
  (bool) false
  >
#+END_SRC

  *Testing NaN constant - Not a Number*

Alias values: 

#+BEGIN_SRC cpp 
  // Machine precison. - EPISILON 
  >> constexpr auto eps = std::numeric_limits<double>::epsilon()
  (const double) 2.2204460e-16

  // NAN - Not A Number 
  >> auto dnan = std::numeric_limits<double>::quiet_NaN()
  (double) nan

  // Positive Infinity 
  >> constexpr auto pinf = std::numeric_limits<double>::infinity()
  (const double) inf

  // Negative Infinity 
  >> constexpr auto ninf = -std::numeric_limits<double>::infinity()
  (const double) -inf
#+END_SRC

NaN propagation: Any operation with a NaN yields a NaN.

#+BEGIN_SRC cpp 
  >> q = sqrt(-10)
  (double) -nan

  // Division of zero by zero 
  >> x = 0.0 / 0.0
  (double) nan

  >> q + 10.0
  (double) nan

  >> q - ninf
  (double) nan

  >> q + ninf
  (double) nan
#+END_SRC

Equality comparison between any float point number and itself
evaluates to true while equality between NaNs evaluates to false.  

#+BEGIN_SRC cpp 
  >> 0.0 == 0.0
  (bool) true
  >> 

  >> 10.0 == 10.0
  (bool) true

  >> 9.81451654 == 9.81451654
  (bool) true

  >> dnan == dnan
  (bool) false
#+END_SRC

If-else statement: 

#+BEGIN_SRC cpp 
  >> xx = dnan;

  >> double xx = 10.0;
  >> if(xx) { std::puts(" [TRUE]"); } else { std::puts(" [FALSE] "); }
   [TRUE]

  >> xx = -100.0;
  >> if(xx) { std::puts(" [TRUE]"); } else { std::puts(" [FALSE] "); }
   [TRUE]

  // Set to Zero 
  >> xx = 0.0;
  >> if(xx) { std::puts(" [TRUE]"); } else { std::puts(" [FALSE] "); }
   [FALSE] 

  // Set to NAN 
  >> xx = std::numeric_limits<double>::quiet_NaN();
  >> if(xx) { std::puts(" [TRUE]"); } else { std::puts(" [FALSE] "); }
   [TRUE]

#+END_SRC


 *Testing float point limits:*

#+BEGIN_SRC cpp 
   >> double x;

   >> x = std::numeric_limits<double>::infinity()
   (double) inf

   >> x = -std::numeric_limits<double>::infinity()
   (double) -inf

   >> x = std::numeric_limits<double>::quiet_NaN()
   (double) nan
   >> 

   >> x = std::numeric_limits<double>::signaling_NaN()
   (double)

   >>  x = std::numeric_limits<double>::max()
   (double) 1.7976931e+308

   >>  x = std::numeric_limits<double>::min()
   (double) 2.2250739e-308

   >> x = std::numeric_limits<double>::lowest()
   (double) -1.7976931e+308

   >> x = std::numeric_limits<double>::epsilon()
   (double) 2.2204460e-16

   >> float fx = std::numeric_limits<float>::epsilon()
   (float) 1.19209e-07f

   >> std::numeric_limits<long double>::epsilon()
   (long double) 1.0842022e-19L
   >> 
#+END_SRC

** Functions for inspecting float points
*** Equality of Float Points

Equality based on absolute error:
  + Two float points are almost equal under a given tolerance when the
    relative error is smaller than the tolerance.

#+BEGIN_SRC text
  abs(x - y)  < tolerance
#+END_SRC

Equality based on relative error (Better):

#+BEGIN_SRC text
    abs(x - y)  < tolerance
    -----------
      abs(x)

   Or:

      abs(x - y)  < tolerance x abs(x)
#+END_SRC

Or:

#+BEGIN_SRC text
     abs(x - y)  < tolerance x max(abs(x), abs(y))

  OR
     abs(x - y)  < tolerance x (abs(x) + abs(y)) / 2.0
#+END_SRC

 *C++ Implementations*

Equality based on absolute error:

#+BEGIN_SRC cpp
  /** Checks whether two floats X and Y are almost equal under given tolerance
    ,* Requires headers: <cmath> and <limits>
    ,* @tparam T - Any float point type (float, double, long double)
    ,*/
  template<typename T>
  auto aeq_abs(T x, T y, T tol) -> bool
  {
      constexpr auto eps = std::numeric_limits<T>::epsilon();
      // Tolerance can never be smaller than the Epsilon for this
      tol = std::max(tol, eps);
      // Missing: handle the case if X and/or Y are NaN
      return std::fabs(x - y) < tol;
  }
#+END_SRC

Equality based on relative error:
 + Note: It can be misleading for very small numbers.

#+BEGIN_SRC cpp
  template<typename T>
  auto aeq_rel(T x, T y, T tol) -> bool
  {
      constexpr auto eps = std::numeric_limits<T>::epsilon();
      // Tolerance can never be smaller than the Epsilon for this
      tol = std::max(tol, eps);
      // Missing: handle the case if X and/or Y are NaN
      return std::fabs(x - y) < tol * std::max(std::fabs(x), std::fabs(y)) ;
  }
#+END_SRC

Equality based on relative error with tolerance given as number of
digits:

#+BEGIN_SRC cpp
  template<typename T>
  auto aeq_rel_digits(T x, T y, unsigned int digits = 0) -> bool
  {
      static T precisions [] = { 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9 };
      T tol;
      if(digits == 0)
          tol = std::numeric_limits<T>::epsilon();
      else
          tol = precisions[digits - 1];
      // Missing: handle the case if X and/or Y are NaN
      return std::fabs(x - y) < tol * std::max(std::fabs(x), std::fabs(y)) ;
  }
#+END_SRC

 *Testing:*

#+BEGIN_SRC cpp
  std::cout << std::boolalpha;

  // 3 digits precision
  std::cout << " ==>> [A] 1 / 3 == 0.3333 ? =: " << aeq_abs(1.0 / 3.0, 0.333, 0.001) << std::endl;
  // 4 digits precision
  std::cout << " ==>> [A] PI = 3.1415 ? =: " << aeq_abs(M_PI, 3.1415, 1E-4) << std::endl;

  // 3 digits precision
  std::cout << " ==>> [B] 1 / 3 == 0.3333 ? =: "
            << aeq_rel_digits(1.0 / 3.0, 0.333333, 4) << std::endl;


  std::cout << " ==>> [B] PI = 3.1415 ? =: "
            << aeq_rel_digits(M_PI, 3.141, 3) << std::endl;

  // Expect false
  std::cout << " ==>> [B] PI = 3.1415 ? =: "
            << aeq_rel_digits(M_PI, 3.141, 4) << std::endl;
#+END_SRC

Output:

#+BEGIN_SRC text
   ==>> [A] 1 / 3 == 0.3333 ? =: true
   ==>> [A] PI = 3.1415 ? =: true
   ==>> [B] 1 / 3 == 0.3333 ? =: true
   ==>> [B] PI = 3.1415 ? =: true
   ==>> [B] PI = 3.1415 ? =: false
#+END_SRC

*** Check if float is Finite, NaN or Infinity

 *Check if float point* is *NaN* - Not-a-Number.

 + std::isnan

#+BEGIN_SRC cpp
  >> float x = 4.5;
  >>
  >> std::isnan(x)
  (bool) false
  >>
  >> x = 4.0 / 0.0
  (float) inff
  >>
  >> std::isnan(x)
  (bool) false
  >>
  >> x = std::sqrt(-1.0)
  (float) -nanf
  >>
  >> std::isnan(x)
  (bool) true
  >>
  >> x = 0.0 / 0.0
  (float) nanf
  >>
  >> std::isnan(x)
  (bool) true
#+END_SRC

 *Check whether float point is finite*

 + std::isfinite

#+BEGIN_SRC cpp
  >> double q = 10.0
  (double) 10.000000
  >> std::isfinite(q)
  (bool) true

  >> q = 0.0 / 0.0
  (double) nan
  >> std::isfinite(q)
  (bool) false

  >> q = 1.0 / 0.0
  (double) inf
  >> std::isfinite(q)
  (bool) false

  >> q = -1.0 / 0.0
  (double) -inf
  >> std::isfinite(q)
  (bool) false
#+END_SRC
** Float Point Numerical Constants

Notes: Those constants are defined at the header <cmath>

 *Numerical Constants in Header CMath* 

 + [[https://en.cppreference.com/w/cpp/header/cmath][<cmath>]]

#+CAPTION: C++ Numerical constants in header <cmath> 
|------------------------+-----------+----------------------------------------------|
| Constant               |     Value | Description                                  |
|------------------------+-----------+----------------------------------------------|
| *General Math Constants* |           |                                              |
| ~M_E~                    | 2.7182818 | Euler's number or exp(1)                     |
| ~M_LN2~                  | 0.6931472 | Natural logarithm of 2 or log(2)             |
| ~M_LN10~                 | 2.3025851 | Natural logarithm of 10 or log(10)           |
|                        |           |                                              |
| ~M_LOG10E~               | 0.4342945 | Log of E (Euler's number) at base 10         |
| ~M_LOG2E~                | 1.4426950 | Log of E (Euler's number) at base 2          |
|                        |           |                                              |
| ~M_SQRT2~                | 1.4142136 | Square root of 2 or sqrt(2)                  |
| ~M_SQRT1_2~              | 0.7071068 | Square root of 1/2 or sqrt(1/2) or 1/sqrt(2) |
|                        |           |                                              |
| ~M_PI~                   | 3.1415927 | PI number                                    |
| ~M_PI_2~                 | 1.5707963 | PI/2                                         |
| ~M_PI_4~                 | 0.7853982 | PI/3                                         |
| ~M_1_PI~                 | 0.3183099 | 1/PI                                         |
| ~M_2_PI~                 | 0.6366197 | 2/PI                                         |
| ~M_2_SQRTPI~             | 1.1283792 | 2/sqrt(PI)                                   |
|                        |           |                                              |
|                        |           |                                              |
|------------------------+-----------+----------------------------------------------|


 *Example in CERN's Root REPL - Math Constants*

#+BEGIN_SRC cpp 
  #include <cmath>
 
  >> M_PI
  (double) 3.1415927

  >> sin(M_PI)
  (double) 1.2246468e-16

  >> cos(M_PI)
  (double) -1.0000000

  >> cos(M_PI_2)
  (double) 6.1232340e-17

  >> sin(M_PI_2)
  (double) 1.0000000
  >> 
#+END_SRC

See: 

 + P0631R2 Math Constants - Document P0631R2 - *Math Constants* -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0631r2.pdf>
 + [[https://en.cppreference.com/w/cpp/numeric/math/INFINITY][INFINITY - cppreference.com]]
 + [[https://en.cppreference.com/w/cpp/numeric/math/NAN][NAN -   cppreference.com]]

** C++11 Random Number Library 
*** Overview 

C++11 provides a safer, more convenient and useful random number
facilities than the old C-API rand() that fits many different domains
such as numerical simulations, games, quizzes, password generation,
security and so on. 

 + Header: [[https://en.cppreference.com/w/cpp/numeric/random][<random>]]
 + Predecessor: [[https://www.boost.org/doc/libs/1_70_0/doc/html/boost_random.html][Boost.Random]] 

 + Advatanges over the old C-API rand():
   + Safer and Stronger 
   + More user control
   + Multiple random number engines
   + Many probability distributions


Note:

 + The C++11 random numbers' API is not object oriented, there is no
   class hierarchy. The library is *generic* and uses lots of *C++'s
   generic programming* (template meta programming) features. This
   design choice allows the library to be header-only and to be reused
   for many different types without virtual-function calls overhead.

 *Uses of Random Numbers* 

 + Many Science, Physics and Engineering fields:
   + Monte-Carlo Simulations
   + Brownian Motion Simulation
   + Simulation of noises and disturbances 
   + SDE 

 + Cryptography
   + Password generation
   + Generation of keys 

 + Games and RPG Role Play Games

 + Shuffling 

 + Lottery 

 *C++11 Random Number System:*

The random number API has three parts, a seed generator, a pseudo-random
number engine and a probability distribution. 

 + *seed* - Initial state of a pseudo-random number generator, a big
   random integer.  

 + *seed generator:* A non-deterministic random number generator that
   yields new seed random whenever it is invoked. Its purpose is to
   initialize the random engine.

 + *pseudo-random generator engine*: Generates a reproducible sequence
   of big integers that are fed to a probability distribution. A
   pseudo-random generator always yields the same numerical sequence
   for the same *seed* or initial state, therefore, in order to make the
   generator really random, it is necessary to initialize it with a
   different seed during the program initialization. While the
   deterministic feature of the random engines may look like a
   disadvantange, they are useful for testing and reproducibility of
   results, simulations and experiments. For instance, by using the
   same seed and engine, it is possible to reproduce and test the
   results of monte-carlo numerical simulation.
   + Note: The engines are deterministic, but can be made
     non-deterministic by changing the seed during the
     initialization. 

 + *probability distribution*: A probability distribution object takes
   the generator output, a big number, and returns a random number
   specified by the distribution.

Some Engines: 

| Library Class                      | Description                                                                |
|------------------------------------+----------------------------------------------------------------------------|
| *Seed Generator*                     |                                                                            |
|------------------------------------+----------------------------------------------------------------------------|
| [[https://en.cppreference.com/w/cpp/numeric/random/random_device][std::random_device]]                 | Generates a seed, aka non-deterministic random number.                     |
|                                    |                                                                            |
| *Random Generator Engines*           |                                                                            |
|------------------------------------+----------------------------------------------------------------------------|
| std::default_random_engine         | Default engine, the algorithm used is implementation defined.              |
| std::mt19937                       | 32-bit Mersenne Twister by Matsumoto and Nishimura, 1998                   |
| std::mt19937_64                    | 64-bit Mersenne Twister by Matsumoto and Nishimura, 2000                   |
| std::minstd_rand0                  | Linear Congruential                                                        |
| std::minstd_rand                   | Linear Congruential                                                        |
| std::ranlux48                      |                                                                            |
| std::knuth_b                       |                                                                            |
|                                    |                                                                            |
| *Probability Distributions*          |                                                                            |
|------------------------------------+----------------------------------------------------------------------------|
| [[https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution][std::uniform_int_distribution]]      | Generates uniformly distributed integers in the interval [a, b]            |
| [[https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution][std::uniform_real_distribution<T>]]  | Generates uniformly distributed float point numbers.                       |
|                                    |                                                                            |
| [[https://en.cppreference.com/w/cpp/numeric/random/normal_distribution][std::normal_distribution]]           | Yields normally distributed numbers with some mean and standard deviation. |
| [[https://en.cppreference.com/w/cpp/numeric/random/lognormal_distribution][std::lognormal_distribution]]        | Variant of the normal distribution.                                        |
|                                    | -                                                                          |
| bernouli_distributions<T>          | -                                                                          |
| binomial_distribution<T>           | -                                                                          |
| negative_binonmial_distribution<T> | -                                                                          |
| geometric_distribution<T>          | -                                                                          |
|------------------------------------+----------------------------------------------------------------------------|

 *Further Reading*

 + [[https://en.wikipedia.org/wiki/Applications_of_randomness][Applications of randomness]]

 + [[https://en.wikipedia.org/wiki/Pseudorandom_number_generator][Pseudorandom number generator]]

 + [[http://www0.cs.ucl.ac.uk/staff/d.jones/GoodPracticeRNG.pdf][Good Practice in (Pseudo) Random Number Generation for Bioinformatics Applications]]

 + [[https://softwareengineering.stackexchange.com/questions/147134/how-should-i-test-randomness][testing - How should I test randomness? - Software Engineering Stack Exchange]]

 + [[http://blog.jessitron.com/2013/08/a-trick-for-deterministic-testing-of.html][Abstractivate: A trick for deterministic testing of random behavior]]

 *Reproducibility in Science and Research* 

 + [[https://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970][1,500 scientists lift the lid on reproducibility : Nature News & Comment]]

 + [[https://reproduciblescience.org/][Reproducible Science]]

 + [[http://rescience.github.io/][Reproducible Science is good. Replicated Science is better.]]

 + [[https://www.natureindex.com/news-blog/when-it-comes-to-reproducible-science-git-is-code-for-success][When it comes to reproducible science, Git is code for success | Nature Index]]

 + [[https://towardsdatascience.com/data-sciences-reproducibility-crisis-b87792d88513][Data Science's Reproducibility Crisis â€“ Towards Data Science]]

 + [[https://www.codeproject.com/Articles/1083372/Random-Number-Generator-Recommendations-for-Applic][Random Number Generator Recommendations for Applications - CodeProject]]

*** Basic Examples 

 *Example in CERN's ROOT REPL:*

 + Example 1: The function generate_randoms1 fails to generate a
   random sequence as whenever the function is called, it generates
   the same sequence of numbers because the seed was not set.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <random>

  void generate_randoms1(size_t n){
       // Create default initialized engine object 
       std::default_random_engine engine{};
       // Generates uniformily distributed integers from 1 to 10, 
       // including both bounds of the interval.  
       std::uniform_int_distribution<int> dist(1, 10); 
       for(auto i = 0; i < n; i++)
         std::cout << " x[" << i << "] = " << dist(engine) << std::endl;
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> generate_randoms1(4)
   x[0] = 1
   x[1] = 2
   x[2] = 8
   x[3] = 5

  >> generate_randoms1(4)
   x[0] = 1
   x[1] = 2
   x[2] = 8
   x[3] = 5

  >> generate_randoms1(6)
   x[0] = 1
   x[1] = 2
   x[2] = 8
   x[3] = 5
   x[4] = 6
   x[5] = 3 

  >> generate_randoms1(10)
   x[0] = 1
   x[1] = 2
   x[2] = 8
   x[3] = 5
   x[4] = 6
   x[5] = 3
   x[6] = 1
   x[7] = 7
   x[8] = 7
   x[9] = 10
#+END_SRC

 + Example 2: The function generate_randoms2, generates quasi-random
   numbers whenever the seed is changed, if it is kept unchanged, the
   distribution and engine will always generate the same results. 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <random>

  void generate_randoms2(size_t n, unsigned int seed){
       // Create default initialized engine object 
       std::default_random_engine engine{seed};
       // Generates uniformily distributed integers from 1 to 10, 
       // including both bounds of the interval.  
       std::uniform_int_distribution<int> dist(1, 10); 
       for(auto i = 0; i < n; i++)
         std::cout << " x[" << i << "] = " << dist(engine) << std::endl;
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  // Generates a new seed whenever it is called 
  std::random_device seed_gen{};

  // A seed is a big integer used for initializing the generator 
  >> seed_gen()
  (unsigned int) 4133644392

  >> seed_gen()
  (unsigned int) 2900292039

  // Save current seed 
  >> auto seed = seed_gen()
  (unsigned int) 2616205616

  >> generate_randoms2(5, seed)
   x[0] = 4
   x[1] = 1
   x[2] = 5
   x[3] = 10
   x[4] = 6
  >> 
  >> generate_randoms2(6, seed)
   x[0] = 4
   x[1] = 1
   x[2] = 5
   x[3] = 10
   x[4] = 6
   x[5] = 10

  >> generate_randoms2(10, seed)
   x[0] = 4
   x[1] = 1
   x[2] = 5
   x[3] = 10
   x[4] = 6
   x[5] = 10
   x[6] = 2
   x[7] = 8
   x[8] = 9
   x[9] = 6
  >> 
#+END_SRC

Changing the seed: 

#+BEGIN_SRC cpp 
  >> auto seed2 = seed_gen()
  (unsigned int) 3091314163


  >> generate_randoms2(4, seed2)
   x[0] = 8
   x[1] = 5
   x[2] = 2
   x[3] = 7

  >> generate_randoms2(8, seed2)
   x[0] = 8
   x[1] = 5
   x[2] = 2
   x[3] = 7
   x[4] = 6
   x[5] = 9
   x[6] = 4
   x[7] = 1
#+END_SRC

Making the sequence "really" random:

#+BEGIN_SRC cpp 
  >> generate_randoms2(5, seed_gen())
   x[0] = 1
   x[1] = 9
   x[2] = 8
   x[3] = 10
   x[4] = 2

  >> generate_randoms2(5, seed_gen())
   x[0] = 5
   x[1] = 6
   x[2] = 7
   x[3] = 8
   x[4] = 4

  >> generate_randoms2(5, seed_gen())
   x[0] = 3
   x[1] = 4
   x[2] = 1
   x[3] = 8
   x[4] = 8
#+END_SRC

*** Example - Normally Distributed Randoms 

The following sample code generates N normally distributed random
numbers with mean 10.0 and standard deviation 5 in three different
ways: first with seed not set; then with seed set by used and third
with seed generated automatically. 

 + File: *randoms1.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <random> 
  #include <vector> 
  #include <string> 
  #include <functional>

  int main(int argc, char** argv)
  {		
      if(argc < 3)
      {
          std::cout << "Error: option provided. Try again!" << std::endl;
          return EXIT_FAILURE;		
      }	

      size_t quantity = std::stoi(argv[1]);
      std::string command = argv[2];

      // Subprogram 1 - Run without any provided seed 
      if(command == "-empty")
      {
          std::cout << " [INFO] Running without setting the generator's seed" << std::endl;		
          // Random number engine 
          std::default_random_engine rngen{};
          // mean = 10.0, stdev = 5.0 
          std::normal_distribution<double> ndist(10.0, 5.0);
          for(auto i = 0; i < quantity; i++)
              std::cout << "Next random is = " << ndist(rngen) << std::endl;
          return EXIT_SUCCESS;
      }
      // Subprogram 2 - User provides the seed 
      if(command == "-seed")
      {
          if(argc < 4){
                  std::cout << "Error: missing seed. " << std::endl;
                  return EXIT_FAILURE;
          }
          auto seed = std::atol(argv[3]);
          std::cout << " [INFO] Using seed = " << seed << std::endl;

          // Random number engine 
          std::default_random_engine rngen{seed};
          // mean = 10.0, stdev = 5.0 
          std::normal_distribution<double> ndist(10.0, 5.0);
          for(auto i = 0; i < quantity; i++)
             std::cout << "Next random is = " << ndist(rngen) << std::endl;				
      }
      // Subprogram 2  - Automatically generates a seed 
      if(command == "-auto")
      {
          // Object that generates seed (initial state of random generator)
          std::random_device seed_gen;

          // Get a seed (big random integer) used for initializing the random generator. 
          auto seed = seed_gen();	
          std::cout << "seed = " <<  seed << std::endl;

          // Random number engine 
          std::default_random_engine rngen{seed};
          // mean = 10.0, stdev = 5.0 
          std::normal_distribution<double> ndist(10.0, 5.0);
          for(auto i = 0; i < quantity; i++)
             std::cout << "Next random is = " << ndist(rngen) << std::endl;				
      }		

      return 0;
  }

#+END_SRC

Compiling: 

#+BEGIN_SRC sh  
  # Using Clang 
  $ clang++ randoms1.cpp -o randoms1.bin -std=c++1z -g -O0 -Wall 

  # Using GCC
  $ gcc++ randoms1.cpp -o randoms1.bin -std=c++1z -g -O0 -Wall 
#+END_SRC

 + *Experiment 1:* Running command *empty* => generates N normally
   distributed numbers with mean 4 and standard deviation 10 without
   setting the engine rngen's seed, aka initial state. 

#+BEGIN_SRC text 
  # Fails! 

  $ ./randoms1.bin 5 -empty
   [INFO] Running without setting the generator's seed
  Next random is = 9.39017
  Next random is = 4.56591
  Next random is = 13.4214
  Next random is = 4.62405
  Next random is = 10.1663


  $ ./randoms1.bin 5 -empty
   [INFO] Running without setting the generator's seed
  Next random is = 9.39017
  Next random is = 4.56591
  Next random is = 13.4214
  Next random is = 4.62405
  Next random is = 10.1663
  (base) 

  $ ./randoms1.bin 8 -empty
   [INFO] Running without setting the generator's seed
  Next random is = 9.39017
  Next random is = 4.56591
  Next random is = 13.4214
  Next random is = 4.62405
  Next random is = 10.1663
  Next random is = 13.7242
  Next random is = 10.168
  Next random is = 7.36681
#+END_SRC

 + *Experiment 2:* Running command *auto* => generate N random numbers
   with same features, but with a seed generated automatically by the
   object _seed_gen_ with type random_device. 

Simulation run A:

#+BEGIN_SRC text 
  $ ./randoms1.bin 4 -auto
  seed = 2138866676
  Next random is = 6.58512
  Next random is = 11.7181
  Next random is = 9.55006
  Next random is = 7.35961
#+END_SRC

Simulation run B: 

#+BEGIN_SRC text 
  $ ./randoms1.bin 8 -auto
  seed = 4200712391
  Next random is = 0.575461
  Next random is = 11.82
  Next random is = 6.07653
  Next random is = 13.8118
  Next random is = 11.0999
  Next random is = 7.04851
  Next random is = 7.56055
  Next random is = 3.67443
#+END_SRC

Simulation run C:

#+BEGIN_SRC text 
  $ ./randoms1.bin 3 -auto
  seed = 1536173647
  Next random is = 13.4482
  Next random is = 12.2431
  Next random is = 12.2183
#+END_SRC

 + *Experiment 3:* The results of the simulation runs of experiment 2
   can be reproduced by reusing the seed with command *-seed*.

Reproduce simulation run A: 

#+BEGIN_SRC cpp 
  $ ./randoms1.bin 4 -seed 2138866676
   [INFO] Using seed = 2138866676
  Next random is = 6.58512
  Next random is = 11.7181
  Next random is = 9.55006
  Next random is = 7.35961

  $ ./randoms1.bin 8 -seed 2138866676
   [INFO] Using seed = 2138866676
  Next random is = 6.58512
  Next random is = 11.7181
  Next random is = 9.55006
  Next random is = 7.35961
  Next random is = 3.621
  Next random is = 8.41599
  Next random is = 11.3628
  Next random is = 8.27506
#+END_SRC

Reproduce simulation run B:

#+BEGIN_SRC cpp 
  $ ./randoms1.bin 8 -seed 4200712391
   [INFO] Using seed = 4200712391
  Next random is = 0.575461
  Next random is = 11.82
  Next random is = 6.07653
  Next random is = 13.8118
  Next random is = 11.0999
  Next random is = 7.04851
  Next random is = 7.56055
  Next random is = 3.67443
#+END_SRC

*** Example - Class encapsulating uniform random distribution 

Source: 
 + File: [[file:src/math/RandInt.cpp][file:src/math/RandInt.cpp]]
 + Online Compile: https://rextester.com/PNY72010

Headers: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <random>
  #include <iomanip>
  #include <string>
#+END_SRC

Class RndInt => Class for generating random numbers between an integer
interval including both bounds in a simplified way similar to the old
C's rand() API: 

#+BEGIN_SRC cpp 
  template<typename TInt = int>
  class RandInt {
  private:
      std::random_device                 m_nextSeed;	
      unsigned int                       m_seed;
      std::default_random_engine         m_engine;
      std::uniform_int_distribution<int> m_dist;
  public:
       using TSeed = long;

       // Intialize with a known seed 
       RandInt(TInt min, TInt max, unsigned int seed)
        : m_seed(seed), m_engine(seed), m_dist(min, max)
       {		
       }

       // Initialize with a random seed 
       RandInt(TInt min, TInt max)
         : m_nextSeed{},
           m_seed(m_nextSeed()),
           m_engine(m_seed),
           m_dist(min, max)
       {		
       }
       TInt  Min()  const { return m_dist.min(); }
       TInt  Max()  const { return m_dist.max(); }
       TSeed Seed() const { return m_seed; }
       void  Seed(TSeed seed)
       {
            m_seed = seed;
            m_engine.seed(seed);
       }
       // Set seed to a new random (non-deterministic) value and return it 
       TSeed NextSeed()
       {
            m_seed = m_nextSeed();
            m_engine.seed(m_seed);
            return m_seed;
       }
       // Get NExt random 
       TInt operator()()
       {
            return m_dist(m_engine);
       }
  };
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
  std::cout << "\n ===== Random numbers with a random seed ===="
                    << std::endl;
  {
       RandInt rnd(1, 10);
       std::cout << " => rnd.Seed() = " << rnd.Seed() << std::endl;
       std::cout << " => rnd.Min() = "  << rnd.Min() << std::endl;
       std::cout << " => rnd.Max() = "  << rnd.Max() << std::endl;

       for(int i = 0; i < 15; i++){
           auto field = std::string(" x[") + std::to_string(i) + "] = "; 
           std::cout << std::setw(10)
                     << field
                     << std::setw(5) << rnd() << std::endl;
       }		
  }	

  std::cout << "\n ===== Random numbers with a non-random seed ===="
            << std::endl;
  {
       // Initialize Random generator object with known and fixed
       // seed to reproduce computation results. 
       long seed = 1195785783;
       RandInt rnd(1, 10, seed);
       std::cout << " => rnd.Seed() = " << rnd.Seed() << std::endl;
       std::cout << " => rnd.Min() = "  << rnd.Min() << std::endl;
       std::cout << " => rnd.Max() = "  << rnd.Max() << std::endl;

       /* Expected sequence: 7, 10, 9, 2, 2, 1, 3, 1, 6, 5, 1, 2, 3, 2 ... */ 
       for(int i = 0; i < 15; i++){
               auto field = std::string(" x[") + std::to_string(i) + "] = "; 
               std::cout << std::setw(10)
                         << field
                         << std::setw(5) << rnd() << std::endl;
       }		
  }	

  return 0;
#+END_SRC

Compilation: 

#+BEGIN_SRC sh 
 $ g++ RandInt.cpp -o RandInt.bin -std=c++1z -g -O0 -Wall 
 $ clang++ RandInt.cpp -o RandInt.bin -std=c++1z -g -O0 -Wall
#+END_SRC

Sample program outpu: 

#+BEGIN_SRC sh 
  $ clang++ RandInt.cpp -o RandInt.bin -std=c++1z -g -O0 -Wall && ./RandInt.bin

   ===== Random numbers with a random seed ====
   => rnd.Seed() = 2611535369
   => rnd.Min() = 1
   => rnd.Max() = 10
     x[0] =     9
     x[1] =     1
     x[2] =    10
     x[3] =     6
     x[4] =    10
     x[5] =     5
     x[6] =     2
     x[7] =     9
     x[8] =     9
     x[9] =    10
    x[10] =     5
    x[11] =     9
    x[12] =     8
    x[13] =     5
    x[14] =     9

   ===== Random numbers with a non-random seed ====
   => rnd.Seed() = 1195785783
   => rnd.Min() = 1
   => rnd.Max() = 10
     x[0] =     7
     x[1] =    10
     x[2] =     9
     x[3] =     2
     x[4] =     2
     x[5] =     1
     x[6] =     3
     x[7] =     1
     x[8] =     6
     x[9] =     5
    x[10] =     1
    x[11] =     2
    x[12] =     1
    x[13] =     3
    x[14] =     2

#+END_SRC

*** Example - Functional wrapper for random uniform distribution 

The function *make_uniform_random_distribution* returns a lambda object
(anonymous callable object) that generates uniformly distributed
randoms with a given seed. 

Sources: 
 + File:  [[file:src/math/rand_int_fun.cpp][file:src/math/rand_int_fun.cpp]]
 + Online Compiler: https://wandbox.org/permlink/g8C8n7Dq7LwgLoLT

Headers:

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <random>
  #include <iomanip>
  #include <string>
#+END_SRC

 + Function overloading 1 of *make_uniform_random_distribution* -
   Returns a fuction (lambda object) that generates random integers
   with a seed supplied by the calling code.

#+BEGIN_SRC cpp 
  // FUNCTION OVERLOAD 1 
  //-----------------------
  // Note: The return type of this function must not be set to std::function<TInt (void)>
  // or that will have a performance penalty as this container uses type erasure and heap allocation.
  // This function returns lambda or an anonymous callable object, in other words, an object that overloads
  // the operator()(), generated by the compiler.
  template<typename TInt> 
  auto make_uniform_random_distribution(TInt a, TInt b, long seed) 
  {	    
      std::mt19937 engine(seed);
      std::uniform_int_distribution<TInt> dist(a, b);        
      return [=]() mutable -> TInt { return dist(engine); };
  }
#+END_SRC

 + Function overloading 2 of *make_uniform_random_distribution* -
   Returns a "fuction" (lambda object) that generates random integers
   with a random seed.

#+BEGIN_SRC cpp 
  // FUNCTION OVERLOADING 2
  //----------------------------
  template<typename TInt> 
  auto make_uniform_random_distribution(TInt a, TInt b) 
  {
     std::random_device rd;
     return make_uniform_random_distribution(a, b, rd()) ;
  }
#+END_SRC

 + Main Function: 

#+BEGIN_SRC cpp 
  #if 1 
   std::cout << "\n ===== Random numbers with a random seed ===="
             << std::endl;
   {
      auto rnd = make_uniform_random_distribution<int>(1, 10);
      for(int i = 0; i < 15; i++){
          auto field = std::string(" x[") + std::to_string(i) + "] = "; 
          std::cout << std::setw(10)
                    << field
                    << std::setw(5) << rnd() << std::endl;
          }		
   }	
  #endif 

  std::cout << "\n ===== Random numbers with a non-random seed ===="
            << std::endl;
  {
     // Initialize Random generator object with known and fixed
     // seed to reproduce computation results. 
     unsigned int seed = 1195785783;
     auto rnd = make_uniform_random_distribution<int>(1, 10, seed);

     /* Expected sequence: 7, 10, 9, 2, 2, 1, 3, 1, 6, 5, 1, 2, 3, 2 ... */ 
     for(int i = 0; i < 15; i++)
     {
         auto field = std::string(" x[") + std::to_string(i) + "] = "; 
         std::cout << std::setw(10)
                   << field
                   << std::setw(5) << rnd() << std::endl;
      }		
  }	
#+END_SRC

 *Sample Output:* 

Compiling:  

#+BEGIN_SRC sh 
    # Clang LLVM 
    $ clang++ rand_int_fun.cpp -o rand_int_fun.bin -std=c++1z -g -O0 -Wall 
   
    # GCC - GNU C/C++ Compiler 
    $ g++ rand_int_fun.cpp -o rand_int_fun.bin -std=c++1z -g -O0 -Wall 
#+END_SRC

Running: (64 bits processor)

#+BEGIN_SRC sh 
  $ ./rand_int_fun.bin 

   ===== Random numbers with a random seed ====
     x[0] =     8
     x[1] =     4
     x[2] =     4
     x[3] =     7
     x[4] =     9
     x[5] =     2
     x[6] =     2
     x[7] =     6
     x[8] =     3
     x[9] =     8
    x[10] =     3
    x[11] =     1
    x[12] =     3
    x[13] =     1
    x[14] =    10

   ===== Random numbers with a non-random seed ====
     x[0] =     6
     x[1] =    10
     x[2] =     6
     x[3] =     2
     x[4] =     4
     x[5] =     1
     x[6] =     9
     x[7] =    10
     x[8] =     3
     x[9] =     6
    x[10] =    10
    x[11] =     6
    x[12] =     2
    x[13] =     1
    x[14] =     1

#+END_SRC

Second for-loop output in 32 bits processor (x86) or with 32 bits
compiler:  

#+BEGIN_SRC text 
  ===== Random numbers with a non-random seed ====
     x[0] =     3
     x[1] =     6
     x[2] =     1
     x[3] =     5
     x[4] =     4
     x[5] =     7
     x[6] =     2
     x[7] =     6
     x[8] =     7
     x[9] =     4
    x[10] =     8
    x[11] =     7
    x[12] =     2
    x[13] =     1
    x[14] =    10
#+END_SRC




