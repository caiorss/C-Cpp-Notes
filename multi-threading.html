<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-16 Mon 19:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multithreading and concurrency</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Caio Rodrigues Soares - caiorss [DOT] rodrigues [AT] gmail [DOT] COM" />
<meta name="description" content="cpp/c++ thread concurrency std::thread modern cpp c++"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Multithreading and concurrency</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge6bbd2a">1. Multithreading and concurrency</a>
<ul>
<li><a href="#org313666c">1.1. Fundamental Concepts</a></li>
<li><a href="#org3604eab">1.2. Standard Library Reference</a></li>
<li><a href="#orgd74205e">1.3. Class std::thread</a></li>
<li><a href="#org425b233">1.4. Functions of namespace std::this_thread</a></li>
<li><a href="#orgd2600d2">1.5. Thread - std::thread usage and synchronization primtives</a>
<ul>
<li><a href="#orgd44a6f6">1.5.1. Race condition</a></li>
<li><a href="#org92ca64e">1.5.2. Debugging Race Conditions with CLang's Sanitizers</a></li>
<li><a href="#org66fd2f0">1.5.3. Mutex solution</a></li>
<li><a href="#org17f1f71">1.5.4. Atomic variable solution</a></li>
</ul>
</li>
<li><a href="#org0ef0e0a">1.6. Thread - Returning values from std::thread</a>
<ul>
<li><a href="#orgab47ecf">1.6.1. Return value from thread</a></li>
<li><a href="#orgad50eab">1.6.2. Catch exceptions in threads</a></li>
<li><a href="#org8c06cb0">1.6.3. Example: Returning values and catching exceptions</a></li>
</ul>
</li>
<li><a href="#org65c30fe">1.7. Task-based APIs =&gt; Futures and Promises</a>
<ul>
<li><a href="#orgf36892a">1.7.1. Futures overview</a></li>
<li><a href="#orgec380c6">1.7.2. Usage</a></li>
<li><a href="#org8ba4684">1.7.3. Example</a></li>
</ul>
</li>
<li><a href="#org36bbf00">1.8. Condition Variables and Producer Consumer Problem</a></li>
<li><a href="#orgda178ce">1.9. Messaging Passing Concurrency and Message Queue</a>
<ul>
<li><a href="#orgb5237e2">1.9.1. Overview</a></li>
<li><a href="#orgf5c6ae3">1.9.2. Producer/consumer problem with messague queue</a></li>
<li><a href="#orga1b2809">1.9.3. References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge6bbd2a" class="outline-2">
<h2 id="orge6bbd2a"><span class="section-number-2">1</span> Multithreading and concurrency</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org313666c" class="outline-3">
<h3 id="org313666c"><span class="section-number-3">1.1</span> Fundamental Concepts</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>Processes and Threads</b>
</p>

<p>
Processes: 
</p>

<ul class="org-ul">
<li>A process is a running program with its own virtual memory,
address space, unique process identifier ID and context (CPU
registers - IP - Instruction Pointer and SP - Stack Pointer)</li>

<li>A single <span class="underline">CPU core</span> is only capable of executing a single process
at a time. However, users have the illusion that multiple
processes are being run simultaneously because the <span class="underline">operating system's</span>
<span class="underline">scheduler</span> multiplexes the CPU execution time between all
processes. As a result, each process is run sequentially by a
single CPU core during a short <span class="underline">time slice</span> (time sharing). When the
scheduler switches to another process, it saves the <span class="underline">process' state</span>
(current directory, CPU registers, &#x2026;) and loads the state of the
next process (context switching).</li>
</ul>

<p>
Threads: 
</p>

<ul class="org-ul">
<li>A thread is a independent flow of execution or task within a
single process. The purpose of threads is to allow a process to
execute multiple independent simultaneous tasks, such as running
the user interface dispatch thread, handling socket connections,
performing the download in a different thread and so on.</li>

<li>For an operating system, a thread is a <span class="underline">lightweight process</span> or a
stripped down process with its own stack, local data, CPU
registers (specially IP - Instruction Pointer and SP - Stack
Pointer), but without its own address space and virtual memory,
instead it only can access to the virtual memory of the process
that thread belongs to.</li>

<li>Threads are also known as (aka):
<ul class="org-ul">
<li>Lightweight process</li>
<li>Native thread</li>
<li>Kernel-thread</li>
<li>Operating system thread or OS thread</li>
</ul></li>
</ul>

<p>
Benefits of multi-threading:
</p>

<ul class="org-ul">
<li>Increase application responsiviness, specially GUI - Graphical
User Interface Applications.</li>

<li>Take advantage of multi-core processor</li>

<li>Speed up heavy math computations. Multi-threading allows to
split a heavy matrix calculation into multiple threads running
in different CPU cores.</li>

<li>Fewer system resources usage. Using multiple threads for running
multiple tasks is cheaper than running multiple processes for
each task. Note: before multi-threading, it was common in
Unix-like operating system to use the <span class="underline">fork()</span> system call to fork
(copy) the current process for handling client socket
connections in network server appliocations.</li>
</ul>


<p>
Synchronization Primitives
</p>

<ul class="org-ul">
<li>Mutex</li>

<li>Semaphore</li>

<li>Condition variables</li>

<li>Barriers</li>

<li>Atomic variables</li>
</ul>

<p>
Potential Problems of Concurrency and Multi-threading
</p>

<ul class="org-ul">
<li>Race condition, aka data race</li>

<li>Deadlock</li>

<li>Starvation</li>

<li>Oversubscription</li>

<li>Load balancing</li>

<li>Thread exaustion</li>
</ul>

<p>
<b>Low Level Multithreading APIs:</b>
</p>

<p>
Threads and processes require operating system support, therefore
programming languages do not provide threads, they just provide high
level wrapper APIs for calling operating systems' low level APIs. The
most common of those low level APIs are: 
</p>

<ul class="org-ul">
<li><span class="underline">pthread (Posix threads)</span> - POSIX API (C-API)
<ul class="org-ul">
<li>The posix thread API is implemented by most Unix-like operating
systems such Linux, MacOsx, iOS, Android, BSD and some embedded
real time systems such as RTEMS, QNX and VxWorks.</li>
</ul></li>

<li><span class="underline">Windows Win32 Thread API</span>
<ul class="org-ul">
<li>Available only for Windows NT and Windows CE kernels.</li>
</ul></li>
</ul>


<p>
<b>Concurrency X Parallelism</b>
</p>

<ul class="org-ul">
<li><span class="underline">Concurrency</span>

<ul class="org-ul">
<li>=&gt; Multiple threads run sharing resources (shared memory) in the
same process. It is not possible to run them safely without
synchronization promitives, specially locks such as mutexes and
semaphores.</li>

<li>Note: concurrency is possible in a system with just one processor
and one core.</li>

<li>Main purpose: <span class="underline">Increase system responsiviness.</span>
<ul class="org-ul">
<li>Avoid blocking main threads of user interface's event loop by
running a computation with significant delay in a new thread;
handle multiple client requests of a web server in another
thread or in a thread pool and so on..</li>
</ul></li>

<li>Better for:

<ul class="org-ul">
<li>GUI - Graphical User Interfaces, increase responsiviness
avoiding freezing the UI.</li>

<li>Network Servers with lots IO.</li>

<li>Games and computer graphics =&gt; Tasks with long delay that could
block the game loop can be executed in another thread.</li>
</ul></li>
</ul></li>

<li><span class="underline">Parallel Computing</span>

<ul class="org-ul">
<li>=&gt; Multiple threads are running in different processing units
without any communication or shared data. Parallelism  require at
least more than one processing unit, which can be multiple CPU
cores, multiple CPU chips/sockets, multiple computers or a GPU
card.</li>

<li>=&gt; Parallelism is not possible with a single core CPU, it
requires multiple cores or multiple processing units.</li>

<li>=&gt; Parallism is also possible without threads with SIMD CPU
instructions (data parallelism).</li>

<li>=&gt; Better for:
<ul class="org-ul">
<li>HPC - High Performance Computing</li>
<li>Math intensive computation</li>
<li>CPU-bound tasks</li>
<li>Math, Physics, Science and Engineering</li>
</ul></li>

<li>Hardware for Parallel Computing 
<ul class="org-ul">
<li>Multi-core CPUs</li>
<li>Multi processor servers with multi-core CPUs.</li>
<li>GPU</li>
<li>Computer cluster (distributed systems)</li>
</ul></li>

<li>APIs - Application Programming Interfaces for Parallel Computing

<ul class="org-ul">
<li>OpenMP =&gt; Useful for parallelizing existing algorithms and loops.</li>

<li>MPI - Message Passing Interface.</li>

<li>GPU =&gt; Cuda, OpenCL, Sycl &#x2026;</li>

<li>SIMD Libraries</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Computation bottlenecks</b>
</p>

<ul class="org-ul">
<li>IO-bound computations 

<ul class="org-ul">
<li>=&gt; Most of the time of an IO-bound computation is spent waiting,
reading and writing IO. The speed of the task is limited by the
IO speed.</li>

<li>Example: Processing big files, web servers, FTP servers &#x2026;</li>

<li>Solutions:

<ul class="org-ul">
<li>Thread-pools + non-blocking IO based on operating system APIs:
epool (Linux);  Kqueue (BSD and Mac OSX) and IOCP (Windows).
<ul class="org-ul">
<li>Some libraries: Boost ASIO or LibUV used by NodeJS. &#x2026;</li>
</ul></li>

<li>User-space threads (aka fibers, greenthreads or coroutines) +
Non-blocking IO such as <span class="underline">epoll</span> (Linux); <span class="underline">kqueue</span>  (MacOSX and
BSD-variants) and <span class="underline">IOCP</span> on Windows.
<ul class="org-ul">
<li>Some libraries: Boost Asio + Boost Coroutines or C++20 Coroutines.</li>
</ul></li>
</ul></li>
</ul></li>

<li>CPU-bound computations 
<ul class="org-ul">
<li>=&gt; A CPU-bound computations is CPU intensive and its speed is
limited by the CPU speed. As the CPU clock is no longer
increasing as before, the only way to boost performance when no
further optimization is possible is by using multithreading and
parallel programming for taking advantage of multicore CPUs.</li>

<li>Example: Heavy mathematical computation; matrix computations;
linear algebra; solving PDEs partial differential equations;
computer vision &#x2026;</li>

<li>Solutions:
<ul class="org-ul">
<li>Find better algorithms</li>
<li>Select suitable data structures</li>
<li>Cache-friendly data structures</li>
<li>Parallize algorithms for running a chunck on N threads on
different cores. APIs: C++ STL parallel algorithms; Intel TBB;
OpenMP &#x2026;</li>
<li>Use a CPU with more cores or higher clock "if possible".</li>
<li>Use a server with multiple multi-core CPUs.</li>
<li>Use a cluster or distributed computer.</li>
</ul></li>
</ul></li>

<li>IO-bound and CPU-bound.

<ul class="org-ul">
<li>The speed of the task is limited both by CPU speed and time spent
waiting, reading or writing IO.</li>
</ul></li>
</ul>


<p>
<b>Hardware and Multicore</b> 
</p>

<p>
The days where manufacturers would keep increasing the CPU frequency
are over as a technology limit was reached, an increase in the CPU
clock speed, increases the CPU power consumption in a cubic rate,
therefore the CPU heat rises dramatically requiring even more
cooling. The solution found was to design CPU chips with more cores
instead of keep increasing the CPU frequency. However, it crates new
challenges for developers as the only way to boost the performance and
speed of CPU-bound applications is by taking advantage of the
multicore processors which means using multithreading and parallel
programming tehcniques.
</p>

<p>
Terminology:
</p>

<ul class="org-ul">
<li>Physical Processor, aka CPU (Central Processing Unit) or socket
<ul class="org-ul">
<li>=&gt; Chip visible in the computer's motherboard. A single modern
chip can contain multiple processing units inside of it, called
<span class="underline">CPU core</span>. Note: some <span class="underline">server computers</span> may have multiple physical
processors or CPU chips.</li>
</ul></li>

<li>CPU Core and Multicore CPUs 

<ul class="org-ul">
<li>=&gt; A CPU core is a <span class="underline">processing unit</span> or the device that executes
the machine code instructions. Nowadays most processors chips
are <span class="underline">multicore</span>, a single CPU chip contain multiple cores. A CPU
with N cores is capable of executing at least N stream of
instruction simultaneously or at least N <span class="underline">hardware threads</span>.</li>
</ul></li>

<li>Hyper Thread
<ul class="org-ul">
<li>=&gt; <span class="underline">Hyper threading</span> is a Intel's proprietary technology which
allows a single CPU core to run process multiple streams of
instructions as it was multiple processors. In other words, a
single core is capable of running multiple threads in parallel.</li>
</ul></li>

<li>Total number of hardware threads or <span class="underline">logical processors</span>
<ul class="org-ul">
<li>=&gt; NHW = TOTAL NUMBER OF LOGICAL PROCESSORS = TOTAL NUMBER OF THREADS</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-text">NHW = (Number of CPUs) * (Number of Cores per CPU) * ( Number of HW threads per core ) 
</pre>
</div>

<p>
A server computer with 2 physical processors or CPU sockets, 4
processing cores per CPU and 2 threads per core has a total of 
</p>

<ul class="org-ul">
<li>NHW = 2 x 2 x 4 = 16 threads or 16 logical processors</li>
</ul>
</div>
</div>

<div id="outline-container-org3604eab" class="outline-3">
<h3 id="org3604eab"><span class="section-number-3">1.2</span> Standard Library Reference</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>Technical Specifications</b> 
</p>

<ul class="org-ul">
<li>P0159 - Technical Specifiction for Concurrency</li>

<li>P0024 - Technical Specifiction for Parallelism</li>

<li>C++17 Concurrency TS (Technical Specification)</li>
</ul>


<p>
<b>C++11/14 Thread API</b>
</p>

<ul class="org-ul">
<li>std::threads (C++11)</li>
</ul>

<p>
<b>Task Based API</b>
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/promise-class?view=vs-2019">std::promise</a> (Microsoft)</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/future?view=vs-2019">std::future</a> (Microsoft)</li>

<li>std::future&lt;&gt;, std::shared_future&lt;&gt;, std::atomic_future&lt;&gt;</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/packaged-task-class?view=vs-2019">std::packaged_task</a> (Microsft)</li>

<li>std::async</li>

<li>Function: <a href="https://docs.microsoft.com/en-us/cpp/standard-library/future-functions?view=vs-2019">std::async</a> (Microsft)</li>

<li>std::launch</li>
</ul>

<p>
C++17 Additions: 
</p>

<ul class="org-ul">
<li>Concurrent TS (Nonblocking futures (.then), executors, await)</li>
<li>future::when_any</li>
<li>future::when_all()</li>
<li>future::then()</li>
<li>future::unwrap()</li>
</ul>

<p>
<b>Syncronization Primitives:</b>
</p>

<ul class="org-ul">
<li>Locks 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></li>
<li>std::condition_variable</li>
</ul></li>

<li>RAII Wrappers for locks 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock&lt;&gt;</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard</a> - RAII Wrapper for locks</li>
</ul></li>

<li>Atomic Operations =&gt; Header: <a href="https://en.cppreference.com/w/c/atomic">&lt;atomic&gt;</a>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a></li>
<li>std::atomic_xxx, std::atomic&lt;&gt;, std::atomic_thread_fence()</li>
</ul></li>
</ul>

<p>
<b>Implementations of C++11 Standard Library</b>
</p>

<ul class="org-ul">
<li>Clang LLVM</li>

<li>GNU GCC/G++</li>

<li>MSVC - Microsft Visual C++ Compiler (aka Visual Studio Compiler)</li>

<li>just::thread - commercial implementation by Just Software
Solution for MSVC, GNU GCC/G++ and CLang.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd74205e" class="outline-3">
<h3 id="orgd74205e"><span class="section-number-3">1.3</span> Class std::thread</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The class std::threads <span class="underline">is not thread</span>, it is a proxy for a native
thread and encapsulates a native thread or a kernel thread which the
documentation calls <span class="underline">thread of execution</span>.  
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/thread">&lt;thread&gt;</a></li>
</ul>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/thread">std::thread</a>  - cppreference</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-class?view=vs-2019">std::thread</a> - Microsft MSFT, MSVC</li>

<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread.html">boost:thread</a>  - Predecessor of the standard library threads</li>

<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/thread_management.html">Thread Management - 1.71.0</a> (Boost docs)</li>
</ul>

<p>
Papers related to the standard library implementation: 
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">WG21 - N2093</a>  - Multithreading API for C++0X - A Layered Approach - 2006-09-09</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">WG21 - N2139</a> - Thoughts on a Thread Library for C++ - 2006-11-06</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">WG21 - N2184</a> - Thread Launching for C++0X - 2007-03-09</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html">WG21 - N2497</a> - Multi-threading Library for Standard C++ (Revision 1) - 2008-01-07</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">WG21 - N2320</a> - Multi-threading Library for Standard C++ - 2007-06-24</li>
</ul>


<p>
<b>Type of signature of std::thread member functions</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">thread</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">types:</span>
    <span class="org-keyword">class</span> <span class="org-type">id</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">typedef implementation-defined native_handle_type; // See [thread.native]</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">construct/copy/destroy:</span>
    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">F</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">explicit</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">F</span> <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">F</span>, <span class="org-keyword">class</span> ...<span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    ~<span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">thread</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">thread</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">thread</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-type">thread</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">members:</span>
    <span class="org-type">void</span> <span class="org-function-name">swap</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">bool</span> <span class="org-function-name">joinable</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
    <span class="org-type">void</span> <span class="org-function-name">join</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-type">void</span> <span class="org-function-name">detach</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-type">id</span> <span class="org-function-name">get_id</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
    <span class="org-type">native_handle_type</span> <span class="org-function-name">native_handle</span><span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">See [thread.native]</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">static members:</span>
    <span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-function-name">hardware_concurrency</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Detailed Member Functions of class std::thread</b>
</p>

<ul class="org-ul">
<li><span class="underline">Default and move constructors</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Default constructor - without any thread of execution </span>
thread<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Move constructor </span>
thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">thread</span>&amp;&amp; <span class="org-variable-name">Other</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">Other Constructors</span>
<ul class="org-ul">
<li>The following constructor can take as agument (type parameter
Fn): any function pointer; callable object (aka "functor") or
lambda expression. The thread of execution associated to the
constructed object starts its execution immediately.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Fn</span>, <span class="org-keyword">class</span>... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">explicit</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Fn</span>&amp;&amp; <span class="org-variable-name">F</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">A</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Example: Construct thread out of function pointer: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">========= Create thread out of function pointer =======// </span>
<span class="org-type">void</span> <span class="org-function-name">do_forever</span><span class="org-rainbow-delimiters-depth-1">()</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>every 10 seconds<span class="org-rainbow-delimiters-depth-2">){</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" 10 second elapsed!"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  

<span class="org-type">void</span> <span class="org-function-name">action_sleep</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-comment-delimiter">// </span><span class="org-comment">.... sleep for N seconds ....</span>
   print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] Thread wake up! OK"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">thread</span> <span class="org-variable-name">th1</span> <span class="org-rainbow-delimiters-depth-1">{</span>do_forever<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">thread</span> <span class="org-variable-name">th2</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;do_forever<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">thread</span> <span class="org-variable-name">th3</span> <span class="org-rainbow-delimiters-depth-1">{</span>action_sleep, 10<span class="org-rainbow-delimiters-depth-1">}</span>; 
<span class="org-type">thread</span> <span class="org-variable-name">th4</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;action_sleep, 1<span class="org-rainbow-delimiters-depth-1">}</span>;   
</pre>
</div>

<p>
Example: construct threads out of function object, aka callable
objects or functors. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Functor</span>
<span class="org-keyword">struct</span> <span class="org-type">LoopMessage</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span>;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">delay</span>;

    <span class="org-function-name">LoopMessage</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span>, <span class="org-type">int</span> <span class="org-variable-name">delay</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        message<span class="org-rainbow-delimiters-depth-2">(</span>message<span class="org-rainbow-delimiters-depth-2">)</span>
      , delay<span class="org-rainbow-delimiters-depth-2">(</span>delay<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator called by the thread class. </span>
    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">seconds</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-variable-name">delay</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] thread id = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-4">()</span>
                      &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; message &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">thread_messageA</span> <span class="org-rainbow-delimiters-depth-2">{</span>LoopMessage, <span class="org-string">"Hello world"</span>, 10<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_messageB</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">{</span>LoopMessage, <span class="org-string">"Hello world"</span>, 10<span class="org-rainbow-delimiters-depth-2">}</span>; 
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Example: construct thread object out of lambda expressions. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::thread threadA <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-5">(</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">... action .... // </span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">th4</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-5">(</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">.... action ... // </span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span>, 10<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Note: Before a given std::thread object goes out of scope, it is
necessary to call the methods .join() for waiting for the completion
of associated thread of execution or std::thread::detach() for
detaching the thread of execution. If neither of those functions are
called, the C++ runtime calls <span class="underline">std::terminate</span> and <span class="underline">std::abort()</span>
indirectly which causes abnormal termination of the current
application.  
</p>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Failure =&gt; Te runtime will call std::terminate </span>
<span class="org-type">int</span> <span class="org-function-name">Function_error</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Error: Missing call to methods .detach() or .join() </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">The runtime will call std::terminate() causing abnormal terminatoon!!</span>
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OK =&gt; Does not call std::terminate. </span>
<span class="org-type">int</span> <span class="org-function-name">Function_join</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Ok </span>
   threadA.join<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for completion of threadA. </span>
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">ThreaA out of scope here! </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OK =&gt; Does not call std::terminate.</span>
<span class="org-type">int</span> <span class="org-function-name">Function_detach</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Ok </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Detach, no longer control or manage threadA. </span>
   threadA.detach<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 
   Function_error<span class="org-rainbow-delimiters-depth-2">()</span>; 
   Function_join<span class="org-rainbow-delimiters-depth-2">()</span>; 
   Function_detach<span class="org-rainbow-delimiters-depth-2">()</span>;

   <span class="org-keyword">return</span> 10; 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li><span class="underline">joinable()</span>
<ul class="org-ul">
<li>=&gt; Returns true if the thread is <span class="underline">joinable</span>, in other words, if the
thread of execution associated to the called object is running.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">joinable</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">join()</span>
<ul class="org-ul">
<li>=&gt; Blocks the current thread waiting for the completion of the
called object thread. For instance, calling threadA.join() will
block the current thread waiting until the thread of execution of
threadA object finishes.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">thread</span>::<span class="org-function-name">join</span><span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">detach()</span> 
<ul class="org-ul">
<li>=&gt; Detaches the associated thread of execution from a given
std::thread object. After this function is called, it is no
longer possible to control the detached thread of execution or
joining it (waiting for its completion). Then, the std::thread
object no longer represents the detached execution thread.</li>
<li>=&gt; A thread of execution that was detached is also called <span class="underline">daemon thread</span>.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">thread</span>::<span class="org-function-name">detach</span><span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">id()</span>
<ul class="org-ul">
<li>=&gt; Returns the unique ID indentifier number for each thread.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-constant">thread</span>::<span class="org-function-name">id</span> <span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">hardware_concurrency()</span>
<ul class="org-ul">
<li>=&gt; Returns an estimate for the number of threads that can be run
in parallel. The result is often equal to the number of <span class="underline">logical CPU cores</span>.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-constant">thread</span>::<span class="org-function-name">hardware_concurrency</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org425b233" class="outline-3">
<h3 id="org425b233"><span class="section-number-3">1.4</span> Functions of namespace std::this_thread</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Utilities functions for currrent thread of execution: 
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread">&lt;header&gt;</a></li>
</ul>

<p>
Function Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/yield">this_thread::yield</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/get_id">this_thread::get_id</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">this_thread::sleep_for</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">this_thread::sleep_until</a></li>
</ul>

<p>
Signature of functions in namespace this_thread. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Namespace: std::this_thread. </span>
<span class="org-keyword">namespace</span> <span class="org-constant">std</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">namespace</span> <span class="org-constant">this_thread</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the id of the current thread.</span>
    <span class="org-constant">std</span>::<span class="org-constant">thread</span>::<span class="org-type">id</span> <span class="org-function-name">get_id</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">noexcept</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Provides a hint to the implementation to reschedule the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">execution of threads, allowing other threads to run.</span>
    <span class="org-type">void</span>            <span class="org-function-name">yield</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">noexcept</span>;      
    <span class="org-comment-delimiter">// </span><span class="org-comment">Blocks the execution of the current thread for at least the specified sleep_duration.</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span>
    <span class="org-type">void</span>            <span class="org-function-name">sleep_for</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>&amp; <span class="org-variable-name">sleep_duration</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Blocks the execution of the current thread until specified</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">sleep_time has been reached.</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span>
    <span class="org-type">void</span>           <span class="org-function-name">sleep_until</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Clock</span>,<span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>&amp; <span class="org-variable-name">sleep_time</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
 <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2600d2" class="outline-3">
<h3 id="orgd2600d2"><span class="section-number-3">1.5</span> Thread - std::thread usage and synchronization primtives</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgd44a6f6" class="outline-4">
<h4 id="orgd44a6f6"><span class="section-number-4">1.5.1</span> Race condition</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
When the a race condition happens, the outcome of the computation with
a shared resource depends precisely on the order of execution of the
threads. Race condition bugs are hard to trace and debug. The solution
to this flaw is to coordinate the thread access to shared resources
through synchronization primitives, namely, mutex (mutual exclusion
locks), atomic variables, and so on.
</p>

<p>
Most common types of shared resources: 
</p>
<ul class="org-ul">
<li>Global variable or objects such as: std::cout, std::cerr, std::cin</li>
<li>Shared variables between threads</li>
<li>Singleton objects - class with an unique global instance.</li>
</ul>

<p>
C++ Standard definition about <b>Data Race</b> (aka race condition): 
</p>

<blockquote>
<p>
The execution of a program contains a <b>data race</b> if it conains two
potential concurrent conflicting actions, at least one of which is
not atomic, and neither happens before the other, except of the
special case for singnal handlers described below. <b>Any such data</b>
<b>race results</b> in <b>undefined behavior</b>.
</p>
</blockquote>

<p>
C++ Standard about Undefined Behavior: 
</p>

<blockquote>
<p>
A conforming implementation executing a well-formaed program shall
reproduce the same observable behavior as one of the possible
executions of the corresponding instances of the abstract machien
with the smae program and the same input. However, if any such
exeuction contains an undefined operation, this International
Standard places no requirement on the implementation executing that
program with that input.
</p>
</blockquote>

<p>
<b>Example about race condition:</b>
</p>

<p>
Race condition: 
</p>

<ul class="org-ul">
<li>File: race_condtion.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">acc</span><span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc = acc + x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span>Worker<span class="org-rainbow-delimiters-depth-5">(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>, i<span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ thread1.cpp -o <span class="org-keyword">thread1.bin</span> -std=c++1z -Wall -Wextra -O0 -g -lpthread 
</pre>
</div>

<p>
Running: 
</p>
<ul class="org-ul">
<li>The expected result is 385. However, the program sometimes yields
an incorrect result due to a <span class="underline">race condition</span> bug (aka data
race).</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread1.bin 
 result   = 385

$ ./thread1.bin 
 result   = 384

$ ./thread1.bin 
 result   = 385

$ ./thread1.bin 
 result   = 368

$ ./thread1.bin 
 result   = 385

./thread1.bin 
 result   = 376
</pre>
</div>
</div>
</div>
<div id="outline-container-org92ca64e" class="outline-4">
<h4 id="org92ca64e"><span class="section-number-4">1.5.2</span> Debugging Race Conditions with CLang's Sanitizers</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
It is well known that Race condition (aka data races) are hard to
reproduce, trace and debug due to the nondeterminism of concurrent
systems and the result in race condition be dependent on the order
that threads were run. For instance, multiple executions with the same
inputs may lead to different outcomes. 
</p>

<p>
Clang compiler has some <span class="underline">sanitizers</span> and static analysis tools that
helps to debug undefined behavior, memory and race condition. 
</p>

<p>
Clang Sanitizer Tools: 
</p>

<ul class="org-ul">
<li><a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Thread Safety Analysis</a> (Static analysis tool =&gt; compiler warning)
<ul class="org-ul">
<li>Compiler switch:  <b>-Wthread-safety</b></li>
<li>Warns about potential race conditions in the code at compile-time.</li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=thread</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Race conditions or data races at runtime.</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=address</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Out-of-bounds accesses to heap, stack and globals</li>
<li>Use-after-free</li>
<li>Use-after-return (runtime flag ASAN_OPTIONS=detect_stack_use_after_return=1)</li>
<li>Double-free, invalid free</li>
<li>Memory leaks (experimental)</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Undefined Behavior Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=undefined</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Using misaligned or null pointer</li>
<li>Signed integer overflow</li>
<li>Conversion to, from, or between floating-point types which
would overflow the destination.</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">Memory Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=memory</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Uninitialized reads (reading of unitialized variables)</li>
</ul></li>
</ul></li>
</ul>

<p>
Example: Using Clang sanitizer tools for race condition detection: 
</p>

<ul class="org-ul">
<li>File: flawed-program.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">acc</span><span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc = acc + x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span>Worker<span class="org-rainbow-delimiters-depth-5">(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>, i<span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Compiler swiches: </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -O0                  Disable optimization </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -g                   Enable debug building </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -Wthread-safety      Enable Clang compiler warning for race conditions</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -fsanitize=thread    Enable thread sanitizer </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -fsanitize=undefined Eanble undefined behavior sanitizer </span>
$ clang++ flawed-program.cpp -o <span class="org-keyword">out.bin</span> -O0 -g -lpthread -Wall -Wextra -pedantic <span class="org-sh-escaped-newline">\</span>
    -Wthread-safety <span class="org-sh-escaped-newline">\</span>
    -fsanitize=thread <span class="org-sh-escaped-newline">\</span>
    -fsanitize=undefined 
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 

==================
<span class="org-function-name">WARNING</span>: ThreadSanitizer: data race (<span class="org-variable-name">pid</span>=22979)
  Read of size 4 at 0x7ffdb2ae1b78 by thread T2:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:17 (out.bin+0x4b7516)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  Previous write of size 4 at 0x7ffdb2ae1b78 by thread T1:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:15 (out.bin+0x4b75c6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  As if synchronized via sleep:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 nanosleep &lt;null&gt; (out.bin+0x43565e)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1000l&gt; &gt;(std::chrono::duration&lt;long, std::ratio&lt;1l, 1000l&gt; &gt; const&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:379:9 (out.bin+0x4b7798)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:15:11 (out.bin+0x4b74ef)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">7 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">8 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  Location is stack of main thread.

  Location is global <span class="org-string">'??'</span> at 0x7ffdb2ac4000 ([stack]+0x00000001db78)

  Thread T2 (<span class="org-variable-name">tid</span>=22982, running) created by main thread at:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 pthread_create &lt;null&gt; (out.bin+0x425eba)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xbf8a8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 main /Users/dummy/projects/cmake-experiment/flawed-program.cpp:27:34 (out.bin+0x4b3304)</span>

  Thread T1 (<span class="org-variable-name">tid</span>=22981, finished) created by main thread at:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 pthread_create &lt;null&gt; (out.bin+0x425eba)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xbf8a8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 main /Users/dummy/projects/cmake-experiment/flawed-program.cpp:27:34 (out.bin+0x4b3304)</span>

<span class="org-function-name">SUMMARY</span>: ThreadSanitizer: data race /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:17<span class="org-keyword"> in</span> Worker::operator()(int)
==================
 result   = 304
<span class="org-function-name">ThreadSanitizer</span>: reported 1 warnings

</pre>
</div>

<p>
The santizer found a <span class="underline">data race</span> in the line 16 and column 17 of the
file: flawed-program.cpp 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">SUMMARY</span>: ThreadSanitizer: data race /Users/... ..../flawed-program.cpp:16:17<span class="org-keyword"> in</span> Worker::operator()(int)
</pre>
</div>

<p>
The data race is in the following line where a reference to a variable
is modified by multiple threads without any lock or mutex. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">acc = acc + x * x;
</pre>
</div>
</div>
</div>


<div id="outline-container-org66fd2f0" class="outline-4">
<h4 id="org66fd2f0"><span class="section-number-4">1.5.3</span> Mutex solution</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
The race condition can be solved by using <b>mutex</b> - mutual exclusion
synchronization primitive which allows only a single thread at a time
to access the critical section, portion of the code with a shared
resource.   
</p>

<p>
File: thread2.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires &lt;mutex&gt; header</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>, <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-2">)</span>: acc<span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span>, m<span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">--- Start of critical section ---- //</span>
        m.lock<span class="org-rainbow-delimiters-depth-3">()</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Curren thread acquire locks</span>
        acc = acc + x * x;
        m.unlock<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Current thread releases lock</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of critical section ---- //</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Shared resource</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-variable-name">Worker</span><span class="org-rainbow-delimiters-depth-5">(</span>result, m<span class="org-rainbow-delimiters-depth-5">)</span>, <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ thread2.cpp -o <span class="org-keyword">thread2.bin</span> -std=c++1z -Wall -Wextra -O0 -g -lpthread 
</pre>
</div>

<p>
Running:  
</p>

<ul class="org-ul">
<li>The computation becomes reproducible and predictable due to the
mutex allow only a single thread at atime access the shared
resource (variable result).</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385


$ ./thread2.bin 
 result   = 385
</pre>
</div>

<p>
Note: The current code is not exception safe and error prone, as a
result if an exception happens or if the lock releasing code is
missing, the outcome will be a <span class="underline">deadlock.</span> It is better to use the
std::mutex_guard which is an RAII (Resource Acquisition Is
Initialization) wrapper for locks. When the mutex guard object is
constructed, the current thread acquires the lock and when the guard
goes out of scope, the mutex lock is released. So, by using a
<span class="underline">scope_guard</span>, the code becomes:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-1">()</span></span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-3">(</span>500<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">--- Start of critical section ---- //</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Acquires lock </span>
    <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">mutex_guard</span><span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span>;
    acc = acc + x * x;
    <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of critical section ---- //</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Releases lock here, when the mutex_guard goes out of scope and is destroyed. </span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17f1f71" class="outline-4">
<h4 id="org17f1f71"><span class="section-number-4">1.5.4</span> Atomic variable solution</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
Another way to solve the race condition (aka data race) problem is
using <span class="underline">atomic variables and atomic operations</span>. 
</p>

<p>
File: thread3.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">atomic</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">acc</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires &lt;mutex&gt; header</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">acc</span>, <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : acc<span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span>, m<span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc += x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Shared resource</span>
    <span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">result</span> = 0;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-variable-name">Worker</span><span class="org-rainbow-delimiters-depth-5">(</span>result, m<span class="org-rainbow-delimiters-depth-5">)</span>, <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0ef0e0a" class="outline-3">
<h3 id="org0ef0e0a"><span class="section-number-3">1.6</span> Thread - Returning values from std::thread</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orgab47ecf" class="outline-4">
<h4 id="orgab47ecf"><span class="section-number-4">1.6.1</span> Return value from thread</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
There is no way to return a value from a std::thread computaiton, if a
function used for instantiating std::thread has any returning value it
is ignored.  
</p>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">  <span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">doube</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">do something .... heavy calculation </span>
      <span class="org-keyword">return</span> output; 
  <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Return value ignored. </span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span> &amp;heavy_computation, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... </span>

 th.join<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
The workaround for returning a value out of std::thread is to set a
variable defined outside of the thread or set a parameter passed as
pointer or reference.
</p>

<ul class="org-ul">
<li>Return value from thread by setting a variable defined outside of
the thread.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-variable-name">output</span> = 0.0;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Return value ignored. </span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span> &amp;<span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]</span>
          <span class="org-rainbow-delimiters-depth-2">{</span> 
             <span class="org-comment-delimiter">// </span><span class="org-comment">perform heavy computation // </span>
              .... 
             <span class="org-comment-delimiter">/* </span><span class="org-comment">set output */</span>
             output =  .... 
          <span class="org-rainbow-delimiters-depth-2">}</span>, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... </span>

 th.join<span class="org-rainbow-delimiters-depth-1">()</span>;
 printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" output = %f"</span>, output<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Return value from thread by setting the function parameters passed
by reference or pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">doube</span> <span class="org-variable-name">input</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">output1</span>, <span class="org-type">double</span>* <span class="org-variable-name">output2</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">do something .... heavy calculation </span>
    output1 =  .... ;
    *output2 = <span class="org-string">"Something else ...."</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span>      <span class="org-variable-name">output1</span> = 0.0; 
<span class="org-function-name">std</span>::string output2 = <span class="org-string">""</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span>&amp;heavy_computation, <span class="org-constant">std</span>::ref<span class="org-rainbow-delimiters-depth-2">(</span>output1<span class="org-rainbow-delimiters-depth-2">)</span>, &amp;output2<span class="org-rainbow-delimiters-depth-1">)</span>;
th.join<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" output1 = "</span> &lt;&lt; output1 <span class="org-string">" ; "</span> &lt;&lt; <span class="org-string">" output2 = "</span> &lt;&lt; output2 &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgad50eab" class="outline-4">
<h4 id="orgad50eab"><span class="section-number-4">1.6.2</span> Catch exceptions in threads</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
If any exception is thrown in a std::thread, the exception is not
propagated to the try &#x2026; catch block outside of the thread, instead
the C++ runtime calls std::terminate causing abonormal termination. 
</p>

<p>
<b>Example: code does not work =&gt; calls std::terminate</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">do_something</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">....  .... // </span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>input &lt; 0 <span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Invalid input"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">//</span><span class="org-comment">.... ... ... ... //</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">DOES NOT WORK =&gt;&gt;&gt; C++ runtime calls std::terminate !!!</span>
<span class="org-keyword">try</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>do_something, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Error: "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>.;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Example: Solution</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::exception_ptr exptr = <span class="org-constant">nullptr</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">do_something</span> = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">....  .... // </span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>input &lt; 0 <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Invalid input"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-comment-delimiter">//</span><span class="org-comment">.... ... ... ... //</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions </span>
  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      exception_ptr = <span class="org-constant">std</span>::current_exception<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">try</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>do_something, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
   th.join<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-constant">std</span>::rethrow_exception<span class="org-rainbow-delimiters-depth-2">(</span>exptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Error: "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>.;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8c06cb0" class="outline-4">
<h4 id="org8c06cb0"><span class="section-number-4">1.6.3</span> Example: Returning values and catching exceptions</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
File: return-thread.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Experiment returning results from threads</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------------------</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;
<span class="org-keyword">namespace</span> <span class="org-constant">cr</span> = <span class="org-constant">std</span>::chrono;

<span class="org-keyword">struct</span> <span class="org-type">Timer</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-variable-name">start</span>;

    <span class="org-function-name">Timer</span><span class="org-rainbow-delimiters-depth-2">(){</span>  start = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">Timer</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">duration</span> = <span class="org-constant">cr</span>::duration_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">cr</span>::seconds<span class="org-rainbow-delimiters-depth-3">&gt;(</span>end - start<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Elapsed time: "</span> &lt;&lt; duration.count<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">string_literals</span>;

    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>4s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>input &lt; 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: invalid input: "</span>s + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-4">(</span>input<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> input * 3.815 + 5.6;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>* <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>         <span class="org-variable-name">inputs</span><span class="org-rainbow-delimiters-depth-2">{</span>2, 10, 5<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>      <span class="org-variable-name">results</span><span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">threads</span>;
    threads.reserve<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: A std::thread will never return anything from a function</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">passed as argument, even if has non-void return type.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">The only to return a value from a thread is to set an</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">argument passed by pointer or reference or set a global object.</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_adapter</span> = <span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">size_t</span> <span class="org-variable-name">index</span>, <span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        results<span class="org-rainbow-delimiters-depth-3">[</span>index<span class="org-rainbow-delimiters-depth-3">]</span> = heavy_computation<span class="org-rainbow-delimiters-depth-3">(</span>input<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ===== Experiment 1 - Return value from threads (Parallel Computing) ==== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Shows elapsed time at end of this scope</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">timer</span> = Timer<span class="org-rainbow-delimiters-depth-3">{}</span>;

        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            threads.push_back<span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-5">(</span>thread_adapter, i, inputs<span class="org-rainbow-delimiters-depth-6">[</span>i<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Waiting for thread completion"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for the completion of all threads</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> threads<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span>.join<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Show results</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" Result[%lu] = %f\n"</span>, i, results<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">///</span><span class="org-comment">---------------------------------------------------------------//</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ===== Dealing with exceptions from threads ==== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">double</span> <span class="org-variable-name">output</span> = 0.0;
    <span class="org-constant">std</span>::<span class="org-type">exception_ptr</span> <span class="org-variable-name">exptr</span> = <span class="org-constant">nullptr</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_adapter2</span> = <span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Inside thread_adapter2"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: if an exception is not caught,</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">it will not be propagated to the parent thread.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Instead, the C++ runtime will call std::terminate</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">causing abonormal temrination.</span>
        <span class="org-keyword">try</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            output = heavy_computation<span class="org-rainbow-delimiters-depth-4">(</span>input<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span>...<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions from the computation that</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">should run in a new thread and set a shared memory variable</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">set only once by this thread.</span>
            exptr = <span class="org-constant">std</span>::current_exception<span class="org-rainbow-delimiters-depth-4">()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>thread_adapter2, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Waiting thread_adapter2 thread termination."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    th.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>exptr<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Result of thread_adapter2 is: "</span> &lt;&lt; output &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">try</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::rethrow_exception<span class="org-rainbow-delimiters-depth-4">(</span>exptr<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">err</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; err.what<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ return-thread.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -g -lpthread
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 

 ===== Experiment 1 - Return value from threads (Parallel Computing) ==== 

 [INFO] Waiting for thread completion
 Result[0] = 13.230000
 Result[1] = 43.750000
 Result[2] = 24.675000
 [TRACE] Elapsed time: 4

 ===== Dealing with exceptions from threads ==== 

 [TRACE] Waiting thread_adapter2 thread termination.
 [TRACE] Inside thread_adapter2
 [ERROR] Error: invalid input: -10

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org65c30fe" class="outline-3">
<h3 id="org65c30fe"><span class="section-number-3">1.7</span> Task-based APIs =&gt; Futures and Promises</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-orgf36892a" class="outline-4">
<h4 id="orgf36892a"><span class="section-number-4">1.7.1</span> Futures overview</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
Overview: 
</p>

<ul class="org-ul">
<li>The std::future class encapsulates a value that will eventually
become available from an asynchronous computation.</li>

<li>This class makes easier to run functions or anything callable that
returns value in a new thread and get this value without any
global variables. Another benefit is that is much easier to handle
exceptions from another thread than the class std::thread.</li>

<li>Use cases:
<ul class="org-ul">
<li>Short computations that returns a value such as a network request.</li>
<li>Implement parallel algorithms and parallel computations.</li>
</ul></li>

<li>Not good for: 
<ul class="org-ul">
<li>Long running thread, threads that run in an infinite loop or
worker thread.</li>
</ul></li>

<li>Problems:
<ul class="org-ul">
<li>Many other implementations of futures run the tasks in a
thread-pool, a pre-allocated set of threads used for avoiding
spawning too much threads that would increase the memory
footprint, reducing the performance and throughput.</li>

<li>The C++ standard library's std::future API does not use thread
pools.</li>
</ul></li>
</ul>

<p>
<b>Documentation</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/promise">std::promise</a></li>

<li><a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a></li>
</ul>

<p>
<b>Other Implementations of Futures and Promises</b>
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/synchronization.html#thread.synchronization.futures">boost::future</a></li>

<li><a href="https://github.com/facebook/folly/blob/master/folly/docs/Futures.md">folly::Future</a></li>

<li><a href="http://stlab.cc/libraries/concurrency/future/future/">stlab::future</a></li>

<li>hpx::future</li>
</ul>
</div>
</div>
<div id="outline-container-orgec380c6" class="outline-4">
<h4 id="orgec380c6"><span class="section-number-4">1.7.2</span> Usage</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
The function <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a> is used for creating  <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> objects out of
functions that return values.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Note: simplified pseudo-signature =&gt; </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload 1: </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Callable</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">async</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Return<span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload 2: </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Return</span>, <span class="org-keyword">typename</span> <span class="org-type">Callable</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">async</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::<span class="org-type">launch</span> <span class="org-variable-name">policy</span>, <span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Return</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<ul class="org-ul">
<li>The object futA represents the return value or the result of the
computation heavy_computation that is run in a new thread not
blocking the thread that called std::async.</li>

<li>The parameter <span class="underline">std::launch::async</span> =&gt; or launch policy is necessary
to run the computation in a new thread.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">label</span>, <span class="org-type">bool</span> <span class="org-variable-name">flag</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-comment-delimiter">// </span><span class="org-comment">Sleep blocking the current thread for 10 seconds.</span>
   <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>10s<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... .. </span>
   <span class="org-keyword">return</span> output; 
<span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">futA</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, heavy_computation, 100, <span class="org-string">"calc1"</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;

 <span class="org-keyword">auto</span> <span class="org-variable-name">futB</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-rainbow-delimiters-depth-2">{</span> 
               <span class="org-comment-delimiter">// </span><span class="org-comment">.... heavy CPU bound computation ... // </span>
               <span class="org-type">double</span> <span class="org-variable-name">output</span> = ...; 
                 ... ... ... 
               <span class="org-keyword">return</span> output;
            <span class="org-rainbow-delimiters-depth-2">}</span>, 200<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">std::future&lt;T&gt;::get()</span>
<ul class="org-ul">
<li>The member function .get() from <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> blocks the current
thread (similar to std::thread::join) waiting for the completion
of the computation and then returns its result.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread - similar to std::thread::join()</span>
<span class="org-type">double</span> <span class="org-variable-name">resultA</span> = futA.get<span class="org-rainbow-delimiters-depth-1">()</span>; 
<span class="org-type">double</span> <span class="org-variable-name">resultB</span> = futB.get<span class="org-rainbow-delimiters-depth-1">()</span>; 

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" resultA = "</span> &lt;&lt; resultA &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; resultB &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">std::future&lt;T&gt;::wait()</span>
<ul class="org-ul">
<li>The member function .wait() blocks the current thread waiting the
std::future's thread termination.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Wait for the computation completion blocking current thread.</span>
futB.wait<span class="org-rainbow-delimiters-depth-1">()</span>; 
</pre>
</div>

<ul class="org-ul">
<li>Catching exceptions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-function-name">computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   ... .... ... ... 

   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>bad_input<span class="org-rainbow-delimiters-depth-3">(</span>input<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
       <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Invalid input, try again ..."</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>

   ... .... ... ... 
   <span class="org-keyword">return</span> result; 
<span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Type: std::future&lt;double&gt;</span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">afuture</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, computation, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

 <span class="org-keyword">try</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-type">double</span> <span class="org-variable-name">result</span> = afuture.get<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Result = "</span> &lt;&lt; result &lt;&lt; <span class="org-string">"\n"</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>:
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Run computations in parallel</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">  <span class="org-type">double</span> <span class="org-function-name">computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> 
    ... .... ... ... 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Sleep blocking this thread for 8 seconds </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">for simulating a heavy CPU-bound computation.</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>8s<span class="org-rainbow-delimiters-depth-2">)</span>;
    ... .... ... ... 
    <span class="org-keyword">return</span> result; 
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">futures</span>; 
 futures.reserver<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">inputs</span> <span class="org-rainbow-delimiters-depth-1">{</span>10, 20, 25<span class="org-rainbow-delimiters-depth-1">}</span>;
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">outputs</span>; 

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: inputs<span class="org-rainbow-delimiters-depth-1">){</span> 
   futures.push_back<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, computation, x<span class="org-rainbow-delimiters-depth-3">)</span>;   <span class="org-rainbow-delimiters-depth-2">)</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread waiting all computations finish. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">If every computation takes 8 seconds, the total time waiting </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">will be 8 seconds since they are all run in parallel. </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">fut</span>: futures<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">double</span> <span class="org-variable-name">x</span> = fut.get<span class="org-rainbow-delimiters-depth-2">()</span>; 
   outputs.push_back<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8ba4684" class="outline-4">
<h4 id="org8ba4684"><span class="section-number-4">1.7.3</span> Example</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
File: future1.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">optional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">cr</span> = <span class="org-constant">std</span>::chrono;
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-preprocessor">#define</span> <span class="org-function-name">LOG_FUNCTION_ENTRY</span><span class="org-rainbow-delimiters-depth-1">()</span> \
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE-ENTRY] Function = "</span> &lt;&lt; __FUNCTION__  \
          &lt;&lt; <span class="org-string">" ; threadID "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl


<span class="org-keyword">struct</span> <span class="org-type">TimeCounter</span>
<span class="org-rainbow-delimiters-depth-1">{</span>


    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-variable-name">start</span>;
    <span class="org-function-name">TimeCounter</span><span class="org-rainbow-delimiters-depth-2">(){</span>  start = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">report</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">label</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">duration</span> = <span class="org-constant">cr</span>::duration_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">cr</span>::seconds<span class="org-rainbow-delimiters-depth-3">&gt;(</span>end - start<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Elapsed time: {"</span> &lt;&lt; label &lt;&lt; <span class="org-string">"} = "</span> &lt;&lt; duration.count<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::mutex mu;

<span class="org-type">double</span> <span class="org-function-name">expensive_computationA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- Start of critical section --- */</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition</span>
        <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-3">(</span>mu<span class="org-rainbow-delimiters-depth-3">)</span>;
        LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- End of critical section --- */</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>4s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 4.0 * n + 5;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-function-name">expensive_computationB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- Start of critical section --- */</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition</span>
        <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-3">(</span>mu<span class="org-rainbow-delimiters-depth-3">)</span>;
        LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- End of critical section --- */</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>8s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 2.515 * n + 15.8714;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string
computatio_with_exception<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>1s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &lt; 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" Error: not allowed negative N"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-string">"Hello world"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>



<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Number of hardware threads = "</span>
              &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-preprocessor">#if</span> 1

    LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 1 &gt;&gt;  without std::future =&gt; Run Serially ==== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">TimeCounter</span> <span class="org-variable-name">tc</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultA</span> = expensive_computationA<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultB</span> = expensive_computationB<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Completed =&gt;&gt; resultA = "</span> &lt;&lt; resultA
                  &lt;&lt; <span class="org-string">" ; resultB = "</span> &lt;&lt; resultB
                  &lt;&lt; <span class="org-constant">std</span>::endl;
        tc.report<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"EXPERIMENT1"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 2 &gt;&gt; with std::futures - Run in Parallel ===== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">TimeCounter</span> <span class="org-variable-name">tc</span>;


        <span class="org-comment-delimiter">// </span><span class="org-comment">Function runs in another thread when the future object</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is instantiated.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The default policy of std::async is (async | deferred) which</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">would let the C++ runtime decide when run the thread.</span>
        <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">futA</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async
                                              , &amp;expensive_computationA, 10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Function runs only when the std::future&lt;T&gt;::get() method is called.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The function expensive_computationB is not run at the moment futB object</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is created.</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">futB</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, expensive_computationB, 10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition (aka data race)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-4">(</span>mu<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Waiting futures results "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Calls to .get() method blocks the current thread and waits</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">for the completion of the computations wrapped in the future object.</span>
        <span class="org-type">double</span> <span class="org-variable-name">resultB</span> = futB.get<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultA</span> = futA.get<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Completed =&gt;&gt; resultA = "</span> &lt;&lt; resultA
                  &lt;&lt; <span class="org-string">" ; resultB = "</span> &lt;&lt; resultB
                  &lt;&lt; <span class="org-constant">std</span>::endl;

        tc.report<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"EXPERIMENT2"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">The method can only be used only once!!</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, it calls std::termiante causing abnormal termination.</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">double resultAA = futA.get(); // DO NOT!</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 3 &gt;&gt; Exceptions handling ====================== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Future Created"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">fut1</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span>computatio_with_exception, -10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">result1</span> = fut1.get<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Result1 = "</span> &lt;&lt; result1 &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-preprocessor">#endif</span>

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">clang++ future1.cpp -o <span class="org-keyword">future1.bin</span> -std=c++1z -lpthread -Wall -Wextra -O0 -g
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ ./future1.bin 

 Number of hardware threads = 4

 ==== EXPERIMENT 1 &gt;&gt;  without std::future =&gt; Run Serially ==== 
-----------------------------------------------------------------

 [TRACE-ENTRY] Function = main ; threadID 139662702782272
 [TRACE-ENTRY] Function = expensive_computationA ; threadID 139662702782272
 [TRACE-ENTRY] Function = expensive_computationB ; threadID 139662702782272
 [TRACE] Completed =&gt;&gt; resultA = 45 ; resultB = 41.0214
 [TRACE] Elapsed time: {EXPERIMENT1} = 12

 ==== EXPERIMENT 2 &gt;&gt; with std::futures - Run<span class="org-keyword"> in</span> Parallel ===== 
-----------------------------------------------------------------

 [TRACE] Waiting futures results 
 [TRACE-ENTRY] Function = expensive_computationA ; threadID 139662684923648
 [TRACE-ENTRY] Function = expensive_computationB ; threadID 139662676530944
 [TRACE] Completed =&gt;&gt; resultA = 45 ; resultB = 41.0214
 [TRACE] Elapsed time: {EXPERIMENT2} = 8

 ==== EXPERIMENT 3 &gt;&gt; Exceptions handling ====================== 
-----------------------------------------------------------------

Future Created
 [TRACE-ENTRY] Function = computatio_with_exception ; threadID 139662684923648
 [ERROR]  Error: not allowed negative N
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org36bbf00" class="outline-3">
<h3 id="org36bbf00"><span class="section-number-3">1.8</span> Condition Variables and Producer Consumer Problem</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>A condition variable is a synchronization primitive which allows
one or more threads to wait for a event, signal from another
thread, without wasting CPU cycles.</li>

<li>Mechanism: several threads wait on a condition variable, until
another thread notifies this synchronization primitive.</li>

<li>Note: Condition variables do not provide locking such as Mutexes,
so they must be used alongside condition variables in order to
avoid race conditions.</li>

<li>Operations of condition Variables:

<ul class="org-ul">
<li>ConditionVar.wait(MutexLock)
<ul class="org-ul">
<li>=&gt; Makes current thread (waiting thread) sleep waiting from a signal</li>
</ul></li>

<li>ConditionVar.notify_one()
<ul class="org-ul">
<li>=&gt; Wakes up a waiting thread. If there is no waiting thread,
the operation does nothing.</li>
</ul></li>

<li>ConditionVar.notify_all()
<ul class="org-ul">
<li>=&gt; Wake up all waiting threads.</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Condition Variable Method Signatures</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">condition_variable</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-keyword">public</span>:
    <span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    ~<span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">condition_variable</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-type">condition_variable</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">condition_variable</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Wake up only one sleeping thread */</span>
    <span class="org-type">void</span> <span class="org-function-name">notify_one</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">noexcept</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Wake up all sleeping threads that are waiting for this signal */</span>      
    <span class="org-type">void</span> <span class="org-function-name">notify_all</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">noexcept</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Make thread which alls this method sleep (wait for signal)</span>
<span class="org-comment">      * without waste CPU cycles */</span>  
    <span class="org-type">void</span> <span class="org-function-name">wait</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-type">void</span> <span class="org-function-name">wait</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">cv_status</span> <span class="org-function-name">wait_until</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Clock</span>, <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">abs_time</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span>, <span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">bool</span> <span class="org-function-name">wait_until</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Clock</span>, <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">abs_time</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">cv_status</span> <span class="org-function-name">wait_for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rel_time</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span>, <span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">bool</span> <span class="org-function-name">wait_for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rel_time</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">typedef</span> <span class="org-type">implementation</span>-defined native_handle_type;
    <span class="org-type">native_handle_type</span> <span class="org-function-name">native_handle</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Example: Usage of Conditions Variables in Producer/Consumer problem</b> 
</p>

<p>
The producer consumer problem is classical synchronization problem
where a producer puts data into a data structure and another thread, called
consumer, removes data from the data structure. Only a single thread
should be able to access the data structure at any atime. 
</p>

<p>
Sample implementation: <a href="https://gist.github.com/iikuy/8115191">https://gist.github.com/iikuy/8115191</a>
</p>

<p>
Example: 
</p>

<ul class="org-ul">
<li>File: producer-consumer.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">threads</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>  <span class="org-comment-delimiter">// </span><span class="org-comment">mutex, lock_guard, unique_lock</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">conditional_variables</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Number of hardware threads = "</span>
              &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n\n"</span>;

    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">cond</span>;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;
    <span class="org-constant">std</span>::<span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">buffer</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">finished</span> = <span class="org-constant">false</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">producer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] Producer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 5; i++<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-5">(</span>1s<span class="org-rainbow-delimiters-depth-5">)</span>;
                <span class="org-rainbow-delimiters-depth-5">{</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">-- start of critical section ----//</span>
                    <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-6">&gt;{</span>m<span class="org-rainbow-delimiters-depth-6">}</span>;
                    <span class="org-type">double</span> <span class="org-variable-name">x</span> = 5 * i + 10;
                    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [PRODUCER] Send data to buffer x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
                    buffer.push<span class="org-rainbow-delimiters-depth-6">(</span>x<span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex protects the buffer fron race condition</span>
                  <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of ciritical section ---- //</span>
                <span class="org-rainbow-delimiters-depth-5">}</span>

                <span class="org-comment-delimiter">// </span><span class="org-comment">Send signal notifying consumer thread to proceed.</span>
                cond.notify_all<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-5">&gt;{</span>m<span class="org-rainbow-delimiters-depth-5">}</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] End of transmission"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
                finished = <span class="org-constant">true</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Consumer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>            
            <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-5">&gt;{</span>m<span class="org-rainbow-delimiters-depth-5">}</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Waiting input "</span> &lt;&lt; <span class="org-string">"\n"</span>;

            <span class="org-comment-delimiter">// </span><span class="org-comment">The condition variable waits for cond.notify_one() signal</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">from the producer thread. Before this signal is sent, this</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">thread sleeps until receives it.</span>
            cond.wait<span class="org-rainbow-delimiters-depth-5">(</span>lock, <span class="org-rainbow-delimiters-depth-6">[</span>&amp;<span class="org-rainbow-delimiters-depth-6">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>buffer.empty<span class="org-rainbow-delimiters-depth-7">()</span>; <span class="org-rainbow-delimiters-depth-6">}</span><span class="org-rainbow-delimiters-depth-5">)</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Processing data ... wait"</span> &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Delay for simulating processing time</span>
            <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-5">(</span>5s<span class="org-rainbow-delimiters-depth-5">)</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Received value "</span> &lt;&lt; buffer.front<span class="org-rainbow-delimiters-depth-5">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
            buffer.pop<span class="org-rainbow-delimiters-depth-5">()</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>finished<span class="org-rainbow-delimiters-depth-5">){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Stop consumer thread. Ok"</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-keyword">break</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">Unlock in order to avoid deadlock</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">lock.unlock();</span>
        <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Waiting thread completion"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    producer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    consumer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building and Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ producer-consumer.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -g -Wall -lpthread
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 
 Number of hardware threads = 4

 [PRODUCER] Producer thread started.
 [TRACE] Waiting thread completion
 [CONSUMER] Consumer thread started.
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 10
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 10
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 15
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 15
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 20
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 20
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 25
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 25
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 30
 [PRODUCER] End of transmission
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 30
 [CONSUMER] Stop consumer thread. Ok

</pre>
</div>
</div>
</div>

<div id="outline-container-orgda178ce" class="outline-3">
<h3 id="orgda178ce"><span class="section-number-3">1.9</span> Messaging Passing Concurrency and Message Queue</h3>
<div class="outline-text-3" id="text-1-9">
</div>
<div id="outline-container-orgb5237e2" class="outline-4">
<h4 id="orgb5237e2"><span class="section-number-4">1.9.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
Message Passing Concurrency
</p>

<ul class="org-ul">
<li>In Message passing concurrency threads communicate by sending
messages to each other through a <span class="underline">message queue</span> FIFO buffer,
instead of communicating through explicit locks and mutating the
shared memory.</li>

<li>The mosft fundamental construct of message passing concurrency is
the <span class="underline">message queue</span>, that allows communication between <span class="underline">producers</span>
(aka senders) and <span class="underline">consumers</span> (aka receivers) threads running at
different speeds.</li>

<li><span class="underline">Message queues</span> are also called mailbox, channels or concurrent queue.</li>

<li><span class="underline">Message queues</span> are used for the from implementing the following
messaging passing design patterns: 

<ul class="org-ul">
<li><span class="underline">CSP</span> - Concurrent Sequential Process - proposed by Tony Hoare and
used in GO/Golang and Clojure.</li>

<li><span class="underline">Actor Model</span> - Proposed by Carl Hewitt and used in Erlang and
Scala's Akka.</li>

<li><span class="underline">Active Object</span></li>

<li><span class="underline">Thread Pools</span></li>
</ul></li>
</ul>

<p>
Producer Consumer Problem: 
</p>

<ul class="org-ul">
<li>The most basic use case of <span class="underline">message queues</span> is solving the producer
consumer/problem inter-thread communication problem where a
producer and consumer thread communicates through a buffer,
generally a queue. There are two scenarios, if the buffer is empty,
the consumer thread gets blocked (suspended) and is only resumed
when the producer puts some item in the buffer. If the queue has a
limited size and is full, the producer thread gets blocked
(suspended) until the consumer removes the item from the queue.</li>

<li>Note: <span class="underline">Message queues</span> can be implemented as a class that
encapsulates the queue data structure and synchronization
primitives: condition variables and mutexes.</li>
</ul>

<p>
Other uses of <span class="underline">message passing</span> and <span class="underline">message queues</span> 
</p>

<ul class="org-ul">
<li>Message passing is not only used for inter-thread communication,
this approach is also applicable for process communication through
IPC - Inter Process Communication and distributed systems where
multiple processes communicates over the network through sockets.</li>
</ul>

<p>
Sample Implementations of <span class="underline">message queue</span> 
</p>

<ul class="org-ul">
<li>Java:

<ul class="org-ul">
<li>LinkedBlockingQueue (Bounded buffer)
<ul class="org-ul">
<li>=&gt; Linked list of unlimited size that blocks/suspends the
consumer thread if the queue is empty until the producer puts
some element in the queue.</li>
</ul></li>

<li>ArrayBlockingQueue (Bounded buffer)
<ul class="org-ul">
<li>=&gt; Fixed size queue that blocks/suspends the consumer thread
(aka receiver) if the queue is empty until the producer thread
(aka sender) adds an element to the queue. The producer thread
gets blocked if the queue is full until the consumer thread
pops an element from the queue.</li>
</ul></li>
</ul></li>

<li><a href="https://github.com/cameron314/concurrentqueue">cameron314/concurrentqueue</a>
<ul class="org-ul">
<li>"A fast multi-producer,  multi-consumer lock-free concurrent queue for C++11"</li>
</ul></li>

<li>Facebook's Folly - <a href="https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md">ProducerConsumerQueue</a> (documentation) - Code: <a href="https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h">ProducerConsumerQueue.h</a></li>

<li><a href="https://juanchopanzacpp.wordpress.com/2013/02/26/concurrent-queue-c11/">Concurrent queue  C++11 | Juan's C++ blog</a></li>
</ul>


<p>
Example of Message Queue Behavior in Pseudocode: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Message queue of fixed size 10 </span>
<span class="org-type">fixed_message_queue</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">buffer</span><span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]{</span>
   <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span>buffer.is_closed<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span>
      sleep<span class="org-rainbow-delimiters-depth-4">(</span>2<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread if the queue is empty </span>
      <span class="org-type">double</span> <span class="org-variable-name">next</span> = buffer.take<span class="org-rainbow-delimiters-depth-4">()</span>;   
      print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Received message x = %.3f"</span>, next<span class="org-rainbow-delimiters-depth-4">)</span>;
   <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">producer_thread</span> = thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]{</span>
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = 0.0; x &lt; 100.0; x += 2.0<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
      sleep<span class="org-rainbow-delimiters-depth-4">(</span>10<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-type">double</span> <span class="org-variable-name">y</span> = 4 * x + 10;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread if the queue is full (has 10 elements)</span>
      <span class="org-type">double</span> <span class="org-variable-name">next</span> = buffer.put<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;   
      print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Received message x = %.3f"</span>, next<span class="org-rainbow-delimiters-depth-4">)</span>;
   <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates that messages will no longer be sent </span>
   queue.close<span class="org-rainbow-delimiters-depth-3">()</span>;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Message Passing Concurrency in other languages</b> 
</p>

<ul class="org-ul">
<li><a href="https://golang.org/doc/effective_go.html#concurrency">Effective Go - The Go Programming Language</a> - Concurrency</li>

<li><a href="https://bartoszmilewski.com/2009/07/16/on-actors-and-casting/">On Actors and Casting | Bartosz Milewski's Programming Cafe</a></li>
</ul>

<p>
<b>C++ Implementations of Message Passing</b> (Message Queue / Actor Model and CSP)
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/dd492627(v=vs.100)?redirectedfrom=MSDN">Asynchronous Agents Library | Microsoft Docs</a> - PPL Library</li>

<li><a href="https://github.com/Himmele/Mindroid.ecpp">Mindroid.ecpp: Mindroid.ecpp</a> - is an embedded application
framework inspired by Google's Android operating system</li>

<li><a href="http://web.archive.org/web/20090303231159/http://www.ddj.com/hpc-high-performance-computing/210604448">Writing Lock-Free Code: A Corrected Queue</a> - Herb Sutter</li>

<li><a href="https://stackoverflow.com/questions/26489876/what-is-the-best-practice-for-passing-data-between-threads-queues-messages-or">c++ - What is the best practice for passing data between threads? Queues, messages or others?</a></li>

<li><a href="https://github.com/cameron314/concurrentqueue">cameron314/concurrentqueue</a>
<ul class="org-ul">
<li>"A fast multi-producer,  multi-consumer lock-free concurrent queue for C++11"</li>
</ul></li>

<li>Facebook's Folly - <a href="https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md">ProducerConsumerQueue</a> (documentation) - Code: <a href="https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h">ProducerConsumerQueue.h</a></li>

<li><a href="https://juanchopanzacpp.wordpress.com/2013/02/26/concurrent-queue-c11/">Concurrent queue  C++11 | Juan's C++ blog</a></li>

<li><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/thread/sds.html#thread.sds.synchronized_queues">Boost Synchronized Data Structure - Synchronized Queue</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/parallel/concrt/reference/concurrent-queue-class?view=vs-2019">concurrent_queue Class | Microsoft Docs</a></li>

<li><a href="https://codereview.stackexchange.com/questions/128832/c11-blocking-queue-learning-exercise">c++ - C++11 Blocking Queue learning exercise - Code Review Stack Exchange</a></li>

<li><a href="https://gist.github.com/thelinked/6997598">C++11 blocking queue using the standard library.  GitHub</a></li>

<li><a href="https://github.com/Balnian/ChannelsCPP">GitHub - Balnian/ChannelsCPP: C++ implementation of the Go (GoLang) Channel and Select structure</a></li>

<li><a href="https://gist.github.com/vmrob/e4fde208302ae8979b57">Go channels in C++  GitHub</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf5c6ae3" class="outline-4">
<h4 id="orgf5c6ae3"><span class="section-number-4">1.9.2</span> Producer/consumer problem with messague queue</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
The producer consumer synchronization problem can be simplified with a
message queue (aka concurrent blocking queue) which encapsulates the
data structure implementation and the all synchronization promitives.
</p>

<p>
Requirements: 
</p>

<ul class="org-ul">
<li>The <span class="underline">producer thread</span> puts an element in the queue and signals the
condition variable what wakes up the <span class="underline">consumer thread</span>.</li>

<li>When the queue is empty, the <span class="underline">consumer thread</span> gets in sleep state
and waits for some element to be put into the queue.</li>

<li>The access to the queue must be thread-safe.</li>
</ul>

<p>
Parts of standard library used: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard">lock:guard</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/queue">queue</a></li>
</ul>

<p>
<b>Example:</b> Simple Blocking Queue Implementation for consumer/producer problem. 
</p>

<p>
File: concurrent_queue.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">threads</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>  <span class="org-comment-delimiter">// </span><span class="org-comment">mutex, lock_guard, unique_lock</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">conditional_variables</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">MessageQueue</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-type">guard</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-2">&gt;</span>;

    <span class="org-constant">std</span>::<span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>           <span class="org-variable-name">m_queue</span>;
    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">m_cvar</span>;
    <span class="org-keyword">mutable</span> <span class="org-constant">std</span>::<span class="org-type">mutex</span>      <span class="org-variable-name">m_mutex</span>;

<span class="org-function-name">public</span>:
    <span class="org-function-name">MessageQueue</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by producer thread</span>
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.push<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp;&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.push<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">blocks consumer thread making</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">it sleep when the queue is empty</span>
    <span class="org-type">void</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.pop<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread</span>
    <span class="org-type">T</span>&amp; <span class="org-function-name">front</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::unique_lock<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">The second argument of m_cvar.wait, a lambda function is</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">passed as predicate to prevent spurious thread wake up.</span>
        m_cvar.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">T</span>&amp; <span class="org-variable-name">result</span> = m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
        lock.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread</span>
    <span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-function-name">front</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::unique_lock<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">T</span>&amp; <span class="org-variable-name">result</span> = m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
        lock.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span>  m_queue.size<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>* <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-type">MessageQueue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">queue</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex used for protecting std::cout from frace condition</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">output_mutex</span>;
    <span class="org-constant">std</span>::<span class="org-type">atomic_bool</span> <span class="org-variable-name">finished</span> = <span class="org-constant">false</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-5">(</span>output_mutex<span class="org-rainbow-delimiters-depth-5">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Consumer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">value</span> = queue.front<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-rainbow-delimiters-depth-5">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-6">(</span>output_mutex<span class="org-rainbow-delimiters-depth-6">)</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Wait input ..."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Received value = "</span> &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>
            queue.pop<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-negation-char">!</span>queue.empty<span class="org-rainbow-delimiters-depth-6">()</span> &amp;&amp; finished<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-comment-delimiter">// </span><span class="org-comment">Protect cout from race condition</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-3">(</span>output_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Start interactive SHELL OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">The producer thread is the current one (main thread)</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 5; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span>1s<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">double</span> <span class="org-variable-name">x</span> = i * i - 4 * i + 10.0 ;
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-4">(</span>output_mutex<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] =&gt; Sending number: "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        queue.push<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    finished = <span class="org-constant">true</span>;
    consumer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ message_queue.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -Wall -g -lpthread
</pre>
</div>

<p>
Running:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ out.bin  
 [TRACE] Start interactive SHELL OK.
 [CONSUMER] Consumer thread started.
 [PRODUCER] =&gt; Sending number: 10
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 10
 [PRODUCER] =&gt; Sending number: 7
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 7
 [PRODUCER] =&gt; Sending number: 6
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 6
 [PRODUCER] =&gt; Sending number: 7
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 7
 [PRODUCER] =&gt; Sending number: 10
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 10
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1b2809" class="outline-4">
<h4 id="orga1b2809"><span class="section-number-4">1.9.3</span> References</h4>
<div class="outline-text-4" id="text-1-9-3">
<ul class="org-ul">
<li><b>Chapter 10 - Concurrency - Message Passing</b>
<ul class="org-ul">
<li><a href="https://www.doc.ic.ac.uk/~jnm/book/firstbook/pdf/ch10.pdf">https://www.doc.ic.ac.uk/~jnm/book/firstbook/pdf/ch10.pdf</a></li>
</ul></li>

<li><b>Reading 22: Queues and Message-Passing</b> - MIT 
<ul class="org-ul">
<li><a href="http://web.mit.edu/6.031/www/fa17/classes/22-queues/">http://web.mit.edu/6.031/www/fa17/classes/22-queues/</a></li>
<li>Note: contains "Implementing message passing with queues"</li>
</ul></li>

<li><b>Two models for concurrent programming</b> - MIT 
<ul class="org-ul">
<li><a href="http://web.mit.edu/6.031/www/fa17/classes/19-concurrency/#two_models_for_concurrent_programming">http://web.mit.edu/6.031/www/fa17/classes/19-concurrency/#two_models_for_concurrent_programming</a></li>
</ul></li>

<li><b>Android Style Message Passing</b> - Communicating between Threads using Message Queues.
<ul class="org-ul">
<li><a href="http://blog.coldflake.com/posts/Android-style-Message-Passing/">http://blog.coldflake.com/posts/Android-style-Message-Passing/</a></li>
<li>Coverage: Message queue, active object.</li>
</ul></li>

<li><b>Programming with Trheads - Synchronization and Communication</b> [PAPER]
<ul class="org-ul">
<li><a href="https://cms.uni-konstanz.de/fileadmin/archive/deussen/fileadmin/informatik/ag-deussen/2011/heck2011-programming_with_threads.pdf">https://cms.uni-konstanz.de/fileadmin/archive/deussen/fileadmin/informatik/ag-deussen/2011/heck2011-programming_with_threads.pdf</a></li>
</ul></li>

<li><b>Producer consumer design pattern</b> - DZone 
<ul class="org-ul">
<li><a href="https://dzone.com/articles/producer-consumer-pattern">https://dzone.com/articles/producer-consumer-pattern</a></li>
</ul></li>

<li><b>A Thread-Safe Message Queue</b>
<ul class="org-ul">
<li><a href="https://wiki.tcl-lang.org/page/A+Thread-Safe+Message+Queue">https://wiki.tcl-lang.org/page/A+Thread-Safe+Message+Queue</a></li>
</ul></li>

<li><b>How to use wait, nitifyAll in Java - Producer Consumer Example</b>
<ul class="org-ul">
<li><a href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html">https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html</a></li>
</ul></li>

<li><b>5. Message Passing</b>
<ul class="org-ul">
<li><a href="https://cs.gmu.edu/~rcarver/ModernMultithreading/LectureNotes/chapter5notes-2up.pdf">https://cs.gmu.edu/~rcarver/ModernMultithreading/LectureNotes/chapter5notes-2up.pdf</a></li>
</ul></li>

<li>Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0260r3.html">WG21 - C++ Concurrent Queues</a> - Lawerence Crwol, Chris Mysen
<ul class="org-ul">
<li>"Concurrent queues are a fundamental structuring tool for
concurrent programs. We propose a concurrent queue concept and a
concrete implementation. We propose a set of communication types
that enable loosely bound program components to dynamically
construct and safely share concurrent queues."</li>
</ul></li>

<li><a href="https://www.baeldung.com/java-blocking-queue">Guide to java.util.concurrent.BlockingQueue | Baeldung</a>
<ul class="org-ul">
<li>Shows how a concurrent queue works and solves the
producer/consumer problem.</li>
</ul></li>

<li><a href="https://vorbrodt.blog/2019/02/03/blocking-queue/">Blocking queue  Vorbrodt's C++ Blog</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Caio Rodrigues Soares - caiorss [DOT] rodrigues [AT] gmail [DOT] COM</p>
<p class="date">Created: 2019-09-16 Mon 19:42</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
