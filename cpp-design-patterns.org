#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Design Patterns 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

- [[wiki:index][Index]]

* General Design Patterns 
** General Techniques / Mechanism for Code Reuse 

 + *Inheritance*
   + Dynamic / Runtime / Subtyping Polymorphism.
   + Benefits:
     + Allow switching implementation at runtime, store
       different objects (pointers, smart pointers or references) at the
       same container, defer method calls to specific implementation and
       allow a client code work with multiple different implementations
       at runtime. Inheritance alone is not evil, the problem is deep
       inheritance hierarchies.
   + Drawbacks:
     + Loss of value semantics and intrusive.
     + Classes must inherit from the same base class which requires
       modification. 
     + Objects can only be returned from factory functions as pointers
       or pointers wrapped by smart pointers.
     + Slower speed than static polymorphism (templates and overloaded
       functions or methods.)

 + *Delegation* (a kind of OO composition)
   + Use another object for implementing some functionality and
     forward a method call to it instead of inheriting the object
     class. Examples: store items in a std::vector, instead of storing
     them directly in the class with heap-allocated arrays; store an
     heap-allocated object using smart pointers rather than storing it
     using raw pointer and freeing it on the destructor.

 + *Static Polymorphism*
   + It is templates and overloaded functions or methods.
   + Templates can eliminate virtual method call overhead by resolving
     methods at compile-time rather than at runtime.

 + *Type Erasure*
   + Combination of static and dynamic polymorphism which gets the
     best of both sides with minimal overhead.

 + *Free Functions*
   + C++ is a multiparadigm language and not everything needs to to be
     a class. So, functions can be used to extending classes without
     modifying them by taking objects as arguments and applying
     operations on them. 

 + *Higher Order Functions / Higher Order Methods / Lambda Functions*
   + Lambda function can be used to add new behaviors to an object at
     runtime, create generalized algorithms, functions, simplify event
     handling, callbacks and design patterns.  
** Singleton 

Singleton is a creational design pattern where there is only a single
instance of a class and client code is forbidden from creating new
instances.

Note: Despite that there are lots of objections against this design
pattern, it is still worth knowing how it works.

 + File: [[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]
 + Onlien Compiler: https://rextester.com/SJWB72590

Header of class FileRepository => (FileRepository.hpp)

#+BEGIN_SRC cpp
  //----- file: FileRepository.hpp ------//
  #ifndef __file_repository 
  #define __file_repository
  #include <std::string>

  class FileRepository
  {
  private:
      std::deque<std::string> _files;	
      // Forbid client code instating a new instance. 
      FileRepository(){
         std::cerr << " [LOG] File Respository Initialized." << "\n";
      }	
      // Forbid client code from creating a copy or using the
      // copy constructor.
      FileRepository(const FileRepository&){}		
  public:
      ~FileRepository();
	
      // Return a reference to not allow client code 
      // to delete object. 	
      static auto getInstance() -> FileRepository&;	

      // Use old C++ 'member function' syntax.
      void addFile(std::string fname);
      void clearFiles();
      // C++11 member function declaration looks better. 
      auto showFiles() -> void;
  };
  #endif 
#+END_SRC

Implementation of FileRepository (FileRepository.cpp)

#+BEGIN_SRC cpp
  #include <iostream>
  #include "FileRepository.hpp"

  FileRepository::~FileRepository(){
        std::cerr << " [LOG] File Respository Deleted. Ok." << "\n";
  }

  // Static method 
  auto FileRepository::getInstance() -> FileRepository& {
       static auto instance = std::unique_ptr<FileRepository>{nullptr};		
       // Initialized once - lazy initialization 
       if(!instance)
            instance.reset(new FileRepository);		
       return *instance.get();
  }

  void FileRepository::addFile(std::string fname){
       _files.push_back(std::move(fname));
  }

  void FileRepository::clearFiles(){
       _files.clear();
  }
  // C++11 Member function declaration 
  auto FileRepository::showFiles() -> void {
       for(const auto& file: _files)
          std::cout << " File = " << file << std::endl;
  }
#+END_SRC

Test in CERN ROOT/Clign REPL:

#+BEGIN_SRC cpp 
   // Load C++ code as it was a script.
   >> .L singleton1.cpp

   // Try to instantiate singleton object without reference. 
   //------------------------------------------------------
   >> FileRepository repo = FileRepository::getInstance()
   ROOT_prompt_2:1:23: error: calling a private constructor of class 'FileRepository'
   FileRepository repo = FileRepository::getInstance()
                         ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> FileRepository& repo = FileRepository::getInstance()
   [LOG] File Respository Initialized.

   (FileRepository &) @0x2fc9640
   >> 

   >> repo.showFiles()
   >> 
   >> repo.addFile("quarterly-sales-report.dat")
   >> repo.addFile("interest-payments.txt")
   >> repo.addFile("taxes-report.xls")
   >> repo.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 
   >> 

   // Try to copy object. 
   >> FileRepository r = repo;
   ROOT_prompt_9:1:20: error: calling a private constructor of class 'FileRepository'
   FileRepository r = repo;
                      ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> 

   // Try to create a new object 
   >> FileRepository& repo2 = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> repo2.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 

   // Check whether repo and repo2 are the same object (reference equality)
   // -> They are equal under reference equality criteria if they have the same address.
   >> &repo == &repo2
   (bool) true
   >> 

   // Exit REPL.
   >> .q
  [LOG] File Respository Deleted. Ok.
#+END_SRC

Main function: 

#+BEGIN_SRC cpp
  FileRepository& repo1 = FileRepository::getInstance();
  repo1.addFile("CashFlowStatement.txt");
  repo1.addFile("Balance-Sheet.dat");
  repo1.addFile("Sales-Report.csv");

  FileRepository& repo2 = FileRepository::getInstance();

  std::cout << std::boolalpha << "Same object? (&repo == &repo1 ?) = "
            << (&repo1 == &repo2)
            << "\n";
  std::cout << "Repository files" << std::endl;
  repo2.showFiles();

  std::cout << "Add more files" << std::endl;
  repo2.addFile("fileX1.pdf");
  repo2.addFile("fileX2.pdf");
  repo2.addFile("fileX3.pdf");
  repo2.showFiles();
#+END_SRC

Compiling and running ([[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]): 

#+BEGIN_SRC txt 
  clang++ singleton1.cpp -o singleton1.bin -g -std=c++14 -Wall -Wextra && ./singleton1.bin

   [LOG] File Respository Initialized.
  Same object? (&repo == &repo1 ?) = true
  Repository files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
  Add more files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
   File = fileX1.pdf
   File = fileX2.pdf
   File = fileX3.pdf
   [LOG] File Respository Deleted. Ok.
#+END_SRC

** Named constructor - static factory method

The named constructor or static factory design pattern uses static
methods instead of constructors for instantiating objects. This
approach has many advantages over constructor instantiation. Named
constructors are more readable than ordinary constructors and unlike
constructors, many named constructors static methods sharing the same
type signature can coexist. Another benefit is that this technique
allows objects to be instantiated in many different ways from several
different data representation.

Side note: It should not be confused with factory design pattern or
abstract factory design pattern.

Example:

#+BEGIN_SRC cpp   :results output pp :exports both 
  #include <iostream>
  #include <ostream>
  #include <cstdint>

  // #include <stdint>   // WARNING - It may not be available

  // Unsigned byte from 0 to 255 or 0x00 to 0xFF
  // ---> typedef uint8_t ubyte;
  using ubyte = uint8_t ; 

  class Color{
  private:
      ubyte m_r;
      ubyte m_g;
      ubyte m_b;
  public:
      Color(ubyte red, ubyte green, ubyte blue):
          m_r(red), m_g(green), m_b(blue) {}
      ubyte red(){
          return m_r;
      }
      ubyte blue(){
          return m_b;
      }
      ubyte green(){
          return m_g;
      }
      // Named constructor or static factory method which builds the object
      // From the RGB tuple data representation 
      static Color fromRGB(ubyte red, ubyte green, ubyte blue){
          return Color(red, green, blue);
      }
      // Named constructor which builds Color object 
      // from hexadecimal data representation 
      static Color fromHex(int color){
          int r = color & 0xFF;
          int g = (color >> 8 ) & 0xFF;
          int b = (color >> 16) & 0xFF;
          return Color(r, g, b);
      }
      // Named constructor which builds a specific color.
      static Color colorRED(){
          return fromRGB(255, 0, 0);
      }
      static Color colorBLUE(){
          return fromRGB(0, 255, 0);
      }
      static Color colorGREEN(){
          return fromRGB(0, 0, 255);
      }
      friend std::ostream& operator <<(std::ostream& os, const Color& c){
          os << "Color(r = "
             << static_cast<int>(c.m_r)
             << ", g = " << static_cast<int>(c.m_g)
             << ", b = " << static_cast<int>(c.m_b) << ")";
          return os;
      }      
  };

  int main(){
      std::cout << "Red    = " << Color::colorRED()   << "\n";
      std::cout << "Blue   = " << Color::colorBLUE()  << "\n";
      std::cout << "Green  = " << Color::colorGREEN() << "\n";
      std::cout << "Color1 = " << Color::fromRGB(20, 90, 200) << "\n";
      std::cout << "Color2 = " << Color::fromHex(0xFF8AB5) << "\n";
      std::cout.flush();
      return 0;
  }
#+END_SRC

#+RESULTS:
: Red    = Color(r = 255, g = 0, b = 0)
: Blue   = Color(r = 0, g = 255, b = 0)
: Green  = Color(r = 0, g = 0, b = 255)
: Color1 = Color(r = 20, g = 90, b = 200)
: Color2 = Color(r = 181, g = 138, b = 255)

See: 
 + [[https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)][Factory (object-oriented programming) - Wikipedia]]

** Factory Method 
*** Overview  

Factory method design pattern allows instatiating classes from a class
hierarchy without hardcoding the class name and kwnowing the class
implementation. There are many variations of this design pattern,
however the most common form is a class with method which returns an
instance of a derived class based on some input such as a number,
code, class name as string or number.

Definitions: 

 + Factory method or factory functions are any methods or functions
   which returns an instance of a class or derived class.

Note: The factory design pattern in this document is the variation
which creates an instance of a set of derived classes based on some
input. 

*** Factory Method Pattern Variations 

Some variations: 

 + _An ordinary function_ whith if-else statements which returns an
   instance of a set of derived  classes according to some
   input.
   + Disadvantage: Adding new derived classes requires code
     modification.

 + _A static method_ with if-else statements. This is mostly used on
   languages where there are not free functions or ordinary
   functions.
   + Disadvantage: Requires modifying the code when new classes are
     added to the hierarchy. 

 + _Registry-based factory_ (mostly known as Polymorphic Factory)- A
   class contains a factory method for instantiating derived classes
   based on some input and a hash table for registration of derived
   classes.
   + Disadvantage: Possibly requires manual registration during the
     program initialization.

   + Example:
     + Factory.register("sql",   SQLCreator)
     + Factory.register("mysql", MYSQLCreator)
     + DBDrivef driver = Factory.create("sqlite");

 + _Reflection-base factory_ - Some implementations uses reflection
   registration of derived classes.
   + Disadvantage: May not be possible in languages without reflection
     such as C++.

*** Sample Class Hierarchy 

Consider the following class hierarchy: 

 + Base class 

#+BEGIN_SRC cpp 
  class Base{
  public:
     Base() = default;
      // Destructor of base class must always be virtual 
      virtual ~Base() = default;   
      virtual auto getType() const -> std::string {
        return "Base";
     }	
     void showType(){
        std::cout << "Class type = " << this->getType() << "\n";
     }
  };
#+END_SRC

 + Derived class A 

#+BEGIN_SRC cpp 
class DerivedA: public Base{
public:
    DerivedA(){}
    auto getType() const  -> std::string {
       return "DerivedA";
    }
};
#+END_SRC

 + Derived class B

#+BEGIN_SRC cpp 
  class DerivedB: public Base{
  public:
     DerivedB(){}
     auto getType() const -> std::string {
        return "DerivedB";
     }
  };
#+END_SRC

*** Simple factory - if-else statement

Note: This implementation uses a factory function instead of a factory
method. The function creates an instance of Base, DerivedA or DerivedB
based on the provided name. The problem of this implementation is that
it requires modification of the code when new derived classes are
added.

#+BEGIN_SRC cpp 
  #include <memory> // smart pointers 
 
  auto simpleFactory(const std::string& name) -> std::unique<Base> {
       if(name == "Base")
           return std::make_unique<Base>();
       if(name == "DerivedA")
           return std::make_unique<DerivedA>();
       if(name == "DerivedB")
           return std::make_unique<DerivedB>();
       return nullptr;
  }

  >> auto base = simpleFactory("Base");
  >> if(base) { std::puts("Ok, then proceed."); }
  Ok, then proceed.

  >> base->getType()
  (std::string) "Base"

  >> auto da = simpleFactory("DerivedA");
  >> da->getType()
  (std::string) "DerivedA"
  >> 
#+END_SRC

*** Polymorphic Factory - registry based factory

Despite this implementation be more complex than a factory-method
pattern implementation using if-else statement, this one doesn't
require source modification if new derived classes are added to the
hierarchy. 

The class Factory is used for instantiating derived classes of Base
class based on the class name provided as a string. The factory
methods in this class are makeUnique and makeRaw.

 + File:
   + [[file:src/design-patterns/factory-pattern1.cpp][file:src/design-patterns/factory-pattern1.cpp]]
 + Online Compiler:
   + https://rextester.com/ILKI85678

#+BEGIN_SRC cpp 
  class Factory{
  private:
      using FactoryMap = std::map<std::string, Factory*>;
      // Force global variable to be initialized, thus it avoid
      // the inialization order fisaco. 
      static auto getRegister() -> FactoryMap& {
         static FactoryMap classRegister{};
         return classRegister;
      }
  public:	
      /** Register factory object of derived class */
      static
      auto registerFactory(const std::string& name, Factory* factory) -> void {
           auto& reg = Factory::getRegister();
           reg[name] = factory;
      }
      /** Show all registered classes */
      static
      auto showClasses() -> void {
           std::cout << " Registered classes. " << "\n";
           std::cout << " =================== " << "\n";
           for(const auto& pair: Factory::getRegister())
                   std::cout << " + " << pair.first << "\n";
      }		
      /**  Construct derived class returning a raw pointer */
      static
      auto makeRaw(const std::string& name) -> Base* {
           auto it = Factory::getRegister().find(name);
           if(it != Factory::getRegister().end())
                   return it->second->construct();
           return nullptr;
      }

      /** Construct derived class returning an unique ptr  */
      static
      auto makeUnique(const std::string& name) -> std::unique_ptr<Base>{
          return std::unique_ptr<Base>(Factory::makeRaw(name));
      }

      // Destructor 
      virtual
      ~Factory() = default;

      virtual
      auto construct() const -> Base* = 0;
  };
#+END_SRC
 
Concrete Factory: 

 + Template class used for creating static object which registers the
   associated derived class during the program initialization before
   the function main. 

#+BEGIN_SRC cpp 
  template<typename DerivedClass>
  class ConcreteFactory: Factory{
  public:
     // Register this global object on the Factory register 
     ConcreteFactory(const std::string& name){
        std::cerr << " [TRACE] " << " Registered Class = " << name << "\n";
        Factory::registerFactory(name, this);
     }
     auto construct() const -> Base* {
        return new DerivedClass;
     }	
  };
#+END_SRC

Manual class registration: 

#+BEGIN_SRC cpp 
  // Register Base class
  namespace {
     // Anonymous namespace is used to make the definitions here private to the current
     // compilation unit (current file). It is equivalent to the old C static keyword.
     // It could be placed at Base.cpp 
     ConcreteFactory<Base> factoryBase("Base");
  }
#+END_SRC

Class registration with macros:

#+BEGIN_SRC cpp 
  // Macro for class registration 
  #define REGISER_FACTORY(derivedClass) \
          namespace { auto registry_ ## derivedClass = ConcreteFactory<derivedClass>(#derivedClass);  }

  //  Registration with macro. 
  REGISER_FACTORY(DerivedA);
  REGISER_FACTORY(DerivedB);
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
    Factory::showClasses();
    std::cout << "\n";
    std::unique_ptr<Base> objBase = Factory::makeUnique("Base");
    std::cout << " type of objBase = " << objBase->getType() << "\n";

    std::unique_ptr<Base> objDA = Factory::makeUnique("DerivedA");
    std::cout << " type of derivedA = " << objDA->getType() << "\n";

    std::unique_ptr<Base> objDB = Factory::makeUnique("DerivedB");
    std::cout << " type of derivedA = " << objDB->getType() << "\n";

    std::unique_ptr<Base> objDC = Factory::makeUnique("Derived-error");
    if(!objDC)
       std::cout << " ==> Error: object not found in factory" << '\n';
#+END_SRC

Output:

#+BEGIN_SRC txt 
  $ clang++ factory-pattern1.cpp -o factory-pattern1.bin -g -std=c++1z -Wall -Wextra $

  $ ./factory-pattern1.bin
   [TRACE]  Registered Class = Base
   [TRACE]  Registered Class = DerivedA
   [TRACE]  Registered Class = DerivedB
   Registered classes. 
   =================== 
   + Base
   + DerivedA
   + DerivedB

   type of objBase = Base
   type of derivedA = DerivedA
   type of derivedA = DerivedB
   ==> Error: object not found in factory
#+END_SRC

*** References

 *References*

 + Bruce Eckel - *Thinking in Patterns with Java* - Page: 53
   + <http://www.cs.huji.ac.il/~noam/intro2cs2001/www/TIPatterns.pdf>

 + Bruce Eckel - *Thinking in C++, 2nd edition, Volume 2*
   + <http://www.cs.cmu.edu/~gregjor/project/eckelbook/volume2/Chap11.htm>

 + http://www.lsi.us.es/~jtorres/LibroJava/TIJ2R3-17_.html

 + [[http://www.andypatterns.com/index.php/blog/from_strategy_to_bridge/][AndyPatterns - From Strategy to Bridge]]

 + [[http://www.thedevpiece.com/cdi-polymorphism-and-the-factory-pattern/][CDI, Polymorphism and The Factory Pattern]]

 + Design patterns - OOD Lecture 6 -
   <https://www.it.uu.se/edu/course/homepage/ood/ht12/overview/patterns/Lecture6.pdf>

 + Creational Patterns for Variability
   + <http://www-st.inf.tu-dresden.de/Lehre/WS04-05/dpf/slides/2b-creational-variability-2p.pdf>

 + the Factory Design Pattern -
   <https://cs.anu.edu.au/courses/comp2500/notes/15factory.slides.pdf>

 + Design Patterns as Quality Influencing Factor in Object Oriented
   Design Approach - <https://arxiv.org/pdf/1402.2372.pdf>

 + [[https://www.journaldev.com/1392/factory-design-pattern-in-java][Factory Design Pattern in Java - JournalDev]]

 + [[https://industriallogic.com/xp/refactoring/polymorphicCreationFactory.html][Introduce Polymorphic Creation with Factory Method]]

 + Factory Method -
   <https://www.dofactory.com/net/factory-method-design-pattern> 

 *Further Reading* 

 + *Doing something on shared library initialization*
   + <http://zerohour.net/~reed/dylib_init.html>

 + *Factory Design Pattern in C++*
   + <http://blog.fourthwoods.com/2011/06/04/factory-design-pattern-in-c/>

 + *Abstract Factory Step-by-Step Implementation in C++*
   + <http://www.dorodnic.com/blog/2014/03/29/abstract-factory/>

 + *Sutter's Mill - GotW #90 Solution: Factories*
   + <https://herbsutter.com/2013/05/30/gotw-90-solution-factories/>

 + *Unforgettable Factory Registration*
   + <http://www.nirfriedman.com/2018/04/29/unforgettable-factory/>

 + *C++: Factory With Self-Registering Types*
   + <https://dzone.com/articles/factory-with-self-registering-types>

 + *Object Factories in a Static Library*
   + <http://www.sourcexr.com/articles/2014/06/21/object-factory-in-a-static-library>

 + *Automatic object factory in C++*
   + <https://blog.noctua-software.com/object-factory-c++.html>

 + *Self Registering Classes - Taking polymorphism to the limit*
   + <https://accu.org/index.php/journals/597>

** Builder (Joshua Blosh)

The purpose of the builder design pattern proposed by Joshua Bloch is
to simplify the instantiation of objects with many constructor
parameters or many optional parameters. Note: it should not be
confused with the GOF (Gang of Four) builder pattern.

Example: 

 - File: builder.cpp 

#+BEGIN_SRC cpp 
  // Joshua Bloch's Builder Pattern for simplifying the instantiation
  // of objects with many constructor parameters. It is not the
  // GOF (Gang of Four) builder pattern. 
  #include <iostream>
  #include <string>

  // Function meta object 
  class UserData{
  public:
          using ulong = unsigned long;
  private:
          ulong          _userID = 0;
          std::string    _name;
          std::string    _lastName;
          std::string    _email;
          UserData() = default;
  public:
          // Explicit is better than implicit 
          ~UserData() = default;
	
          auto show() -> void
          {
              std::cout << "\nUser{"
                        << "\n" << "  id        = " << _userID
                        << "\n" << "  name      = " << _name
                        << "\n" << "  last name = " << _lastName
                        << "\n" << "  email     = " << _email
                        << "\n" << "}"
                        << "\n";
          }
	
          // Allow builder class access UserData's private data
          friend class UserBuilder;
  }; //--- EoF class UserData --- //

  class UserBuilder{
  private:
          //class UserData;
          UserData _data{};
  public:
          UserBuilder(){
                  // _data = UserData();
          }		
          auto setID(ulong userID ) -> UserBuilder& {
             _data._userID = userID;
             return *this;
          }
          auto setName(const std::string& name) -> UserBuilder& {
              _data._name = name;
              return *this;
          }
          auto setLastName(const std::string& name) -> UserBuilder& {
              _data._lastName = name;
              return *this;
          }
          auto setEmail(const std::string& email) -> UserBuilder& {
             _data._email = email;
             return *this;
          }
          auto build() -> UserData {
             return this->_data;
          }
  }; //--- EoF class UserData::builder --- //

  int main(){
      auto user0 =
              UserBuilder()
              .setID(2065)
              .setName("John")
              .setLastName("Von Neumman")
              .setEmail("nx098774a@sknmap.co")
              .build();
      auto user1 =
              UserBuilder()
              .setID(1065)
              .setName("Enrico")
              .setLastName("Fermi")
              .setEmail("dummyEmail@service1.co.uk")
              .build();
      auto user2 =
              UserBuilder()
              .setID(2001)
              .setName("Stanislaw")
              .setLastName("Ulam")
              .setEmail("wsx752@couk.com.sk")
              .build();
      user0.show();
      user1.show();		
      user2.show();
      return EXIT_SUCCESS;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ g++ builder.cpp -o builder.bin -g -std=c++1z -Wall -Wextra && ./builder.bin
   User{
     id        = 2065
     name      = John
     last name = Von Neumman
     email     = nx098774a@sknmap.co
   }

   User{
     id        = 1065
     name      = Enrico
     last name = Fermi
     email     = dummyEmail@service1.co.uk
   }

   User{
     id        = 2001
     name      = Stanislaw
     last name = Ulam
     email     = wsx752@couk.com.sk
   }
#+END_SRC
** Strategy
*** Overview  

Intent: A behavioral design pattern from GOF which allows the client
code to select and change an algorithm encapsulated as an object at
runtime.

Note: this design pattern is similar to a callback and can be
simplified with functional programming. 

 *Parts:*

 + _Context_:
   + Object that has a reference to an strategy objects and sets the
     strategy at runtime.
   + Resposibilities:
     + Set strategy
     + Change strategy
     + Invoke strategy

 + _IStrategy_: (Algorithm interface)
   + Strategt interface define the algorithm operations.

 + _Concrete strategy_.
   + Strategies objects or implementation of IStrategy class.
*** Example 

Code: 
 + File: [[file:src/design-patterns/strategy-pattern1.cpp][file:src/design-patterns/strategy-pattern1.cpp]]
 + Online Compiler: https://rextester.com/WQO93455

Strategy interface: 

#+BEGIN_SRC cpp 
  // Strategy interface 
  struct IStrategy{
    virtual ~IStrategy(){}
    // Essential: Algorithm encapsulated by strategy object 
    virtual auto compute(double x, double y) const -> double = 0;  
    // Optional: Provides strategy metadata 
    virtual auto name() const -> const std::string = 0;
    // Clone this object (Note: This is a virtual constructor)
    virtual auto clone() const -> IStrategy* = 0;
  };
#+END_SRC

Context Class: 
 - Selects and switch the strategy (aka algorithm).

#+BEGIN_SRC cpp 
  class Context{
  private: 
    std::unique_ptr<IStrategy> _strategy;
  public:
    Context()
      : _strategy{nullptr} { }
    Context(IStrategy* s)
      : _strategy{s} { }
    Context(const IStrategy& s)
      : _strategy{s.clone()} { }
    auto setStrategy(IStrategy* s){
      _strategy.reset(s);
    }
    auto setStrategy(const IStrategy& s){
      _strategy.reset(s.clone());
    }  
    auto compute(double x, double y) -> void {
      if(_strategy == nullptr)
        std::runtime_error("Error: strategy not set");
      double result = _strategy->compute(x, y);
      std::cout << " strategy = " << _strategy->name() << " "
                << "( x = " << x << " ; "
                << "y = " << y << " )"
                << "\n" ;
      std::cout << "Result = " << result << "\n";
    }
  };
#+END_SRC

Concrete strategies: 

 - add => algorithm which adds two numbers.

#+BEGIN_SRC cpp 
  class AddStrategy: public IStrategy {
  public:
    auto name() const -> const std::string{
      return "add";
    }
    auto compute(double x, double y) const -> double {
      return x + y;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] AddStrategy => I was cloned" << "\n";
      return new AddStrategy(*this);
    }
  };
#+END_SRC

 + Multiplication 

#+BEGIN_SRC cpp 
  struct MulStrategy: public IStrategy {
  public:
    auto name() const -> const std::string{
      return "mul";
    }  
    double compute(double x, double y) const {
      return x + y;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] MulStrategy => I was cloned" << "\n";
      return new MulStrategy(*this);
    }  
  };
#+END_SRC

 + Linear Combination: 

#+BEGIN_SRC cpp 
  struct LinearCombStrategy: public IStrategy {
    double a, b, c;
    LinearCombStrategy(double a, double b, double c)
      : a(a), b(b), c(c)
    {
    }
    auto name() const -> const std::string{
      return "Linear combination a * x + b * y + c";
    }    
    auto compute(double x, double y) const -> double{
      return a * x + b * y + c;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] LinearCombStrategy => I was cloned" << "\n";
      return new LinearCombStrategy(*this);
    }  
  };
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
  Context ctx;
  std::cout << "==== Strategy = add ====" << "\n";
  ctx.setStrategy(new AddStrategy);
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = mul ====" << "\n";
  ctx.setStrategy(new MulStrategy);
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = Linear combination ====" << "\n";
  ctx.setStrategy(new LinearCombStrategy(5, 3, 4));
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = Linear combination [2] ====" << "\n";
  auto comb1 = LinearCombStrategy(6.0, 5.0, 10.0);
  // Copy stack-allocated object comb1 using the virtual constructor
  ctx.setStrategy(comb1);
  ctx.compute(5.0, 3.0);  

  std::cout << "==== Strategy = Linear combination [2] ====" << "\n";  
  // Copy stack-allocated temporary object comb1 using the virtual constructor
  // clone
  ctx.setStrategy(LinearCombStrategy{6.0, 5.0, 10.0});
  ctx.compute(2.0, 6.0);  
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  $ clang++ strategy-pattern1.cpp -o strategy-pattern1.bin -g -std=c++1z -Wall -Wextra 
  $ ./strategy-pattern1.bin
  ==== Strategy = add ====
   strategy = add ( x = 3 ; y = 4 )
  Result = 7
  ==== Strategy = mul ====
   strategy = mul ( x = 3 ; y = 4 )
  Result = 7
  ==== Strategy = Linear combination ====
   strategy = Linear combination a * x + b * y + c ( x = 3 ; y = 4 )
  Result = 31
  ==== Strategy = Linear combination [2] ====
   [TRACE] LinearCombStrategy => I was cloned
   strategy = Linear combination a * x + b * y + c ( x = 5 ; y = 3 )
  Result = 55
  ==== Strategy = Linear combination [2] ====
   [TRACE] LinearCombStrategy => I was cloned
   strategy = Linear combination a * x + b * y + c ( x = 2 ; y = 6 )
  Result = 52

#+END_SRC

** Method Chaining - Fluent API

#+BEGIN_SRC cpp 
  class CharacterSuperMutant{
  private:
      double m_x;
      double m_y;
      double m_z;
  public:
      CharacterSuperMutant& setX(double x){
          m_x = x;
          return *this;
      }
      CharacterSuperMutant& setPosition(double x, double y, double z);

      auto setColor(COLOR color) -> decltype(this*)& {
          ... ....
          return *this;
      }
      // C++ 11 
      auto setForce(double force) -> CharacterSuperMutant& {
          ... ... 
          return *this;
      }   
     
      // Method / member function declaration, the implemention is in a different file.
      CharacterSuperMutant& CharacterSuperMutant::setPosition(double x, double y, double z);

      // C++11 
      auto CharacterSuperMutant::setStamina(double x, double y, double z) -> CharacterSuperMutant&;
  };

  // Example: Method implemented separated from class declaration in .cpp file.
  CharacterSuperMutant& CharacterSuperMutant::setPosition(double x, double y, double z){
      m_x = x; m_y = y; m_z  = z;
      return *this;
  }

  // C++11 auto syntax 
  auto CharacterSuperMutant::setStamina(double x, double y, double z) -> CharacterSuperMutant& {
      // ... ... ... 
      return *this;
  }

#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  CharacterSuperMutant mutant1;
  mutant1.setForce(1000).setColor(BLUE).setPosition(x).show();

  // Set methods at initialization 
  auto superMonster = CharacterSuperMutant().setForce(100).setPosition(4300).;

  // Instead of:
  mutant1.setForce(1000);
  mutant1.setColor(BLUE);
  mutant1.setPosition(x);
#+END_SRC

** GOF - Template Pattern 

It is stated by GOF as: "Defines the skeleton of an algorithm in a
method, deferring some steps to subclasses. Template Method lets
subclasses redefine certain steps of an algorithm without changing the
algorithms structure."

 + Intent: Create an algorithm template that allows redefine some
   steps without changing its structure.

The parent abstract class has four different types of methods:
 + _Concrete methods_: Methods implemented in the abstract class.

 + _Abstract methods_: Methods without implementation that must be
   implemented by subclasses.

 + _Hook methods_: Methods with default implementation that can be
   overriden by subclasses.

 + _Template methods_: Method that calls concrete methods, abstract
   methods or hook methods.

Participants: 
 + _Base Class_: Defines an algorithm which calls primitive methods (aka
   hook methods) that will be defined by the derived classes.
 + _Derived Class_: Implements primitive methods (virtual methods or
   methods that can be overriden) defined in the _base class_.

Features: 
 + The base class defines an algorithm stub, however some steps are
   required to be implemented by the derived class.
 + This pattern provides an _inverse control structure_, the algorithm
   defined in the base class which calls the primitive methods which
   are algorithm steps declared in the base class.
 + This pattern can be the base of an framework. 

Example: 

#+BEGIN_SRC cpp 
  class IntervalSummation{
  public:
   // Algorithm or entry point which calls the derived class method.
   // This is the template method 
   double summation(int lower, int upper) const{
           double sum = 0;
           for(int i = lower; i <= upper; i++)
                   sum += this->stepFn(i);
           return sum; 
   }
  protected:
      // Hook method or to be defined by the derived class
      virtual double stepFn(double x) const = 0 ;
  };

  class SumOfSquares: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x * x; }
  };

  void clientCode(const IntervalSummation& obj){
      std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

#+END_SRC

Running in CERN's ROOT REPL:

#+BEGIN_SRC sh 
  >> sq.summation(0, 10)
  (double) 385.00000

  >> sc.summation(0, 10)
  (double) 3025.0000

  >> clientCode(sq)
  Summation at [0, 15] = 1240

  >> clientCode(sc)
  Summation at [0, 15] = 14400
  >> 
#+END_SRC

References: 

 + Template Method, Factory Method, and Composite. -
   <http://condor.depaul.edu/cjones1/depaul/se455/notes/lecture07.pdf>
 + Template Method - <http://cs.unb.ca/~wdu/cs4015/ch5k.pdf>
 + Encapsulating Algorithms with the Template Method Design Pattern -
   <https://redlich.net/pdf/publications/jupitermedia/template.pdf>
 + Template Method Design Pattern in Java -
   <https://www.journaldev.com/1763/template-method-design-pattern-in-java>

** Null-Object Pattern 

An object, called nulll object, which doesn't do anything and has
empty methods implementing a required interface by the client code is
used to convey the absense of an ordinary object instead of null or
null pointer.

Example: in a database system, instead of returning null, null
reference or null pointer for an not found employee object, an empty
object, called null object, with an empty mehtods is returned. It has
the advantage of avoiding null exception that can crash unexpectdely a
program. Another problem of null or null pointers is that null bugs
cannot be caught at compile-time and are also known to be hard to
debug and trace.

Alternatives: 
 + Throw an exception when there is the absense of an object. For
   instance, std::runtime_error("Error: record not found.").
 + Use optional type (Haskell's maybe) or C++17 Optional.
 + Return a pointer that is set to null for denoting the absence of an
   object. This pattern is widely used by many C and C++
   codes. However it is prone for the infamous null pointer exception
   problems. 

#+BEGIN_QUOTE
  A Null Object provides a surrogate for another object that shares
  the same interface but does nothing. Thus, the Null Object
  encapsulates the implementation decisions of how to do nothing and
  hides those details from its collaborators.
    -- Bobby Woolf in [PLoP3]
#+END_QUOTE

Code Example:

#+BEGIN_SRC cpp
  // Interface 
  class ICompany{
          virtual unsigned    getID() const       = 0;	
          virtual std::string getName() const     = 0;
          virtual void        showCompany() const = 0;
          virtual ~ICompany() = default;
  };

  class Company: public ICompany{
  public:
          Company(unsigned id, const std::string& name):
                  _name(name),
                  _id(id){
          }
          unsigned getID()      const { return _id; }
          std::string getName() const { return _name; }
          void showCompany() const {
                  std::cout << "Company is = " << _name << "\n";
          }	
          ~Company() = default;
  private:
          std::string _name;
          unsigned    _id;	
  };

  // Null object 
  // Returns this null object instead of returning a null pointer
  // when a givne company is not found in the database system.
  class NullCompany: public ICompany{
  public:
          unsigned getID()      const { return 0; }
          std::string getName() const { return ""; }
          void showCompany()    const {}		
  };
#+END_SRC

** Composite 

The composite pattern is a structural design pattern intruduced by GOF
which allows clients to deal with tree collection of objects in the
same way as a primitive objects. 

Features and applications: 

 + Allow client code to ignore differences between individual objects
   and collection (composite objects) and treat them uniformly.

 + Known cases:
   + GUI Widgets - Java Swing GUI library allows to build a complex
     GUI out of individual UI elements such as buttons, menu, text box
     and panels which can have many UI child objects and other panels.
   + AST - Abstract Syntax Trees 
   + XML - Nodes 

 + Participants of Composite
   * _Component_:
     + Overview: Interface or abstract class which defines common
       operations shared by the primitive objects and composite objects.

   * _Leaf_
     + Overview:
       + Represents a primitive object which doesn't contain any child
         object. 

   * _Composite_
     * Overview 
       * As the name implies, the composite object contains leaf
         children objects.
       * Implements child operations in the component interface.
       * Can add or remove leaf objects or composite object as
         children.
       * The composite object forwards the messages related to child
         operations to the children elements.
     * Methods:
       - .Add(Component)   
       - .Remove(Component)
       - .Clear()

 *Example:*

File: 
 + [[file:src/design-patterns/composite1.cpp][file:src/design-patterns/composite1.cpp]]
 
Online Compiler: 
 + https://rextester.com/DYIE1548


Component interface: 
 + Defines primitive elements operations.

#+BEGIN_SRC cpp 
  class IGraphic{
  public:
       virtual auto type() const -> const std::string  = 0;
       virtual auto draw() -> void = 0;
       virtual auto rotate(double) -> void = 0;
       virtual ~IGraphic() = default;
  };
#+END_SRC

Convenient type aliases: 

#+BEGIN_SRC cpp 
  using cstring = const char*;
  using GNode = std::shared_ptr<IGraphic>;
#+END_SRC

Leaf, group aka composite object: 
 + Allows to performing an operation, which would be performed on a
   single primitive element, on all elements stored in the composite
   object.

#+BEGIN_SRC cpp 
  class Group: public IGraphic{
  private:
      std::vector<GNode> _nodes;
      const std::string _id;
      static constexpr cstring _type = "Group";
  public:
      Group(const std::string& id): _id(id) {
          std::cout << " [TRACE] Create group = " << id << "\n";
      }
      ~Group(){
          std::cout << " [TRACE] Destroy group - id = << " << _id << "\n";
      }

      auto begin() const -> decltype(_nodes.begin()) {
          return _nodes.begin();
      }
      auto end() const -> decltype(_nodes.end()) {
          return _nodes.end();
      }

      auto clear() -> void {
          _nodes.clear();
      }
      auto size() -> size_t {
          return _nodes.size();
      }
      auto add(GNode n) -> void {
          std::cout << " [TRACE] id = " << _id
                    << "; Add object = " << n->type() << "\n";
         _nodes.push_back(n);
      }
      auto add(IGraphic* n) -> void {
          std::cout << " [TRACE] id = " << _id
                    << " ; Add object = " << n->type() << "\n";
          _nodes.push_back(std::shared_ptr<IGraphic>(n));
      }
      // Add stack-allocated object 
      auto addFromStack(IGraphic* n) -> void {
          std::cout << " [TRACE] id = " << _id
                    << " ; Add object = " << n->type() << "\n";
          // Dummy deleter to avoid core dump by avoiding deleting
          // stack-allocated object or non-owned pointer.
          auto s = std::shared_ptr<IGraphic>(n, [](IGraphic*){ return ; });
          _nodes.push_back(s);
      }	

      // Note: Template methods should always be in the header files
      template<class Node>
      auto addNew(const std::string& id) -> void {
          auto n = std::make_unique<Node>(id);
          std::cout << " [TRACE] id = " << _id
                            << " ; Add object = " << n->type() << "\n";    
          _nodes.push_back(std::move(n));
      }

      // ======> Interface IGraphic <<=========//

      auto type() const -> const std::string override {
          return _type;
      }    
      auto draw() -> void override {
          std::cout << " [TRACE] Draw group - id =  " << _id << "\n";
          for(const auto& obj: _nodes)
              obj->draw();
      }
      auto rotate(double angle) -> void override {
          std::cout << " [TRACE] Rotate group - id = " << _id << "\n";
          for(const auto& obj: _nodes)
              obj->rotate(angle);
      }    
  };
#+END_SRC

Primitive element or node: Line  

#+BEGIN_SRC cpp 
  class Line: public IGraphic {
  private:
      static constexpr cstring _type = "Line";
      std::string _id;
  public:
      Line(const std::string& id): _id{id} { }
      auto type() const -> const std::string override {
           return _type;
      } 
      auto draw() -> void override {
           std::cout << " [TRACE] Draw line - id = " << _id << "\n";
      } 
      auto rotate(double angle) -> void override {
           std::cout << " [TRACE] Rotate line ; id = " << _id 
                     << "; angle = " << angle << "\n";
      }  
  };
#+END_SRC


Primitive element or node: Triangle 

#+BEGIN_SRC cpp 
  class Triangle: public IGraphic {
  private:
      static constexpr cstring _type = "Triangle";
      std::string _id;
  public:
      Triangle(const std::string& id): _id{id} { }
      auto type() const -> const std::string override {
         return _type;
      } 
      auto draw() -> void override {
          std::cout << " [TRACE] Draw triangle - id = " << _id << "\n";
      } 
      auto rotate(double angle) -> void override {
           std::cout << " [TRACE] Rotate triangle"
                     << " id = " << _id
                     << " angle = " << angle << "\n";
      }  
  };
#+END_SRC

Sample client code: 

#+BEGIN_SRC cpp 
  // Count total number of elements 
  auto countElements(const Group& group) -> size_t {
      size_t n = 0;
      for(const auto& g: group){
         if(g->type() == "Group"){
                 auto p = static_cast<Group*>(g.get());
                 n += countElements(*p);			
         } else{ ++n; }
      }
      return n;
  }

#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
   const char nl = '\n';

   std::cout << "=== Objects construction === " << nl;

   auto groupA = Group("groupA");
   groupA.add(new Triangle("triangleA1"));
   groupA.add(new Line("lineA1"));
   groupA.addNew<Line>("LineA2");

   auto groupB = std::make_shared<Group>("GroupB");
   groupB->add(new Triangle("triangleB1"));
   groupB->addNew<Triangle>("triangleB2");
   groupB->addNew<Line>("LineB1");
   groupB->addNew<Line>("LineB2");
   auto triangleB3 = Triangle("triangleB3");
   groupB->addFromStack(&triangleB3);
   groupA.add(groupB);

   std::cout << nl << "=== End of object construction === " << nl;
   std::cout << "Total of elements of groupA = " << countElements(groupA) << "\n";
   std::cout << "Total of elements of groupB = " << countElements(*groupB) << "\n";

   std::cout << nl << " [*] ==> Draw group B" << "\n";
   groupB->draw();

   std::cout << nl << " [*] ==> Rotate group B" << "\n";
   groupB->rotate(90);

   std::cout << nl << " [*] ==> Draw group A" << "\n";
   groupA.draw();

   std::cout << nl << " [*] ==> Rotate group A" << "\n";
   groupA.rotate(15);

   std::cout << nl << " [*] ==> Remove objects from group B" << "\n";
   groupB->clear();
   groupA.draw();

   std::cout << "=== End of Program ====" << "\n";

#+END_SRC

Running:  ([[file:src/design-patterns/composite1.cpp][file:src/design-patterns/composite1.cpp]])

#+BEGIN_SRC sh 
   $ g++ composite1.cpp -o composite1.bin -g -std=c++1z -Wall -Wextra 
   $ ./composite1.bin

   === Objects construction === 
    [TRACE] Create group = groupA
    [TRACE] id = groupA ; Add object = Triangle
    [TRACE] id = groupA ; Add object = Line
    [TRACE] id = groupA ; Add object = Line
    [TRACE] Create group = GroupB
    [TRACE] id = GroupB ; Add object = Triangle
    [TRACE] id = GroupB ; Add object = Triangle
    [TRACE] id = GroupB ; Add object = Line
    [TRACE] id = GroupB ; Add object = Line
    [TRACE] id = GroupB ; Add object = Triangle
    [TRACE] id = groupA; Add object = Group

   === End of object construction === 
   Total of elements of groupA = 8
   Total of elements of groupB = 5

    [*] ==> Draw group B
    [TRACE] Draw group - id =  GroupB
    [TRACE] Draw triangle - id = triangleB1
    [TRACE] Draw triangle - id = triangleB2
    [TRACE] Draw line - id = LineB1
    [TRACE] Draw line - id = LineB2
    [TRACE] Draw triangle - id = triangleB3

    [*] ==> Rotate group B
    [TRACE] Rotate group - id = GroupB
    [TRACE] Rotate triangle id = triangleB1 angle = 90
    [TRACE] Rotate triangle id = triangleB2 angle = 90
    [TRACE] Rotate line ; id = LineB1; angle = 90
    [TRACE] Rotate line ; id = LineB2; angle = 90
    [TRACE] Rotate triangle id = triangleB3 angle = 90

    [*] ==> Draw group A
    [TRACE] Draw group - id =  groupA
    [TRACE] Draw triangle - id = triangleA1
    [TRACE] Draw line - id = lineA1
    [TRACE] Draw line - id = LineA2
    [TRACE] Draw group - id =  GroupB
    [TRACE] Draw triangle - id = triangleB1
    [TRACE] Draw triangle - id = triangleB2
    [TRACE] Draw line - id = LineB1
    [TRACE] Draw line - id = LineB2
    [TRACE] Draw triangle - id = triangleB3

    [*] ==> Rotate group A
    [TRACE] Rotate group - id = groupA
    [TRACE] Rotate triangle id = triangleA1 angle = 15
    [TRACE] Rotate line ; id = lineA1; angle = 15
    [TRACE] Rotate line ; id = LineA2; angle = 15
    [TRACE] Rotate group - id = GroupB
    [TRACE] Rotate triangle id = triangleB1 angle = 15
    [TRACE] Rotate triangle id = triangleB2 angle = 15
    [TRACE] Rotate line ; id = LineB1; angle = 15
    [TRACE] Rotate line ; id = LineB2; angle = 15
    [TRACE] Rotate triangle id = triangleB3 angle = 15

    [*] ==> Remove objects from group B
    [TRACE] Draw group - id =  groupA
    [TRACE] Draw triangle - id = triangleA1
    [TRACE] Draw line - id = lineA1
    [TRACE] Draw line - id = LineA2
    [TRACE] Draw group - id =  GroupB
   === End of Program ====
    [TRACE] Destroy group - id = << groupA
    [TRACE] Destroy group - id = << GroupB
#+END_SRC
** Visitor 
*** Overview 

The visitor design pattern is a behavioral design pattern which allows
to add new operations to a class hierarchy without modifying classes
or adding new methods to derived classes. While the visitor makes
easier to add new operators, it makes harder to add new derived
classes.

Intent: (GOF):

 + "Represent an operation to be performed on the elements of an
    object structure. Visitor lets you define a new operation without 
    changing the classes of the elements on which it operates."

Features: 

 + Define operations to be performed on tree data structures without
   modifying them or adding new virtual methods.
 + Decouple data structure and algorithms.
 + Decouple two class hierarchies.
 + The code to perform the operation is centralized in the visitor
   object. If the operation were implemented as methods, the code
   would be scattered through all derived classes.

Drawbacks: 
 + The class hierarchy must be stable as adding a new derived class
   requires modifying all visitors implementations.

Application Domains: 

 + Process tree-like recursive data structures such as:
   + File systems: directories + files
   + AST - Abstract Syntax Tree
   + XML

 + Process a collection of heterogenous derived classes. 

 + Emulate *double dispatching* (aka dual dispatching or multi-methods)
   which is a feature available at Common Lisp (CLOS) and Perl6.

 + Process/ evaluate or interpret an AST - Abstract Syntax Tree in
   many different ways, for instance, evaluate expression, serialize
   to string, compile, get string representation and so on.

 + Serialization

 + Game colisions

 + Shape intersections 

Variations: 
   + Cyclic Visitor 
   + Acyclic Visitor
   + Decorator
   + Extension Object

Alternatives to Visitor Design Pattern: 

 + If-else statements + RTTI (Runtime Type Identification)

 + *Boost.Variant* or C++17 *std::variant* 

 + Multi methods - not possible in C++.
   + Possible in Common Lisp, Clojure and so on.

 + Pattern Matching + Algebraic Data Types or Classes.
   + Possible in functinal laguages such as F# (F Sharp), Scala,
     Haskell and so on.

Parts:

   + Interface: _Element_ 
     + The element is an element of the class hirarchy which contains
       the method _.accept(Visitor v)_ which takes a visitor as
       argument.
     + Method: _.accept(Visitor v)_ => Takes a visitor (operation) as
       argument. 

   + Interface: _Visitor_ - 
     + Perform the operations the class hierarchy. Every operation is
       an implementation of the visitor interface.
     + Methods: The visitor interface requires a method visit for
       derived class of the interface Element. Note: Element1,
       Element2 and Element3 are derived classes of interface Element. 
       + _.visit(Element1 e)_  => Specific version of the operation for class Element1.
       + _.visit(Element2 e1)_ => Specific version of the operation for Element2.
       + _.visit(Element3 e)_  => ... 

   + ConcreteElement -> Implementation of interface Element.

   + ConcreteVisitor -> Operation for the class hierarchy.

Papers: 

  + *Open Pattern Matching for C++*
    + <http://www.stroustrup.com/OpenPatternMatching.pdf>

  + *Design and evaluation of C++ open multi-methods*
     <https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf>
    + Note: Shows many use cases for double-dispatch and 

  + *XVF: C++ Introspection by Extensible Visitation*
    + <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.578.2090&rep=rep1&type=pdf>

  + *Design Patterns for Dealing with Dual Inheritance Hierarchies in C++*
    + <https://pdfs.semanticscholar.org/f403/361d9ef3dac96463787b852b605a918bc4fe.pdf>

  + *Generic Visitors in C++*
    + <https://www.lrde.epita.fr/dload/20030528-Seminar/tisser_n0503_visitors.pdf>

  + *Acyclic Visitor*
    + <https://condor.depaul.edu/dmumaugh/OOT/Design-Principles/acv.pdf>

  + *Using Template Metaprogramming to Enhance Reuse in Visitor-based Model Interpreters*
    + <http://www.dre.vanderbilt.edu/~gokhale/WWW/papers/ECBS12_Templates.pdf>

Other implementation examples: 

 + [[https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch/][A polyglot's guide to multiple dispatch - Eli Bendersky's website]]

 + [[http://www.sourcetricks.com/2011/06/visitor-pattern.html#.W-CKfh6YW00][Visitor Pattern ~ Programming Tutorials by SourceTricks]]

 + [[https://codereview.stackexchange.com/questions/153786/modular-visitor-pattern][c++ - Modular Visitor Pattern - Code Review Stack Exchange]]

 + [[https://www.codeproject.com/Articles/588882/TheplusVisitorplusPatternplusExplained][The Visitor Pattern Explained - CodeProject]]

 + [[https://foonathan.net/blog/2017/12/21/visitors.html][foonathan::blog() - Implementation Challenge: Revisiting the visitor pattern]]

 + [[http://alblue.bandlem.com/2009/07/why-i-don-like-visitor-pattern.html][Why I don't like the visitor pattern - AlBlues Blog]]

 + [[https://accu.org/index.php/articles/2021][ACCU - Defining Visitors Inline in Modern C++]]

 + [[http://softwareengisneering.blogspot.com/2009/03/c-visitors-basic-implementation.html][Software EngiSneering: C++ Visitors: Basic Implementation]]

 + [[http://blog.aaronballman.com/2011/11/visitor/][The Amazing Visitor Pattern | Ruminations]]

Visitor with C++17 - std::variant 

 + [[https://www.boost.org/doc/libs/1_68_0/doc/html/variant.html][Chapter45.Boost.Variant - 1.68.0]] (Boost Variant Documentation)

 + [[https://www.heise.de/developer/artikel/C-17-hat-einen-Visitor-3700274.html][C++17   hat einen Visitor | heise Developer]] (In German)

Generic Visitor 

 + [[https://stackoverflow.com/questions/11796121/implementing-the-visitor-pattern-using-c-templates][Implementing the visitor pattern using C++ Templates - Stack Overflow]]

 + [[https://www.artima.com/cppsource/cooperative_visitor.html][Cooperative Visitor: A Template Technique for Visitor Creation]]

 + [[https://www.etlcpp.com/blog/2017/11/12/templated-implementation-of-the-visitor-pattern/][Templated implementation of the Visitor Pattern  Blog  John  Wellbelove]]

Reflection based visitor: 

 + [[https://www.oodesign.com/visitor-pattern.html][Visitor Pattern | Object Oriented Design]]

*** Example: Basic Cyclic Visitor 

File:
 + [[file:src/design-patterns/visitor1.cpp][file:src/design-patterns/visitor1.cpp]]
Online Compiler: 
 + https://repl.it/repls/LinearVioletredRatio

 + _IVisitor interace_ - The visitor interface encapsulates the
   operation performed on the class hierarchy. It should define a
   specific version operation (method visit) for each derived class.

#+BEGIN_SRC cpp
  // Forward reference
  class Circle;
  class Square;
  class Blob;

  class IVisitor{
  public:
      virtual ~IVisitor() = default;
      virtual void visit(Circle& sh) = 0;
      virtual void visit(Square& sh) = 0;
      virtual void visit(Blob& sh) = 0;
  };
#+END_SRC

Class hierarchy: 

 + Interface IShape.
 
#+BEGIN_SRC cpp 
  // Shape interface - The base class must define the method accept
  class IShape{
  public:
      virtual ~IShape() = default;	
      virtual void accept(IVisitor& v) = 0;
  };
#+END_SRC

 + Implementations of the interface class IShape. 

#+BEGIN_SRC cpp 
  class Circle: public IShape{
  public:
       double radius;
       Circle(double radius): radius(radius) { }
       void accept(IVisitor& v) override {
               v.visit(*this);
       }
  };

  class Square: public IShape{
  public:
      double side;
      Square(double side): side(side) { }
      void accept(IVisitor& v) override {
          v.visit(*this);
      }
  };

  class Blob: public IShape{
  public:
      Blob(){}
      void accept(IVisitor& v) override {
          v.visit(*this);
      }
  };
#+END_SRC
 
 + PrintNameVisitor - Visitor Interface Implementation - This visitor
   encapsulates an operation which prints the name of each object in
   the class hierarchy.

#+BEGIN_SRC cpp 
  // Operation which prints name of the class hierarchy
  class PrintNameVisitor: public IVisitor{
  public:
      void visit(Circle& sh) override
      {
        std::cout << " => Shape is a circle of radius = "
                  << sh.radius
                  << "\n";
      }
      void visit(Square& sh) override
      {
         std::cout << " => Shape is a square of side = "
                   << sh.side
                   << "\n";		
      }
      void visit(Blob& ) override
      {
         std::cout << " => Shape is a blob with an undefined shape"
                   << "\n";
      }
  };
#+END_SRC
 

 + ComputeAreaVisitor - This stateful visitor encapsulate an operation
   which computes the area of each element.

#+BEGIN_SRC cpp 
  class ComputeAreaVisitor: public IVisitor{
  private:
      double _area = 0.0;
  public:
      ComputeAreaVisitor() = default;
      double getArea(){
        return _area;
      }
      void visit(Circle& sh) override
      {
         // CircleArea =  PI * radius^2
         _area = 3.1415 * sh.radius * sh.radius;
      }
      void visit(Square& sh) override
      {
         _area = sh.side * sh.side;
      }
      void visit(Blob& ) override
      {
         _area = 100.0;
      }
  };
#+END_SRC

 + FunctionAdapater - Turns lambda function into a visitor object
   reducing the code boilerplate.

#+BEGIN_SRC cpp 
  // Lambda function are used for adding new behavior to the object.
  template<class Result>
  class FunctionAdapter: public IVisitor{
      template<typename T> using Func = std::function<Result (T& sh)>;
      Result       _res;
      Func<Circle> _fn_circle;
      Func<Square> _fn_square;
      Func<Blob>   _fn_blob;
  public:
      Result get(){
              return _res;
      }
      FunctionAdapter(Func<Circle> fnCircle, Func<Square> fnSquare, Func<Blob> fnBlob)
         : _res{}
         , _fn_circle{fnCircle}
         , _fn_square{fnSquare}
         , _fn_blob{fnBlob}
      {		
      }		
      void visit(Circle& sh) override { _res = _fn_circle(sh); }
      void visit(Square& sh) override { _res = _fn_square(sh);}
      void visit(Blob& sh)   override { _res = _fn_blob(sh); }
  };
#+END_SRC


 + Compiling and Running:

#+BEGIN_SRC sh 
  $ clang++ visitor1.cpp -o visitor1.bin -g -std=c++14 -Wall -Wextra && ./visitor1.bin
#+END_SRC

 + Experiment 1: 

#+BEGIN_SRC cpp 
  // Sample shapes 
  auto s1 = Circle(3.0);
  auto s2 = Square(4.0);
  auto s3 = Blob();

  std::cout << "===> Experiment 1: PrintNameVisitor " << "\n";
  auto visitor1 = PrintNameVisitor();
  s1.accept(visitor1);
  s2.accept(visitor1);
  s3.accept(visitor1);	
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  ===> Experiment 1: PrintNameVisitor 
   => Shape is a circle of radius = 3
   => Shape is a square of side = 4
   => Shape is a blob with an undefined shape

#+END_SRC

 + Experiment 2: 

#+BEGIN_SRC cpp 
    std::cout << "===> Experiment 2: ComputeAreaVisitor " << "\n";
    auto visitor2 = ComputeAreaVisitor();
    s1.accept(visitor2);
    std::cout << "Area of shape 1 = " << visitor2.getArea() << "\n";
    s2.accept(visitor2);
    std::cout << "Area of shape 2 = " << visitor2.getArea() << "\n";
    s3.accept(visitor2);
    std::cout << "Area of shape 3 = " << visitor2.getArea() << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  ===> Experiment 2: ComputeAreaVisitor 
  Area of shape 1 = 28.2735
  Area of shape 2 = 16
  Area of shape 3 = 100
#+END_SRC

 + Experiment 3:

#+BEGIN_SRC cpp 
  auto visitor3 = FunctionAdapter<std::string>{
      [](Circle& ){ return "circle"; },
      [](Square& ){ return "square"; },
      [](Blob&   ){ return "blob";   },
   };
  s1.accept(visitor3);
  std::cout << "Type of shape 1 = " << visitor3.get() << "\n";
  s2.accept(visitor3);
  std::cout << "Type of shape 2 = " << visitor3.get() << "\n";
  s3.accept(visitor3);
  std::cout << "Type of shape 3 = " << visitor3.get() << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  ===> Experiment 3: FunctionAdapter 
  Type of shape 1 = circle
  Type of shape 2 = square
  Type of shape 3 = blob
#+END_SRC

 + Experiment 4: 

#+BEGIN_SRC cpp 
    std::cout << "===> Experiment 4: FunctionAdapter " << "\n";
    // Creates operation to compute shape perimiter
    auto visitor4 = FunctionAdapter<double>{
            [](Circle& s){ return 2 * 3.1415 * s.radius * s.radius ; },
            [](Square& s){ return 4.0 * s.side; },
            [](Blob&    ){ return -100.0;   },
     };	
    s1.accept(visitor4);
    std::cout << "Perimeter of shape 1 = " << visitor4.get() << "\n";
    s2.accept(visitor4);
    std::cout << "Perimeter of shape 2 = " << visitor4.get() << "\n";
    s3.accept(visitor4);
    std::cout << "Perimeter of shape 3 = " << visitor4.get() << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  ===> Experiment 4: FunctionAdapter 
  Perimeter of shape 1 = 56.547
  Perimeter of shape 2 = 16
  Perimeter of shape 3 = -100
#+END_SRC

*** Example: Generic Acyclic Visitor 

File:
 + [[file:src/design-patterns/visitor2.cpp][file:src/design-patterns/visitor2.cpp]]

Online Compiler: 
 + https://rextester.com/TXVI24042

Description: Simple generic acyclic implementation of visitor pattern
in C++11. Note: acyclic means that it doesn't have cyclic
dependencies. 

Template class visitable used the CRTP (Curious Recurring Template
Pattern) for making derived classes visitable without virtual
methods. 


Shape interface class: 

#+BEGIN_SRC cpp 
  // Shape interface - The base class must define the method accept
  class IShape{
  public:
      virtual ~IShape() = default;
  };
#+END_SRC

Visitable CRTP Template class 

#+BEGIN_SRC cpp 
  template<typename Implementation>
  class VisitableShape: public IShape{
  public:
      /** Accept any visitor class which implements
        ,* the method:
        ,* void Visitor::visit(Implementation& impl);
        ,*********************************************/
        template<typename Visitor>
        void accept(Visitor&& v) {
           v.visit(static_cast<Implementation&>(*this));
        }
  };

#+END_SRC

Visitable class hierarchy: 

#+BEGIN_SRC cpp 
  class Circle: public VisitableShape<Circle> {
  public:
      double radius;
      Circle(double radius): radius(radius) { }
  };

  class Square: public VisitableShape<Square> {
  public:
      double side;
      Square(double side): side(side) { }
  };

  class Blob: public VisitableShape<Blob> {
  public:
      Blob(){}
  };
#+END_SRC


The following template class turns a list of lambda function
parameters into a visitor object. 

#+BEGIN_SRC cpp 
  template<class Result>
  class FunctionAdapter{	
      // Lambda function are used for adding new behavior to the object.
       template<typename T> using Func = std::function<Result (T& sh)>;
       Result       _res;
       Func<Circle> _fn_circle;
       Func<Square> _fn_square;
       Func<Blob>   _fn_blob;
  public:
       Result get(){ return _res; }
       FunctionAdapter(Func<Circle> fnCircle, Func<Square> fnSquare, Func<Blob> fnBlob)
               : _res{}
               , _fn_circle{fnCircle}
               , _fn_square{fnSquare}
               , _fn_blob{fnBlob}
       {
       }
       void visit(Circle& sh)  { _res = _fn_circle(sh); }
       void visit(Square& sh)  { _res = _fn_square(sh);}
       void visit(Blob& sh)    { _res = _fn_blob(sh); }

       template<class Visitable>
       Result operator()(Visitable& visitable){
               this->visit(visitable);
               return this->get();
       }
  };
#+END_SRC

Some visitors implementation: 

#+BEGIN_SRC cpp 
  auto visitorGetName = FunctionAdapter<std::string>{
       [](Circle& ){ return "circle"; },
       [](Square& ){ return "square"; },
       [](Blob&   ){ return "blob";   },
  };

  // Creates operation to compute shape perimeter
  auto visitorGetArea = FunctionAdapter<double>{
       [](Circle& s){ return 2 * 3.1415 * s.radius * s.radius ; },
       [](Square& s){ return 4.0 * s.side; },
       [](Blob&    ){ return -100.0;   },
  };
#+END_SRC

Running in REPL: 

#+BEGIN_SRC cpp 
  >> .L visitor2.cpp

  >> auto s1 = Circle(3.0);
  >> auto s2 = Square(4.0);
  >> auto s3 = Blob();

  >> s1.accept(visitorGetName)
  >> visitorGetName.get()
  "circle"

  >> s2.accept(visitorGetName)
  >> visitorGetName.get()
  "square"

  >> visitorGetName(s1)
  "circle"

  >> visitorGetName(s2)
  "square"

  >> visitorGetArea(s1)
  (double) 56.547000

  >> s1.accept(visitorGetArea)
  >> visitorGetArea.get()
  (double) 56.547000

  >> visitorGetArea(s2)
  (double) 16.000000

  >> s2.accept(visitorGetArea)
  >> visitorGetArea.get()
  (double) 16.000000

  >> visitorGetArea(s2)
  (double) 16.000000

  >> visitorGetArea(s3)
  (double) -100.00000
  >> 
#+END_SRC
*** Example: Visitor implemented with C++17 std::variant 

The type std::variant and the function std::visit from C++17 standard
can simplify the implementation of visitor design pattern decreasing
the amount of boilerplate code and the coupling between classes. In
fact, by using std::visit, no class modification is required to
implement this pattern.

 + Note: If the current compiler doesn't support C++17 ISO Standard, a
   workaround is to use [[https://www.boost.org/doc/libs/1_68_0/doc/html/variant.html][Boost.Variant]] library, which is the
   predecessor of C++17's std::variant.

File:
 + [[file:src/design-patterns/visitor1-cpp17.cpp][file:src/design-patterns/visitor1-cpp17.cpp]]

Online Compiler:
 + [[https://coliru.stacked-crooked.com/a/7130e9b6494370d5][visitor1-cpp17.cpp]] 

Headers used: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cstdio>
  #include <string>
  #include <memory>
  #include <functional>
  #include<type_traits>
  // C++17 Variant std::variant and std::visit 
  #include <variant> 
#+END_SRC

Classes: 

#+BEGIN_SRC cpp 
  class Circle{
  public:
      double radius;
      Circle(double radius): radius(radius) { }
  };

  class Square{
  public:
      double side;
      Square(double side): side(side) { }
  };

  class Blob{
  public:
      Blob(){}
  };
#+END_SRC

Simple visitor: 
 + Implements operation which prints the description of an element in
   the class "hierarchy".

#+BEGIN_SRC cpp 
  struct PrintNameVisitor{
      void operator()(const Circle& sh){
           std::cout << " SHAPE = Circle of radius " << sh.radius << std::endl;
      }
      void operator()(const Square& sh){
           std::cout << " SHAPE = Square of radius " << sh.side << std::endl;
      }
      void operator()(const Blob&){
           std::cout << " SHAPE = Blob - no one knows how it looks like. " << std::endl;
      }	
  };
#+END_SRC

Generic Visitor: 
 + Turns 3 lambda functions ,which processes each element, into a
   visitor object. 

#+BEGIN_SRC cpp 
  /** Visitor which adpts a function */
  template<typename Result>
  class FunctionVisitor{
  private:	
       template<typename Input> using FN = std::function<Result (const Input&)>;
       FN<Circle> fn_circle;
       FN<Square> fn_square;
       FN<Blob>   fn_blob;
  public:
      FunctionVisitor(FN<Circle> fnCircle, FN<Square> fnSquare, FN<Blob> fnBlob)
       : fn_circle(fnCircle)
        ,fn_square(fnSquare)
        ,fn_blob(fnBlob){ }
      //Result get() const { return result; }
      Result operator()(const Circle& sh){ return fn_circle(sh); }
      Result operator()(const Square& sh){ return fn_square(sh); }
      Result operator()(const Blob& sh){  return fn_blob(sh);   }
  };
#+END_SRC

 + Higher order function makeVisitor, turn 3 lambda functions into a
   single visitor lambda function. 

#+BEGIN_SRC cpp 
  template<typename Input, typename Result>
  using FnVisit = std::function<Result (const Input&)>;

  /** Make a visitor using a functional-programming way 
   ,* Visitor with lambdas look like "pattern matching"  
   ,* from functional languages.
   ,*/
  template<typename Result = void>
  auto makeVisitor(FnVisit<Circle, Result> fnCircle,
                   FnVisit<Square, Result> fnSquare,
                   FnVisit<Blob, Result>   fnBlob ){
          return [=](auto&& a){
                     using C = std::decay_t<decltype(a)>;
                     if constexpr(std::is_same_v<C, Circle>){               
                          return fnCircle(a);
                     }
                     if constexpr(std::is_same_v<C, Square>){
                          return fnSquare(a);
                     }
                     if constexpr(std::is_same_v<C, Blob>){               
                         return fnBlob(a);
                     }
                     std::cerr << "WARNING - Not returned valid result";
                     return Result{};
               };
  } //-- EoF makeVisitor ----// 
#+END_SRC

Variant type Shape: 
 + An instance of this type can be a Circle, Square or Blob.

#+BEGIN_SRC cpp 
   using Shape = std::variant<Circle, Square, Blob>;	
#+END_SRC

Sample shapes: 

#+BEGIN_SRC cpp 
  // Sample shapes
  Shape s1 = Circle(3.0);
  Shape s2 = Square(4.0);
  Shape s3 = Blob();
#+END_SRC


 + *Experiment Code 1*

#+BEGIN_SRC cpp 
   std::puts("\n === EXPERIMENT 1 =================");
   std::visit(printVisitor, s1);
   std::visit(printVisitor, s2);
   std::visit(printVisitor, s3);
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 1 =================
   SHAPE = Circle of radius 3
   SHAPE = Square of radius 4
   SHAPE = Blob - no one knows how it looks like. 
#+END_SRC

 + *Experiment Code 2*

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 2 =================");
    auto visitorGetName = FunctionVisitor<std::string>{
        [](const Circle& ) { return "circle"; },
        [](const Square& ) { return "square"; },
        [](const  Blob&  ) { return "blob";   }
    };

    std::cout << "Type of shape 1 = " << std::visit(visitorGetName, s1) << "\n";
    std::cout << "Type of shape 2 = " << std::visit(visitorGetName, s2) << "\n";
    std::cout << "Type of shape 3 = " << std::visit(visitorGetName, s3) << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 2 =================
  Type of shape 1 = circle
  Type of shape 2 = square
  Type of shape 3 = blob
#+END_SRC

 + *Experiment Code 3*

#+BEGIN_SRC cpp 
   std::puts("\n === EXPERIMENT 3 =================");

   // Creates operation to compute shape perimeter
   auto visitorGetArea = FunctionVisitor<double>{
       [](const Circle& s){ return 3.1415 * s.radius * s.radius ; },
       [](const Square& s){ return s.side * s.side; },
       [](const Blob&    ){ return 0.0 / 0.0; /* NAN Not a number */   },
   };

   std::cout << "Area of shape 1 = " << std::visit(visitorGetArea, s1) << "\n";
   std::cout << "Area of shape 2 = " << std::visit(visitorGetArea, s2) << "\n";
   std::cout << "Area of shape 3 = " << std::visit(visitorGetArea, s3) << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 3 =================
  Area of shape 1 = 28.2735
  Area of shape 2 = 16
  Area of shape 3 = nan
#+END_SRC

 + *Experiment Code 4*

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 4 =================");

    auto fnVisitorArea = makeVisitor<double>(
        [](const Circle& s){ return 3.1415 * s.radius * s.radius ; }
       ,[](const Square& s){ return s.side * s.side; }
       ,[](const Blob&    ){ return 0.0 / 0.0; /* NAN Not a number */   }
     );

    std::cout << "Area of shape 1 = " << std::visit(fnVisitorArea, s1) << "\n";
    std::cout << "Area of shape 2 = " << std::visit(fnVisitorArea, s2) << "\n";
    std::cout << "Area of shape 3 = " << std::visit(fnVisitorArea, s3) << "\n";
#+END_SRC

Output:

#+BEGIN_SRC text 
   === EXPERIMENT 4 =================
  Area of shape 1 = 28.2735
  Area of shape 2 = 16
  Area of shape 3 = nan
#+END_SRC

* C++ Specific Design Pattern and Idioms
** RAII - Resource Aquisition Is Initialization
*** Overview 

Comes from book: _C++ Programming with Design Patterns Revealed_ 

RAII is a design pattern which takes advantage of C++'s deterministic
destructor feature for deallocating resources such as pointers to
objects allocated on the heap memory, database handlers, socket
handlers and etc. The RAAI technique uses an object allocated on the
stack which acquires the resource as a constructor argument and
performs the resource cleanup in the destructor method which is called
when when the wrapper object goes out scope or an exception happens.

 + Note: This pattern is specific for C++, for Java and Scala use _try_
   _finally_ statements. Python has the _with_ statement and C# has the
   _using_ statement. In addition, this pattern needs the
   *deterministic destructor* feature which is unique to C++.

Alternative or more descriptive names: 

 + CADRE => Constructor Acquires, Destructor Releases
 + SBRM  => Scope-Bound Resource Management. 

Note: It is no longer necessary to design any class for RAII since
C++11 has smart pointers which already implements this
pattern. However, it is important to understand how this idiom works
and the problem that it solves.
 + In C++ >= C++ 11, it is better to use ~unique_ptr~ for handling
   resources as shown at [[https://msdn.microsoft.com/en-us/library/hh438480.aspx][Objects Own Resources (RAII)]] 

RAII is the process of: 
 + Acquiring a resouce and wrapping it as an object's state.
 + Using the resource 
 + Releasing the resource in the object's destructor member function
   which is executed when the object goes out of escope.

Problems solved by this technique.
 + Avoid [[https://en.wikipedia.org/wiki/Memory_leak][memory leak]] 
 + Avoid [[https://en.wikipedia.org/wiki/Resource_leak][resource leak]]
 + Save and restore context. => An object allocated on the stack could
   be used to set the current directory and restore saved directory
   when the destructor is invoked when the object goes out scope. The
   same technique could be used to save and restore std::cout or
   std::cerr flags. 

Known uses: 
 + C++11 _shared_ptr_ (Smart pointer)
 + C++11 _unique_ptr_ (Smart pointer)
 + Almost all STL containers/collections which manages heap-memory
   behind the scene, namely, std::vector, std::list, std::map, ... and
   so on.

 *Example:* 

Naive code - If an exception happens, the resource will not be
released and the code will be vulnerable to memory leak or resource
leak.

#+BEGIN_SRC cpp 
  Handler* handle  = getDatabaseHandler(); 
  // Throw exception => Resource leak 
  performInvalidOperation(handle);  
  ...
  // Forget to release resource!
  deleteResource(handle); 
#+END_SRC

Or: 

#+BEGIN_SRC cpp 
   Object* heapObject = new Object(param0, param1, ....);
   peformOperation(heapObject); 
   heapObject->method1; 

   // Throw exception!! ==> Memory Leak!

   // If the user forget this statement, 
   // a memory leak will happen. 
   delete heapObject; 
#+END_SRC
 
 *Solution - RAAI idiom*

 - An object is used to control the lifetime of a resource ensuring
   that is released when the object goes out of scope or an exception
   happens. The resource is aquired by the constructor and realeased
   by the destructor.

#+BEGIN_SRC cpp 
  template<class Resource>
  class RaaiHandler {
  public:  
     // Consructor: Acquire resource on the constructor 
     RaaiHandler(Resource* rawHandle_) : (rawHandle_) {};

     // Destructor: Releases resource 
     // The destructor is always called when the object goes out of scope 
     // or an exception happens.
     ~RaiiHandler() {
        delete _handler; 
      }      
  private:
     RaiiHandler* _handler;
  };

  // Object created without new keyword is allocated in the stack, not in the heap.
  RaiiHandler hnd(createNewResource());
  // .. . Peform operation 
  Operation(hnd);
  // Once the escope is gone, the resource is released.
#+END_SRC
*** Example - Heap-allocated memory

 Another more specific RAAI Example: 

 + In this example, the resource acquired in the constructor, a
   heap-allocated array of type T, is released at the destructor when
   a HeapArray object goes out of scope. All STL containers such as
   std::vector, std::map, std::deque and so on uses RAII technique for
   avoiding memory leak by deleting the heap-allocated objects when
   no longer needed. 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <ostream>

  template<typename T>
  class HeapArray{
    private:
    size_t m_size;
    T*     m_resource;  
  public:  
    // Resource is acquired at constructor 
    HeapArray(size_t size, T init)
      : m_size(size),
        m_resource(new (std::nothrow) T[size])
    {
      std::cout << " [LOG] Intialize array with size = " << size
                << " and init = " << init << std::endl;
      if(m_resource != nullptr)
        for(size_t i = 0; i < size; i++)
          m_resource[i] = init;
    }
    // Delegated constructor on the right size 
    HeapArray(size_t size): HeapArray(size, T{}){ }
   
    // Resource is released at destructor 
    ~HeapArray()
    {
      std::cout << " [LOG] Destructor -> Delete array" << std::endl;
      // Always safe to delete 
      delete [] m_resource;
      m_resource = nullptr;
    }

    // Forbid copy constructor
    HeapArray(const HeapArray&) = delete;
    // Forbid copy-assignment operator 
    HeapArray& operator= (const HeapArray&) = delete;
    // Move constructor 
    HeapArray(HeapArray&& rhs)
    {
      std::cout << " [LOG] Move constructor " << std::endl;
      std::swap(this->m_resource, rhs.m_resource);
    }
    // Move assignment operator 
    HeapArray& operator= (HeapArray&& rhs)
    {
      std::cout << " [LOG] Move assignment operator " << std::endl;
      std::swap(this->m_resource, rhs.m_resource);
      return *this;
    }
    size_t size() const {
      return m_size;
    }    
    T& operator[](size_t n){
      return m_resource[n];
    }
  
    friend auto operator<< (std::ostream& os, const HeapArray<T>& rhs) -> std::ostream&
    {
     os << "[" << rhs.m_size << "]( ";
     for(size_t i = 0; i < rhs.m_size; i++)
       os << rhs.m_resource[i] << " ";  
     os << ")";
     return os;
    }  
  };

#+END_SRC

Usage example: 

#+BEGIN_SRC cpp 
  >> .L raai1.cpp

  >> auto vb = HeapArray<double>(4, 3.5);
   [LOG] Intialize array with size = 4 and init = 3.5
  >> std::cout << "vb = " << vb << std::endl;
  vb = [4]( 3.5 3.5 3.5 3.5 )

  >> vb[0] = 10.0;
  >> vb[1] = 20.0;
  >> vb[2] = -10.2;

  >> std::cout << "vb = " << vb << std::endl;
  vb = [4]( 10 20 -10.2 3.5 )
#+END_SRC


 *References*

 + [[https://www.codeproject.com/Articles/580077/ResourceplusAcquisitionplusisplusInitializationplu][Resource Acquisition is Initialization (RAII) - CodeProject]]
 + [[https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii][c++ - What is meant by Resource Acquisition is Initialization (RAII)? - Stack Overflow]]
 + [[https://www.codeproject.com/Articles/122129/RAII-Resource-Acquisition-Is-Initialization-C-Help][RAII (Resource Acquisition Is Initialization) C# Helper Classes - CodeProject]]
 + [[http://jrdodds.blogs.com/blog/2004/08/raii_in_c.html/][RAII in C++ (constructive nonconformist)]]
  
*** Example - Managing Resource with custom wrapper

Resource is everything that needs to be released or cleaned up after
no longer needed. Some examples of resource are file descriptors,
handlers, socket handlers, data base handlers and heap allocated
memory. The RAAI technique can help managing resources since it
ensures that a resource cleanup always will happen after the wrapper
object goes out of scope. 

 *Example:*

In the C-file API, the resource is the FILE* file pointer. The API
requies the client code to call fclose after the pointer is no longer
needed. Despite that this case is applied to the C-file API, it can
applied to any other type of resource. 

Note: It is better to use the C++ file API since it is more C++
friendly and already has RAII. The C-file API was used in this section
for simulating a generic resource.

API: 

#+BEGIN_SRC cpp 
   #include <cstdio> // <stdio.h> in C.
   // Open file getting the resource FILE*
   FILE* fopen(const char *pathname, const char *mode);
   // Release resource. 
   int   fclose(FILE* stream);

   int   fputs(const char* s, FILE* stream);
   int   putc(int c, FILE* stream);
#+END_SRC

Solution 1: Use a custom RAAI wrapper object. 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <cstdio>

   template<class Resource>
   class RAIIWrapper{
      public:
      using Cleanup_fn = std::function<void (Resource*)>;

      // Constructor: Acquire resource 
      // Parameter res      => Wrapped Resource 
      // Parameter cleanup  => Clenup function which releases resources. 
      RAIIWrapper(Resource* res, Cleanup_fn cleanup)
       :m_res(res), m_cleanup(cleanup) { }

      // Forbid copy-constructor 
      RAIIWrapper(const RAIIWrapper& rhs) = delete;
      // Forbid copy-assignment operator 
      RAIIWrapper& operator= (const RAIIWrapper& rhs) = delete;

      // Move constructor => Transfer resource ownership 
      //  from teporary object rhs (R-value) to new object (this).
      RAIIWrapper(RAIIWrapper&& rhs){
        this->m_res = rhs.m_res;
        rhs.m_res = nullptr;
      }
      // Move assignment operator - move resource ownership 
      // from temporary object (rhs) in the right hand-size of (=)
      // to this object. 
      RAIIWrapper& operator= (RAIIWrapper&& rhs){
         std::swap(this->m_res, rhs.m_res);
         return *this;
      }    

      void close(){
        if(m_res != nullptr) m_cleanup(m_res);
        m_res = nullptr;
        std::cerr << "LOG cleanup resource.";
      }
      // Destructor => Release resource 
      ~RAIIWrapper(){
         this->close();
       }
      Resource* get() const { return m_res; }
      // Conversion operator to check whether wrapped pointer is null. 
      operator bool() const {
        return m_res != nullptr;
      }

      private:
      Resource* m_res;
      Cleanup_fn m_cleanup;      
   };
#+END_SRC

Sample client code: 

#+BEGIN_SRC cpp 
  void writeFile(const char* file){
       // The wrapper automatically release the wrapped resource when out of scope
       RAIIWrapper<FILE> fptr(::fopen(file, "w"), &fclose);
       if(!fptr){
          ::fputs(" [ERROR] Failed to create file\n", stderr);
          return;
       }
       ::fputs("Testing line 1\n", fptr.get());
       ::fputs("Testing line 2\n", fptr.get());
       ::fputs("C++17 is AWESOME! AMAZING!\n", fptr.get());
  }
#+END_SRC

Test: 

#+BEGIN_SRC cpp 
  >> writeFile("/tmp/raii-resource.txt")
  LOG cleanup resource.>> 

  >> writeFile("/etc/raii-resource.txt")
   [ERROR] Failed to create file
  LOG cleanup resource.>> 
  >> 
  // Check created file. 
  >> .! cat /tmp/raii-resource.txt
  Testing line 1
  Testing line 2
  C++17 is AWESOME! AMAZING!
  >> 
#+END_SRC

*** Example - Managing Resource with smart pointer 

The smart pointer std::unique_ptr is not only suitable for managing
heap-allocated objects, it is also useful for managing resources.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <memory>     // Smart pointers 
  #include <functional> // std::function 

  // Used for simulating a generic resource. 
  // FILE*, fopen, fclose .... 
  #include <cstdio> 

  // Type alias for smart pointer with custom deleter 
  template<typename T>
  using Resource = std::unique_ptr<T, std::function<void (T*)>>;

  void writeFile(const char* file)
  {
       // The wrapper automatically release the resource when out of scope
       Resource<FILE> fptr(::fopen(file, "w"),
                           // Custom-deleter function 
                           [](FILE* hnd){
                             std::cerr << " [TRACE] File closed OK." << std::endl;
                             if(hnd != nullptr) ::fclose(hnd);
                           });
       if(!fptr){
          ::fputs(" [ERROR] Failed to create file\n", stderr);
          return;
       }
       ::fputs("Testing line 1\n", fptr.get());
       ::fputs("Testing line 2\n", fptr.get());
       ::fputs("C++17 is AWESOME! AMAZING!\n", fptr.get());
  }

  >> writeFile("/tmp/resource1.txt");
   [TRACE] File closed OK.
 
  >> .! cat /tmp/resource1.txt
  Testing line 1
  Testing line 2
  C++17 is AWESOME! AMAZING!

  >> writeFile("/boot/resource1.txt");
   [ERROR] Failed to create file
  >> 
 
#+END_SRC
** PIMPL - Pointer to Implementation

The PIMPL - Pointer to Implementation idiom, also known as compiler
firewall, is a widely used technique  in C++ for completly hiding class
private members in the public header file. This technique uses an
opaque pointer to an internal non declared class in the current header
file encapsulating all fields of the outer class.

Also known as: 
 + PIMPL - Pointer to Implementation
 + Compiler firewall idiom
 + Cheshire Cat

Motivation and Benefits: 

 + Reduce compilation time as the number of #include headers in the
   class header is not changed.

 + Makes the class data member in the public header really private and
   obfuscated.

 + Changing of private members of the class which are encapsulated in
   the opaque pointer class does not require recompilation of client
   code. This feature is very important for library development as it
   avoid client code recompilation as the public headers are not
   changed.

 + Less likely to breaking binary compatibility - ABI Application
   Binary Interface.

 + Note: Changing class member variables or member functions (methods)
   breaks the ABI and requires the recompilation of client code. The
   pimpl maintains the binary compatibility by not changing class'
   private members.

 + TL;DR
   + PIMPL: Allow changes to implementation without the
     need to recompile client code.

Drawbacks: 

 + More complexity and work for API implementators.
 + Not convenient when there are protected members which needs to be
   accessed by subclasses. 
 + Runtime performance overhead due to the pointer indirection. 

Example: All private members of class CashFlow are conained in the
opaque type Impl which is not defined in the header file.

 - file: _CashFlow.h_  -> Class public interface.

#+BEGIN_SRC cpp 
  #ifndef _CashFlow_H_
  #define _CashFlow_H_

  // C++ 11's smart pointers
  #include <memory>

  class CashFlow{
  private:
      // Forward declaration of incomplete type (Implementation).
      struct Impl;
      // This opaque type encapsulate the outer class' private member 
      // Pointer to implementation (PIMPL)
      std::unique_ptr<Impl> m_pimpl;
      // Explicit Default ctor 
      ~CashFlow = default;
  public:
      // Default ctor 
      CashFlow();
      void show();
      void add(double x);
      int  size();
      // Net Present Value - NPV of cash flow for a given rate of return 
      double npv(double rate); 
      // Compute IRR - Internal rate of return 
      double irr(); 
  };

  #endif // --- EOF ---- // 
#+END_SRC

 - file: _CashFlow.cpp_  -> Class implementation.

#+BEGIN_SRC cpp 
  // C++ 11's smart pointers
  #include <memory>
  #include "CashFlow.h"

  // Struct is just class with all members
  // public by default 
  struct CashFlow::Impl{
      // cash flow vector 
      std::vector<double> m_clf;
      // Default ctor 
      Impl(){}
      // Default dtor 
      ~Impl() = default;  
  };

  // Ctor 
  CashFlow::CashFlow(): m_pimpl(new Impl()) {}

  void CashFlow::add(double x){
      m_pimpl->m_clf.push_back(x);
  }

  double CashFlow::get(int i){
      return m_pimpl->m_clf[i];
  }
     ... ... ... .... 
#+END_SRC  

References and further: 

 + *Pimpl Idiom* - <>
 
 + *Best Friends: C++11 Move Semantics and Pimpl* -
   <https://www.embeddeduse.com/2016/05/30/best-friends-cpp11-move-semantics-and-pimpl/>

 + *Improving C++ Encapsulation with the Pimpl Idiom* -
   <https://visualstudiomagazine.com/articles/2012/11/29/the-pimpl-idiom-in-c-plus-plus.aspx> 

 + *Why every C++ developer should know about the pimpl idiom pattern* -
   <https://tonka2013.wordpress.com/2013/08/31/why-every-c-developer-should-know-about-the-pimpl-idiom-pattern/> 

 + *Passing Containing Parent to pimpl idiom implementation class* -
   http://www.sharprobotica.com/2010/04/passing-containing-parent-to-pimpl-idiom-implementation-class/

 + *Dive in to C++ and survive* -
   <https://www.embedded.com/print/4008235> 
 
 + *Modern and Lucid C++ Advanced for Professional Programmers* -
   <https://wiki.ifs.hsr.ch/CppAdvanced/files/lecture_12_advanced_library_design.pdf> 
** Non-copiable class 

Classes where copying doesn't make sense such as classes managing
resources or singletons should have the copy constructor and copy
assignment operator no accessible to any external code. It can be done
by making the both member functions private or by annotating them as
deleted (C++11).

 + Note: resource means anything that needs to be disposed when no
   longer needed such as heap memory, database handlers, socket
   handlers, file descriptors and etc.

 *Prior to C++11*

Notes: 

 + The copy-constructor and copy-assignment operators should be
   declared private, even if they are not declared the copiler will
   generate both by default what can lead to unexpected bugs.

 + If the following class used the default copy constructor and
   copy-assignment operator, the socket handler would be copied, but
   the initial class and the copy would still use the same resource,
   in this case connection. Then, if one of the classes went out of
   scope, the destructor would be invoked disposing the
   resource. Therefore, it would close the connection and make the
   socket unavailable to the remaining class and any attempt to use
   the disposed resource would result in a runtime error hard to
   debug. 

#+BEGIN_SRC cpp 
  //=========>> file: socket.hpp - Header <<===========;
  class SocketWrapper{
  public:
      // Constructor 
      SocketWrapper();
      // Destructor 
      ~SocketWrapper();			
  private:
      // Copy constructor 
      SocketWrapper(const SocketWrapper&);
      // Copy assignment operator
      SocketWrapper& operator=(const SocketWrapper&);
	
      // Resource - socket file descriptor 
      int m_sockfd;   
  };

  //====>>> file: socket.cpp - Implementation <<<==========
  SocketWrapper::SocketWrapper(){
      m_sockfd = ::socket(AF_INET, SOCK_STREAM, 0);
  }

  SocketWrapper::~SocketWrapper(){
     ::close(m_sockfd);
  }

  // Forbidden copy constructor 
  SocketWrapper::SocketWrapper(const SocketWrapper&)
  {	
  }

  // Forbidden copy-assignemnt operator 
  SocketWrapper& operator=(const SocketWrapper&)
  {
  }
#+END_SRC

 *>= C++11* 

 + In C++11, it is just necessary to annotate both copy constructor
   and assignment operator with delete to make them non
   accessible. Any attempt to copy a class with those member functions
   annotated as deleted will result in a compile-time error. 

#+BEGIN_SRC cpp 
  //=========>> file: socket.hpp - Header  <<===========;
  class SocketWrapper{
  public:
      // Constructor
      SocketWrapper();
      // Destructor 
      ~SocketWrapper();

      // Copy constructor 
      SocketWrapper(const SocketWrapper&) = delete;
      // Copy assignment operator
      SocketWrapper& operator=(const SocketWrapper&) = delete;	
  private:
      // Resource - socket file descriptor 
      int m_sockfd;   
  };

  //====>>> file: socket.cpp - Implementation <<<==========
  SocketWrapper::SocketWrapper(){
      m_sockfd = ::socket(AF_INET, SOCK_STREAM, 0);
  }
  SocketWrapper::~SocketWrapper(){
     ::close(m_sockfd);
  }
#+END_SRC
** Copy and swap idiom 

The copy-and-swap idiom is a widely used technique for implementing
the _rule-of-three_ by defining the copy-assignment operator with a
custom _swap function_. In C++11, the idiom can also be used for
implementing the rule-of-five by defining the move constructor and
move assignment operator with a swap function.

Notes: 

 + The _copy-assignment operator_ is needed by the _rule-of-three_
   (pre-C++11) which states that a class managing a resouce, which
   implements copy constructor, copy assignment operator and a
   destructor, should all of them.

 + The _move-assignment operator_ is needed by the _rule-of-five_ (C++11)
   which states that a class, which wraps some resource implementing a
   copy constructor, copy assignment operator, move constructor, move
   assignment operator and a destructor, should implement all of them.

 + Note: This idiom is only applicable to _copiable classes_ which
   manages some resource. 

Benefits: 

 + Less code duplication.

 + Just a swap to rule them all for implementing the copy-assignment
   operator, move assignment operator and move constructor in C++11.

The following member functions are necessary to implement this idiom:

 + Copy-constructor
 + Destructor
 + _Swap function_ which can swap the data of two objects of same
   class. This function all member variables of both objects. 
   + DO NOT use std::swap as this function.
   + This functions must be non-throwing. 

 *Example*

The following redundant class String manages a resource, a
heap-allocated array of characters. 

 + File: [[file:src/design-patterns/copy-swap1.cpp][file:src/design-patterns/copy-swap1.cpp]]
 + Gist: [[https://gist.github.com/caiorss/899d8fcb09dd29b920aa0069e5b9b4ab][copy-swap1.cpp]]
 + Online Compiler: https://rextester.com/XWJA10133

#+BEGIN_SRC cpp 
  class String
  {
  public:
      // Default constructor 
      String();
      String(size_t size, char ch);
      String(const char* text);
      // Copy-constructor (rule-of-three and rule-of-five)
      String(const String& rhs);
      // Move-constructor (rule-of-three and rule-of-five)
      String(String&& rhs);
      // Destructor (rule-of-three and rule-of-five)
      ~String();

      // Copy-assignment operator (rule-of-three and rule-of-five)
      String& operator= (const String& rhs);
      // Move-assignment operator (rule-of-five)
      String& operator= (String&& rhs);

      String operator+(const char* text);

      // Swap function (std::swap overload) 
      // needed by the copy-and-swap idiom.
      friend void swap(String& lhs, String& rhs);

      // Make class printable - note this operator is a member
      // function of class ostream, no from this class.
      friend std::ostream& operator<<(std::ostream& os, const String& rhs);

      size_t      size();
      const char* data();
  private:	
      // String size 
      size_t m_size;
      // Resource: Pointer to first string character 
      char*  m_data;	
  };
#+END_SRC

The idiom needs the following functions: 

 + *Copy constructor*

#+BEGIN_SRC cpp 
  String::String(const String& rhs){
     this->m_size = rhs.m_size;
     this->m_data = new (std::nothrow) char [rhs.m_size + 1];
     std::copy(rhs.m_data, rhs.m_data + rhs.m_size + 1, this->m_data);
  }
#+END_SRC

 + *Destructor* 

#+BEGIN_SRC cpp 
  String::~String()
  {
     // Check for null to avoid dangling pointer.
     if(m_data != nullptr)
             delete [] m_data;
     m_data = nullptr;
     m_size = 0;	
  }
#+END_SRC

 + *Swap function* which can be a member function or a friend function
   overload of std::swap. In this case, it was used the friend
   std::swap version. 

#+BEGIN_SRC cpp 
   // std::swap overload - Implementation of
   // => friend void swap(String& lhs, String& rhs)
   void swap(String& lhs, String& rhs){
        std::swap(lhs.m_data, rhs.m_data);
        std::swap(lhs.m_size, rhs.m_size);
   }
#+END_SRC

The copy-assignment operator, move-assignment operator and move
constructor are implemented with the custom _std::swap_ overload. 

 + _Copy-assignment operator_:

   + The temporary copy is used for disposing the current's object
     data which is transferred to the temporary object and deleted
     when the object goes out of scope.

#+BEGIN_SRC cpp 
  // Copy-assignment operator (rule-of-three and rule-of-five)
  // Copy-and-swap implementation 
  String& String::operator= (const String& rhs)
  {
      // Temporary copy 
      String temp(rhs);
      swap(*this, temp);
      return *this;
  }
#+END_SRC

 + _Move constructor_ (C++11, Rule of five)

#+BEGIN_SRC cpp 
  // Move-constructor
  String::String(String&& rhs)
   : String() // Delegated constructor 
  {
     swap(*this, rhs);
  }
#+END_SRC

 + _Move assignment operator_ (C++11, Rule of five)

#+BEGIN_SRC cpp 
   // Move-assignment operator (rule-of-five)
   // Transfer resource ownership from right hand-side object
   // to this object being instantiated. 
   String& String::operator= (String&& rhs){
       swap(*this, rhs);	
       return *this;
   }
#+END_SRC


 *Useful C++ Documentation*

 + [[https://en.cppreference.com/w/cpp/language/copy_assignment][Copy assignment operator - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/algorithm/swap][std::swap - cppreference.com]] (Header <utility>)

 + [[http://www.cplusplus.com/reference/algorithm/swap/][swap - C++ Reference]]

 *Reference and further reading*

 + [[http://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/][Want Speed? Pass by Value.  C++Next]]

 + [[http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0208r1.pdf][Copy-swap transaction]] 

 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Copy-and-swap][More C++ Idioms/Copy-and-swap - Wikibooks, open books for an open world]]

 + [[https://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-1-1097781.html?seite=all][C++: Vor- und Nachteile des d-Zeiger-Idioms, Teil 1 | heise Developer]]
   + Note: In German. 

 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap][More C++ Idioms/Non-throwing swap - Wikibooks, open books for an open world]]

 + [[https://cpppatterns.com/patterns/copy-and-swap.html][Copy-and-swap - C++ Patterns]] 

 + [[https://www.geeksforgeeks.org/copy-swap-idiom-c/][Copy-and-Swap Idiom in C++ - GeeksforGeeks]]

 + [[https://gist.github.com/ZenLulz/34e3ea73893cad952c904b7e9387a847][C/C++ - The perfect Copy-And-Swap idiom usage  GitHub]]

 + [[https://codereview.stackexchange.com/questions/85539/applying-the-copy-swap-idiom-to-humans-and-employees][c++ - Applying the copy-swap idiom to humans and employees - Code Review Stack Exchange]]

 + [[http://www.vollmann.ch/en/blog/implementing-move-assignment-variations-in-c++.html][C++: More on Implementing Move Assignment]]

 + [[https://stackoverflow.com/questions/19841626/move-assignment-incompatible-with-standard-copy-and-swap][c++ - Move Assignment incompatible with Standard Copy and Swap - Stack Overflow]]

** Interface Class 
*** Overview  

Unlike C# and Java, C++ doesn't have any keyword for implementing
interface, however it can be implemented by creating a class with only
pure virtual functions, in other words, only abstract methods or
methods without implementation. 

The interface class has a runtime overhead due to the virtual methods
that are resolved at runtime. An alternative solution when the virtual
methods calls performance overhead is not acceptable, is to use
generic programming or templates which doesn't have runtime cost since
the methods to be called are resolved at compile-time.

Note: 
 + The annotation *virtual* - means that the method (member function)
   can be overriden by the derived class. Methods in the base class
   not annotated as virtual cannot be overriden in the derived
   classes. Unlike Java, C++ methods are not virtual by default. 

 + The annotation (=0) - means a pure virtual member function, aka
   pure virtual function which is an _abstract method_, method without
   implementation. 

 *Example*: Interface Class Declaration: 

#+BEGIN_SRC cpp 
  class IStack{
  public:
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or using C++ auto keyword for functions: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual auto size() const   -> int    = 0;
      virtual auto push(double x) -> void   = 0;
      virtual auto pop()          -> double = 0;
      virtual auto peek() const   -> double = 0;
  };
#+END_SRC
*** Example 

 *Complete Code Example*
 - File:  [[file:src/design-patterns/interface-class.cpp][file:src/design-patterns/interface-class.cpp]]

Interface class declaration:

#+BEGIN_SRC cpp 
  // Interface Stack. (Should be placed in the header file.) 
  class IStack{
  public:
          virtual ~IStack() = default;
          virtual int    size()         const = 0;
          virtual void   push(double x)       = 0;
          virtual double pop()                = 0;
          virtual double peek()         const = 0;
  };
#+END_SRC

Example: Interface implementations. 

 - Implementation of interface IStack using vector as internal
   representation.

#+BEGIN_SRC cpp 
  class StackVector: public IStack{
  public:
          StackVector(){}
          StackVector(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::vector<double> _stack{};
  };
#+END_SRC

 - Implementation using deque as internal representation:

#+BEGIN_SRC cpp 
  class StackDeque: public IStack{
  public:
          StackDeque(){}
          StackDeque(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }	
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::deque<double> _stack{};
  };
#+END_SRC

 - Sample client code: 

#+BEGIN_SRC cpp 

  auto stack_sum(IStack& s) -> double{
          //std::cerr << " ==> stack_sum for references" << std::endl;
          double sum = 0.0;
          if(s.size() == 0)
                  return sum;
          while(s.size() != 0)
                  sum += s.pop();
          return sum;
  }

  auto stack_sum(IStack* s) -> double{
          // std::cerr << " ==> stack_sum for pointers" << std::endl;
          double sum = 0.0;
          if(s->size() == 0)
                  return sum;
          while(s->size() != 0)
                  sum += s->pop();
          return sum;
  }
#+END_SRC

Function main: 

#+BEGIN_SRC cpp 
   StackVector sv = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd = {1.0, 2.0, 3.0, 5.0, 6.0};
   // The same client code works with any implementation of the interface. 
   std::cout << "stack_sum(sv) = " << stack_sum(sv) << std::endl;
   std::cout << "stack_sum(sd) = " << stack_sum(sd) << std::endl;

   IStack* spointer = nullptr;
   StackVector sv2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   spointer = &sv2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;
   spointer = &sd2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;

   auto sptr = std::unique_ptr<IStack, std::function<void (IStack*)>>{
           nullptr,
           // Custom deleter 
           [](IStack* p){
                   std::cerr << " ==== Stack deleted OK" << std::endl ;
                   delete p;
           }
   };
   sptr.reset(new StackVector());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
   sptr.reset(new StackDeque());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
#+END_SRC

Compiling Running: 

#+BEGIN_SRC txt 
   $ clang++ interface-class.cpp -o interface-class.bin -g -std=c++1z -Wall -Wextra 
   $ ./interface-class.bin
   stack_sum(sv) = 17
   stack_sum(sd) = 17
   stack_sum(spointer) = 17
   stack_sum(spointer) = 17
   stack_sum(sptr) = 55
    ==== Stack deleted OK
   stack_sum(sptr) = 55
    ==== Stack deleted OK
#+END_SRC

References and further reading: 
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Interface_Class][More C++ Idioms/Interface Class - Wikibooks, open books for an open world]]
 + [[https://accu.org/index.php/journals/269][ACCU - Separating Interface and Implementation in C++]]
 + [[https://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/sp_techniques.html][Smart Pointer Programming Techniques - 1.63.0]]
** Type Erasure
*** Overview  

Type erasure is a set of techniques for providing an uniform interface
for many different types by hiding the type information from the
client code. In C++ type erasure can be implemented with a combination
of object oriented programming and generic programming, in other
words, inheritance and templates. The fundamental building blocks of
this pattern are a base class, called _concept_, which provides the
uniform interface to the wrapped types and a derived templatized
class, called _model_, inherting the concept class which adapts the
wrapped type to the concept class. The inheritance allows any template
instantation of the model to be treated as it was the base class, thus
this approach hides the type information which can be later recovered
by downcasting the base class to the derived class.

 - Definition by Dave Abrahams and Aleksey Curtovoy in, *C++ Template*
   *Metaprogramming.*

#+BEGIN_QUOTE
  In its fullest expression, type erasure is the process of turning a
  wide variety of types with a common interface into one type with that
  same interface
#+END_QUOTE

Parts: 

 + *Concept class*
   - base class - definines the interface being enforced. 
 + *Model class*
   - templatized class inherting the concept class adpating the
     wrapped type to the concept class and holding an instance of the
     wrapped type. 
 + *Type Erasure class* (outter class)
   - Both the concept and model classes are private inner classes of
     the type erasure class.
   - The type erasure class takes an instance of the model class in the
     constructor.
   - This class stores a pointer variable to the concept class, but
     storing a pointer to the model class (dynamic polymorphism).
 + *Wrapped Type* or Objects 
   + Types wrapped by the model class wich will be erased. 

Use-cases: 

 + Create a common interface for many different types. 
 + Store wrapped types without a common base class in STL containers.
 + Store templatized classes in STL containers.
 + Implement dynamic or runtime polymorphism with value semantics.
 + Take advantage of the commonality of many unrelated classes without
   a common base class without modifying their source code. 

Known uses in C++ standard library: 

 + std::function (C++11, formber Boost.Function)

 + std::any (C++17, former Boost.Any)
   + A container which can store anything and the type of the stored
     object is not known at runtime. 

 + std::variant (C++17, former Boost.Variant)
   + Provides an interface for sum types or disjoint union or _visitor_ OO
     design pattern which is useful for manipulating abstract syntax
     tree, creating interpreters, tree data structures and fixed class
     hierarchies. 

 + void* - Void pointer in many C-APIs. 


References and further reading:
 + Nevin Liber, *Type Erasure*  <http://files.meetup.com/1455470/Type%20Erasure.pdf>
 + [[https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time][c++ - Type erasure: Retrieving value - type check at compile time - Stack Overflow]]
 + [[http://talesofcpp.fusionfenix.com/post-16/episode-nine-erasing-the-concrete][Episode Nine: Erasing the Concrete]]
 + [[https://codereview.stackexchange.com/questions/41879/concept-based-polymorphism][c++ - Concept based polymorphism - Code Review Stack Exchange]]
 + [[https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%2520Generic%2520Programming%2520with%2520Virtual%2520Concepts.pdf][Dynamic Programming with Virtual Concepts]]
 + [[https://www.reddit.com/r/cpp/comments/5epngi/type_erased_concepts/][Type erased concepts : cpp]]
 + [[http://www.cplusplus.com/articles/oz18T05o/][C++ type erasure - C++ Articles]]
 + [[https://blog.tartanllama.xyz/type-erasure-unified-call/][Type erasure with unified call syntax]]
 + [[http://www.sgh1.net/posts/cpp-type-erasure.md][My Internet Weblog - Type Erasure in C++]]
 + [[https://accu.org/index.php/journals/2424][ACCU - Polymorphism in C++  A Type Compatibility View]]

*** Example 1 - Simple type erasure.

_Problem:_ Handle the classes A, B and C which don't have a common base
class using dynamic (aka runtime) polymorphism taking advantage of
their commonality, the method .getName(). Note: the source code of A,
B and C aren't allowed to be modified

 - Complete source code:
   + File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]]
   + Online Compiler: https://rextester.com/XFH16030

#+BEGIN_SRC cpp 
  class A{
  public:
      std::string getName() const {
          return "class A";
      }
      void sayA(){
          std::cout << "I am the class A" << "\n";
      }
  };

  class B{
  public:
      std::string getName() const  {
          return "class B";
      }
      void sayB(){
          std::cout << "I am the class B" << "\n";
      }	
  };

  class C{
  public:
      std::string getName() const  {
          return "class C";
      }
      void sayC() const {
          std::cout << "I am the class C" << "\n";
      }
  };
#+END_SRC

Solution: Type erasure design pattern. 

#+BEGIN_SRC cpp 
  class TypeErasure{
  private:
      //  --- Forward declarations ----
      class Concept;
      template<class T> class Model;

      // --- Member Variables ----- // 
      std::shared_ptr<Concept> _concept_ptr;
      // Optional: 
      // RTTI (runtime type information) for recovering wrapped type
      // by downcasting 
      const std::type_info& _tinfo;
  public:
      template<typename T> 
      TypeErasure(const T& obj)
      : _concept_ptr(std::make_shared<Model<T>>(obj))
      ,_tinfo(typeid(T)) 
      {		
      }

      auto getName() const -> std::string {
              return _concept_ptr->getName();
      }

      // Recover reference to wrapped type 
      template<typename T>
      auto recover() -> T {		
          if(typeid(T) != _tinfo)
                  throw std::runtime_error("Error: cannot cast to this type");
          // Note: static_cast downcasting to wrong type has undefined behavior,
          // use with care!
          return static_cast<Model<T>*>(_concept_ptr.get())->_obj;
      }

      template<typename T>
      auto hasType() -> bool {
              return _tinfo == typeid(T);
      }
  private:
     // Concept class defines the interface to be enforced
     // In general, it is an interface class, a class with only pure virtual
     // methods (abstract methods), in other words methods without implementation.
     class Concept{
     public:
             virtual auto getName() const -> std::string = 0;
             virtual ~Concept() = default;
     };

     // Adapt the wrapped type (T) to the concept
     template<typename T>
     class Model: public Concept {
     public:
             // Instance of the wrapped type 
             T _obj;
             // Initialize _opj by copying the parameter 
             Model(const T& obj): _obj(obj){}
             auto getName() const -> std::string {
                     return _obj.getName();
             }
     };
  };

#+END_SRC

Testing in Cling REPL: 

#+BEGIN_SRC cpp 
  >> .L type-erasure1.cpp 
  >> 
  >> A()
  (A) @0x1fc2970
  >> A().getName()
  (std::string) "class A"
  >> B().getName()
  (std::string) "class B"
  >> 
  >> B().sayB()
  I am the class B
  >> 

  auto tlist = std::deque<TypeErasure>();
  tlist.emplace_back(A())
  tlist.emplace_back(B())
  tlist.emplace_back(C())
 
  >> for(const auto& t: tlist) { std::cout << "Class type = " << t.getName() << "\n"; }
  Class type = class A
  Class type = class B
  Class type = class C
  >> 

  >> tlist.at(0).recover<A>()
  (A) @0x20cc590
  >> tlist.at(0).recover<A>().sayA()
  I am the class A
  >> tlist.at(0).recover<A>().getName()
  (std::string) "class A"
  >> 

  >> tlist.at(1).recover<B>().getName()
  (std::string) "class B"
  >> 

  >> tlist.at(1).recover<C>()
  Error in <TRint::HandleTermInput()>: std::runtime_error caught: Error: cannot cast to this type
  >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
   auto tlist = std::deque<TypeErasure>();
   tlist.emplace_back(A());
   tlist.emplace_back(B());
   tlist.emplace_back(C());

   std::cout << "\n" << "EXPERIMENT 1 ============" << "\n";	
   for(const auto& t: tlist) {
           std::cout << "Class type = " << t.getName() << "\n";
   }

    // Note: It is a copy!
    A objA = tlist.at(0).recover<A>();
    objA.sayA();

    std::cout << "\n" << "EXPERIMENT 2 ============" << "\n";

    // Simulate downcasting failure 
    try {
       B objB = tlist.at(0).recover<B>();
       objB.sayB();
    } catch(const std::runtime_error& ex){
       std::cout << " [FAILURE]" << ex.what() << "\n";
    }

    B objB = tlist.at(1).recover<B>();
    objB.sayB();

    auto objC = tlist.at(2).recover<C>();
    objC.sayC();
#+END_SRC

Compiling and running: (File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]])

#+BEGIN_SRC cpp 
  $ clang++ type-erasure1.cpp -o type-erasure1.bin -g -std=c++1z -Wall -Wextra 
  $ ./type-erasure1.bin

  EXPERIMENT 1 ============
  Class type = class A
  Class type = class B
  Class type = class C
  I am the class A

  EXPERIMENT 2 ============
   [FAILURE]Error: cannot cast to this type
  I am the class B
  I am the class C
#+END_SRC
** CRTP - Curious Recurring Template Pattern
*** Overview 

It is a variation of GOF template design pattern where an algorithm
defined by the base class is customized or specified by the derived 
class. However, unlike the GOF one, this version uses C++ template
metaprogramming for emulating dynamic polymorphism or inheritance
at compile time. So it makes the code faster by eliminating virtual
function-calls.

Features: 
 + Coined by James Coplien - 1995
 + Static polymorphism technique based on template metaprogramming for
   speeding up the code eliminating virtual functions.

Use cases:
 + Reduce virtual function call overhead - by simulating dynamic
   polymorphism through static polymorphism. 
 + Implement state machines.
 + Implement high performance numerical libraries.
 + Code injection.

Libraries using this pattern:
 + Boost.Iterator
 + Boost.Python
 + Boost.Serialization 

Also known as: 
 + Code injection
 + BartonNackman Trick
 + Mixin - Name used outside C++ community 

*** Example 

 *Approach 1 - GOF - OOP template pattern* 

 - Code 1: GOF Template method design pattern using virtual functions.

 #+BEGIN_SRC cpp 
   class IntervalSummation{
   public:
           // Algorithm or entry point which calls the derived class method.
           // This is the template method 
           double summation(int lower, int upper) const{
                   double sum = 0;
                   for(int i = lower; i <= upper; i++)
                           sum += this->stepFn(i);
                   return sum; 
           }
   protected:
           // Hook method or to be defined by the derived class
           virtual double stepFn(double x) const = 0 ;
   };

   class SumOfSquares: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x; }
   };

   class SumOfCubes: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x * x; }
   };

   void clientCode(const IntervalSummation& obj){
           std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
   }
#+END_SRC

  *Approach 2 - CRTP generic programming pattern* 

 + Code 2: Code rewritten using CRTP for eliminating virtual function
   calls. The advantage is that this code can run faster than the
   previous one, however the cost is the higher complexity, loss of
   readability and runtime polymorphism. For instance, now is not
   possible to store multiple implementations of IntervalSummation in
   a data structure or refer to them with the same pointer.

 + File: [[file:src/design-patterns/crtp1.cpp][file:src/design-patterns/crtp1.cpp]]
 + Online Compiler: https://rextester.com/ZLZH2040

#+BEGIN_SRC cpp 
  template<class Implementation>
  class IntervalSummation{
  public:
          // Get reference to implementation 
          Implementation& self(){
                  return *static_cast<Implementation*>(this);
          }
          // Overload method 
          const Implementation& self() const {
                  return *static_cast<Implementation const * const>(this);
          } 	
          double summation(int lower, int upper) const {
          double sum = 0;
          for(int i = lower; i <= upper; i++)
                sum += self().stepFn(i);
          return sum; 
          }
  };

  class SumOfSquares: public IntervalSummation<SumOfSquares>{
  public:
          double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation<SumOfCubes>{
  public:
          double stepFn(double x) const { return x * x * x; }
  };

  template<class T>
  void clientCode(const IntervalSummation<T>& obj){
          std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ crtp.cpp -o crtp.bin -std=c++1z -Wall -Wextra  && ./crtp.bin
  Sum of squares in [0, 10] = 385
  Sum of cubes   in [0, 10] = 3025
  Summation at [0, 15] = 1240
  Summation at [0, 15] = 14400
#+END_SRC

References: 

 + [[https://www.codeproject.com/Tips/537606/Cplusplus-Prefer-Curiously-Recurring-Template-Patt][C++: Prefer Curiously Recurring Template Pattern (CRTP) to Template Pattern - CodeProject]]
 + [[https://mklimenko.github.io/english/2018/07/02/platform-dependent-crtp/][CRTP-based platform-dependent optimizations | GNSS C++ solutions]]
 + http://stevedewhurst.com/once_weakly/once-weakly20170328/once-weakly20170328.pdf
 + [[http://enki-tech.blogspot.com/2012/08/c11-generic-singleton.html][Enki :: Technical Blog: C++11: A generic Singleton]]
 + IDENTIFYING PROGRAMMING IDIOMS IN C++ GENERIC LIBRARIES -
   <https://etd.ohiolink.edu/rws_etd/document/get/kent1259116053/inline>
 + [[http://www.masaers.com/2014/01/22/CRTP-operator-hijacking.html][Using CRTP to easily hijack operators in c++11 | masaers blog]]
 + https://github.com/nojhan/crtp_functor_ttp
 + [[https://web.archive.org/web/20060211034709/http://devnet.developerpipeline.com/documents/s=9843/cuj0601diggins/][Developer::Pipelines | Building More Flexible Types with Mixins]]
 + [[https://accu.org/index.php/journals/296][ACCU :: Better Encapsulation for the Curiously Recurring Template Pattern]]
 + [[http://www.di.unipi.it/~nids/docs/templates_vs_inheritance.html][Replacing Virtual Methods with Templates]]
 + http://gsd.web.elte.hu/lectures/bolyai/2018/mixin_crtp/mixin_crtp.pdf
 + https://faithandbrave.hateblo.jp/entry/20071206/1196934096
 + [[https://nativecoding.wordpress.com/2015/06/05/virtual-methods-vs-crtp-benchmark-2/][Virtual Methods vs CRTP Benchmark  Native Coding]]
 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + http://barngoggles.com/visitor-with-crtp/

Best Links: 

 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + https://marcoarena.wordpress.com/2012/04/29/use-crtp-for-polymorphic-chaining/
 + http://thothonegan.tumblr.com/post/157363120503/crtp-curiously-recurring-template-pattern

Videos: 

 + Curiously Recurring Template Pattern (CRTP) -
   <https://www.youtube.com/watch?v=C3Pi5GlIfjs>

 + 

 + 
** Virtual Copy Constructor Idiom - Prototype Pattern 
*** Overview 

The virtual copy constructor idiom is a workround for allowing a
client to clone or performing deep copy at runtime of C++ instances
of derived classes from a given base class without knowing the type of
those of those instances. In other words, this idioms makes possible
to a client to clone instances of derived classes given as pointers to
base class (the type of pointers is Base*).

Note: this idiom is quite similar tot the [[https://www.programering.com/a/MjN5ADMwATA.html][prototype design pattern.]]

*** Example: Simple Virtual Copy Constructor 

File: [[file:src/design-patterns/virtual-constructor1.cpp][file:src/design-patterns/virtual-constructor1.cpp]]

Note: This example can be improved using smart pointers.

 + Interface class: 

#+BEGIN_SRC cpp 
  class IBase{
  public:
      // Destructor always virtual to avoid memory leak,
      virtual ~IBase() = default;	
      // "virtual copy constructor"
      virtual auto clone() const -> IBase* = 0;
      // "virtual default constructor"
      virtual auto create() const        -> IBase*      = 0;	
      virtual auto getID() const         -> std::string = 0;
      virtual auto setID(std::string id) -> void	= 0;
      virtual auto show() const          -> void        = 0;
  };
#+END_SRC

 + Concrete class DerivedA: 

#+BEGIN_SRC cpp 
  class DerivedA: public IBase{
  private: 
          std::string _id;
  public:
      DerivedA()
       : _id("unnamed-A"){ }

      DerivedA(std::string id)
       : _id{std::move(id)}{  }

      auto clone() const -> IBase* {
        // Invoke copy constructor 
        return new DerivedA(*this);
      }
      auto create() const -> IBase* {
        // Invoke default constructor 
        return new DerivedA();
      }
      auto getID() const -> std::string {
        return _id;
      }
      auto setID(std::string id) -> void {
        _id = id;
      }   
      auto show() const -> void  {
        std::cout << " => Class DerivedA - id = " << _id << "\n";
      }  
  };
#+END_SRC

 + Concrete clas DerivedB: 

#+BEGIN_SRC cpp 
  class DerivedB: public IBase{
  private:
       std::string _id;
  public:
       DerivedB()
        : _id("unnamed-B"){ }

       DerivedB(std::string id)
        : _id{std::move(id)}{  }

       auto clone() const -> IBase* {
         // Invoke copy constructor 
         return new DerivedB(*this);
       }
       auto create() const -> IBase* {
         // Invoke default constructor 
         return new DerivedB();
       }  
       auto getID() const -> std::string {
         return _id;
       }
       auto setID(std::string id) -> void {
          _id = std::move(id);
       }     
       auto show() const -> void  {
          std::cout << " => Class DerivedB - id = " << _id << "\n";
       }  
  };
#+END_SRC

Testing in ROOT REPL:

 + Create test objects: 

#+BEGIN_SRC cpp
// Load file as a script 
>> .L virtual-constructor1.cpp 

>> DerivedA da("objectA");

>> DerivedB db("objectB");
 
>> da.show()
 => Class DerivedA - id = objectA
>>  

>> db.show()
 => Class DerivedB - id = objectB
>> 

>> IBase* ptr = nullptr;

>> ptr->getID()
(std::string) "objectA"

>> ptr->show()
 => Class DerivedA - id = objectA
>> 
#+END_SRC

Clone object DerivedA: 

#+BEGIN_SRC cpp 
  >> IBase* clone1 = ptr->clone();

  >> clone1->getID()
  (std::string) "objectA"
  >> clone1->show()
   => Class DerivedA - id = objectA

  >> if(clone1 != ptr) std::puts("Objects are not the same. OK.");
  Objects are not the same. OK.

  >> clone1->setID("object-A-Clone");

  >> clone1->getID()
  (std::string) "object-A-Clone"

  >> ptr->getID()
  (std::string) "objectA"
  >> 

  // Delete cloned object 
  >> delete clone1;
  >> clone1 = nullptr;
#+END_SRC

Invoke default constructor of class DerivedB through the object
DerivedB:

#+BEGIN_SRC cpp 
  >> ptr = &db;

  >> ptr = &db;
  >> ptr->show()
   => Class DerivedB - id = objectB

  >> IBase* clone2 = ptr->create();

  >> clone2->show()
   => Class DerivedB - id = unnamed-B
  >> 
#+END_SRC


Further Reading: 

 + [[https://isocpp.org/wiki/faq/virtual-functions#virtual-ctors][ISO C++ - FAQ - Inheritance  What is a virtual constructor]]

 + [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/virtual-ctors.html][What is a "virtual constructor"?, C++ FAQ]]

 + [[https://isocpp.org/wiki/faq/virtual-functions#virtual-ctor-rationale][Inheritance  <code>virtual</code> functions, C++ FAQ]]

 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Covariant_Return_Types][More C++ Idioms/Covariant Return Types - Wikibooks, open books for an open world]]

 + [[https://nerdland.net/2009/06/covariant-templatized-virtual-copy-constructors/][Covariant, Templatized Virtual Copy Constructors  Nerdland]]

 + [[http://icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html][The Anatomy of the Assignment Operator]]

Codes using "virtual copy constructor":

 + [[https://people.math.ethz.ch/~concepts/doxygen/html/classconcepts_1_1FrmE__TangentialVector.html#a9da3ec4c6f5b2b0d8f3eff38602c624b][Home  Concepts | Numerical C++ Library Concepts | ETH Zurich]]

 + [[http://www.java2s.com/Tutorial/Cpp/0180__Class/Virtualcopyconstructor.htm][Virtual
   copy constructor : constructorClassC++ Tutorial]]
*** Examle: Virtual Copy Constructor with CRTP 

This alternative implementation uses CRTP (Curious Recurring Template)
for eliminating the boilerplate code and smart pointers.

File: [[file:src/design-patterns/virtual-constructor2.cpp][file:src/design-patterns/virtual-constructor2.cpp]]

 + IBase interface class:

#+BEGIN_SRC cpp 
  class IBase{
  public:
     // Destructor always virtual to avoid memory leak,
     virtual ~IBase() = default;	
     // "virtual copy constructor"
     virtual auto clone() const -> std::unique_ptr<IBase> = 0;
     // "virtual default constructor"
     virtual auto create() const        -> std::unique_ptr<IBase> = 0;	
     virtual auto getID() const         -> std::string  = 0;
     virtual auto setID(std::string id) -> void	        = 0;
     virtual auto show() const          -> void	        = 0;
  };
#+END_SRC

 + CRTP base class:

#+BEGIN_SRC cpp 
  /** Remember: Template always in header files. */
  template<typename Base, typename Derived>
  class Copyable: public Base{
  private:
       inline auto self() const -> const Derived& {
          return *static_cast<const Derived* const>(this);
       }
  public:
      virtual ~Copyable() = default;
      auto clone() const -> std::unique_ptr<Base> {
         // Invoke copy constructor 
         return std::make_unique<Derived>(this->self());
      }
      auto create() const -> std::unique_ptr<Base> {
         // Invoke default constructor 
         return std::make_unique<Derived>();
      }
  };

#+END_SRC

 + Class DerivedA. The class DerivedB is similar to this one. 

#+BEGIN_SRC cpp 
  class DerivedA: public Copyable<IBase, DerivedA>{
  private: 
       std::string _id;
  public:
       DerivedA()
         : _id("unnamed-A"){ }
       DerivedA(std::string id)
         : _id{std::move(id)}{  }
       auto getID() const -> std::string {
          return _id;
       }
       auto setID(std::string id) -> void {
          _id = id;
       }   
       auto show() const -> void  {
          std::cout << " => Class DerivedA - id = " << _id << "\n";
       }
  };
#+END_SRC

Testign in ROOT REPL: 

#+BEGIN_SRC cpp 
  >> .L virtual-constructor2.cpp

  >> DerivedA da("objA");
  >> DerivedB db("objB");
  >> 
  >> IBase* ptr = &da;

  >> ptr->getID()
  (std::string) "objA"

  >> ptr->show()
   => Class DerivedA - id = objA
  >>

  >> auto clone1 = ptr->clone()
  (std::unique_ptr<IBase, std::default_delete<IBase> > &) @0x7fdf62fa5068
  >> 

  >> clone1->setID("objA-clone");

  >> clone1->getID()
  (std::string) "objA-clone"
  >> 

  >> ptr->getID()
  (std::string) "objA"
  >> 

#+END_SRC
** Cross platform code with conditional compilation

Note: It is not a design pattern, but a useful for techinque for
designing cross platform code in C++.

Macros are useful for writing cross-platform code by hiding and
isolating platform-specific details, such as specific hardware
registers address, compiler extensions, APIs and system calls. This
example shows how to use conditional compilation to write code which
can be compiled on an Unix-like operating system, such as Linux or OSX
and Windows.

Example: 

#+BEGIN_SRC cpp 
  // Scoped enum is used to identify the operating system the code 
  // was copiled against.
  enum class SystemType{
      WindowsNT,
      Linux,
      MacOSX,
      FreeBSD,
      Unknown
  };

  /**  Returns operating system that the 
   *   library was compiled against.
  ,*/
  auto getSystemType() -> SystemType {
       #ifdef __apple__
          return SystemType::MacOSX;
       #elif defined __linux__
          return SystemType::Linux;
       #elif defined _WIN32 || defined _WIN64
         return SystemType::WindowsNT;
       #else
         return SystemType::Unknown;
       #endif
  }

  auto getOperatingSystem() -> std::string {
       SystemType type = getSystemType();
       if (type == SystemType::Linux)
          return "Linux";
       if(type == SystemType::MacOSX)
          return "MacOSX";
       if(type == SystemType::WindowsNT)
          return "Windows NT";
       if(type == SystemType::FreeBSD)
          return "FreeBSD";       
       return "Unknown operating system";
  }

  auto isWindows() -> bool {
      return getSystemType() == SystemType::WindowsNT;
  }

  // Check whether is U-N-I-X like 
  auto isNixLike() -> bool {
       auto t = getSystemType();
       return t == SystemType::Linux
               || t == SystemType::FreeBSD
               || t == SystemType::MacOSX;
  }

  /** Cross platform code for creating directory */
  void makeDirectory(std::string path){
       #if defined __linux__ || defined __apple__
      /** ==== U-NIX Specific code ==== */
          mkdir(path.c_str(), 0777);
       #elif _WIN32
      /** ==== Windows Specific Code ==== */
          CreateDirectoryA(path.c_str(), NULL);
       #endif
  }

  /** Get home directory, ~/ or $HOME on Unix or %USERPROFILE% 
   ,* environment variable on Windows 
   ,*/
  std::string getHomeDir(){
      if (getSystemType() == SystemType::WindowsNT)
         return getEnv("USERPROFILE");
       else
        return getEnv("HOME");
  }
#+END_SRC

* Misc Techniques 
** Polymorphic IO 

This technique allows to design input or output functions which can
read from any type of input stream or print to any type of output
stream. Besides C++, this design approach can also be used with any
object oriented language with an IO class hierarchy where there are an
root abstract input class (in C++ std::istream C++) and a root abstract
output class (std::ostream in C++).

File: [[file:src/design-patterns/polymorphic-io1.cpp][file:src/design-patterns/polymorphic-io1.cpp]]

 *Polymorphic IO Functions:*

 + The class std::ostream is the base class of all C++'s output streams. By
   passing the object std::cout to std::ostream, the function
   _writeVector_ writes the vector to standard output. If the parameter passed is
   std::sstringstream, the function writes the vector to the string
   stream.

 + The function readVector can read a vector of doubles from any input
   stream since the class std::istream is the base class of all input
   streams, as a result, it can read vector from std::cin (console or
   stdin), file stream std::ifstream, string stream and so on.

 + Note: This approach can also be used for binary IO and
   serialization. 

 + Summary:
   + In order to design an output agnostic function, write to the
     abstract output _std::ostream_, instead of writing to concrete
     outputs such as std::cout, std::cerr and etc.
   + To design an input agnostic function, use std::istream instead of
     a concrete input stream.

 + Documentation:
   + [[https://en.cppreference.com/w/cpp/io][Input/output library - cppreference.com]]
   + [[http://www.cplusplus.com/reference/ostream/ostream/][ostream - C++ Reference]]
   + [[http://www.cplusplus.com/reference/istream/istream/][istream - C++ Reference]]
   + [[http://www.cplusplus.com/reference/fstream/ifstream/][ifstream - C++ Reference]]

#+BEGIN_SRC cpp 
  namespace VectorIO{
     auto writeVector(std::ostream& os, const std::vector<double>& xs) -> void
     {
         os << "VECTOR";
         os << " ";
         for(auto x: xs)
                 os << x << " ";
         os << "\n";
         os.flush();
     }
     auto writeVector(std::ostream&& os, const std::vector<double>& xs) -> void
     {
         std::cerr << " [LOG] (writeVector) R-value reference" << "\n";
         writeVector(os, xs);
     }
     auto readVector(std::istream& is) -> std::vector<double>
     {
         std::vector<double> xlist;
         std::string label;
         is >> label;
         if(label != "VECTOR")
                 throw std::runtime_error("Error: wrong file layout.");
         double x;
         while(is.good() && !is.eof()){
                 is >> x;
                 xlist.push_back(x);
         }
         return xlist;
     }
     auto readVector(std::istream&& is) -> std::vector<double>
    {
         std::cerr << " [LOG] (readVector) R-value reference" << "\n";
         return readVector(is);
     }
  }
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
     using VectorIO::writeVector;
     using VectorIO::readVector;

     std::vector<double> vtest = {2.0, 4.0, 5.0, 10.0, 3.45, 9.5};

     std::cout << "\n TEST1 Writing to stdout (Standard output stream) " << "\n";
     writeVector(std::cout, vtest);

     std::cout << "\n TEST2 Writing to stderr (Standard error stream) " << "\n";
     writeVector(std::cerr, vtest);

     std::cout << "\n TEST3 Writing to std::stringstream " << "\n";
     std::stringstream fakeFile;
     writeVector(fakeFile, vtest);	
     std::cout << "fakeFile = " << fakeFile.str() << "\n";

     std::cout << "\n TEST4 Reading from std::stringstream " << "\n";
     auto out1 = readVector(fakeFile);
     writeVector(std::cout, out1);

     std::cout << "\n TEST5 Write to a file" << "\n";
     // Note: It is not possible without R-value reference.
     writeVector(std::ofstream("vector.txt"), vtest);

     std::cout << "\n TEST6 Read from file - Version 1" << "\n";
     // Call R-value reference version 
     auto out2 = readVector(std::ifstream("vector.txt"));
     writeVector(std::cout, out2);

     std::cout << "\n TEST7 Read from file - Version 2" << "\n";
     std::ifstream fd{"vector.txt"};
     // Call L-value reference version of readVector 
     auto out3 = readVector(fd);
     writeVector(std::cout, out3);
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  $ clang++ polymorphic-io1.cpp -o polymorphic-io1.bin -g -std=c++11 -Wall -Wextra 
  $ ./polymorphic-io1.bin

   TEST1 Writing to stdout (Standard output stream) 
  VECTOR 2 4 5 10 3.45 9.5 

   TEST2 Writing to stderr (Standard error stream) 
  VECTOR 2 4 5 10 3.45 9.5 

   TEST3 Writing to std::stringstream 
  fakeFile = VECTOR 2 4 5 10 3.45 9.5 


   TEST4 Reading from std::stringstream 
  VECTOR 2 4 5 10 3.45 9.5 9.5 

   TEST5 Write to a file
   [LOG] (writeVector) R-value reference

   TEST6 Read from file - Version 1
   [LOG] (readVector) R-value reference
  VECTOR 2 4 5 10 3.45 9.5 9.5 

   TEST7 Read from file - Version 2
  VECTOR 2 4 5 10 3.45 9.5 9.5 
#+END_SRC

** Multiple booleans encoded as a single bitmask value 

 Note: It is not a design pattern, but a technique for encoding
 multiple booleans or flags inside a single value, passing multiple
 booleans as function parameters or returning multiple booleans as a
 single value.

 Example: 

  - File:  [[file:src/design-patterns/boolean-bitmask.C][file:src/design-patterns/boolean-bitmask.C]]  (CLING script)

 #+BEGIN_SRC cpp 
   #include <iostream>
   #include <vector>
   #include <ostream> // Operator: (<<)
   #include <string>

   enum class Permissions: unsigned {
       executable = 0x01,  // decimal = 1 or (1 << 0)
       writeable  = 0x02,  // decimal = 2 or (1 << 1)
       readable   = 0x04   // decimal = 4 or (1 << 2)
   };

   Permissions operator | (Permissions lhs, Permissions rhs){
       return static_cast<Permissions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs));
   }
   bool operator & (Permissions lhs, Permissions rhs){
       return static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs);
   }
   // Make permissions enum printable. 
   std::ostream& operator<<(std::ostream& os, const Permissions& p){
       os << std::boolalpha; // Make bool printable as 'true' or 'false' instead of 0 or 1
       os << "readable = "   << (p & Permissions::readable)   << "; "
          << "writeable = "  << (p & Permissions::writeable)  << "; "
          << "executable = " << (p & Permissions::executable);
       return os;
   }
 #+END_SRC

 Running: 

 #+BEGIN_SRC cpp 
   // Load script 
   >> .L boolean-bitmask.C 

   >> std::cout << Permissions::readable << std::endl;
   readable = true; writeable = false; executable = false

   >> std::cout << Permissions::readable << "\n";
   readable = true; writeable = false; executable = false

   >> std::cout << Permissions::writeable << "\n";
   readable = false; writeable = true; executable = false

   >> std::cout << Permissions::executable << "\n";
   readable = false; writeable = false; executable = true

   >> auto p1 = Permissions::executable | Permissions::readable ;
   >> std::cout << "p1 => " << p1 << "\n";
   p1 => readable = true; writeable = false; executable = true
   >> 

   >> auto p2 = Permissions::executable | Permissions::readable | Permissions::writeable ;
   >> std::cout << "p2 => " << p2 << "\n";
   p2 => readable = true; writeable = true; executable = true
   >> 

   >> if(p1 & Permissions::readable) { std::cout << "File is readable" << "\n"; }
   File is readable
   >> 

 #+END_SRC

 Shows all flags or all bits that are set: 

 #+BEGIN_SRC cpp 
   void showPermissions(Permissions p){
           std::cout << "Is readable?     : " << (p & Permissions::readable)   << '\n';
           std::cout << "Is writeable?    : " << (p & Permissions::writeable)  << '\n';
           std::cout << "Is executable?   : " << (p & Permissions::executable) << '\n';
   }

   >> showPermissions(p1)
   Is readable?     : true
   Is writeable?    : false
   Is executable?   : true
   >> 
   >> showPermissions(p2)
   Is readable?     : true
   Is writeable?    : true
   Is executable?   : true
   >> 
 #+END_SRC

 Design 1: Function uses multiple bools creating a file with some
 permissions. 

 #+BEGIN_SRC cpp 
   using FilePerms = std::tuple<bool, bool, bool>;

   // Design 1:
   FilePerms createFileDD1(
        std::string name,
        bool readable,
        bool writeable,
        bool executable ){
        std::cout << std::boolalpha
                  << "Create file = " << name << "\n"
                  << " with the following permissions" << "\n"
                  << "  + readable   = " << readable   << "\n"
                  << "  + writeable  = " << writeable  << "\n"
                  << "  + executable = " << executable << "\n"
                  << "\n";
        return FilePerms {readable, writeable, executable};	
   }

   >> auto pd1 = createFileDD1("dataset.txt", true, false, false)
   Create file = dataset.txt
    with the following permissions
     + readable   = true
     + writeable  = false
     + executable = false

   >> pd1
   (std::tuple<bool, bool, bool> &) { true, false, false }
   >> 

   >> std::cout << "R = " << std::get<0>(pd1) << "\n";
   R = true
   >> std::cout << "W = " << std::get<1>(pd1) << "\n";
   W = false
   >> std::cout << "X = " << std::get<2>(pd1) << "\n";
   X = false
   >> 
 #+END_SRC

 Design 2: Use bitmask flags instead of bools. The advantage is more
 readability and less functions parameters. 

 #+BEGIN_SRC cpp 
   // Design 1:
   Permissions createFileDD2(std::string name, Permissions p){
        std::cout << std::boolalpha
                  << "Create file = " << name << "\n"
                  << " with the following permissions" << "\n"
                  << "  + readable   = " << (p & Permissions::readable)   << "\n"
                  << "  + writeable  = " << (p & Permissions::writeable)  << "\n"
                  << "  + executable = " << (p & Permissions::executable) << "\n"
                  << "\n";
        return p;
   }

   >> auto pd2 = createFileDD2("Sales-report.xls", Permissions::readable | Permissions::writeable)
   Create file = Sales-report.xls
    with the following permissions
     + readable   = true
     + writeable  = true
     + executable = false

   (Permissions)  : (unsigned int) 6
   >> 

   >> createFileDD2("parser.exe", Permissions::readable | Permissions::writeable | Create file = parser.exe
    with the following permissions
     + readable   = true
     + writeable  = true
     + executable = true

   (Permissions)  : (unsigned int) 7
   >> 

   >> std::cout << "R = " << (pd2 & Permissions::readable) << "\n";
   R = true
   >> std::cout << "W = " << (pd2 & Permissions::writeable) << "\n";
   W = true
   >> std::cout << "X = " << (pd2 & Permissions::executable) << "\n";
   X = false
 #+END_SRC

** Universal Polymorphic Factory 

This customized implementation of the polymorphic factory can
instantiate objects of any type, even if they don't have the same base
class. Another feature is that the factory class doesn't need to have
any knowledge about any base class. The trick used were templates;
void* pointers for type erasure of heap-objects; static objects for
registering classes in the factory and RTTI - for generating better
error messages and making the conversion from void* to the particular
class being instantiated safer.

 + File: [[file:src/design-patterns/factory-universal1.cpp][file:src/design-patterns/factory-universal1.cpp]]
 + Online Compiler: https://rextester.com/GKEBF89553

The class ~runtime_error_location~ class is used for providing exception
with better context information with the line and the file the
exception was generated.

#+BEGIN_SRC cpp 
  #define RUNTIME_ERROR_LOCATION(message)  \
          runtime_error_location(__LINE__, __FILE__, message)

  struct runtime_error_location: public std::exception {
      std::string  message;
      runtime_error_location(const std::string& text)
                  : message{text}
      {
      }
      runtime_error_location(
                  unsigned int line,
                  const std::string& file,
                  const std::string& text
                  )
          {
            message = file + ":" + std::to_string(line) + ": " + "Error: " + text;
          }
      auto what() const noexcept -> const char* {
          return message.c_str();
      }
  };
#+END_SRC

The UniversalFactory contains the static factory methods make and makeSafe
which returns an unique_ptr to an object instantiated on the heap. If
the factory method make fails it returns a nullptr without throwing an
exception and makeSafe returns an ~runtime_error_location~ exception if
there is a failure to instantiate.

Once the classes are registered, objects can be instantiated with: 

 + std::unique_ptr<BaseA> objectD = UniversalFactory::make<BaseClass>("DerivedClassD");
 + std::unique_ptr<BaseX> object1 = UniversalFactory::make<BaseClass>("DerivedClassY");

#+BEGIN_SRC cpp 
  class UniversalFactory{
  private:
        using FactoryMap = std::map<std::string, UniversalFactory*>;
        // Force global variable to be initialized, thus it avoid the
        // inialization order fisaco.
        static auto getRegister() -> FactoryMap& {
           static FactoryMap classRegister{};
           return classRegister;
        }
  public:
      // ========== Instance Methods ========//

      // Destructor
      virtual
      ~UniversalFactory() = default;

      // Encapsulates class constructor.
      // The type void* performs pointer type erasure
      virtual
      auto create() const -> void* = 0;

      // Encapsulates destructor 
      virtual
      auto destroy(void* object) const -> void = 0;

      virtual
      auto size() const -> size_t = 0;

      virtual
      auto typeinfo() const -> const std::type_info& = 0;

      // ========== Static Methods ========//

      /** Register factory object of derived class */
      static
      auto registerFactory(const std::string& name, UniversalFactory* factory) -> void {
           auto& reg = UniversalFactory::getRegister();
           reg[name] = factory;
      }
      /** Show all registered classes printing their name to stdout. */
      static
      auto showClasses() -> void {
          std::cout << " Registered classes. " << "\n";
          std::cout << " =================== " << "\n";
          for(const auto& pair: UniversalFactory::getRegister())
               std::cout << " + " << pair.first
                         << " ; RTTI name = "
                         << pair.second->typeinfo().name()
                         << " ; size (bytes) = "
                         << pair.second->size()
                         << "\n";
      }

      /** Attemp to instantiate a class, if it is not possible, returns nullptr */
      template<class BaseClass>
      static
      auto make(const std::string& name) -> std::unique_ptr<BaseClass> {
              FactoryMap& reg = UniversalFactory::getRegister();
              auto it = reg.find(name);
              if(it == reg.end())
                      return nullptr;
              // Avoid core dump if the conversion is not possible.
              if(it->second->typeinfo() != typeid(BaseClass))
                      return nullptr;
              void* ptr = it->second->create();
              return std::unique_ptr<BaseClass>(reinterpret_cast<BaseClass*>(ptr));
      }

      /** Attempt to instantiate class, if it is not possible throws an exception. */
      template<class BaseClass>
      static
      auto makeSafe(const std::string& name) -> std::unique_ptr<BaseClass> {
         // Throw exception for providing better context information and avoid
         // Core dump due to dangerous reinterpret_cast<>.
         auto object = UniversalFactory::make<BaseClass>(name);
         if(object == nullptr)
            throw RUNTIME_ERROR_LOCATION(
                 std::string("Cannot create type. Failed to cast void* to: ") + name);
         return object;
      }
  };  // -------- End Of class UniversalFactory() ------//

#+END_SRC

The class FactoryImpl is used for creating static objects (global
objects) for registering classes in the factory during the program
initialization. This class also performs type erasure of the
constructor and destructor by using void* for allowing it to work with
any type. 

#+BEGIN_SRC cpp 
  template<typename DerivedClass, typename BaseClass = DerivedClass>
  class FactoryImpl: UniversalFactory{
  private:
       const std::type_info& _tinfo;
  public:
       // Register this global object on the Factory register
       FactoryImpl(const std::string& name)
               : _tinfo(typeid(BaseClass))
       {
           std::cerr << " [TRACE] " << " Registered Class = " << name << "\n";
           UniversalFactory::registerFactory(name, this);
       }
       // Capture class default constructor => constructor type erasure 
       auto create() const -> void* override {
               return new DerivedClass;
       }
       // Capture destructor => Destructor type erasure 
       auto destroy(void* object) const -> void override {
               delete reinterpret_cast<BaseClass*>(object);
       }	
       auto typeinfo() const -> const std::type_info& override {
               return _tinfo;
       }
       auto size() const -> size_t override {
               return sizeof(DerivedClass);
       }
  };

#+END_SRC

 *Class Registration with static objects.*

Classes can be registered in the factory by creating an static
instance (static object) of the class FactoryImpl, which registers the
class or type passed as template parameter, during the object
initialization. 


 + The first template parameter is the class to be registered and the
   second one is its base class. If the class to be registered, doesn't
   have base class, it can omitted. The constructor argument is the name
   of the class to be registered as string.

 + The anonymous namespace in this example is used for defining
   internal linkage and making the static objects private or only
   visible in the current compilation unit or file for avoiding name
   clashes.

 + Note: The registered classes doesn't need to have a common base
   class, thus it is possible to register any class as the class
   NonDerived in the code below. 

#+BEGIN_SRC cpp 
  namespace {
     
     auto register_Base       = FactoryImpl<Base, Base>("Base");
     auto register_DerivedA   = FactoryImpl<DerivedA, Base>("DerivedA");
     auto register_DerivedB   = FactoryImpl<DerivedB, Base>("DerivedB");

     // Classes without a base class doesn't need the second template paramter 
     auto register_NonDerived = FactoryImpl<NonDerived>("NonDerived");
  }
#+END_SRC

The registration boilerplate can be eliminated by using macros:

#+BEGIN_SRC cpp 
  // Register a non-polymorphic class -> It means a class without base class 
  #define REGISTER_CLASS_TO_FACTORY1(aclass) \
          namespace {  auto register_ ## derived = FactoryImpl<aclass, aclass>( #aclass ); }

  // Register a polymorphic class to the factory.
  #define REGISTER_CLASS_TO_FACTORY2(derivedClass, baseClass) \
          namespace {  auto register_ ## derivedClass = FactoryImpl<derivedClass, baseClass>( #derivedClass ); }

  REGISTER_CLASS_TO_FACTORY2(Base, Base);
  REGISTER_CLASS_TO_FACTORY2(DerivedA, Base);
  REGISTER_CLASS_TO_FACTORY2(DerivedB, Base);
  REGISTER_CLASS_TO_FACTORY1(NonDerived);
#+END_SRC

 *Usage example in CERN's ROOT/Cling REPL:*

Load the proof-of-concept file

#+BEGIN_SRC cpp  
  >> .L factory-universal1.cpp 
   [TRACE]  Registered Class = Base
   [TRACE]  Registered Class = DerivedA
   [TRACE]  Registered Class = DerivedB
   [TRACE]  Registered Class = NonDerived
  >> 
  >> 
#+END_SRC

Instantiate some classes: 

#+BEGIN_SRC cpp 
  >> auto base = UniversalFactory::make<Base>("Base")
  (std::unique_ptr<Base, std::default_delete<Base> > &) @0x7f768c558088
  >> 

  >> base->getType()
  (std::string) "Base"
  >> 

  >> auto derivA = UniversalFactory::make<Base>("DerivedA")
  (std::unique_ptr<Base, std::default_delete<Base> > &) @0x7f768c5581f8

  >> derivA->showType()
  Class type = DerivedA

  >> auto derivB = UniversalFactory::make<Base>("DerivedB")
  (std::unique_ptr<Base, std::default_delete<Base> > &) @0x7f768c558238

  >> derivB->showType()
  Class type = DerivedB
  >> 

  for(const auto& cls : {"Base", "DerivedA", "DerivedB"} ){
      auto obj = UniversalFactory::makeSafe<Base>(cls);
      std::cout << "Class [" << cls << " ] = " << obj->getType() << " \n";
  }
  // Output: 
  Class [Base ] = Base 
  Class [DerivedA ] = DerivedA 
  Class [DerivedB ] = DerivedB 
  >> 

#+END_SRC

Show all registered classes 

#+BEGIN_SRC cpp  
  >> UniversalFactory::showClasses()
   Registered classes. 
   =================== 
   + Base ; RTTI name = 4Base ; size (bytes) = 8
   + DerivedA ; RTTI name = 4Base ; size (bytes) = 8
   + DerivedB ; RTTI name = 4Base ; size (bytes) = 8
   + NonDerived ; RTTI name = 10NonDerived ; size (bytes) = 1
  >> 
#+END_SRC

Instantiate a non-derived class: 

#+BEGIN_SRC cpp 
  // Instantiate a non derived class of Base 
  >> auto ndc = UniversalFactory::make<NonDerived>("NonDerived")
  (std::unique_ptr<NonDerived, std::default_delete<NonDerived> > &) @0x7f768c558138
  >> 

  >> ndc->printMessage();
   ==> I am a non derived class
  >> 
#+END_SRC

Try creating a class which is not registered

#+BEGIN_SRC cpp 
  // Returns a null pointer if there is a failure. 
  >> UniversalFactory::make<Base>("Error") == nullptr
  (bool) true

  >> UniversalFactory::make<DerivedA>("Error") == nullptr
  (bool) true
  >> 

  // makeSafe throws an exception 
  >> auto dummy = UniversalFactory::makeSafe<Base>("NonDerived");
  Error in <TRint::HandleTermInput()>: runtime_error_location caught: 
  factory-universal1.cpp:123: Error: Cannot create type. Failed to cast void* to: NonDerived
  >> 
#+END_SRC
** Visitor Design Pattern for class introspection and serialization

This variation of visitor design pattern presented in this section
allows to introspect a class instance, which makes possible to
transverse class fields; generate automated human-readable output of
member variables and other metadata and also serialize to many different
binary or human-readable text formats. Other significant features of
this technique is that the classes which performs serialization do
not need to know anything about the serializable classes and vice-versa.

File: 
  + [[file:src/design-patterns/visitor-instrospection.cpp][file:src/design-patterns/visitor-instrospection.cpp]]

Online Compiler:
  + https://rextester.com/VLHSG7293

Features: 
 + Transverse class fields.
 + Generate automated human-readable class description as string.
 + An instrospectable class can be serialized to many different
   formats such as XML, Jon, csv, binary and so on. 
 + Serialization code is independent from any instrospectable class
   and can be reused with any other class.

 *Description*

 + An instropectable class defines a member function describe which
   takes a visitor object and describe its fields and metadata to the
   visitor by calling the visitor methods .name, .id, .description and
   .field. Note that the class doesn't need to known anything about
   the visitor.
 + Summary: The method _describe_ describes class fields and additional
   metadata to an visitor object. 

#+BEGIN_SRC cpp 
  struct AClass{
        std::string name;
        int    n;
        double k;
        long   x;

        AClass(std::string name, int n, double k, long x)
          : name(name), n(n), k(k), x(x)  { }

        // Delegated constructor
        AClass(): AClass("unnamed", 10, 25.0, 1000) { }

        // Note: This method should be in the header file.
        // Every serializable class implements
        // a templated member function "describe"
        // which describe the class structure to
        // an visitor object.
        template<class Visitor>
        void describe(Visitor& v){
           v.name("AClass");   
           v.field(n, "n");
           v.field(k, "k");
           v.field(x, "x");
           v.field(name, "name");		
        }
  };
#+END_SRC

  + The visitor class DescriptionVisitor generates and print an
    automated human-readable description of class member variables.

#+BEGIN_SRC cpp 
  /** Print class information such as name and fields to stdout. */
  struct DescriptionVisitor{
       using cstring = const char*;

       template<class Described>
       void visit(Described& desc){
             desc.describe(*this);
       }
       void name(const std::string& className){
            std::cout << "Class name = " << className << "\n";
       }
       void field(int& value, cstring name){
            std::cout << " Field { name = " << name
                      << " ; type = int "
                      << " ; value = " << value << " }\n";
       }
       void field(long& value, cstring name){
            std::cout << " Field { name = " << name
                      << " ; type = long "
                      << " ; value = " << value << " }\n";	
       }
       void field(double& value, cstring name){
            std::cout << " Field { name = " << name
                      << " ; type = double "
                      << " ; value = " << value << " }\n";
       }
       void field(std::string& value, cstring name){
            std::cout << " Field { name = " << name
                      << " ; type = std::string "
                      << " ; value = " << value << " }\n";	
       }
  };
#+END_SRC

 + The visitor _WriterVisitor_ serializes to a stream any
   instrospectable class to human-readable text format.

#+BEGIN_SRC cpp 
  /** Serialize class data to stream in text format. */
  struct WriterVisitor{
      using cstring = const char*;
      std::ostream& _os;
      WriterVisitor(std::ostream& os): _os(os) { }

      template<class Described>
      void visit(Described& desc){
           desc.describe(*this);
      }
      void name(const std::string& className){		
      }
      template<class T>
      void field(T& x, cstring name){
           _os << x << " ";
      }
  };

#+END_SRC

  + The visitor _ReadVisitor_ deserializes any instrospectable class
    from stream. 

#+BEGIN_SRC cpp
  struct ReadVisitor{
      using cstring = const char*;
      std::istream& _is;

      ReadVisitor(std::istream& is): _is(is) { }

      template<class Described>
      void visit(Described& desc){
           desc.describe(*this);
      }
      void name(const std::string& className){		
      }
      template<class T>
      void field(T& value, cstring name){
           _is >> value;
      }
  };
#+END_SRC

  + The visitor _SerializeVisitor_ serializes any instrospectable class to a
    stream in binary format. 

#+BEGIN_SRC cpp 
  /** Serialize class data to stream in binary format. */
  struct SerializeVisitor{
      using cstring = const char*;
      std::ostream& _os;

      SerializeVisitor(std::ostream& os): _os(os) { }

      template<class Described>
      void visit(Described& desc){
            desc.describe(*this);
      }
      void name(const std::string& className){		
      }
      template<class T>
      void field(T& value, cstring name){
           _os.write((char*) &value, sizeof(T));
      }	
      void field(std::string& x, cstring name){
          //std::cerr << " [LOG] String serializer" << "\n";
          auto n = x.size();
          _os.write((char*) &n , sizeof(size_t));
          _os.write((char*) x.data(), n * sizeof(char));
      }
  };

#+END_SRC

 + The visitor _DeserializeVisitor_ performs the inverse operation of
   the visitor _SerializeVisitor_ by deserializing any instrospectable
   class from a stream. 

#+BEGIN_SRC cpp 
  struct DeserializeVisitor{
      using cstring = const char*;
      std::istream& _is;

      DeserializeVisitor(std::istream& is): _is(is) { }

      template<class Described>
      void visit(Described& desc){
           desc.describe(*this);
      }
      void name(const std::string& className){ }

      template<class T>
      void field(T& value, cstring name){
           _is.read((char*) &value, sizeof(T));
      }

      void field(std::string& x, cstring name){
           size_t n = 0;
           _is.read((char*) &n, sizeof(size_t));
           std::cerr << " [LOG] N = " << n << std::endl;
           x.resize(n);
           _is.read((char*) &x[0], n * sizeof(char));
      }
  };
#+END_SRC

 *Testing Code:*

Compiling and Running: 

#+BEGIN_SRC sh 
  $ clang++ visitor-instrospection.cpp -o visitor-instrospection.bin -g -std=c++1z -Wall 
  $ ./visitor-instrospection.bin
#+END_SRC

Testing object:

#+BEGIN_SRC cpp 
   AClass cls1("objectA", 200, -2.34, 900);
#+END_SRC


 + _Experiment_: Print automated human-readable class description to stdout.

#+BEGIN_SRC cpp 
   std::cout << "\n===== EXPERIMENT 1 ===========" << std::endl;
   descVisitor.visit(cls1);
#+END_SRC

Output: 

#+BEGIN_SRC text 
   ===== EXPERIMENT 1 ===========
   Class name = AClass
    Field { name = n ; type = int  ; value = 200 }
    Field { name = k ; type = double  ; value = -2.34 }
    Field { name = x ; type = long  ; value = 900 }
    Field { name = name ; type = std::string  ; value = objectA }
#+END_SRC

 + _Experiment_:  Text Serialization/Deserialization
   + Note: In addition to stringstream, the writer visitor can be used
     with any type of stream, including, file stream or output stream
     std::cout. The std::stringstream was used here for simulating as
     a file mock object. 

#+BEGIN_SRC cpp 
    auto pseudoFile = std::stringstream{};
    auto writer     = WriterVisitor(pseudoFile);
    writer.visit(cls1);

    auto reader = ReadVisitor(pseudoFile);
    AClass clsb;
    reader.visit(clsb);
    descVisitor.visit(clsb);
#+END_SRC

Output: 

#+BEGIN_SRC text 
   ==> pseudoFile = 200 -2.34 900 objectA 

  Class name = AClass
   Field { name = n ; type = int  ; value = 200 }
   Field { name = k ; type = double  ; value = -2.34 }
   Field { name = x ; type = long  ; value = 900 }
   Field { name = name ; type = std::string  ; value = objectA }
#+END_SRC

 + _Experiment_: Serialize class in binary format to a pseudo-file
   (std::stringstream)

#+BEGIN_SRC cpp 
   std::cout << "\n===== EXPERIMENT 5 == Serialize to file ===========" << std::endl;
   auto mockFile = std::stringstream{};
   auto serializer = SerializeVisitor(mockFile);
   serializer.visit(cls1);

   std::cout << "Stream = " << stringToHex(mockFile.str()) << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC text 
   Stream = \xc8\x00\x00\x00\xb8\x1e\x85\xebQ \xb8\x02\xc0\x84\x03\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00o b j e c t A 
#+END_SRC

 + _Experiment_: Deserialize class from stream. 

#+BEGIN_SRC cpp 
   auto deserializer = DeserializeVisitor(mockFile);
   AClass cls2;
   deserializer.visit(cls2);
   descVisitor.visit(cls2);
#+END_SRC

Output:

#+BEGIN_SRC text 
   ===== EXPERIMENT 6 == Deserialize from file ===========
    [LOG] N = 7
   Class name = AClass
    Field { name = n ; type = int  ; value = 200 }
    Field { name = k ; type = double  ; value = -2.34 }
    Field { name = x ; type = long  ; value = 900 }
    Field { name = name ; type = std::string  ; value = objectA }
#+END_SRC

Remarks and considerations: 

 + The size of types integers types, namely, int, short and long are
   platform dependent which can make any serialization code relying on
   them not portable across different platforms. In order to overcome this
   problem, it is necessary to use fixed size integers available at
   header [[https://en.cppreference.com/w/cpp/header/cstdint][<cstdint>]].

 + The visitor code request other metadata such as class unique ID,
   GUID (Global Unique Identifier), field long description and so on.

 + It is also possible to define visitor for XML, csv and json
   serialization. 

 *Inspired by:*

 + [[http://4thmouse.com/mystuff/articles/TemplateVisitor.html][Templatized Visitor Pattern]]
 + [[http://cbloomrants.blogspot.com/2013/02/02-16-13-reflection-visitor-pattern.html][cbloom rants: 02-16-13 - The Reflection Visitor Pattern]]
 + [[https://gamedevcoder.wordpress.com/2013/02/16/c-plus-plus-rtti-for-games/][Practical C++ RTTI for games | Gamedev Coder Diary]]
 + [[https://medium.com/@swortelbernux/libraryless-reflection-in-c-288d7873e3a6][Static Visitor Reflection in C++  Swort Elbernux  Medium]]
 + [[https://stackoverflow.com/questions/2072838/is-there-a-better-design-pattern-method-to-use][c++ - Is there a better design pattern/method to use? - Stack Overflow]]
 + [[https://stackoverflow.com/questions/2555712/c-visitor-pattern-handling-templated-string-types][C++ visitor pattern handling templated string types? - Stack Overflow]]
 + [[https://www.gamedev.net/forums/topic/553884-crtp-and-dynamic-dispatch/][CRTP and dynamic dispatch - General and Gameplay Programming - GameDev.net]]


