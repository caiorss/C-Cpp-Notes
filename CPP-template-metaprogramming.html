<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-10-21 Sun 16:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPP / C++ Review</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPP / C++ Review</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgda3832e">1. Template Metaprogramming or Generic Programming</a>
<ul>
<li><a href="#orgc28b2cd">1.1. Overview</a></li>
<li><a href="#org7abf6f5">1.2. Template type-safe duck-typing or structural typing</a></li>
<li><a href="#orgfd794a4">1.3. Class Templates</a>
<ul>
<li><a href="#org3cff5be">1.3.1. Example: Generic stack class</a></li>
<li><a href="#org013a594">1.3.2. Example: Tuple of three elements</a></li>
</ul>
</li>
<li><a href="#orgc4532a5">1.4. Templates and C++ iterators</a></li>
<li><a href="#org15dc410">1.5. Basic Template Specialization</a></li>
<li><a href="#org5f2a130">1.6. Templates with default arguments</a></li>
<li><a href="#org3c3e1c2">1.7. Implementing Higher Order Functions with templates</a></li>
<li><a href="#org1fb33a5">1.8. Metafunctions or type traits</a>
<ul>
<li><a href="#org9cf6fe0">1.8.1. Overview</a></li>
<li><a href="#org9b55cb5">1.8.2. Example</a></li>
</ul>
</li>
<li><a href="#orgcec902a">1.9. Predefined type traits in &lt;type_traits&gt;</a></li>
<li><a href="#orge4ad476">1.10. Variadic Templates</a></li>
<li><a href="#org749e416">1.11. Variadic Templates - sizeof&#x2026; operator</a></li>
<li><a href="#org52c20c3">1.12. Variadic Templates arguments expansion</a></li>
<li><a href="#org2b0715f">1.13. References and Bookmarks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-orgda3832e" class="outline-2">
<h2 id="orgda3832e"><span class="section-number-2">1</span> Template Metaprogramming or Generic Programming</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgc28b2cd" class="outline-3">
<h3 id="orgc28b2cd"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>C++ Metaprogramming Features:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Templates</span>
<ul class="org-ul">
<li>Use case:
<ul class="org-ul">
<li>Template metaprogramming or generic programming</li>
<li>Generic classes and containers</li>
<li>Generic algorithms</li>
<li>Compile-time optmization</li>
<li>Write high performance code by eliminating virtual member
function calls.</li>
</ul></li>
<li>Limitation: Unfortunately, the C++ templates cannot manipulate
the AST and generate code in the way that LISP-like languages
do.</li>
</ul></li>

<li>C++11 <span class="underline">Constexpr</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Compile-time computations such as look up tables, math
constants, CRC32, hash, string encryption and obfuscation at
compile-time and so on.</li>
</ul></li>
</ul></li>

<li><span class="underline">Inline functions</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Removing function-calls. The function code is inserted at the
call-site by the compiler allowing a more efficient and
perfomant code.</li>
</ul></li>
</ul></li>

<li><span class="underline">Pre-processor macros</span>
<ul class="org-ul">
<li>Use-cases:
<ul class="org-ul">
<li>Debugging, print line number, file, current function, function
signature and so on.</li>
<li>Conditional compilation</li>
<li>Conditional compilation for cross platform compatibility</li>
<li>Boilerplate code generation which cannot be done with templates
or anything else.</li>
<li>Generation of reflection data.</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Generic Programming / Template Metaprogramming Design Patterns:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Generic Functions, algorithms and containers</span>
<ul class="org-ul">
<li>Some known use cases:
<ul class="org-ul">
<li>C++ STL introduced by Alexander Stepanov.</li>
<li>Boost Libraries</li>
</ul></li>
</ul></li>
<li><span class="underline">CRTP =&gt; Curious Recurring Template Pattern</span>
<ul class="org-ul">
<li>Eliminates virtual function-calls overhead by emulating
inheritance or dynamic polymorphism with static polymorphism or
template metaprogramming.</li>
</ul></li>
<li><span class="underline">Type Erasure</span> 
<ul class="org-ul">
<li>Despite the high performance and the ability to operate ony type
regardless of the class hierarchy, the main shortcoming of
generic programming is that, it is not possible to store
unrelated types in the same containers or access them by the same
pointer. The type erasure technique address those downsides by
combining generic programmign and generic programming.</li>
<li>Known uses:
<ul class="org-ul">
<li>std::function (C++11)</li>
<li>std::any (C++17), Boost.any, std::variant (C++17) and Boost.variant</li>
</ul></li>
</ul></li>
<li><span class="underline">EP =&gt; Expression Template</span> =&gt; Technique used by many scientific
library for encoding DSL - Domain Specific Languages with
templates.
<ul class="org-ul">
<li>Some known uses of this design pattern are:
<ul class="org-ul">
<li>Linear Algebra: librareis Blitz++, Eigen and Armadillo</li>
<li>Automatic Differentiation.</li>
</ul></li>
</ul></li>
<li><span class="underline">Meta Functions</span> =&gt; "Functions" emualted with structs and static
methods or members that can manipulate types or query information
about types using template specialisation.</li>
<li><span class="underline">Policy Based Design</span></li>
<li><span class="underline">SFINAE</span></li>
</ul>

<p>
<b>Libraries and Frameworks for metaprogramming:</b>
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html">Boost.Hana</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/fusion/preface.html">Boost.Fusion</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html">Boost.MPL</a></li>
</ul>

<p>
<b>Tool for testing templates online</b> 
</p>

<ul class="org-ul">
<li><a href="http://metashell.org/index.html">Home - Metashell</a> - "The goal of this project is to provide an
interactive template metaprogramming shell."</li>
</ul>


<p>
<b>Template Metaprogramming Reference</b> 
</p>

<ul class="org-ul">
<li>Andrei Alexandrescu's <b>Loki Library</b> (<a href="http://loki-lib.sourceforge.net/">http://loki-lib.sourceforge.net/</a>)
<ul class="org-ul">
<li>type list</li>
<li>functor</li>
<li>singleton</li>
<li>object factory</li>
<li>visitor</li>
<li>multi methods</li>
<li>pimpl - pointer to implementation.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org7abf6f5" class="outline-3">
<h3 id="org7abf6f5"><span class="section-number-3">1.2</span> Template type-safe duck-typing or structural typing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In dynamically programming languages like Python, Ruby and etc, a
function or method can accept any object implementing the methods
referred in the function body regardless of the object base or
interface. For instance, in the code below the function describeArea
will work with any class implementing the methods .area() and .name()
not matter the object's base class. 
</p>

<p>
This ability to work with any object which has that requested types,
in this case .area() and .name() is called <span class="underline">duck-typying</span>. Other
languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
and Objective-C. The advantage of duck-typing is that function or
methods can work with classes without an inheritance hierarchy or a
common base class.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">describeArea</span>(shape):
    <span class="org-keyword">print</span>(<span class="org-string">"Shape is      = "</span> + shape.name())
    <span class="org-keyword">print</span>(<span class="org-string">"Shape area is = "</span> + <span class="org-builtin">str</span>(shape.area()))

<span class="org-keyword">class</span> <span class="org-type">Square</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, side):
        <span class="org-keyword">self</span>.side = side 
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.side * <span class="org-keyword">self</span>.side
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"square"</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, radius):
        <span class="org-keyword">self</span>.radius = radius
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.radius * <span class="org-keyword">self</span>.radius  * 3.1415
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"circle"</span>    
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">s</span> = Square(10)
&gt;&gt;&gt; <span class="org-variable-name">c</span> = Circle(3)
&gt;&gt;&gt;

&gt;&gt;&gt; describeArea(s)
Shape <span class="org-keyword">is</span>      = square
Shape area <span class="org-keyword">is</span> = 100
&gt;&gt;&gt; 
&gt;&gt;&gt; describeArea(c)
Shape <span class="org-keyword">is</span>      = circle
Shape area <span class="org-keyword">is</span> = 28.273500000000002
&gt;&gt;&gt; 
&gt;&gt;&gt; 
</pre>
</div>


<p>
<b>C++ "Duck-typing" or type-safe structural typing</b>
</p>

<p>
C++ templates feature supports a more type-safe duck-typing as the
feature allows to write functions or methods which works with any
object implementing the methods requested in the template code
regardless of passed types have a common class hierarchy or a base
class. However, unlike Python or Scala's duck typing, C++'s template
doesn't have performance penalty due to dynamic polymorphism or
reflection as it generates code at compile-time for each parameter
type. 
</p>

<p>
The C++'s template duck-typing is also called static polymorphism as a
contrast to dynamic polymorphism which requires that all objects
passed to a function or method implement the same base class.
</p>

<p>
Example: The function describeArea works with any object implementing
the methods area() and name(), however unlike Python and other
dynamically typed languages, if an object that doesn't implement none
of those mentioned methods is passed as argument, a compile error will
be generated rather than a runtime error. 
</p>

<p>
The advantage of C++ template is that it eliminates the runtime
overhead of dynamic polymorphism or virtual function calls, therefore
makes the code more performant and loosely coupled as it can work with
any class without any inheritance hierarchy.  
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Works with any type T which implements .name() or .area()</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-type">double</span> <span class="org-variable-name">m_radius</span>;
<span class="org-function-name">public</span>:
        <span class="org-function-name">Circle</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">radius</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_radius</span><span class="org-rainbow-delimiters-depth-2">(</span>radius<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
        <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> 3.1415 * m_radius * m_radius;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"circle"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">Square</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-type">double</span> <span class="org-variable-name">m_side</span>;
<span class="org-function-name">public</span>:
        <span class="org-function-name">Square</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">side</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_side</span><span class="org-rainbow-delimiters-depth-2">(</span>side<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
        <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> m_side * m_side;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"square"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-type">Square</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">(</span>4.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-type">Circle</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        describeArea<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span>;
        describeArea<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Running: 
</p>

<ul class="org-ul">
<li>The template generates multiple versions of the function
describeArea specific for each type, for instance, it generates,
describeArea(const Circle&amp;) and describeArea(const Square&amp;). The
static polymorphism is a high performance alternative to the use of
dynamic polymorphism, inheritance, and virtual methods since the
methods that will be called are resolved at compile-time.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ -std=c++11 templateDuckTyping.cpp -o <span class="org-keyword">out.bin</span> &amp;&amp; ./out.bin
Shape is = square
Area is  = 16
---------
Shape is = circle
Area is  = 28.2735
---------
</pre>
</div>

<p>
Summary: 
</p>

<ul class="org-ul">
<li>C++ Templates works in similar fashion to dynamically typed
languages' duck typing.</li>

<li>Templates can make the code more loosely coupled as they works with
any class or type implementing the requested methods.</li>

<li>Templates have zero cost and follows the C++ motto, "don't pay for
what you don't use" they only generate code when requested or
instantiated.</li>

<li>Templates are widely used in the STL (Standard Template Library)
and the Boost Library.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfd794a4" class="outline-3">
<h3 id="orgfd794a4"><span class="section-number-3">1.3</span> Class Templates</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org3cff5be" class="outline-4">
<h4 id="org3cff5be"><span class="section-number-4">1.3.1</span> Example: Generic stack class</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Note: 
</p>

<ul class="org-ul">
<li>A class template is not a class, it is factory of classes and has
zero cost until it is used or instantiated. For instance,
Stack&lt;int&gt; and Stack&lt;std::string&gt; are different classes and cannot
be stored in containers or accessed with the same pointer.</li>

<li>When Stack&lt;int&gt; or Stack&lt;double&gt; appears in the code, the compiler
generates an unique object code for each of those template
instantiation. The C++ generics doesn't have type erasure like
java where all objects can be casted to an instance of Object.</li>

<li>All the template code must be always in the header files.</li>
</ul>

<p>
Class Template Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_stack</span>;
<span class="org-function-name">public</span>:
        <span class="org-keyword">struct</span> <span class="org-type">stack_empty_error</span>: <span class="org-keyword">public</span> <span class="org-constant">std</span>::<span class="org-type">exception</span><span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">what</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-3">(){</span>
                        <span class="org-keyword">return</span> <span class="org-string">" ==&gt; Error: stack empty."</span> ;
                <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-rainbow-delimiters-depth-2">}</span>;
        <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">){</span>
                _stack.push_back<span class="org-rainbow-delimiters-depth-3">(</span>t<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">T</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
                <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
                _stack.pop_back<span class="org-rainbow-delimiters-depth-3">()</span>;
                <span class="org-keyword">return</span> x;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">T</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
                <span class="org-keyword">return</span> _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">(){</span>  <span class="org-keyword">return</span> _stack.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">bool</span>   <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _stack.empty<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span>   <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> _stack.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" stack: "</span>;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: _stack<span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; x ;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Usage example: 
</p>

<ul class="org-ul">
<li>Instantiate class template with int parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> s1;
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>20<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>-30<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>15<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; 
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; s1.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  10 20 -30 15

&gt;&gt; s1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -30
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::stack_empty_error caught:  ==&gt; Error: stack empty.
&gt;&gt; 

&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Instantiate class template with std::string parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> sd;
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"templates"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"test"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; sd.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; sd.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; sd.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; 
&gt;&gt; sd.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  hello c++ templates test
&gt;&gt; 
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"templates"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"c++"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hello"</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Generic client code for the class stack:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Non-destructive print -&gt; Creates a copy invoking copy constructor </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>t.empty<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; t.pop<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" "</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">fillStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">t</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">data</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">d</span>: data<span class="org-rainbow-delimiters-depth-2">)</span>
                t.push<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Running client code.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_double1;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1, <span class="org-rainbow-delimiters-depth-2">{</span>2.0, 5.0, 6.0, 9.0<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; stack_double1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; stack_double1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; 

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 
&gt;&gt; 
&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 

&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_string;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"hello"</span>, <span class="org-string">"hpc"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"RULEZ"</span>, <span class="org-string">"peformance"</span>, <span class="org-string">"matters"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-variable-name">C</span>++ hpc hello

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">stack_string</span><span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-function-name">C</span>++ hpc hello 
&gt;&gt; 

&gt;&gt; stack_string.clear<span class="org-rainbow-delimiters-depth-1">()</span>
&gt;&gt; printStack3<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org013a594" class="outline-4">
<h4 id="org013a594"><span class="section-number-4">1.3.2</span> Example: Tuple of three elements</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Code: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Empty constructor - necessary to store by value the tuple</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">in STL containers.</span>
        <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
        <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">A</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">B</span>&amp; <span class="org-variable-name">b</span>, <span class="org-keyword">const</span> <span class="org-type">C</span>&amp; <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">)</span>
                : a<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, b<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">)</span>, c<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">){</span>     
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">A</span> <span class="org-variable-name">a</span>;
        <span class="org-type">B</span> <span class="org-variable-name">b</span>;
        <span class="org-type">C</span> <span class="org-variable-name">c</span>;    
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> t.a;     
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> t.b;     
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> t.c;     
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTuple1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
                          &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
                          &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
                          &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
                          &lt;&lt; <span class="org-string">" } "</span>
                          &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTuple2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
                          &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
                          &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
                          &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
                          &lt;&lt; <span class="org-string">" } "</span>
                          &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> h<span class="org-rainbow-delimiters-depth-1">(</span>100.23, <span class="org-string">'x'</span>, <span class="org-string">"world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>tuple3&lt;<span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt; &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f3ea8607010
&gt;&gt; 
&gt;&gt; h.a
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; h.b
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; h.c
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>
&gt;&gt; 

&gt;&gt; getA<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; getB<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; getC<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Types parameter are deduced by the compiler.</span>
&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; printTuple2<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">h</span><span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -100 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

<span class="org-keyword">auto</span> tdata = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>100, <span class="org-string">'x'</span>, <span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>200, <span class="org-string">'z'</span>, <span class="org-string">"Forth"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>-900, <span class="org-string">'k'</span>, <span class="org-string">"Lisp"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>66, <span class="org-string">'p'</span>, <span class="org-string">"route"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tlist<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tdata<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Compiler fails to deduce arguments </span>
&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_32</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>for_each<span class="org-warning">'</span>
<span class="org-function-name">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1&lt;<span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt;<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, &amp;<span class="org-type">printTuple1</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4532a5" class="outline-3">
<h3 id="orgc4532a5"><span class="section-number-3">1.4</span> Templates and C++ iterators</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Templates can be used for writing more generic and resuable code which
operates like functions or STL algorithms on  any type of iterator or
container. 
</p>

<p>
This example shows how to implement generic code which operates on any
type of container or iterator in modern C++.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-iterator-container.cpp">file:src/template-iterator-container.cpp</a></li>
</ul>

<p>
Code highlights:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">namespace</span> <span class="org-constant">IterUtils</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-type">double</span> <span class="org-function-name">sumContainer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>, <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                        sum += *it;
                <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Sum elements of any type &lt;Container&gt; with methods .begin() and .end()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">returnign iterators.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">U</span>, <span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">sumContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">container</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">U</span><span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-type">U</span> <span class="org-variable-name">sum</span><span class="org-rainbow-delimiters-depth-3">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = container.begin<span class="org-rainbow-delimiters-depth-4">()</span>; it != container.end<span class="org-rainbow-delimiters-depth-4">()</span>; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                        sum += *it;
                <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>,
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span>,
                <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span> <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-constant">std</span>::cout &lt;&lt;  *it &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span>
                  <span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">cont</span>
                 ,<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span>
                <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 For-range based loop</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-constant">std</span>::cout &lt;&lt;  x &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Higher order function</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The parameter actions accepts any type which can be called like</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">a function returning void.</span>
        <span class="org-comment-delimiter">//</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It doesn't matter as it is possible to use both class T or typename T.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span>, <span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">for_each</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span> <span class="org-variable-name">cont</span>, <span class="org-type">Function</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span> action<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">----- End of namespace IterUtils ----- //</span>
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-iterator-container.cpp -o <span class="org-keyword">template-iterator-container.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-iterator-container.bin

=========== Experiment 1 - sumContainer
<span class="org-function-name">template-iterator-container.cpp</span>:95: ; iu::sumContainer(&amp;carray[0], &amp;carray[0] + arrsize) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:96: ; iu::sumContainer(vec1.begin(), vec1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:97: ; iu::sumContainer(list1.begin(), list1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:98: ; iu::sumContainer(deque1.begin(), deque1.end()) = 16

=========== Experiment 2 - sumContainer2 
<span class="org-function-name">template-iterator-container.cpp</span>:101: ; iu::sumContainer2&lt;double&gt;(vec1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:102: ; iu::sumContainer2&lt;int&gt;(vec1) = 15
<span class="org-function-name">template-iterator-container.cpp</span>:103: ; iu::sumContainer2&lt;double&gt;(list1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:104: ; iu::sumContainer2&lt;int&gt;(list2) = 114

=========== Experiment 3 - printContainer 

Contents of carray  = 1, 2, 4.5, 2.5, 6, 
Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 4 - printContainer2 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 5 - for_each higher order <span class="org-keyword">function</span> 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, c++, templates, awesome, binary, 
Contents of m1  = 
  earth-gravity     9.810
          euler     2.718
             pi     3.142
              x     2.345

</pre>
</div>
</div>
</div>

<div id="outline-container-org15dc410" class="outline-3">
<h3 id="org15dc410"><a id="ID-80f3766a-39eb-47ef-a3f5-5a49ef183db0"></a><span class="section-number-3">1.5</span> Basic Template Specialization</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Code example showing template specialization. As the code shows, the
template specilization can be used for type introspection, type
identification and implement reflection.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-specialization1.cpp">file:src/template-specialization1.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/BKG53705">http://rextester.com/BKG53705</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Stream manipulator std::fixed, std::setw ... </span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>      <span class="org-comment-delimiter">// </span><span class="org-comment">sin, cos, tan, exp ... M_PI, M_E ...</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">std::function </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 1 ===============================//</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether type is float point </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type float</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type double </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 2 - Template specialization for runtime type identification ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: this technique can be used for implemeting custom C++ reflection </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Return name of a given type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"unknown"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> \
        <span class="org-keyword">auto</span> <span class="org-variable-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> #type; <span class="org-rainbow-delimiters-depth-1">}</span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Specialization for int type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"int"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Automate boilerplate code using macros.</span>
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 3 - Template with int argument specialization ===//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"I down't known"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"zero"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"one"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"two"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>3<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"three"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 4 - Template with bool argument specialization ====//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"false"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"true"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 5 - Check whether types are equal ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Partial template specialization </span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 0 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Partial specialisation</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 1<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 1 - Check whether type is float pointer"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;int&gt;    ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;char&gt;   ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;float&gt;  ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;double&gt; ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 2 - Type introspection"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;    

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 3 - Templates with integers as arguments"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;0&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>0<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;1&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>1<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;2&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>2<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;10&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>10<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;14&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>14<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 4 - Templates with bool as arguments"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;false&gt;::getName&gt;()  = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;true&gt;::getName&gt;()   = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"Check whether types are equal"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, char&gt;::get()       = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;    
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;char, double&gt;::get()    = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;double, double&gt;::get()  = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, int&gt;::get()        = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">int</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are equal\n"</span>;
        <span class="org-keyword">else</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are not equal\n"</span>;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">double</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are equal\n"</span>;
        <span class="org-keyword">else</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are not equal\n"</span>;


        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-specialization1.cpp -o <span class="org-keyword">template-specialization1.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-specialization1.bin

EXPERIMENT 1 - Check whether type is float pointer
--------------------------------------------
is float point type&lt;int&gt;    ? = false
is float point type&lt;char&gt;   ? = false
is float point type&lt;float&gt;  ? = true
is float point type&lt;double&gt; ? = true

EXPERIMENT 2 - Type introspection
--------------------------------------------
<span class="org-builtin">type</span> = int
<span class="org-builtin">type</span> = char
<span class="org-builtin">type</span> = float
<span class="org-builtin">type</span> = const char*
<span class="org-builtin">type</span> = std::string

EXPERIMENT 3 - Templates with integers as arguments
--------------------------------------------
getNumberName&lt;0&gt;() = zero
getNumberName&lt;1&gt;() = one
getNumberName&lt;2&gt;() = two
getNumberName&lt;10&gt;() = I down<span class="org-string">'t known</span>
<span class="org-string">getNumberName&lt;14&gt;() = I down'</span>t known

EXPERIMENT 4 - Templates with bool as arguments
--------------------------------------------
boolTemplate&lt;false&gt;::getName&gt;()  = false
boolTemplate&lt;true&gt;::getName&gt;()   = true

Check whether types are equal
type_equal&lt;int, char&gt;::get()       = false
type_equal&lt;char, double&gt;::get()    = false
type_equal&lt;double, double&gt;::get()  = true
type_equal&lt;int, int&gt;::get()        = true
[1] Types are not equal
[2] Types are equal
</pre>
</div>
</div>
</div>
<div id="outline-container-org5f2a130" class="outline-3">
<h3 id="org5f2a130"><span class="section-number-3">1.6</span> Templates with default arguments</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Example: Array allocated on the stack memory.
</p>

<ul class="org-ul">
<li>File: default-template-args.C</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Array allocated on stack with size 10.</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Element</span>, <span class="org-type">size_t</span> <span class="org-variable-name">Size</span> = 10<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-type">Element</span> <span class="org-variable-name">m_data</span> <span class="org-rainbow-delimiters-depth-2">[</span>Size<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-function-name">public</span>:
        <span class="org-keyword">auto</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">size_t</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> Size;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">fill</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Element</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; Size; i++<span class="org-rainbow-delimiters-depth-3">)</span>
                        m_data<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> = t;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-keyword">operator</span> <span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">index</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Element&amp; <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> m_data<span class="org-rainbow-delimiters-depth-3">[</span>index<span class="org-rainbow-delimiters-depth-3">]</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">begin</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">end</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span> = <span class="org-constant">std</span>::cout<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
                os &lt;&lt; name &lt;&lt; <span class="org-string">" = "</span>;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: *<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>
                        os &lt;&lt; x &lt;&lt; <span class="org-string">" "</span> &lt;&lt; <span class="org-constant">std</span>::flush;
                os &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">default_template_args</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s1</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s1.size() = "</span> &lt;&lt; s1.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        s1.fill<span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        s1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = 8.23;
        s1<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = -10.2;
        s1<span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">]</span> = 0.0;
        s1.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s1"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, 4<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s2</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s2.size() = "</span> &lt;&lt; s2.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        s2.fill<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        s2<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"PlusPlus"</span>;
        s2<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"CPP"</span>;
        s2<span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"ASM"</span>;
        s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running on CLING REPL:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .X <span class="org-keyword">default</span>-<span class="org-keyword">template</span>-args.C 
s1.size<span class="org-rainbow-delimiters-depth-1">()</span> = 10
s1 = 8.23 -10.2 3 0 3 3 3 3 3 3 
s2.size<span class="org-rainbow-delimiters-depth-1">()</span> = 4
s2 = C++ C++ C++ C++ 
s2 = PlusPlus CPP ASM C++ 
</pre>
</div>
</div>
</div>
<div id="outline-container-org3c3e1c2" class="outline-3">
<h3 id="org3c3e1c2"><a id="ID-20156a12-aa32-407d-8cc0-5c4b85ba9021"></a><span class="section-number-3">1.7</span> Implementing Higher Order Functions with templates</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>File: <a href="src/template-hof1.cpp">file:src/template-hof1.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/ZAT8950">https://rextester.com/ZAT8950</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/**   </span><span class="org-comment">File:     template-hof1.cpp </span>
<span class="org-comment">  *  Brief:    Shows how to implement template higher order functions which operates on containers.</span>
<span class="org-comment">  *  Features: Template metaprogramming, C++11, functional programming and STL.</span>
<span class="org-comment">  ****************************************************************************/</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">list</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">ELEM</span>, <span class="org-keyword">class</span> <span class="org-type">ALLOC</span>, <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span>, <span class="org-keyword">class</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ELEM</span>, <span class="org-type">ALLOC</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">ELEM</span>&amp;<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-4">(</span>cont.front<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Template for folding over a container in a similar way to the higher order function fold. </span>
<span class="org-comment"> * Note: </span>
<span class="org-comment"> * + CONTAINER parameter accepts any argument which has .begin() and .end() methods </span>
<span class="org-comment"> *   returning iterators. </span>
<span class="org-comment"> * + STEPFN type parameters accepts any function-object, function pointer or lambda </span>
<span class="org-comment"> *   whith the following signature: (ACC, X) =&gt; ACC where ACC is the accumulator type </span>
<span class="org-comment"> *   and X is the type of the container element. </span>
<span class="org-comment"> */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span>, <span class="org-keyword">class</span> <span class="org-type">ACC</span>, <span class="org-keyword">class</span> <span class="org-type">STEPFN</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">foldRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-keyword">const</span> <span class="org-type">ACC</span>&amp; <span class="org-variable-name">init</span>, <span class="org-type">STEPFN</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">ACC</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-type">ACC</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                acc = fn<span class="org-rainbow-delimiters-depth-2">(</span>*i, acc<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-constant">std</span>::<span class="org-constant">ios_base</span>::sync_with_stdio<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;
        <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>   <span class="org-variable-name">lst</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Requires template argument </span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 1 =================\n"</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - List"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't require the template argument as the compiler can infer its type.</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 2 =================\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - list"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 3 =================\n"</span>;
        <span class="org-type">int</span> <span class="org-variable-name">result1</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>vec, 0, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-3">){</span>
                                                <span class="org-keyword">return</span> x + acc;
                                          <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;   
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(vec1) = "</span> &lt;&lt; result1 &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-type">int</span> <span class="org-variable-name">result2</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(lst) = "</span> &lt;&lt; result2 &lt;&lt; <span class="org-string">"\n"</span> ;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"product(lst) = "</span> &lt;&lt; foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">clang++ template-hof1.cpp -o <span class="org-keyword">template-hof1.bin</span> -g -std=c++11 -Wall -Wextra &amp;&amp; ./template-hof1.bin
===== EXPERIMENT 1 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - List
    1     2   400   100 
===== EXPERIMENT 2 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - list
    1     2   400   100 
===== EXPERIMENT 3 =================
<span class="org-function-name">sum</span>(vec1) = 503
<span class="org-function-name">sum</span>(lst) = 503
<span class="org-function-name">product</span>(lst) = 80000
</pre>
</div>
</div>
</div>
<div id="outline-container-org1fb33a5" class="outline-3">
<h3 id="org1fb33a5"><span class="section-number-3">1.8</span> Metafunctions or type traits</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org9cf6fe0" class="outline-4">
<h4 id="org9cf6fe0"><span class="section-number-4">1.8.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
Metafunction (aka type traits) is a template metaprogramming technique
for type introspection, type manipulation and type computation. This
idiom uses templates, template specialization, structs (classes with
everything public) and constexpr in C++11.
</p>

<p>
This section contains examples about template metafunctions. For more
information about this subject and further reading, see: 
</p>
<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Metafunction">More C++ Idioms/Metafunction - Wikibooks, open books for an open world</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Type_Generator">More C++ Idioms/Type Generator - Wikibooks, open books for an open world</a></li>
<li><a href="https://akrzemi1.wordpress.com/2012/03/19/meta-functions-in-c11/">Meta-functions in C++11 | Andrzej's C++ blog</a></li>
<li><a href="https://accu.org/index.php/journals/442">ACCU - An introduction to C++ Traits</a></li>
</ul>


<p>
A meta function has the forms: 
</p>

<ul class="org-ul">
<li>Meta function which returns type.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't matter using typename T1, typename T2</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">or using class T1, class T2 ..</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
        <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T1</span>, <span class="org-keyword">typename</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
        <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11 </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">typedef</span> ... ... <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-keyword">using</span> <span class="org-type">type_synonym</span> =  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::type ;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or in before C++11</span>
<span class="org-keyword">typedef</span>  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span> <span class="org-type">type_synonym</span>;
</pre>
</div>

<ul class="org-ul">
<li>Meta function which returns value.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">At least C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
        <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage:</span>
<span class="org-type">TYPE</span> <span class="org-variable-name">result</span> = <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ..<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value;
</pre>
</div>

<p>
Further References: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.youtube.com/watch?v=eVtLOHoDbTo">Type Traits - CopperSpice video</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9b55cb5" class="outline-4">
<h4 id="org9b55cb5"><span class="section-number-4">1.8.2</span> Example</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
<b>Example</b>
</p>

<p>
Example in:
</p>
<ul class="org-ul">
<li>file:            <a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/TAT89158">http://rextester.com/TAT89158</a></li>
<li>The code in the example demonstrates how to query types using
template specialization, catalog type information and display the
user as well.</li>
</ul>

<p>
Highlights: 
</p>

<ul class="org-ul">
<li>The <b>metafunction isPointer</b> checks whether a given type is a
pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">false</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">true</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Sample usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short*&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short&gt;::value   = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double*&gt;::value = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
</pre>
</div>

<ul class="org-ul">
<li>The <b>meta function removePointer</b> turns any pointer type into a
non-pointer type removing the star operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Partial specilization</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>

<ul class="org-ul">
<li><b>The metafunction Typeinfo</b> computes basic information about types at
compile-time. As this "metafunction" relies on template
specialization, it requires defining template specialization for
all supported types what can be cumbersome. In order to avoid the
specialization boilerplate code, the macro <code>REGISTER_TYPE_INFO</code> is
used to register the supported types.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>    = <span class="org-string">"unknown"</span>;
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>    = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>    = <span class="org-constant">false</span>;
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span> = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>     = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;     
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Macro for type registration </span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE_INFO</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span>, <span class="org-variable-name">isNumberFlag</span><span class="org-rainbow-delimiters-depth-1">)</span> \
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;{</span> \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>       = #type; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>       = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>type<span class="org-rainbow-delimiters-depth-2">)</span>; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>   = isNumberFlag; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span>  = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>    = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;   \
        <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Type registration </span>
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Type info for "</span> &lt;&lt; <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>&gt;::name 
          &lt;&lt; <span class="org-string">" size = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::size 
          &lt;&lt; <span class="org-string">" isPointer = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::isPointer 
          &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>


<p>
<b>Complete Program output:</b> (<a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a>)
</p>

<div class="org-src-container">
<pre class="src src-text">$ clang++ template-metafunction.cpp -o template-metafunction.bin -g -std=c++11 -Wall -Wextra  
./template-metafunction.bin

isPointerOLD&lt;short*&gt;::value  = 1
isPointerOLD&lt;short&gt;::value   = 0
isPointerOLD&lt;double&gt;::value  = 0
isPointerOLD&lt;double*&gt;::value = 1
isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
isPointer&lt;short*&gt;()()  = true
isPointer&lt;short&gt;()()   = false
isPointer&lt;double&gt;()()  = false
isPointer&lt;double*&gt;()() = true
Type Info: name =            bool ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =            char ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =     std::string ; bytes =   32 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =             int ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           short ; bytes =    2 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           float ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =          double ; bytes =    8 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =     const char* ; bytes =    8 ; isNumber =  true ; isPointer =  true ; isConst =  true
Type Info: name =          float* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =         double* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =   const double&amp; ; bytes =    8 ; isNumber = false ; isPointer = false ; isConst =  true
template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcec902a" class="outline-3">
<h3 id="orgcec902a"><span class="section-number-3">1.9</span> Predefined type traits in &lt;type_traits&gt;</h3>
<div class="outline-text-3" id="text-1-9">
<p>
The C++11 header <code>&lt;type_traits&gt;</code> (before <code>boost.type_traits</code>) provide many
useful type traits, also known as metafunction, for querying and
transforming types at compile-time. In addition to those operations,
the type traits available in this header can also be used for
optimizing templates by specializing them for specific types.
</p>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/type_traits/doc/html/index.html">Chapter1.Boost.TypeTraits - 1.68.0</a></li>
</ul>

<p>
Examples: 
</p>

<ul class="org-ul">
<li>To use the C++11's type traits, it is necessary to include the
header <code>&lt;type_traits&gt;</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
</pre>
</div>

<ul class="org-ul">
<li>Type trait <code>std::is_void</code>
<ul class="org-ul">
<li>Checks whether type is void.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> inspectType<span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">else</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is not void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; 
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Type <span class="org-type">is</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is float point: <code>std::is_floating_point</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is interger: <code>std::is_integral</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">unsigned</span> <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is const</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is a reference (&amp;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Type relationship</b>
</p>

<ul class="org-ul">
<li>Check whether type are equal.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if types are the same </span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Checks whether types are derived.
<ul class="org-ul">
<li><code>std::is_base_of&lt;A, B&gt;::value</code> returns true if A is a base type (superclass) of
B or B is derived class of A.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">B</span>: <span class="org-keyword">public</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Z</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

</pre>
</div>
</div>
</div>
<div id="outline-container-orge4ad476" class="outline-3">
<h3 id="orge4ad476"><span class="section-number-3">1.10</span> Variadic Templates</h3>
<div class="outline-text-3" id="text-1-10">
<p>
This code shows examples about variadic templates in C++11 and
newer standards.
</p>

<p>
File: <a href="src/template-variadic.cpp">file:src/template-variadic.cpp</a>
</p>

<p>
Code Highlights:
</p>


<ul class="org-ul">
<li>Print a sequence of heterogenous arguments.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>    
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
                                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
                                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::clog &lt;&lt; <span class="org-string">" [TRACE] Base case =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Variadic template arguments </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span>, <span class="org-keyword">const</span> <span class="org-type">Types</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
                                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
                                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
        printTypes<span class="org-rainbow-delimiters-depth-2">(</span>args ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">printTypes<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello world"</span>, 10, <span class="org-string">'x'</span>, 20.23f, <span class="org-constant">true</span>, NAN<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Ouput: 
</p>

<div class="org-src-container">
<pre class="src src-text">hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
</pre>
</div>


<ul class="org-ul">
<li>Create a function that applies a member function to a given object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span> <span class="org-type">R</span>, <span class="org-keyword">class</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">makeCommand</span><span class="org-rainbow-delimiters-depth-1">(</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to member function </span>
        <span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">T</span>::* <span class="org-function-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>,
        <span class="org-comment-delimiter">// </span><span class="org-comment">Member function arguments </span>
        <span class="org-type">Args</span> ... <span class="org-variable-name">arglist</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>R <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>=<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-3">)(</span>arglist ...<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">CNCMachine</span> <span class="org-variable-name">mach1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"7Z9FA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">CNCMachine</span> <span class="org-variable-name">mach2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"MY9FT"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">setSpeed10</span> = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::setSpeed, 10<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">shutdown</span>   = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::shutdown<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach1<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
shutdown<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Dynamic load an [U] nix-shared library or shared object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Type synonym for shared library handler </span>
<span class="org-comment"> *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">using</span> <span class="org-type">LibHandle</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">loadDLL</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">libPath</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">LibHandle</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Return unique_ptr for RAAI -&gt; Resource Acquisition is Initialization</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">releasing closing handle when the unique_ptr goes out of scope. </span>
        <span class="org-keyword">return</span> LibHandle<span class="org-rainbow-delimiters-depth-2">(</span>
                dlopen<span class="org-rainbow-delimiters-depth-3">(</span>libPath.c_str<span class="org-rainbow-delimiters-depth-4">()</span>, RTLD_LAZY<span class="org-rainbow-delimiters-depth-3">)</span>,
                <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">void</span>* <span class="org-variable-name">h</span><span class="org-rainbow-delimiters-depth-3">){</span>
                        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Shared library handle released OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                        dlclose<span class="org-rainbow-delimiters-depth-4">(</span>h<span class="org-rainbow-delimiters-depth-4">)</span>;
                <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;     
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Load symbol from shared library </span>
<span class="org-comment">  *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">loadSymbol</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LibHandle</span>&amp; <span class="org-variable-name">handle</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">symbol</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">Function</span>* <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-type">void</span>* <span class="org-variable-name">voidptr</span> = dlsym<span class="org-rainbow-delimiters-depth-2">(</span>handle.get<span class="org-rainbow-delimiters-depth-3">()</span>, symbol.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>voidptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
        <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Function</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>voidptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">GNU Scientific Library - Linear Algebra CBLAS </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">handle1</span> = loadDLL<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"/usr/lib64/libgslcblas.so"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">using</span> <span class="org-type">cblas_daxpy_type</span> = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">cblas_daxpy_type</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 3.0, 5.0, 6.0, 10.0, 8.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">ys</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 2.0, 2.0, 2.0,  2.0, 2.0<span class="org-rainbow-delimiters-depth-1">}</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"xs"</span>, xs<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Compute xs * 4.0 + ys</span>
cblas_daxpy<span class="org-rainbow-delimiters-depth-1">(</span>xs.size<span class="org-rainbow-delimiters-depth-2">()</span>, 4.0, &amp;xs<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1, &amp;ys<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>


<p>
Complete Output: 
</p>

<div class="org-src-container">
<pre class="src src-txt">$ g++ template-variadic.cpp -o template-variadic.bin -g -std=c++11 -Wall -Wextra -ldl 
$ ./template-variadic.bin

EXPERIMENT 1 = Function of many argument for printing all of them
---------------------------------------
hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
 [TRACE] Base case =&gt; x = nan

EXPERIMENT 2 = Indirect method invocation
--------------------------------------
[MACHINE] id = 7Z9FA Set machine speed to level 10
[MACHINE] id = MY9FT Set machine speed to level 10
[MACHINE] id = 7Z9FA  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = MY9FT  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = 7Z9FA Shutdown equipment
[MACHINE] id = MY9FT Shutdown equipment

EXPERIMENT 3 = Dynamic Loading from shared library (libgslcblas.so) 
--------------------------------------
 [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>

<p>
References:  
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
<li><a href="https://www.nag.com/numeric/FL/nagdoc_fl24/html/F06/f06ecf.html">F06ECF (DAXPY) : NAG Library, Mark 24</a></li>
<li><a href="https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html">Dynamically Loaded (DL) Libraries</a></li>
<li><a href="https://www.gnu.org/software/gsl/doc/html/cblas.html">GSL CBLAS Library  GSL 2.5 documentation</a></li>
</ul>
</div>
</div>

<div id="outline-container-org749e416" class="outline-3">
<h3 id="org749e416"><span class="section-number-3">1.11</span> Variadic Templates - sizeof&#x2026; operator</h3>
<div class="outline-text-3" id="text-1-11">
<p>
The operator sizeof&#x2026;(args) is used for counting the number of template
arguments.
</p>

<ul class="org-ul">
<li>Class or function with type parameters.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Return</span> <span class="org-function-name">FUNCTION</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ARGUMENTS</span> ... <span class="org-variable-name">arguments</span><span class="org-rainbow-delimiters-depth-1">){</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Operator: sizeof&#x2026;(ARGUMENTS)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">size_t</span> <span class="org-variable-name">NumberOfTypeArguments</span> = <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-1">(</span>ARGUMENTS<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Count number of type parameters</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countArgs1</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Args<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 3

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>

<ul class="org-ul">
<li>Count number of template numeric arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Number</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countNumberArguments</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Number<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 2

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3, 5, 6, 7, 10<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 6
</pre>
</div>

<ul class="org-ul">
<li>Count number of function arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Or:</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">Params</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countParameters</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Params</span> ... <span class="org-variable-name">params</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of parameters equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>params<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">()</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>12, <span class="org-string">'x'</span>, <span class="org-string">"hello world"</span>, 3.34<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>
</div>
</div>

<div id="outline-container-org52c20c3" class="outline-3">
<h3 id="org52c20c3"><span class="section-number-3">1.12</span> Variadic Templates arguments expansion</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li><b>Example 0</b>:</li>
</ul>

<p>
Expand numeric template arguments into a std::vector.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Numbers</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getNumberParameters</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> Numbers ... <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L script-parampack.C
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0, 10, 56, 100, 5, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0, 10, 56, 100, 5, 3 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>Example 1:</b></li>
</ul>

<p>
Get deque container containing the size in bytes of every type from
the parameter pack (arguments of a variadic template).
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Return a deque containing the size in bytes of each type from the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">parameter pack (types arguments).</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">{ ... } Intializer list - used for </span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 default intialization feature. </span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 8 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>, <span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1, 4, 8, 16, 32 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li><b>Example 2:</b></li>
</ul>

<p>
Example: modify example 1 for requiring at least one type parameter.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Type0</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList2</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Type0<span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;    
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-function-name">ROOT_prompt_2</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>getSizeList2<span class="org-warning">'</span>
getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
^~~~~~~~~~~~~~
<span class="org-function-name">/home/archbox/root-scripts/script-parampack.C</span>:41:6: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-warning">'</span>Type0<span class="org-warning">'</span>
<span class="org-keyword">auto</span> getSizeList2<span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   ^
&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 1 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8, 4, 1, 16, 32 <span class="org-rainbow-delimiters-depth-2">}</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 3:</b> 
</p>

<p>
Print RTTI (Runtime Type Information) about types parameters.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">TypeInfo</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-function-name">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">hash_code</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-2">)</span>
     : name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>,
       hash_code<span class="org-rainbow-delimiters-depth-2">(</span>hash_code<span class="org-rainbow-delimiters-depth-2">)</span>,
       size<span class="org-rainbow-delimiters-depth-2">(</span>size<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>   <span class="org-variable-name">name</span>;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">hash_code</span>;
    <span class="org-type">size_t</span>        <span class="org-variable-name">size</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTypesInfoFromRTTI</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">void</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tlist</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            TypeInfo<span class="org-rainbow-delimiters-depth-3">{</span>
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.name<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.hash_code<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>
                    <span class="org-rainbow-delimiters-depth-3">}</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Name"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Size"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"Hash"</span>
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;   
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: tlist<span class="org-rainbow-delimiters-depth-2">){</span>
        ss.str<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        ss.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
        ss &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; x.hash_code;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.name
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.size
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>15<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; ss.str<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">//</span><span class="org-comment">--- End of printTypesInfoFromRTTI() ----- //</span>
</pre>
</div>

<p>
Running (ROOT/Cling REPL): 
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; printTypesInfoFromRTTI&lt;&gt;()
 Name Size           Hash
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char, int, double, long double&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
    i    4     0xb675de06
    d    8     0x44573475
    e   16     0xbbbbed2c
</pre>
</div>
</div>
</div>

<div id="outline-container-org2b0715f" class="outline-3">
<h3 id="org2b0715f"><span class="section-number-3">1.13</span> References and Bookmarks</h3>
<div class="outline-text-3" id="text-1-13">
<p>
General 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/templates">Templates - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/class_template">Class template - cppreference.com</a></li>
</ul>


<p>
Templates and Iterators: 
</p>
<ul class="org-ul">
<li><a href="https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/">std::iterator is deprecated: Why, What It Was, and What to Use Instead - Fluent C++</a></li>
</ul>

<p>
Dependent Type Names: 
</p>
<ul class="org-ul">
<li><a href="http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/dependent_name.html">Dependent names - cppreference.com</a></li>
</ul>

<p>
Variadic Templates:
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/articles/EhvU7k9E/">C++11 - New features - Variadic template - C++ Articles</a></li>
<li><a href="http://kevinushey.github.io/blog/2016/01/27/introduction-to-c++-variadic-templates/">Introduction to C++ Variadic Templates  R and C++</a></li>
<li><a href="https://docs.microsoft.com/en-gb/cpp/cpp/ellipses-and-variadic-templates?view=vs-2017">Ellipses and Variadic Templates | Microsoft Docs</a></li>
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
</ul>

<p>
Videos: 
</p>

<ul class="org-ul">
<li>CppCon 2015: Peter Sommerlad "Variadic Templates in C++11 / C++14 -
An Introduction" - <a href="https://www.youtube.com/watch?v=R1G3P5SRXCw">https://www.youtube.com/watch?v=R1G3P5SRXCw</a></li>

<li>CppCon 2016: Micha Dominiak "Variadic expansion in examples" -
<a href="https://www.youtube.com/watch?v=Os5YLB5D2BU">https://www.youtube.com/watch?v=Os5YLB5D2BU</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>Variadic Templates are Funadic</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic">https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>The Way of the</b>
<b>Exploding Tuple</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple">https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple</a></li>
</ul>

<p>
Papers and technical documents about Generic Programming and Template Metaprogramming 
</p>

<ul class="org-ul">
<li>Alexander Stepanov and David R. Musser - <b>Generic Programming</b> -
<a href="http://stepanovpapers.com/genprog.pdf">http://stepanovpapers.com/genprog.pdf</a></li>

<li>Alexander Stepanov and Meng Lee. <b>The Standard Template Library</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/STL/DOC.PDF">http://stepanovpapers.com/STL/DOC.PDF</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.lrde.epita.fr/dload/papers/coots01.html">https://www.lrde.epita.fr/dload/papers/coots01.html</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html">https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html</a></li>
</ul></li>

<li>James C. Dehnert and Alexander Stepanov. <b>Fundamentals of Generic Programming</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/DeSt98.pdf">http://stepanovpapers.com/DeSt98.pdf</a></li>
</ul></li>

<li>Jeremy Gibbons. <b>Patterns in Datatype-Generic Programming</b>
<ul class="org-ul">
<li><a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf">http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf</a></li>
</ul></li>

<li>Giuseppe Lipari. <b>Design Patterns in C++ Template metaprogramming</b>
<ul class="org-ul">
<li><a href="http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf">http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf</a></li>
</ul></li>

<li>Gabriel Dos Reis and Jaakko Jarvi. <b>What is Generic Programming?</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf">https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf</a></li>
</ul></li>

<li><b>Functional Programming with C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf">https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf</a></li>
</ul></li>

<li><b>Implementing Monads for C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf">http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf</a></li>
</ul></li>

<li>Angelika Langer. <b>C++ Expression Templates - An Introduction to the</b>
<b>Principles of Expression Templates</b>
<ul class="org-ul">
<li><a href="http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm">http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm</a></li>
</ul></li>

<li><b>Advanced C++ Template Techniques: An Introduction to Meta-Programming for Scientific Computing</b>
<ul class="org-ul">
<li><a href="https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf">https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf</a></li>
</ul></li>

<li><a href="http://people.cs.uchicago.edu/~jacobm/pubs/templates.html">What's Wrong with C++ Templates?</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2018-10-21 Sun 16:46</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
