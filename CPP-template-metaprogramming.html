<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-12 Fri 10:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPP / C++ - Template Metaprogramming - Generic Programming</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPP / C++ - Template Metaprogramming - Generic Programming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1e5d64b">1. Template Metaprogramming or Generic Programming</a>
<ul>
<li><a href="#org3b8625f">1.1. Overview</a></li>
<li><a href="#orgdeabdf2">1.2. Template type-safe duck-typing or structural typing</a></li>
<li><a href="#org6c4e329">1.3. Class Template</a>
<ul>
<li><a href="#org906f484">1.3.1. Example: Generic stack class</a></li>
<li><a href="#org5036097">1.3.2. Example: Tuple of three elements</a></li>
</ul>
</li>
<li><a href="#org0b61400">1.4. Generic Programming "Concepts"</a></li>
<li><a href="#org79d9492">1.5. Non-class template parameters</a>
<ul>
<li><a href="#orge83a42d">1.5.1. Overview</a></li>
<li><a href="#orgd0ce7f0">1.5.2. Integer as template parameter</a></li>
<li><a href="#org7c1fabc">1.5.3. Function pointer as template parameter</a></li>
<li><a href="#org0ad440d">1.5.4. Class templates as template parameters</a></li>
</ul>
</li>
<li><a href="#org71e2707">1.6. Templates and STL Containers</a>
<ul>
<li><a href="#org88be806">1.6.1. Overview</a></li>
<li><a href="#org0357305">1.6.2. Example 1 - iterating over containers</a></li>
<li><a href="#org8f4824e">1.6.3. Example 2 - print any sequential container (typename)</a></li>
<li><a href="#org2702177">1.6.4. Example 3 - print map container</a></li>
<li><a href="#org6ae5d2c">1.6.5. Example 4 - print any associative container</a></li>
</ul>
</li>
<li><a href="#org312bfa9">1.7. Templates with Ranges</a></li>
<li><a href="#org0068b48">1.8. Basic Template Specialization</a></li>
<li><a href="#org1475c4f">1.9. Template Type Alias - 'using' (C++11)</a></li>
<li><a href="#org57afe5b">1.10. Templates with default arguments</a></li>
<li><a href="#org6c416f8">1.11. Implementing Higher Order Functions with templates</a></li>
<li><a href="#orgbe5e57d">1.12. Metafunctions or type traits</a>
<ul>
<li><a href="#org66dd439">1.12.1. Overview</a></li>
<li><a href="#org3dc1a40">1.12.2. Example</a></li>
</ul>
</li>
<li><a href="#orgfab43e7">1.13. Predefined type traits in &lt;type_traits&gt;</a></li>
<li><a href="#org1394f3c">1.14. Variadic Templates</a></li>
<li><a href="#org8075c8e">1.15. Variadic Templates - sizeof&#x2026; operator</a></li>
<li><a href="#org52a408f">1.16. Variadic Templates arguments expansion</a></li>
<li><a href="#org9a5c906">1.17. C++17 Variadic Template - Fold Expressions</a></li>
<li><a href="#org3bbb4bc">1.18. SFINAE - Substution Is Not a Failure</a>
<ul>
<li><a href="#org8df607e">1.18.1. Fundamentals</a></li>
<li><a href="#org8117b70">1.18.2. Metafunction or type trait std::enable_if</a></li>
<li><a href="#org8c45089">1.18.3. Metafunction or type trait std::enalbe_if_t</a></li>
</ul>
</li>
<li><a href="#org755c3e7">1.19. SFINAE - Type instrospection</a>
<ul>
<li><a href="#orga77abd3">1.19.1. Example 1 - Check whether type has default constructor</a></li>
<li><a href="#org041a967">1.19.2. Example 2 - Check whether type has .end() member function</a></li>
<li><a href="#org7784998">1.19.3. Example 3 - Check whether type is printable</a></li>
<li><a href="#org2ca0569">1.19.4. Example 4 - Print type if it is printable (C++17 if constexpr)</a></li>
</ul>
</li>
<li><a href="#org1a4ef98">1.20. Compile-time computations with constexpr specifier</a>
<ul>
<li><a href="#orged40cca">1.20.1. Overview</a></li>
<li><a href="#org1a352db">1.20.2. Basic Example - constexpr functions</a></li>
</ul>
</li>
<li><a href="#org7b88c77">1.21. References and Bookmarks</a>
<ul>
<li><a href="#orgcc1972d">1.21.1. General</a></li>
<li><a href="#orga1d8e96">1.21.2. Standard Library Facilities for Metaprogramming</a></li>
<li><a href="#orgdc3c6fa">1.21.3. Videos</a></li>
<li><a href="#org656c873">1.21.4. Papers and technical documents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-org1e5d64b" class="outline-2">
<h2 id="org1e5d64b"><span class="section-number-2">1</span> Template Metaprogramming or Generic Programming</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3b8625f" class="outline-3">
<h3 id="org3b8625f"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>C++ Metaprogramming Features:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Templates</span>
<ul class="org-ul">
<li>Use case:
<ul class="org-ul">
<li>Template metaprogramming or generic programming</li>
<li>Generic classes and containers</li>
<li>Generic algorithms</li>
<li>Compile-time optmization</li>
<li>Write high performance code by eliminating virtual member
function calls.</li>
</ul></li>
<li>Limitation: Unfortunately, the C++ templates cannot manipulate
the AST and generate code in the way that LISP-like languages
do.</li>
</ul></li>

<li>C++11 <span class="underline">Constexpr</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Compile-time computations such as look up tables, math
constants, CRC32, hash, string encryption and obfuscation at
compile-time and so on.</li>
</ul></li>
</ul></li>

<li><span class="underline">Inline functions</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Removing function-calls. The function code is inserted at the
call-site by the compiler allowing a more efficient and
perfomant code.</li>
</ul></li>
</ul></li>

<li><span class="underline">Pre-processor macros</span>
<ul class="org-ul">
<li>Use-cases:
<ul class="org-ul">
<li>Debugging, print line number, file, current function, function
signature and so on.</li>
<li>Conditional compilation</li>
<li>Conditional compilation for cross platform compatibility</li>
<li>Boilerplate code generation which cannot be done with templates
or anything else.</li>
<li>Generation of reflection data.</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Generic Programming / Template Metaprogramming Design Patterns:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Generic Functions, algorithms and containers</span>
<ul class="org-ul">
<li>Some known use cases:
<ul class="org-ul">
<li>C++ STL introduced by Alexander Stepanov.</li>
<li>Boost Libraries</li>
</ul></li>
</ul></li>

<li><span class="underline">CRTP =&gt; Curious Recurring Template Pattern</span>
<ul class="org-ul">
<li>Eliminates virtual function-calls overhead by emulating
inheritance or dynamic polymorphism with static polymorphism or
template metaprogramming.</li>
</ul></li>

<li><span class="underline">Type Erasure</span> 
<ul class="org-ul">
<li>Despite the high performance and the ability to operate ony type
regardless of the class hierarchy, the main shortcoming of
generic programming is that, it is not possible to store
unrelated types in the same containers or access them by the same
pointer. The type erasure technique address those downsides by
combining generic programmign and generic programming.</li>
<li>Known uses:
<ul class="org-ul">
<li>std::function (C++11)</li>
<li>std::any (C++17), Boost.any, std::variant (C++17) and Boost.variant</li>
</ul></li>
</ul></li>

<li><span class="underline">EP =&gt; Expression Template</span> =&gt; Technique used by many scientific
library for encoding DSL - Domain Specific Languages with
templates.
<ul class="org-ul">
<li>Some known uses of this design pattern are:
<ul class="org-ul">
<li>Linear Algebra: libraries Blitz++, Eigen and Armadillo. Those
libraries uses the EP pattern for optimizing loops at
compile-time.</li>
<li>Automatic Differentiation.</li>
</ul></li>
</ul></li>

<li><span class="underline">Meta Functions</span> or <span class="underline">Type traits</span> =&gt; "Functions" emulated with structs
and static methods or members that can manipulate types or query
type information using template specialisation.</li>

<li><span class="underline">SFINAE</span> - Substitution Is Not An Error. Use cases:
<ul class="org-ul">
<li>Type instrospection at compile-time.</li>
<li>Constrain templated overload function</li>
<li>Constrain the types of a templated function for generating better
error messages. (Hack for concepts)</li>
</ul></li>

<li><span class="underline">Tag dispatch</span> - Use an additional empty struct parameter for allowing
the compiler to distinguish between functions of multiple signature.</li>

<li><span class="underline">Policy Based Design</span></li>
</ul>


<p>
<b>Libraries and Frameworks for metaprogramming:</b>
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html">Boost.Hana</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/fusion/preface.html">Boost.Fusion</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html">Boost.MPL</a></li>
</ul>

<p>
<b>Tool for testing templates online</b> 
</p>

<ul class="org-ul">
<li><a href="http://metashell.org/index.html">Home - Metashell</a> - "The goal of this project is to provide an
interactive template metaprogramming shell."</li>

<li><a href="https://github.com/schulmar/Templar">Templar</a> - "Visualization tool for Templight C++ template debugger traces"</li>

<li><a href="https://godbolt.org/">https://godbolt.org/</a> - Compiler explorer, allows taking a closer
look at the object code (assembly and symbols) generated by
templates.</li>
</ul>

<p>
<b>Advanced Templates</b> 
</p>

<ul class="org-ul">
<li>template-template or nested templates</li>
<li>Universal references, std::forward</li>
<li>std::index_sequence</li>
<li>std::make_index_sequence</li>
<li>std::enable_if</li>
<li>dependent type with (typename) keyword</li>
<li>decltype</li>
<li>declval</li>
<li>variadic templates with tuples and variadic functions</li>
<li>Policy-based design pattern</li>
<li>SFINAE</li>
<li>CRTP</li>
</ul>

<p>
<b>Template Metaprogramming Reference</b> 
</p>

<ul class="org-ul">
<li>Andrei Alexandrescu's <b>Loki Library</b> (<a href="http://loki-lib.sourceforge.net/">http://loki-lib.sourceforge.net/</a>)
<ul class="org-ul">
<li>type list</li>
<li>functor</li>
<li>singleton</li>
<li>object factory</li>
<li>visitor</li>
<li>multi methods</li>
<li>pimpl - pointer to implementation.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgdeabdf2" class="outline-3">
<h3 id="orgdeabdf2"><span class="section-number-3">1.2</span> Template type-safe duck-typing or structural typing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In dynamically programming languages like Python, Ruby and etc, a
function or method can accept any object implementing the methods
referred in the function body regardless of the object base or
interface. For instance, in the code below the function describeArea
will work with any class implementing the methods .area() and .name()
not matter the object's base class. 
</p>

<p>
This ability to work with any object which has that requested types,
in this case .area() and .name() is called <span class="underline">duck-typying</span>. Other
languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
and Objective-C. The advantage of duck-typing is that function or
methods can work with classes without an inheritance hierarchy or a
common base class.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">describeArea</span>(shape):
    <span class="org-keyword">print</span>(<span class="org-string">"Shape is      = "</span> + shape.name())
    <span class="org-keyword">print</span>(<span class="org-string">"Shape area is = "</span> + <span class="org-builtin">str</span>(shape.area()))

<span class="org-keyword">class</span> <span class="org-type">Square</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, side):
        <span class="org-keyword">self</span>.side = side 
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.side * <span class="org-keyword">self</span>.side
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"square"</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, radius):
        <span class="org-keyword">self</span>.radius = radius
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.radius * <span class="org-keyword">self</span>.radius  * 3.1415
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"circle"</span>    
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">s</span> = Square(10)
&gt;&gt;&gt; <span class="org-variable-name">c</span> = Circle(3)
&gt;&gt;&gt;

&gt;&gt;&gt; describeArea(s)
Shape <span class="org-keyword">is</span>      = square
Shape area <span class="org-keyword">is</span> = 100
&gt;&gt;&gt; 
&gt;&gt;&gt; describeArea(c)
Shape <span class="org-keyword">is</span>      = circle
Shape area <span class="org-keyword">is</span> = 28.273500000000002
&gt;&gt;&gt; 
&gt;&gt;&gt; 
</pre>
</div>


<p>
<b>C++ "Duck-typing" or type-safe structural typing</b>
</p>

<p>
C++ templates feature supports a more type-safe duck-typing as the
feature allows to write functions or methods which works with any
object implementing the methods requested in the template code
regardless of passed types have a common class hierarchy or a base
class. However, unlike Python or Scala's duck typing, C++'s template
doesn't have performance penalty due to dynamic polymorphism or
reflection as it generates code at compile-time for each parameter
type. 
</p>

<p>
The C++'s template duck-typing is also called static polymorphism as a
contrast to dynamic polymorphism which requires that all objects
passed to a function or method implement the same base class.
</p>

<p>
Example: The function describeArea works with any object implementing
the methods area() and name(), however unlike Python and other
dynamically typed languages, if an object that doesn't implement none
of those mentioned methods is passed as argument, a compile error will
be generated rather than a runtime error. 
</p>

<p>
The advantage of C++ template is that it eliminates the runtime
overhead of dynamic polymorphism or virtual function calls, therefore
it makes the code more performant and loosely coupled as it can work
with any class regardless of any inheritance hierarchy.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Works with any type T which implements .name() or .area()</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">double</span> <span class="org-variable-name">m_radius</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">Circle</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">radius</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_radius</span><span class="org-rainbow-delimiters-depth-2">(</span>radius<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> 3.1415 * m_radius * m_radius;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"circle"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">Square</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-type">double</span> <span class="org-variable-name">m_side</span>;
<span class="org-function-name">public</span>:
   <span class="org-function-name">Square</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">side</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_side</span><span class="org-rainbow-delimiters-depth-2">(</span>side<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
   <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> m_side * m_side;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"square"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-type">Square</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">(</span>4.0<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">Circle</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
    describeArea<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span>;
    describeArea<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Running: 
</p>

<ul class="org-ul">
<li>The template generates multiple versions of the function
<b>describeArea</b> specific for each type, for instance, it generates the
overload functions <b>describeArea(const Circle&amp;)</b> and
<b>describeArea(const Square&amp;)</b>.</li>
<li>Static polymorphism is a high performance alternative to dynamic
polymorphism, inheritance, and virtual methods since all called
functions are resolved at compile-time.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ -std=c++11 templateDuckTyping.cpp -o <span class="org-keyword">out.bin</span> &amp;&amp; ./out.bin
Shape is = square
Area is  = 16
---------
Shape is = circle
Area is  = 28.2735
---------
</pre>
</div>

<p>
Generated functions: 
</p>

<ul class="org-ul">
<li>Once the template is instantiated, it generates the following
overloaded functions as object-code (compiled-code):</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Overloaded describeArea for Circle class </span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Circle</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Overloaded describeArea for Square class  </span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Square</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Generated Object-Code</b> 
</p>

<ul class="org-ul">
<li>The generated object-code can be viewed at: <a href="https://godbolt.org/z/XqhjuZ">https://godbolt.org/z/XqhjuZ</a></li>
</ul>

<p>
Main function assembly (object-code):
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">main</span>:                                   # @main
        <span class="org-keyword">push</span>    rbp
        <span class="org-keyword">mov</span>     rbp, rsp
        ... ... ... ... ... ... ... ... 
        <span class="org-keyword">call</span>    void describeArea&lt;Square&gt;(Square const&amp;) <span class="org-comment-delimiter">;; </span><span class="org-comment">Mangled name:  _Z12describeAreaI6SquareEvRKT_ </span>
        <span class="org-keyword">lea</span>     rdi, [rbp - 24]
        <span class="org-keyword">call</span>    void describeArea&lt;Circle&gt;(Circle const&amp;) <span class="org-comment-delimiter">;; </span><span class="org-comment">Mangled name: _Z12describeAreaI6CircleEvRKT_ </span>
        ... ... ... ... ... ... ... ... 
        <span class="org-keyword">ret</span>
</pre>
</div>

<p>
As C++ supports function overloading and the object code need a unique
function name for every function, the compiler generates an unique name
for every function overload, classes and template classes. This
process of generating an unique this name is called <b>name mangling</b> or
name decoration which is unique to every compiler. Due to the name
mangling, the compiler (Clang) encodes the symbol of the overloaded function
<b>describeArea&lt;Square&gt;</b> as  <code>_Z12describeAreaI6SquareEvRKT_</code>  and the
symbol of the overloaded function <b>describeArea&lt;Circle&gt;</b> as
<code>_Z12describeAreaI6CircleEvRKT_</code>.
</p>

<p>
Generated object code for function overload: describeArea&lt;Square&gt;(Square const&amp;).
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-comment-delimiter">;; </span><span class="org-comment">Mangled name: _Z12describeAreaI6SquareEvRKT_</span>
<span class="org-function-name">void</span> <span class="org-keyword">describeArea</span>&lt;Square&gt;(Square const&amp;):         # @void describeArea&lt;Square&gt;(Square const&amp;)
        <span class="org-keyword">push</span>    rbp
        <span class="org-keyword">mov</span>     rbp, rsp
        <span class="org-keyword">sub</span>     rsp, 48
        <span class="org-keyword">mov</span>     qword ptr [rbp - 8], rdi
   ... ... ... ... ... ... ... ... ... 
</pre>
</div>


<p>
Generated object code for function overload: describeArea&lt;Circle&gt;(Circle const&amp;).
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-comment-delimiter">;; </span><span class="org-comment">Mangled name:  _Z12describeAreaI6CircleEvRKT_</span>
<span class="org-function-name">void</span> <span class="org-keyword">describeArea</span>&lt;Circle&gt;(Circle const&amp;):         # @void describeArea&lt;Circle&gt;(Circle const&amp;)
        <span class="org-keyword">push</span>    rbp
        <span class="org-keyword">mov</span>     rbp, rsp
        <span class="org-keyword">sub</span>     rsp, 48
        <span class="org-keyword">mov</span> qword ptr [rbp - 8], rdi
        <span class="org-keyword">movabs</span>  rdi, offset std::__1::cout
        <span class="org-keyword">movabs</span>  rsi, offset .L.str
   ... ... ... ... ... ... ... ... ... 
</pre>
</div>


<p>
<b>Summary:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Type-safe code generator</span>: The main difference between C++ generics
(templates metaprogramming) and the generics of other languages
such as Java and C# is that C++ templates generates code at
compile-time and never erases type information, therefore C++
templates are more performant.</li>

<li>The C++ generic programming has the name <span class="underline">metaprogramming</span> (template
<span class="underline">metaprogramming</span>) because it <b>generates code at compile-time</b> just
like Lisp macros metaprogramming, although with more
limitations. For short: <span class="underline">C++ templates are type-safe code generators.</span></li>

<li>Templates have zero cost and follows the C++ motto, "don't pay for
what you don't use" they only generate code when requested or
instantiated, in other words, when there is any reference to them
in the code, for instance, std::vector&lt;double&gt;, std::vector&lt;int&gt;
and so on.</li>

<li>Templates are widely used in the STL (Standard Template Library)
and the Boost Library and many other libraries.</li>
</ul>

<p>
<b>Disadvantages:</b>
</p>

<ul class="org-ul">
<li>Generally, templates must be in header files what increases the
compile-time.</li>

<li>Hard to hide or obfuscate templates in proprietary code as they
need to be exposed in header files.</li>

<li>Template code can be hard to understand and it may be hard to
figure out the set of types parameters that can satisfy the
template constraints.</li>

<li>Hard to restrict type parameters that a template can take. The
requirements of a template type parameters are called <b>concepts</b> and
there is no language feature for making concepts explicit.</li>

<li>Templates can generate long and cryptic error messages.</li>

<li>Templates can increase the executable size, since they generate
object-code for overloaded functions generated by function
templates and also object code for classes generated by class
templates. It may not be a problem for desktop applications,
but it can be a drawback for embedded systems with limited ROM
size.</li>
</ul>
</div>
</div>

<div id="outline-container-org6c4e329" class="outline-3">
<h3 id="org6c4e329"><span class="section-number-3">1.3</span> Class Template</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org906f484" class="outline-4">
<h4 id="org906f484"><span class="section-number-4">1.3.1</span> Example: Generic stack class</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Note: 
</p>

<ul class="org-ul">
<li>A class template is not a class, it is factory of classes and has
zero cost until it is used or instantiated. For instance,
Stack&lt;int&gt; and Stack&lt;std::string&gt; are different classes and cannot
be stored in containers or accessed with the same pointer.</li>

<li>When Stack&lt;int&gt; or Stack&lt;double&gt; appears in the code, the compiler
generates an unique object code for each of those template
instantiation. The C++ generics doesn't have type erasure like
java where all objects can be casted to an instance of Object.</li>

<li>All the template code must be always in the header files.</li>
</ul>

<p>
Class Template Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_stack</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">struct</span> <span class="org-type">stack_empty_error</span>: <span class="org-keyword">public</span> <span class="org-constant">std</span>::<span class="org-type">exception</span><span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">what</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-3">(){</span>
           <span class="org-keyword">return</span> <span class="org-string">" ==&gt; Error: stack empty."</span> ;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">){</span>
        _stack.push_back<span class="org-rainbow-delimiters-depth-3">(</span>t<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
        _stack.pop_back<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">(){</span>  <span class="org-keyword">return</span> _stack.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>   <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _stack.empty<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> _stack.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" stack: "</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: _stack<span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; x ;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Usage example: 
</p>

<ul class="org-ul">
<li>Instantiate class template with int parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> s1;
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>20<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>-30<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>15<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; 
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; s1.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  10 20 -30 15

&gt;&gt; s1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -30
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::stack_empty_error caught:  ==&gt; Error: stack empty.
&gt;&gt; 

&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Instantiate class template with std::string parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> sd;
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"templates"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"test"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; sd.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; sd.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; sd.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; 
&gt;&gt; sd.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  hello c++ templates test
&gt;&gt; 
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"templates"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"c++"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hello"</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Generic client code for the class stack:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Non-destructive print -&gt; Creates a copy invoking copy constructor </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>t.empty<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-constant">std</span>::cout &lt;&lt; t.pop<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" "</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">fillStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">t</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">data</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">d</span>: data<span class="org-rainbow-delimiters-depth-2">)</span>
         t.push<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Running client code.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_double1;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1, <span class="org-rainbow-delimiters-depth-2">{</span>2.0, 5.0, 6.0, 9.0<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; stack_double1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; stack_double1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; 

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 
&gt;&gt; 
&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 

&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_string;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"hello"</span>, <span class="org-string">"hpc"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"RULEZ"</span>, <span class="org-string">"peformance"</span>, <span class="org-string">"matters"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-variable-name">C</span>++ hpc hello

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">stack_string</span><span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-function-name">C</span>++ hpc hello 
&gt;&gt; 

&gt;&gt; stack_string.clear<span class="org-rainbow-delimiters-depth-1">()</span>
&gt;&gt; printStack3<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org5036097" class="outline-4">
<h4 id="org5036097"><span class="section-number-4">1.3.2</span> Example: Tuple of three elements</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Code: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Empty constructor - necessary to store by value the tuple</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">in STL containers.</span>
     <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
     <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">A</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">B</span>&amp; <span class="org-variable-name">b</span>, <span class="org-keyword">const</span> <span class="org-type">C</span>&amp; <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : a<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, b<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">)</span>, c<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">){</span>     
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">A</span> <span class="org-variable-name">a</span>;
     <span class="org-type">B</span> <span class="org-variable-name">b</span>;
     <span class="org-type">C</span> <span class="org-variable-name">c</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.a;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.b;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.c;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTuple1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
               &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
               &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
               &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
               &lt;&lt; <span class="org-string">" } "</span>
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTuple2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
               &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
               &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
               &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
               &lt;&lt; <span class="org-string">" } "</span>
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> h<span class="org-rainbow-delimiters-depth-1">(</span>100.23, <span class="org-string">'x'</span>, <span class="org-string">"world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>tuple3&lt;<span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt; &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f3ea8607010
&gt;&gt; 
&gt;&gt; h.a
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; h.b
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; h.c
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>
&gt;&gt; 

&gt;&gt; getA<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; getB<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; getC<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Types parameter are deduced by the compiler.</span>
&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; printTuple2<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">h</span><span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -100 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

<span class="org-keyword">auto</span> tdata = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>100, <span class="org-string">'x'</span>, <span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>200, <span class="org-string">'z'</span>, <span class="org-string">"Forth"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>-900, <span class="org-string">'k'</span>, <span class="org-string">"Lisp"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>66, <span class="org-string">'p'</span>, <span class="org-string">"route"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tlist<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tdata<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Compiler fails to deduce arguments </span>
&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_32</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>for_each<span class="org-warning">'</span>
<span class="org-function-name">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1&lt;<span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt;<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, &amp;<span class="org-type">printTuple1</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0b61400" class="outline-3">
<h3 id="org0b61400"><span class="section-number-3">1.4</span> Generic Programming "Concepts"</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li><b>Concepts:</b>

<ul class="org-ul">
<li>"Concepts" is a set of requirements (implicit interface) that a
template parameter must fulfill in order to instantiate a
template.</li>

<li>The name "concepts" was coined by Alexander Stepanov, author of
the STL and one of the main proponents of generic programming.</li>

<li>A type that satisfies or fulfill a given concept is said to
<b>model this concept</b>.</li>
</ul></li>

<li><b>Concept Language Feature:</b>
<ul class="org-ul">
<li>A shortcoming of templates is the implicit requirements that
makes the code harder to read and understand and lead to verbose
and unhelpful error messages. The aim of "concept" language feature
is to make the template type requirements <span class="underline">explicit</span> and fully
specified for constraining the type parameters to type satisfying
the concept and improve the readability and error messages.</li>

<li>The C++11, C++14 and C++17 does not have the "concepts" language
feature, however it is being introduced in the upcoming C++20
standard. So, until it is not fully mainstream, the reader has to
figure out or deduce the requirement of the template parameter or
it should be specified in the comments.</li>

<li>C++20 Concepts: <a href="https://en.cppreference.com/w/cpp/language/constraints">Constraints and concepts (since C++20) - cppreference.com</a></li>
</ul></li>

<li><b>Named Requirements</b>
<ul class="org-ul">
<li>Named requirements are a set of standard widely used "concepts"
in the STL Standard Template Library for documenting template
arguments. They are helpful for understanding the STL assumptions
and expectations about the type parameters.</li>

<li><a href="https://en.cppreference.com/w/cpp/named_req">Named requirements</a></li>

<li>Widely used STL concepts or named requirements: 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/PODType">PODType</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">EqualityComparable</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/FunctionObject">FunctionObject</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/Callable">Callable</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/Iterator">LegacyIterator</a></li>
</ul></li>
</ul></li>
</ul>

<p>
Some STL Named Requirements:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Concept</th>
<th scope="col" class="org-left">Expression</th>
<th scope="col" class="org-left">Description</th>
</tr>

<tr>
<th scope="col" class="org-left">or "STL Named Requirement"</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a></td>
<td class="org-left">T obj{}; T obj; T(); T{}</td>
<td class="org-left">Type T is default constructible.</td>
</tr>

<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></td>
<td class="org-left">T a(b); T a{b}; T a = b;</td>
<td class="org-left">Type T has a copy constructor.</td>
</tr>

<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">EqualityComparable</a></td>
<td class="org-left">x == y</td>
<td class="org-left">The type has the (==) equality operator returning bool.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>



<p>
<b>References</b> 
</p>

<ul class="org-ul">
<li>Bjarne Stroustrup - <b>Concepts: The Future of Generic Programming</b>
<ul class="org-ul">
<li><a href="http://www.stroustrup.com/good_concepts.pdf">http://www.stroustrup.com/good_concepts.pdf</a></li>
</ul></li>

<li>Johan Torp - <b>Generic Programmign Intro</b> 
<ul class="org-ul">
<li><a href="https://drive.google.com/viewerng/viewer?url=http://johantorp.com/presentations/generic_programming_intro.ppt">https://drive.google.com/viewerng/viewer?url=http://johantorp.com/presentations/generic_programming_intro.ppt</a></li>
</ul></li>

<li><b>Concepts: Linguistic Support for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="http://ecee.colorado.edu/ecen5533/fall11/reading/gregor.pdf">http://ecee.colorado.edu/ecen5533/fall11/reading/gregor.pdf</a></li>
</ul></li>

<li id="[[<a href="https://accu.org/index.php/journals/2157">https://accu.org/index.php/journals/2157</a>][ACCU">Introducing Concepts]]</li>

<li><a href="https://en.wikipedia.org/wiki/Concept_(generic_programming)">Concept (generic programming) - Wikipedia</a></li>
</ul>
</div>
</div>
<div id="outline-container-org79d9492" class="outline-3">
<h3 id="org79d9492"><span class="section-number-3">1.5</span> Non-class template parameters</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orge83a42d" class="outline-4">
<h4 id="orge83a42d"><span class="section-number-4">1.5.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
It is possible to use the following kinds of template parameters.
</p>

<ul class="org-ul">
<li>class or typename</li>
<li>Integers</li>
<li>Function pointer</li>
<li>Member function pointer</li>
</ul>
</div>
</div>

<div id="outline-container-orgd0ce7f0" class="outline-4">
<h4 id="orgd0ce7f0"><span class="section-number-4">1.5.2</span> Integer as template parameter</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">n =&gt; Numeric template argument with default value 3 </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 3, <span class="org-keyword">typename</span> <span class="org-type">Action</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">repeat</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Action</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = n; i &gt; 0; i--<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
This templated function, repeat&lt;n&gt;, generates a different functions
for every different value of n. For instance, it will generate the
functions repeat&lt;1&gt; for n = 1, repeat&lt;3&gt; for n = 3, repeat&lt;10&gt; for n =
10 and so on. It can be tested at <a href="https://godbolt.org/">https://godbolt.org/</a>. 
</p>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;</span>5<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c1fabc" class="outline-4">
<h4 id="org7c1fabc"><span class="section-number-4">1.5.3</span> Function pointer as template parameter</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Syntax 1: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">mfunction</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTR</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Syntax 2: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-function-name">mfunction</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTRB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Syntax 3: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">It is also possible the following syntax with auto keyword.</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-function-name">mfunction</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTRC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-text">&gt;&gt; tabulateFunPTR&lt;exp&gt;(4)
    0     1.000
    1     2.718
    2     7.389
    3    20.086

&gt;&gt; tabulateFunPTR&lt;sqrt&gt;(9)
    0     0.000
    1     1.000
    2     1.414
    3     1.732
    4     2.000
    5     2.236
    6     2.449
    7     2.646
    8     2.828

&gt;&gt; tabulateFunPTRB&lt;cbrt&gt;(4)
    0     0.000
    1     1.000
    2     1.260
    3     1.442

&gt;&gt; tabulateFunPTRC&lt;std::exp&gt;(5)
    0     1.000
    1     2.718
    2     7.389
    3    20.086
    4    54.598
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ad440d" class="outline-4">
<h4 id="org0ad440d"><span class="section-number-4">1.5.4</span> Class templates as template parameters</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
AKA: template template. 
</p>

<p>
<b>Example 1:</b> 
</p>

<p>
Every STL container has two type parameters, the element type and the
allocator type which has the element type as parameter. In the
following code, the type parameter named Container is used for
changing the STL container used by the stack class.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">list</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Type of stack element </span>
     <span class="org-keyword">typename</span> <span class="org-type">Element</span>,
     <span class="org-comment-delimiter">// </span><span class="org-comment">Every STL container has two type parameters Container&lt;Element, Allocator&gt;</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">The allocator has the type parameter Allocator&lt;Element&gt;</span>
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span> = <span class="org-constant">std</span>::deque
     <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_stack</span>;
<span class="org-function-name">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Element</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">){</span>
         _stack.push_back<span class="org-rainbow-delimiters-depth-3">(</span>t<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">Element</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
         _stack.pop_back<span class="org-rainbow-delimiters-depth-3">()</span>;
         <span class="org-keyword">return</span> x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">(){</span>  <span class="org-keyword">return</span> _stack.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>   <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _stack.empty<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> _stack.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" stack: "</span>;
         <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: _stack<span class="org-rainbow-delimiters-depth-3">)</span>
                 <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; x ;
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> s1;
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>, s1.push<span class="org-rainbow-delimiters-depth-1">(</span>15<span class="org-rainbow-delimiters-depth-1">)</span>, s1.push<span class="org-rainbow-delimiters-depth-1">(</span>25<span class="org-rainbow-delimiters-depth-1">)</span>; s1.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  10 15 25
&gt;&gt; 

&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-1">&gt;</span> s2;
&gt;&gt; s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"IOT"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Network"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.print<span class="org-rainbow-delimiters-depth-1">()</span>;
 <span class="org-constant">stack</span>:  C++ IOT Network
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> sn = <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::list<span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;
&gt;&gt; sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'y'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'w'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'k'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.print<span class="org-rainbow-delimiters-depth-1">()</span>;
 <span class="org-constant">stack</span>:  x y <span class="org-type">w</span> <span class="org-variable-name">k</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 2:</b> Generic higher-order function which can peform a
fold-operation on any STL sequence container.
</p>

<ul class="org-ul">
<li>Version A - Using for-range based loop.</li>
</ul>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
     <span class="org-keyword">typename</span> <span class="org-type">Acc</span>,
     <span class="org-keyword">typename</span> <span class="org-type">Element</span>,  
     <span class="org-keyword">typename</span> <span class="org-type">Func</span>,
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Allocator</span>,
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span>
     <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldContainerA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Acc</span> <span class="org-variable-name">init</span>, <span class="org-keyword">const</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-type">Func</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">Acc</span> <span class="org-variable-name">acc</span> <span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-2">)</span> acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, x<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li>Version B - Using iterator based loop</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
    <span class="org-keyword">typename</span> <span class="org-type">Acc</span>,
    <span class="org-keyword">typename</span> <span class="org-type">Element</span>,   
    <span class="org-keyword">typename</span> <span class="org-type">Func</span>,
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Allocator</span>,
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span>
    <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldContainerB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Acc</span> <span class="org-variable-name">init</span>, <span class="org-keyword">const</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-type">Func</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Acc</span> <span class="org-variable-name">acc</span> <span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Dependent name </span>
    <span class="org-keyword">using</span> <span class="org-type">Iterator</span> = <span class="org-keyword">typename</span> <span class="org-constant">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::const_iterator;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Or: typedef typename Container&lt;Element, Allocator&lt;Element&gt;&gt;::const_iterator Iterator;</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = cont.begin<span class="org-rainbow-delimiters-depth-3">()</span>; it &lt; cont.end<span class="org-rainbow-delimiters-depth-3">()</span>; it++<span class="org-rainbow-delimiters-depth-2">)</span>
            acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, *it<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xsa<span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5, 6<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 123456
&gt;&gt; 

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 123456

<span class="org-comment-delimiter">// </span><span class="org-comment">1 + 2 + 3 + 4 + 5 + 6</span>
&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span>  acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xsb<span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsb, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>1, xsb, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 120
&gt;&gt; 

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>1, xsb, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 120


</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org71e2707" class="outline-3">
<h3 id="org71e2707"><span class="section-number-3">1.6</span> Templates and STL Containers</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org88be806" class="outline-4">
<h4 id="org88be806"><span class="section-number-4">1.6.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
Templates can be used for writing more generic and resuable code which
operates like functions or STL algorithms on  any type of iterator or
container. 
</p>
</div>
</div>
<div id="outline-container-org0357305" class="outline-4">
<h4 id="org0357305"><span class="section-number-4">1.6.2</span> Example 1 - iterating over containers</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
This example shows how to implement generic code which operates on any
type of container or iterator in modern C++.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-iterator-container.cpp">file:src/template-iterator-container.cpp</a></li>
</ul>

<p>
Code highlights:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">namespace</span> <span class="org-constant">IterUtils</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-type">double</span> <span class="org-function-name">sumContainer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>, <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">){</span>
            <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                sum += *it;
            <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Sum elements of any type &lt;Container&gt; with methods .begin() and .end()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">returnign iterators.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">U</span>, <span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">sumContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">container</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">U</span><span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-type">U</span> <span class="org-variable-name">sum</span><span class="org-rainbow-delimiters-depth-3">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = container.begin<span class="org-rainbow-delimiters-depth-4">()</span>; it != container.end<span class="org-rainbow-delimiters-depth-4">()</span>; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
               sum += *it;
            <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>,
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span>,
                <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span> <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-constant">std</span>::cout &lt;&lt;  *it &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span>
                  <span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">cont</span>
                 ,<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span>
                <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 For-range based loop</span>
           <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span>
                   <span class="org-constant">std</span>::cout &lt;&lt;  x &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Higher order function</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The parameter actions accepts any type which can be called like</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">a function returning void.</span>
        <span class="org-comment-delimiter">//</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It doesn't matter as it is possible to use both class T or typename T.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span>, <span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">for_each</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span> <span class="org-variable-name">cont</span>, <span class="org-type">Function</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span> action<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">----- End of namespace IterUtils ----- //</span>
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-iterator-container.cpp -o <span class="org-keyword">template-iterator-container.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-iterator-container.bin

=========== Experiment 1 - sumContainer
<span class="org-function-name">template-iterator-container.cpp</span>:95: ; iu::sumContainer(&amp;carray[0], &amp;carray[0] + arrsize) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:96: ; iu::sumContainer(vec1.begin(), vec1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:97: ; iu::sumContainer(list1.begin(), list1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:98: ; iu::sumContainer(deque1.begin(), deque1.end()) = 16

=========== Experiment 2 - sumContainer2 
<span class="org-function-name">template-iterator-container.cpp</span>:101: ; iu::sumContainer2&lt;double&gt;(vec1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:102: ; iu::sumContainer2&lt;int&gt;(vec1) = 15
<span class="org-function-name">template-iterator-container.cpp</span>:103: ; iu::sumContainer2&lt;double&gt;(list1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:104: ; iu::sumContainer2&lt;int&gt;(list2) = 114

=========== Experiment 3 - printContainer 

Contents of carray  = 1, 2, 4.5, 2.5, 6, 
Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 4 - printContainer2 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 5 - for_each higher order <span class="org-keyword">function</span> 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, c++, templates, awesome, binary, 
Contents of m1  = 
  earth-gravity     9.810
          euler     2.718
             pi     3.142
              x     2.345

</pre>
</div>
</div>
</div>
<div id="outline-container-org8f4824e" class="outline-4">
<h4 id="org8f4824e"><span class="section-number-4">1.6.3</span> Example 2 - print any sequential container (typename)</h4>
<div class="outline-text-4" id="text-1-6-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printContents</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Container</span>&amp; <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Dependent type declaration </span>
     <span class="org-keyword">typename</span> <span class="org-constant">Container</span>::<span class="org-type">iterator</span> <span class="org-variable-name">i</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span>i = c.begin<span class="org-rainbow-delimiters-depth-3">()</span>; i != c.end<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; *i &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs<span class="org-rainbow-delimiters-depth-1">{</span>10.23, -24.23, 25.2, 100.34<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> ds<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"hello world"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"HPC"</span>, <span class="org-string">"processor"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 
&gt;&gt; printContents<span class="org-rainbow-delimiters-depth-1">(</span>xs<span class="org-rainbow-delimiters-depth-1">)</span>
 10.23
 -24.23
 25.2
 100.34

&gt;&gt; printContents<span class="org-rainbow-delimiters-depth-1">(</span>ds<span class="org-rainbow-delimiters-depth-1">)</span>
 hello <span class="org-type">world</span>
 <span class="org-variable-name">C</span>++
 HPC
 processor
</pre>
</div>
</div>
</div>
<div id="outline-container-org2702177" class="outline-4">
<h4 id="org2702177"><span class="section-number-4">1.6.4</span> Example 3 - print map container</h4>
<div class="outline-text-4" id="text-1-6-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">KEY</span>, <span class="org-keyword">typename</span> <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printMap</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">typename</span> <span class="org-constant">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span>it = mp.begin<span class="org-rainbow-delimiters-depth-3">()</span>; it != mp.end<span class="org-rainbow-delimiters-depth-3">()</span>; it++<span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it-&gt;first
                    &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it-&gt;second 
                    &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Or, using for-range based loop: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">KEY</span>, <span class="org-keyword">typename</span> <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printMap2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">p</span>: mp<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; p.first
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; p.second 
                   &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> m1 <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; printMap<span class="org-rainbow-delimiters-depth-1">(</span>m1<span class="org-rainbow-delimiters-depth-1">)</span>
         x       200
         y      1000
         z      3400

&gt;&gt; printMap2<span class="org-rainbow-delimiters-depth-1">(</span>m1<span class="org-rainbow-delimiters-depth-1">)</span>
         x       200
         y      1000
         z      3400

&gt;&gt; <span class="org-keyword">auto</span> m2 = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span>100, <span class="org-string">"Argentina"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>900, <span class="org-string">"Colombia"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>80, <span class="org-string">"Brazil"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>600, <span class="org-string">"Chile"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; printMap<span class="org-rainbow-delimiters-depth-1">(</span>m2<span class="org-rainbow-delimiters-depth-1">)</span>
        80    Brazil
       100 Argentina
       600     Chile
       900  Colombia
</pre>
</div>
</div>
</div>
<div id="outline-container-org6ae5d2c" class="outline-4">
<h4 id="org6ae5d2c"><span class="section-number-4">1.6.5</span> Example 4 - print any associative container</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printAssoc</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">it</span> : mp<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it.first
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it.second 
                  &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">m1a</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">m2a</span> = <span class="org-constant">std</span>::<span class="org-type">unordered_map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

 &gt;&gt; printAssoc<span class="org-rainbow-delimiters-depth-1">(</span>m1a<span class="org-rainbow-delimiters-depth-1">)</span>
          x       200
          y      1000
          z      3400

 &gt;&gt; printAssoc<span class="org-rainbow-delimiters-depth-1">(</span>m2a<span class="org-rainbow-delimiters-depth-1">)</span>
          z      3400
          y      1000
          x       200
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org312bfa9" class="outline-3">
<h3 id="org312bfa9"><span class="section-number-3">1.7</span> Templates with Ranges</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<b>Example 1:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Range</span>, <span class="org-keyword">class</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forEachRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Range</span>&amp; <span class="org-variable-name">range</span>, <span class="org-type">Function</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: range<span class="org-rainbow-delimiters-depth-2">)</span> func<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; forEachRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 x = 1
 x = 2
 x = 3
 x = 4
 x = 5
 x = 6
 x = 7

 &gt;&gt; <span class="org-keyword">auto</span> list = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;{</span> <span class="org-string">"c++"</span>, <span class="org-string">"asm"</span>, <span class="org-string">"rust"</span>, <span class="org-string">"DLang"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

 &gt;&gt; forEachRange<span class="org-rainbow-delimiters-depth-1">(</span>::list, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> 
                              <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; "</span> &lt;&lt; x &lt;&lt; st =&gt; c++; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
  =&gt; <span class="org-keyword">asm</span>
  =&gt; rust
  =&gt; DLang
</pre>
</div>

<p>
<b>Example 2:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Range</span>, <span class="org-keyword">class</span> <span class="org-type">Acc</span>, <span class="org-keyword">class</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Range</span>&amp; <span class="org-variable-name">range</span>, <span class="org-keyword">const</span> <span class="org-type">Acc</span>&amp; <span class="org-variable-name">init</span>, <span class="org-type">Function</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">acc</span> = init;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: range<span class="org-rainbow-delimiters-depth-2">)</span> acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, x<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">---------- std::vector --------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> xs = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 1 + 2 + 3 + 4 + 5 + 6 + 7
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28

&gt;&gt; 1 * 2 * 3 * 4 * 5 * 6 * 7
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 0, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1234567
&gt;&gt; 

<span class="org-comment-delimiter">//</span><span class="org-comment">---------- std::deque -------------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> ys = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>ys, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>ys, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">------------- std::set -----------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> zs = <span class="org-constant">std</span>::<span class="org-type">set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>zs, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org0068b48" class="outline-3">
<h3 id="org0068b48"><a id="ID-80f3766a-39eb-47ef-a3f5-5a49ef183db0"></a><span class="section-number-3">1.8</span> Basic Template Specialization</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Code example showing template specialization. As the code shows, the
template specilization can be used for type introspection, type
identification and implement reflection.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-specialization1.cpp">file:src/template-specialization1.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/BKG53705">http://rextester.com/BKG53705</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Stream manipulator std::fixed, std::setw ... </span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>      <span class="org-comment-delimiter">// </span><span class="org-comment">sin, cos, tan, exp ... M_PI, M_E ...</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">std::function </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 1 ===============================//</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether type is float point </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type float</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type double </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 2 - Template specialization for runtime type identification ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: this technique can be used for implemeting custom C++ reflection </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Return name of a given type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"unknown"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> \
        <span class="org-keyword">auto</span> <span class="org-variable-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> #type; <span class="org-rainbow-delimiters-depth-1">}</span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Specialization for int type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"int"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Automate boilerplate code using macros.</span>
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 3 - Template with int argument specialization ===//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"I down't known"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"zero"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"one"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"two"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>3<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"three"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 4 - Template with bool argument specialization ====//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"false"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"true"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 5 - Check whether types are equal ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Partial template specialization </span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 0 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Partial specialisation</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 1<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
      <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 1 - Check whether type is float pointer"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;int&gt;    ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;char&gt;   ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;float&gt;  ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;double&gt; ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 2 - Type introspection"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;  

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 3 - Templates with integers as arguments"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;0&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>0<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;1&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>1<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;2&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>2<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;10&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>10<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;14&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>14<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 4 - Templates with bool as arguments"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;false&gt;::getName&gt;()  = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;true&gt;::getName&gt;()   = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"Check whether types are equal"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, char&gt;::get()       = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;  
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;char, double&gt;::get()    = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;double, double&gt;::get()  = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, int&gt;::get()        = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">int</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are equal\n"</span>;
      <span class="org-keyword">else</span>
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are not equal\n"</span>;

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">double</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are equal\n"</span>;
      <span class="org-keyword">else</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are not equal\n"</span>;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-specialization1.cpp -o <span class="org-keyword">template-specialization1.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-specialization1.bin

EXPERIMENT 1 - Check whether type is float pointer
--------------------------------------------
is float point type&lt;int&gt;    ? = false
is float point type&lt;char&gt;   ? = false
is float point type&lt;float&gt;  ? = true
is float point type&lt;double&gt; ? = true

EXPERIMENT 2 - Type introspection
--------------------------------------------
<span class="org-builtin">type</span> = int
<span class="org-builtin">type</span> = char
<span class="org-builtin">type</span> = float
<span class="org-builtin">type</span> = const char*
<span class="org-builtin">type</span> = std::string

EXPERIMENT 3 - Templates with integers as arguments
--------------------------------------------
getNumberName&lt;0&gt;() = zero
getNumberName&lt;1&gt;() = one
getNumberName&lt;2&gt;() = two
getNumberName&lt;10&gt;() = I down<span class="org-string">'t known</span>
<span class="org-string">getNumberName&lt;14&gt;() = I down'</span>t known

EXPERIMENT 4 - Templates with bool as arguments
--------------------------------------------
boolTemplate&lt;false&gt;::getName&gt;()  = false
boolTemplate&lt;true&gt;::getName&gt;()   = true

Check whether types are equal
type_equal&lt;int, char&gt;::get()       = false
type_equal&lt;char, double&gt;::get()    = false
type_equal&lt;double, double&gt;::get()  = true
type_equal&lt;int, int&gt;::get()        = true
[1] Types are not equal
[2] Types are equal
</pre>
</div>
</div>
</div>
<div id="outline-container-org1475c4f" class="outline-3">
<h3 id="org1475c4f"><span class="section-number-3">1.9</span> Template Type Alias - 'using' (C++11)</h3>
<div class="outline-text-3" id="text-1-9">
<p>
In addition to be useful for creating type alias, the keyword "using"
can also be used for defining template type alias or parametrized type
alias. 
</p>

<p>
<b>Basic Example:</b>
</p>

<p>
Type alias for shared_ptr: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">sh</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">sh</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>DataObjeect<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> objects;  
</pre>
</div>

<p>
Type alias for unique_ptr:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">up</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">up</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>DataObjeect<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> objects;
</pre>
</div>

<p>
Type alias for polymorphic objects containers:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor"> #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor"> #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

 <span class="org-comment-delimiter">// </span><span class="org-comment">Vector of shared pointer for storing polymorphic objects (shared ownership)</span>
 <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
 <span class="org-keyword">using</span> <span class="org-type">SHVector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Vector of shared pointer for storing polymorphic objects (unique ownership)</span>
 <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
 <span class="org-keyword">using</span> <span class="org-type">UPVector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;


 <span class="org-keyword">class</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
   ... 
   <span class="org-keyword">public</span>:
     ~<span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
     <span class="org-keyword">virtual</span> <span class="org-type">double</span> <span class="org-function-name">Price</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> = 0 ;
 <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedA</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
  ... 
  <span class="org-type">double</span> Price<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
      ... <span class="org-comment-delimiter">// </span><span class="org-comment">Compute Price --- // </span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedB</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
  ... 
  <span class="org-type">double</span> Price<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> 
 <span class="org-rainbow-delimiters-depth-2">{</span>
  ... <span class="org-comment-delimiter">// </span><span class="org-comment">Compute Price --- // </span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-type">SHVector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">list</span>;
list.reserve<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>;
list.push_back<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
list.push_back<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedA</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>arg0, arg1, arg2, ... argN<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
list.push_back<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedB</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>arg0, arg1, arg2, ... argN<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">impl</span> : list<span class="org-rainbow-delimiters-depth-1">)</span> 
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Price = "</span> &lt;&lt; impl-&gt;Price<span class="org-rainbow-delimiters-depth-1">(</span>10.0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
</pre>
</div>


<p>
<b>Example: std::function container type alias</b>
</p>

<p>
Type synonym: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">Action</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>T <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">doTimes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">Action</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" i = 0; x = "</span> &lt;&lt; action<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; doTimes<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>3, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 3.0 * i + 4.5; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0; x = 4.5
 i = 0; x = 7.5
 i = 0; x = 10.5
&gt;&gt; 

&gt;&gt; doTimes<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>6, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 65 + i; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0; x = A
 i = 0; x = B
 i = 0; x = C
 i = 0; x = D
 i = 0; x = E
 i = 0; x = F
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org57afe5b" class="outline-3">
<h3 id="org57afe5b"><span class="section-number-3">1.10</span> Templates with default arguments</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Example: Array allocated on the stack memory.
</p>

<ul class="org-ul">
<li>File: default-template-args.C</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Array allocated on stack with size 10.</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Element</span>, <span class="org-type">size_t</span> <span class="org-variable-name">Size</span> = 10<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-type">Element</span> <span class="org-variable-name">m_data</span> <span class="org-rainbow-delimiters-depth-2">[</span>Size<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-function-name">public</span>:
   <span class="org-keyword">auto</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">size_t</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> Size;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">fill</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Element</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; Size; i++<span class="org-rainbow-delimiters-depth-3">)</span>
           m_data<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> = t;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-keyword">operator</span> <span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">index</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Element&amp; <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> m_data<span class="org-rainbow-delimiters-depth-3">[</span>index<span class="org-rainbow-delimiters-depth-3">]</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">begin</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">end</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span> = <span class="org-constant">std</span>::cout<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
       os &lt;&lt; name &lt;&lt; <span class="org-string">" = "</span>;
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: *<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>
          os &lt;&lt; x &lt;&lt; <span class="org-string">" "</span> &lt;&lt; <span class="org-constant">std</span>::flush;
       os &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">default_template_args</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s1</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s1.size() = "</span> &lt;&lt; s1.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     s1.fill<span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = 8.23;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = -10.2;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">]</span> = 0.0;
     s1.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s1"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, 4<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s2</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s2.size() = "</span> &lt;&lt; s2.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     s2.fill<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"PlusPlus"</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"CPP"</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"ASM"</span>;
     s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running on CLING REPL:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .X <span class="org-keyword">default</span>-<span class="org-keyword">template</span>-args.C 
s1.size<span class="org-rainbow-delimiters-depth-1">()</span> = 10
s1 = 8.23 -10.2 3 0 3 3 3 3 3 3 
s2.size<span class="org-rainbow-delimiters-depth-1">()</span> = 4
s2 = C++ C++ C++ C++ 
s2 = PlusPlus CPP ASM C++ 
</pre>
</div>
</div>
</div>
<div id="outline-container-org6c416f8" class="outline-3">
<h3 id="org6c416f8"><a id="ID-20156a12-aa32-407d-8cc0-5c4b85ba9021"></a><span class="section-number-3">1.11</span> Implementing Higher Order Functions with templates</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>File: <a href="src/template-hof1.cpp">file:src/template-hof1.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/ZAT8950">https://rextester.com/ZAT8950</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/**   </span><span class="org-comment">File:     template-hof1.cpp </span>
<span class="org-comment">  *  Brief:    Shows how to implement template higher order functions which operates on containers.</span>
<span class="org-comment">  *  Features: Template metaprogramming, C++11, functional programming and STL.</span>
<span class="org-comment">  ****************************************************************************/</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">list</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">ELEM</span>, <span class="org-keyword">class</span> <span class="org-type">ALLOC</span>, <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span>, <span class="org-keyword">class</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ELEM</span>, <span class="org-type">ALLOC</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">ELEM</span>&amp;<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-4">(</span>cont.front<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Template for folding over a container in a similar way to the higher order function fold. </span>
<span class="org-comment"> * Note: </span>
<span class="org-comment"> * + CONTAINER parameter accepts any argument which has .begin() and .end() methods </span>
<span class="org-comment"> *   returning iterators. </span>
<span class="org-comment"> * + STEPFN type parameters accepts any function-object, function pointer or lambda </span>
<span class="org-comment"> *   whith the following signature: (ACC, X) =&gt; ACC where ACC is the accumulator type </span>
<span class="org-comment"> *   and X is the type of the container element. </span>
<span class="org-comment"> */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span>, <span class="org-keyword">class</span> <span class="org-type">ACC</span>, <span class="org-keyword">class</span> <span class="org-type">STEPFN</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">foldRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-keyword">const</span> <span class="org-type">ACC</span>&amp; <span class="org-variable-name">init</span>, <span class="org-type">STEPFN</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">ACC</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">ACC</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        acc = fn<span class="org-rainbow-delimiters-depth-2">(</span>*i, acc<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-constant">std</span>::<span class="org-constant">ios_base</span>::sync_with_stdio<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;
        <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>   <span class="org-variable-name">lst</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Requires template argument </span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 1 =================\n"</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - List"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't require the template argument as the compiler can infer its type.</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 2 =================\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - list"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 3 =================\n"</span>;
        <span class="org-type">int</span> <span class="org-variable-name">result1</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>vec, 0, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-3">){</span>
                                                <span class="org-keyword">return</span> x + acc;
                                          <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;   
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(vec1) = "</span> &lt;&lt; result1 &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-type">int</span> <span class="org-variable-name">result2</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(lst) = "</span> &lt;&lt; result2 &lt;&lt; <span class="org-string">"\n"</span> ;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"product(lst) = "</span> &lt;&lt; foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">clang++ template-hof1.cpp -o <span class="org-keyword">template-hof1.bin</span> -g -std=c++11 -Wall -Wextra &amp;&amp; ./template-hof1.bin
===== EXPERIMENT 1 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - List
    1     2   400   100 
===== EXPERIMENT 2 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - list
    1     2   400   100 
===== EXPERIMENT 3 =================
<span class="org-function-name">sum</span>(vec1) = 503
<span class="org-function-name">sum</span>(lst) = 503
<span class="org-function-name">product</span>(lst) = 80000
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbe5e57d" class="outline-3">
<h3 id="orgbe5e57d"><span class="section-number-3">1.12</span> Metafunctions or type traits</h3>
<div class="outline-text-3" id="text-1-12">
</div>
<div id="outline-container-org66dd439" class="outline-4">
<h4 id="org66dd439"><span class="section-number-4">1.12.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
Metafunction (aka type traits) is a template metaprogramming technique
for type introspection, type manipulation and type computation. This
idiom uses templates, template specialization, structs (classes with
everything public) and constexpr in C++11.
</p>

<p>
This section contains examples about template metafunctions. For more
information about this subject and further reading, see: 
</p>
<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Metafunction">More C++ Idioms/Metafunction - Wikibooks, open books for an open world</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Type_Generator">More C++ Idioms/Type Generator - Wikibooks, open books for an open world</a></li>
<li><a href="https://akrzemi1.wordpress.com/2012/03/19/meta-functions-in-c11/">Meta-functions in C++11 | Andrzej's C++ blog</a></li>
<li><a href="https://accu.org/index.php/journals/442">ACCU - An introduction to C++ Traits</a></li>
</ul>


<p>
A meta function has the forms: 
</p>

<ul class="org-ul">
<li>Meta function which returns type.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't matter using typename T1, typename T2</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">or using class T1, class T2 ..</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T1</span>, <span class="org-keyword">typename</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11 </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">typedef</span> ... ... <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-keyword">using</span> <span class="org-type">type_synonym</span> =  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::type ;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or in before C++11</span>
<span class="org-keyword">typedef</span>  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span> <span class="org-type">type_synonym</span>;
</pre>
</div>

<ul class="org-ul">
<li>Meta function which returns value.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">At least C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage:</span>
<span class="org-type">TYPE</span> <span class="org-variable-name">result</span> = <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ..<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value;
</pre>
</div>

<p>
Further References: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.youtube.com/watch?v=eVtLOHoDbTo">Type Traits - CopperSpice video</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3dc1a40" class="outline-4">
<h4 id="org3dc1a40"><span class="section-number-4">1.12.2</span> Example</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
<b>Example</b>
</p>

<p>
Example in:
</p>
<ul class="org-ul">
<li>file:            <a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/TAT89158">http://rextester.com/TAT89158</a></li>
<li>The code in the example demonstrates how to query types using
template specialization, catalog type information and display the
user as well.</li>
</ul>

<p>
Highlights: 
</p>

<ul class="org-ul">
<li>The <b>metafunction isPointer</b> checks whether a given type is a
pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">false</span>;
    <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">true</span>;
    <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Sample usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short*&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short&gt;::value   = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double*&gt;::value = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
</pre>
</div>

<ul class="org-ul">
<li>The <b>meta function removePointer</b> turns any pointer type into a
non-pointer type removing the star operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Partial specilization</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>

<ul class="org-ul">
<li><b>The metafunction Typeinfo</b> computes basic information about types at
compile-time. As this "metafunction" relies on template
specialization, it requires defining template specialization for
all supported types what can be cumbersome. In order to avoid the
specialization boilerplate code, the macro <code>REGISTER_TYPE_INFO</code> is
used to register the supported types.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>   = <span class="org-string">"unknown"</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>   = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>   = <span class="org-constant">false</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span> = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>    = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;     
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Macro for type registration </span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE_INFO</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span>, <span class="org-variable-name">isNumberFlag</span><span class="org-rainbow-delimiters-depth-1">)</span> \
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;{</span> \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>       = #type; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>       = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>type<span class="org-rainbow-delimiters-depth-2">)</span>; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>   = isNumberFlag; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span>  = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>    = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;   \
        <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Type registration </span>
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Type info for "</span> &lt;&lt; <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>&gt;::name 
          &lt;&lt; <span class="org-string">" size = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::size 
          &lt;&lt; <span class="org-string">" isPointer = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::isPointer 
          &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>


<p>
<b>Complete Program output:</b> (<a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a>)
</p>

<div class="org-src-container">
<pre class="src src-text">$ clang++ template-metafunction.cpp -o template-metafunction.bin -g -std=c++11 -Wall -Wextra  
./template-metafunction.bin

isPointerOLD&lt;short*&gt;::value  = 1
isPointerOLD&lt;short&gt;::value   = 0
isPointerOLD&lt;double&gt;::value  = 0
isPointerOLD&lt;double*&gt;::value = 1
isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
isPointer&lt;short*&gt;()()  = true
isPointer&lt;short&gt;()()   = false
isPointer&lt;double&gt;()()  = false
isPointer&lt;double*&gt;()() = true
Type Info: name =            bool ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =            char ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =     std::string ; bytes =   32 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =             int ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           short ; bytes =    2 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           float ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =          double ; bytes =    8 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =     const char* ; bytes =    8 ; isNumber =  true ; isPointer =  true ; isConst =  true
Type Info: name =          float* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =         double* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =   const double&amp; ; bytes =    8 ; isNumber = false ; isPointer = false ; isConst =  true
template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfab43e7" class="outline-3">
<h3 id="orgfab43e7"><span class="section-number-3">1.13</span> Predefined type traits in &lt;type_traits&gt;</h3>
<div class="outline-text-3" id="text-1-13">
<p>
The C++11 header <code>&lt;type_traits&gt;</code> (before <code>boost.type_traits</code>) provide many
useful type traits, also known as metafunction, for querying and
transforming types at compile-time. In addition to those operations,
the type traits available in this header can also be used for
optimizing templates by specializing them for specific types.
</p>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/type_traits/doc/html/index.html">Chapter1.Boost.TypeTraits - 1.68.0</a></li>
</ul>

<p>
Examples: 
</p>

<ul class="org-ul">
<li>To use the C++11's type traits, it is necessary to include the
header <code>&lt;type_traits&gt;</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
</pre>
</div>

<ul class="org-ul">
<li>Type trait <code>std::is_void</code>
<ul class="org-ul">
<li>Checks whether type is void.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> inspectType<span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-keyword">else</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is not void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; 
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Type <span class="org-type">is</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is float point: <code>std::is_floating_point</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is interger: <code>std::is_integral</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">unsigned</span> <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is const</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is a reference (&amp;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Type relationship</b>
</p>

<ul class="org-ul">
<li>Check whether type are equal.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if types are the same </span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Checks whether types are derived.
<ul class="org-ul">
<li><code>std::is_base_of&lt;A, B&gt;::value</code> returns true if A is a base type (superclass) of
B or B is derived class of A.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">B</span>: <span class="org-keyword">public</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Z</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

</pre>
</div>
</div>
</div>
<div id="outline-container-org1394f3c" class="outline-3">
<h3 id="org1394f3c"><span class="section-number-3">1.14</span> Variadic Templates</h3>
<div class="outline-text-3" id="text-1-14">
<p>
This code shows examples about variadic templates in C++11 and
newer standards.
</p>

<p>
File: <a href="src/template-variadic.cpp">file:src/template-variadic.cpp</a>
</p>

<p>
Code Highlights:
</p>


<ul class="org-ul">
<li>Print a sequence of heterogenous arguments.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>    
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::clog &lt;&lt; <span class="org-string">" [TRACE] Base case =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Variadic template arguments </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span>, <span class="org-keyword">const</span> <span class="org-type">Types</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
     printTypes<span class="org-rainbow-delimiters-depth-2">(</span>args ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">printTypes<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello world"</span>, 10, <span class="org-string">'x'</span>, 20.23f, <span class="org-constant">true</span>, NAN<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Ouput: 
</p>

<div class="org-src-container">
<pre class="src src-text">hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
</pre>
</div>


<ul class="org-ul">
<li>Create a function that applies a member function to a given object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span> <span class="org-type">R</span>, <span class="org-keyword">class</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">makeCommand</span><span class="org-rainbow-delimiters-depth-1">(</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to member function </span>
     <span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">T</span>::* <span class="org-function-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>,
     <span class="org-comment-delimiter">// </span><span class="org-comment">Member function arguments </span>
     <span class="org-type">Args</span> ... <span class="org-variable-name">arglist</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>R <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>=<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-3">)(</span>arglist ...<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">CNCMachine</span> <span class="org-variable-name">mach1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"7Z9FA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">CNCMachine</span> <span class="org-variable-name">mach2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"MY9FT"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">setSpeed10</span> = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::setSpeed, 10<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">shutdown</span>   = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::shutdown<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach1<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
shutdown<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Dynamic load an [U] nix-shared library or shared object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Type synonym for shared library handler </span>
<span class="org-comment"> *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">using</span> <span class="org-type">LibHandle</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">loadDLL</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">libPath</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">LibHandle</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Return unique_ptr for RAAI -&gt; Resource Acquisition is Initialization</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">releasing closing handle when the unique_ptr goes out of scope. </span>
     <span class="org-keyword">return</span> LibHandle<span class="org-rainbow-delimiters-depth-2">(</span>
             dlopen<span class="org-rainbow-delimiters-depth-3">(</span>libPath.c_str<span class="org-rainbow-delimiters-depth-4">()</span>, RTLD_LAZY<span class="org-rainbow-delimiters-depth-3">)</span>,
             <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">void</span>* <span class="org-variable-name">h</span><span class="org-rainbow-delimiters-depth-3">){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Shared library handle released OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                dlclose<span class="org-rainbow-delimiters-depth-4">(</span>h<span class="org-rainbow-delimiters-depth-4">)</span>;
             <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;        
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Load symbol from shared library </span>
<span class="org-comment">  *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">loadSymbol</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LibHandle</span>&amp; <span class="org-variable-name">handle</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">symbol</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">Function</span>* <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">void</span>* <span class="org-variable-name">voidptr</span> = dlsym<span class="org-rainbow-delimiters-depth-2">(</span>handle.get<span class="org-rainbow-delimiters-depth-3">()</span>, symbol.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>voidptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
     <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Function</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>voidptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">GNU Scientific Library - Linear Algebra CBLAS </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">handle1</span> = loadDLL<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"/usr/lib64/libgslcblas.so"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">using</span> <span class="org-type">cblas_daxpy_type</span> = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">cblas_daxpy_type</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 3.0, 5.0, 6.0, 10.0, 8.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">ys</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 2.0, 2.0, 2.0,  2.0, 2.0<span class="org-rainbow-delimiters-depth-1">}</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"xs"</span>, xs<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Compute xs * 4.0 + ys</span>
cblas_daxpy<span class="org-rainbow-delimiters-depth-1">(</span>xs.size<span class="org-rainbow-delimiters-depth-2">()</span>, 4.0, &amp;xs<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1, &amp;ys<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>


<p>
Complete Output: 
</p>

<div class="org-src-container">
<pre class="src src-txt">$ g++ template-variadic.cpp -o template-variadic.bin -g -std=c++11 -Wall -Wextra -ldl 
$ ./template-variadic.bin

EXPERIMENT 1 = Function of many argument for printing all of them
---------------------------------------
hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
 [TRACE] Base case =&gt; x = nan

EXPERIMENT 2 = Indirect method invocation
--------------------------------------
[MACHINE] id = 7Z9FA Set machine speed to level 10
[MACHINE] id = MY9FT Set machine speed to level 10
[MACHINE] id = 7Z9FA  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = MY9FT  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = 7Z9FA Shutdown equipment
[MACHINE] id = MY9FT Shutdown equipment

EXPERIMENT 3 = Dynamic Loading from shared library (libgslcblas.so) 
--------------------------------------
 [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>

<p>
References:  
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
<li><a href="https://www.nag.com/numeric/FL/nagdoc_fl24/html/F06/f06ecf.html">F06ECF (DAXPY) : NAG Library, Mark 24</a></li>
<li><a href="https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html">Dynamically Loaded (DL) Libraries</a></li>
<li><a href="https://www.gnu.org/software/gsl/doc/html/cblas.html">GSL CBLAS Library  GSL 2.5 documentation</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8075c8e" class="outline-3">
<h3 id="org8075c8e"><span class="section-number-3">1.15</span> Variadic Templates - sizeof&#x2026; operator</h3>
<div class="outline-text-3" id="text-1-15">
<p>
The operator sizeof&#x2026;(args) is used for counting the number of template
arguments.
</p>

<ul class="org-ul">
<li>Class or function with type parameters.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Return</span> <span class="org-function-name">FUNCTION</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ARGUMENTS</span> ... <span class="org-variable-name">arguments</span><span class="org-rainbow-delimiters-depth-1">){</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Operator: sizeof&#x2026;(ARGUMENTS)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">size_t</span> <span class="org-variable-name">NumberOfTypeArguments</span> = <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-1">(</span>ARGUMENTS<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Count number of type parameters</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countArgs1</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Args<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 3

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>

<ul class="org-ul">
<li>Count number of template numeric arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Number</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countNumberArguments</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Number<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 2

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3, 5, 6, 7, 10<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 6
</pre>
</div>

<ul class="org-ul">
<li>Count number of function arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Or:</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">Params</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countParameters</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Params</span> ... <span class="org-variable-name">params</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of parameters equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>params<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">()</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>12, <span class="org-string">'x'</span>, <span class="org-string">"hello world"</span>, 3.34<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>
</div>
</div>

<div id="outline-container-org52a408f" class="outline-3">
<h3 id="org52a408f"><span class="section-number-3">1.16</span> Variadic Templates arguments expansion</h3>
<div class="outline-text-3" id="text-1-16">
<ul class="org-ul">
<li><b>Example 0</b>:</li>
</ul>

<p>
Expand numeric template arguments into a std::vector.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Numbers</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getNumberParameters</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> Numbers ... <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L script-parampack.C
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0, 10, 56, 100, 5, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0, 10, 56, 100, 5, 3 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>Example 1:</b></li>
</ul>

<p>
Get deque container containing the size in bytes of every type from
the parameter pack (arguments of a variadic template).
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Return a deque containing the size in bytes of each type from the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">parameter pack (types arguments).</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">{ ... } Intializer list - used for </span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 default intialization feature. </span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 8 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>, <span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1, 4, 8, 16, 32 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li><b>Example 2:</b></li>
</ul>

<p>
Example: modify example 1 for requiring at least one type parameter.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Type0</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList2</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Type0<span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;    
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-function-name">ROOT_prompt_2</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>getSizeList2<span class="org-warning">'</span>
getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
^~~~~~~~~~~~~~
<span class="org-function-name">/home/archbox/root-scripts/script-parampack.C</span>:41:6: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-warning">'</span>Type0<span class="org-warning">'</span>
<span class="org-keyword">auto</span> getSizeList2<span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   ^
&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 1 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8, 4, 1, 16, 32 <span class="org-rainbow-delimiters-depth-2">}</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 3:</b> 
</p>

<p>
Print RTTI (Runtime Type Information) about types parameters.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">TypeInfo</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-function-name">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">hash_code</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-2">)</span>
     : name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>,
       hash_code<span class="org-rainbow-delimiters-depth-2">(</span>hash_code<span class="org-rainbow-delimiters-depth-2">)</span>,
       size<span class="org-rainbow-delimiters-depth-2">(</span>size<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>   <span class="org-variable-name">name</span>;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">hash_code</span>;
    <span class="org-type">size_t</span>        <span class="org-variable-name">size</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTypesInfoFromRTTI</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">void</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tlist</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            TypeInfo<span class="org-rainbow-delimiters-depth-3">{</span>
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.name<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.hash_code<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>
                    <span class="org-rainbow-delimiters-depth-3">}</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Name"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Size"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"Hash"</span>
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;   
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: tlist<span class="org-rainbow-delimiters-depth-2">){</span>
        ss.str<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        ss.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
        ss &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; x.hash_code;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.name
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.size
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>15<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; ss.str<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">//</span><span class="org-comment">--- End of printTypesInfoFromRTTI() ----- //</span>
</pre>
</div>

<p>
Running (ROOT/Cling REPL): 
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; printTypesInfoFromRTTI&lt;&gt;()
 Name Size           Hash
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char, int, double, long double&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
    i    4     0xb675de06
    d    8     0x44573475
    e   16     0xbbbbed2c
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a5c906" class="outline-3">
<h3 id="org9a5c906"><span class="section-number-3">1.17</span> C++17 Variadic Template - Fold Expressions</h3>
<div class="outline-text-3" id="text-1-17">
<p>
C++17 fold expression features allow to expand and process variadic
template type arguments, also known as parameter pack, without
complicated recursion and function overloads.
</p>

<ul class="org-ul">
<li>Documentation: <a href="https://en.cppreference.com/w/cpp/language/fold">C++17 fold expression</a></li>
</ul>

<p>
<b>Syntax:</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Index</th>
<th scope="col" class="org-left">Syntax</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">( pack op &#x2026; )</td>
<td class="org-left">Unary Right Fold</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">( &#x2026; op pack)</td>
<td class="org-left">Unarfy Left Fold</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">(pack op &#x2026; op init)</td>
<td class="org-left">Binary Right Fold</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">(init op &#x2026; op pack)</td>
<td class="org-left">Binary Left Fold</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Pack - <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">Parameter pack</a></li>

<li>init	- "an expression that does not contain an unexpanded
parameter pack and does not contain an operator with precedence
lower than cast at the top level (formally, a cast-expression)"</li>

<li>OP - Operator that can be any of the 32 supported operators:</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Supported operators by fold expressiosn</label><pre class="src src-text">+ - * / % ^ &amp; | = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %= ^= &amp;= 
|= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;*. 
</pre>
</div>

<p>
<b>Example:</b>
</p>

<ul class="org-ul">
<li>File: <a href="src/cpp17/fold-expressions1.cpp">file:src/cpp17/fold-expressions1.cpp</a></li>
<li>Online Compiler: <a href="https://wandbox.org/permlink/6ZmVdoDWFMa89eBO">https://wandbox.org/permlink/6ZmVdoDWFMa89eBO</a></li>
</ul>

<p>
Compilation: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Compile with GCC </span>
$ g++ fold-expressions1.cpp -o <span class="org-keyword">fold-expressions1.bin</span> -std=c++1z -g -O0 -Wall
<span class="org-comment-delimiter"># </span><span class="org-comment">Compile with Clang </span>
$ clang++ fold-expressions1.cpp -o <span class="org-keyword">fold-expressions1.bin</span> -std=c++1z -g -O0 -Wall
<span class="org-comment-delimiter"># </span><span class="org-comment">Run </span>
$ ./fold-expressions1.bin
</pre>
</div>

<p>
Headers: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">tuple</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">any</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
</pre>
</div>

<p>
Function multiply:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">multiply</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Args</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">args</span> * ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function printArguments: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printArguments</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Args</span>&amp;&amp; ...  <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cout &lt;&lt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>args<span class="org-rainbow-delimiters-depth-4">)</span>.name<span class="org-rainbow-delimiters-depth-4">()</span>  &lt;&lt; <span class="org-string">" "</span> &lt;&lt; args &lt;&lt; <span class="org-constant">std</span>::endl<span class="org-rainbow-delimiters-depth-3">)</span>, ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function GetTypesFromArgs1:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">type_info</span> <span class="org-keyword">const</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">GetTypesFromArgs1</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">type_info</span> <span class="org-keyword">const</span>*<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">tinfo</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Received "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Args<span class="org-rainbow-delimiters-depth-2">)</span>
              &lt;&lt; <span class="org-string">" types arguments"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>tinfo.push_back<span class="org-rainbow-delimiters-depth-4">(</span>&amp;<span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-5">(</span>Args<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, ...<span class="org-rainbow-delimiters-depth-2">)</span> ;
    <span class="org-keyword">return</span> tinfo;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function GetTypesFromArgs2:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">type_info</span> <span class="org-keyword">const</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">GetTypesFromArgs2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Args</span> <span class="org-keyword">const</span>&amp; ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">){</span>    
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Received "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Args<span class="org-rainbow-delimiters-depth-2">)</span>
              &lt;&lt; <span class="org-string">" types arguments"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;<span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-3">(</span>args<span class="org-rainbow-delimiters-depth-3">)</span> ...<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Main Function:</b> 
</p>

<p>
Experiment 1: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ======= EXPERIMENT 1 ===============\n"</span>;   
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Result 1 = "</span> &lt;&lt; multiply<span class="org-rainbow-delimiters-depth-1">(</span>1, 2, 3, 4, 5, 6<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Result 2 = "</span> &lt;&lt; multiply<span class="org-rainbow-delimiters-depth-1">(</span>3.5, 1.65, 0.25, 10.98, 100.5, 6<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">
======= EXPERIMENT 1 ===============
=&gt; Result 1 = 720
=&gt; Result 2 = 9558.98
</pre>
</div>

<p>
Experiment 2: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ======= EXPERIMENT 2 ===============\n"</span>;
printArguments<span class="org-rainbow-delimiters-depth-1">(</span>10, 200.5, <span class="org-string">"hello world"</span>, <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ======= EXPERIMENT 2 ===============
i 10
d 200.5
A12_c hello world
c x
</pre>
</div>

<p>
Experiment 3: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ======= EXPERIMENT 3 ===============\n"</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">tinfo</span> = GetTypesFromArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>*, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>;
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span>: tinfo<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Name = "</span> &lt;&lt; t-&gt;name<span class="org-rainbow-delimiters-depth-2">()</span>
               &lt;&lt; <span class="org-string">" - id = "</span> &lt;&lt; t-&gt;hash_code<span class="org-rainbow-delimiters-depth-2">()</span>
               &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======= EXPERIMENT 3 ===============
Received 4 types arguments
Name = i - id = 6253375586064260614
Name = d - id = 14494284460613645429
Name = PKc - id = 3698062409364629473
Name = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE - id = 5774750460303204477
</pre>
</div>

<p>
Experiment 4: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ======= EXPERIMENT 4 ===============\n"</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">tinfo2</span> = GetTypesFromArgs2<span class="org-rainbow-delimiters-depth-1">(</span>200, <span class="org-string">'x'</span>, 9.87, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"CPP17"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span>: tinfo2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Name = "</span> &lt;&lt; t-&gt;name<span class="org-rainbow-delimiters-depth-2">()</span>
               &lt;&lt; <span class="org-string">" - id = "</span> &lt;&lt; t-&gt;hash_code<span class="org-rainbow-delimiters-depth-2">()</span>
               &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-text"> ======= EXPERIMENT 4 ===============
Received 5 types arguments
Name = i - id = 6253375586064260614
Name = c - id = 10959529184379665549
Name = d - id = 14494284460613645429
Name = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE - id = 5774750460303204477
Name = A6_c - id = 15419073316311588377
</pre>
</div>
</div>
</div>


<div id="outline-container-org3bbb4bc" class="outline-3">
<h3 id="org3bbb4bc"><span class="section-number-3">1.18</span> SFINAE - Substution Is Not a Failure</h3>
<div class="outline-text-3" id="text-1-18">
</div>
<div id="outline-container-org8df607e" class="outline-4">
<h4 id="org8df607e"><span class="section-number-4">1.18.1</span> Fundamentals</h4>
<div class="outline-text-4" id="text-1-18-1">
<p>
SFINAE stands for <span class="underline">Substition Failure Is Not An Error</span>. It was
introduced by David Vandervood in book "C++ Templates: The Complete
Guide". The SFINAE technique is peformed by adding new overload
functions (function with same name and different type signatures) for
preveting compilation error during the template parameter type
substitution. When a substition failure happens, the compiler looks
for a the next function overload, if the substition fails again and
there are no more candidates, the compiler will generate an error.
</p>

<p>
<b>Example: 1</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-type">int</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">AStructB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:   
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type contains ASubtype = TRUE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Template substution worked. OK. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span>AStruct<span class="org-rainbow-delimiters-depth-1">&gt;(</span>200<span class="org-rainbow-delimiters-depth-1">)</span>
 Type <span class="org-type">contains</span> <span class="org-variable-name">ASubtype</span> = TRUE 
 Value = 200

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution worked. OK. </span>
 &gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span>AStructB<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"PARAMETER"</span><span class="org-rainbow-delimiters-depth-1">)</span>
  Type <span class="org-type">contains</span> <span class="org-variable-name">ASubtype</span> = TRUE 
  Value = PARAMETER

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution error. Failed. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>600<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_13</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>600<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_3</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution error. Failed. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-function-name">ROOT_prompt_14</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_3</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
</pre>
</div>

<p>
By defining a two new overload functions which can match the type
arguments, the substition failure of the first overload function with
the type parameters int and const char* will no longer be an error as
the compiler will select the next two overoads. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Note: This overload function is not a function template, just a free function</span>
<span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 2 =&gt; [INT] Type contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: This overload function is not a function template, just a free function</span>
<span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 3 =&gt; [CONST CHAR*] Type contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>400<span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 2 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INT</span><span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = 400
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Implicit conversion </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 2 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INT</span><span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = 120
&gt;&gt; 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Hello world SFINAE"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 3 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">CONST</span> CHAR*<span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = Hello world SFINAE
</pre>
</div>

<p>
If there is no overload candidate matching the type argument, then the
type substition failure will become an error:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-function-name">ROOT_prompt_31</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_16</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     ^
<span class="org-function-name">ROOT_prompt_20</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-2">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-2">)</span> to <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
     ^
<span class="org-function-name">ROOT_prompt_8</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
                          ^
</pre>
</div>

<p>
The substition failure error can again be eliminated by defiing a new
overload:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 4 =&gt; [Match Any Type] contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type T as std::string </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
&gt;&gt; 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type std::vector&lt;double&gt;</span>
&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span>200.34, -100.6, 6.1546<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type std::vector&lt;double&gt;</span>
&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">{</span>200.34, -100.6, 6.1546<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
</pre>
</div>

<p>
<b>Case 2</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-type">int</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">AStructB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:   
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Clever trick found at: http://cppedinburgh.uk/slides/201508-concepts-bottom-up-view.pdf</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>

<p>
Before defining the second overload function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AStruct a;
&gt;&gt; AStructB b;

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>b<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_14</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>FunctionTest<span class="org-warning">'</span>
FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_9</span>:1:60: note: candidate <span class="org-keyword">template</span> ignored: substitution failure <span class="org-rainbow-delimiters-depth-1">[</span>with T = <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">]</span>: type <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span>
      cannot be used prior to <span class="org-warning">'</span>::<span class="org-warning">'</span> because it has no members
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">bool</span> FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>...
</pre>
</div>

<p>
After defining the second overload function:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [2] Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  
<span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [3] Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> Value = 100
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C++20"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> Value = C++20
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org8117b70" class="outline-4">
<h4 id="org8117b70"><span class="section-number-4">1.18.2</span> Metafunction or type trait std::enable_if</h4>
<div class="outline-text-4" id="text-1-18-2">
<p>
The metafunction (aka type trait) std::enable_if is used for
conditionally selectig a given overload function template from an
overload set when the boolean argument is true or removing the
function from the overload resolution when the boolean argument is
false (SFINAE).
</p>

<ul class="org-ul">
<li>Header: <a href="https://en.cppreference.com/w/cpp/header/type_traits">&lt;type_traits&gt;</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/enable_if">Documentation</a></li>
</ul>

<p>
<b>Use cases:</b>
</p>

<ul class="org-ul">
<li>Select a given overload function when a condition is true.</li>

<li>Constrain template arguments by only allowing the templated
function or class be used with types matching a predicate
metafunction. When the predicate evaluates to false, a compile-time
error happens.</li>
</ul>

<p>
<b>Definition</b>
</p>

<p>
The metafunction or type trait std::enable_if could be defined as:
</p>

<ul class="org-ul">
<li>Base template:</li>
</ul>

<p>
When the flag is false, the subtype <span class="underline">type</span> is not defined and the
expression <span class="underline">enable_if&lt;false, T&gt;::type</span> is not valid, then compiler looks
for the next overload function matching the template type arguments.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span> <span class="org-variable-name">Flag</span>, <span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">enable_if</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Paratial specialization:</li>
</ul>

<p>
When the flag is true, the expression <span class="underline">enable_if&lt;true, T&gt;::type</span> is
defined and returns the type T.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-keyword">using</span> <span class="org-type">type</span> = T;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Example: The following code has a templated function classifyType with
two overaloads, the first overload only works with integral types
(int, char, long, &#x2026;) and the second with float types (float, double
and long double). If the function is used with non integral or float
points type argument, a compilation error happens.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">First Overload classifyType</span>
<span class="org-comment-delimiter">/** </span><span class="org-comment">Note: when the predicate std::is_integral&lt;T&gt;::value is true, </span>
<span class="org-comment">  * the expression: typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type</span>
<span class="org-comment">  * evaluates to void. When the predicate is false  this overload </span>
<span class="org-comment">  * (implementation) is discarded. (SFINAE)</span>
<span class="org-comment">  */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>100L<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-type">double</span> <span class="org-variable-name">z</span> = 9.34;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>z<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">float</span> <span class="org-variable-name">x</span> = 3.1415; 
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-text">Type = integral ;  3 * value = 60
Type = integral ;  3 * value = 300
Type = integral ;  3 * value = 360
Type = floating point ;  25% x value = 2.335
Type = floating point ;  25% x value = 0.785375
</pre>
</div>


<p>
The templated functions could also be written as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> 
   -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> 
  -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The code could also be written in a another way as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">First Overload of classifyType </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; Only works with char, int, long, unsigned, ... </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span>, 
                  <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; Only works with float, double or long double </span>
 <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
 <span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span>, 
                   <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> 
 <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The metafunction std::enable_if can be removed from the function
signature by writing the code as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">First Overload classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c45089" class="outline-4">
<h4 id="org8c45089"><span class="section-number-4">1.18.3</span> Metafunction or type trait std::enalbe_if_t</h4>
<div class="outline-text-4" id="text-1-18-3">
<p>
The metafunction <span class="underline">std::enable_if_t</span> simplifies the usage of
std::enable_if as it can be used as a dummy template argument instead
of being used as return type. 
</p>

<p>
Definition:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-type">bool</span> <span class="org-variable-name">B</span>, <span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">enable_if_t</span> = <span class="org-keyword">typename</span> <span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>B,<span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::type;
</pre>
</div>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-constant">std</span>::<span class="org-type">enable_if_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">&gt;</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-constant">std</span>::<span class="org-type">enable_if_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">&gt;</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>100L<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-type">double</span> <span class="org-variable-name">z</span> = 9.34;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>z<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">float</span> <span class="org-variable-name">x</span> = 3.1415; 
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-cpp">Type = integral ;  3 * value = 60
Type = integral ;  3 * value = 300
Type = integral ;  3 * value = 360
Type = floating point ;  25% x value = 2.335
Type = floating point ;  25% x value = 0.785375
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org755c3e7" class="outline-3">
<h3 id="org755c3e7"><span class="section-number-3">1.19</span> SFINAE - Type instrospection</h3>
<div class="outline-text-3" id="text-1-19">
</div>
<div id="outline-container-orga77abd3" class="outline-4">
<h4 id="orga77abd3"><span class="section-number-4">1.19.1</span> Example 1 - Check whether type has default constructor</h4>
<div class="outline-text-4" id="text-1-19-1">
<p>
This example based on the book "Template the complete guide" shows a
metafunction which can check whether a type has a default constructor,
it means a constructor without any arguments.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">HasDefaultConstructor</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-comment-delimiter">/** </span><span class="org-comment">If the expressions decltype(X()) fails,</span>
<span class="org-comment">     *  then, the type X has no default constructor </span>
<span class="org-comment">     *  and SFINAE happens and this function is </span>
<span class="org-comment">     *  excluded from the overload resolution.</span>
<span class="org-comment">     */</span>
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span>, <span class="org-keyword">typename</span> = <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
     <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">testConstructor</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">char</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Fallback - template with dummy parameter */</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">testConstructor</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">long</span>;       
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">/* </span><span class="org-comment">If the class has default constructor,</span>
<span class="org-comment">     * the returned type of testConstructor&lt;T&gt;(nullptr)</span>
<span class="org-comment">     * is char, otherwise, it is long.</span>
<span class="org-comment">     */</span>
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span>
     = <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span>testConstructor<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Testing:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">HasDefaultConstructor</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; <span class="org-keyword">struct</span> A<span class="org-rainbow-delimiters-depth-1">{}</span>;
&gt;&gt; <span class="org-constant">HasDefaultConstructor</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; <span class="org-keyword">struct</span> X<span class="org-rainbow-delimiters-depth-1">{</span> X<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">delete</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; <span class="org-constant">HasDefaultConstructor</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>X<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org041a967" class="outline-4">
<h4 id="org041a967"><span class="section-number-4">1.19.2</span> Example 2 - Check whether type has .end() member function</h4>
<div class="outline-text-4" id="text-1-19-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span>, <span class="org-keyword">typename</span> = <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::declval<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">X</span><span class="org-rainbow-delimiters-depth-4">&gt;()</span>.end<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
     <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">char</span>;

     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
     <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">long</span>;        
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span>
    = <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span>check<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; HasEndMemberFunction<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> @0x2d63b70

&gt;&gt; <span class="org-constant">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; <span class="org-constant">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; <span class="org-constant">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; <span class="org-constant">HasEndMemberFunction</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org7784998" class="outline-4">
<h4 id="org7784998"><span class="section-number-4">1.19.3</span> Example 3 - Check whether type is printable</h4>
<div class="outline-text-4" id="text-1-19-3">
<p>
This metafunction IsPrintable checks whether type is printable, in
other words, whether it can be printed with (&lt;&lt;) operator:
</p>

<ul class="org-ul">
<li>File: <a href="src/sfinae_is_printable.cpp">file:src/sfinae_is_printable.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/GMK72456">https://rextester.com/GMK72456</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/**  </span><span class="org-comment">@brief Checks whether type is printable, or supports the insertion operator (&lt;&lt;).  </span>
<span class="org-comment"> *   @details This metafunction tests</span>
<span class="org-comment"> *   whether type supports the operator (&lt;&lt;) or std::ostream&amp;</span>
<span class="org-comment"> *   operator&lt;&lt;(std::ostream&amp; os, const RHS&amp; rhs)</span>
<span class="org-comment"> * </span>
<span class="org-comment"> *   @tparam - Any type, int, char, class, std::string, std::vector ... </span>
<span class="org-comment"> */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span>, <span class="org-keyword">typename</span> = <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::declval<span class="org-rainbow-delimiters-depth-4">&lt;</span>X<span class="org-rainbow-delimiters-depth-4">&gt;()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">char</span>;

    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">long</span>;  

    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> =
      <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span>check<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Main function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"        IsPrintable&lt;int&gt; = "</span> &lt;&lt; <span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"IsPrintable&lt;std::string&gt; = "</span> &lt;&lt; <span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"  IsPrintable&lt;SomeClass&gt; = "</span> &lt;&lt; <span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>SomeClass<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"      IsPrintable&lt;Point&gt; = "</span> &lt;&lt; <span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Point<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ sfinae_is_printable.cpp -o <span class="org-keyword">sfinae_is_printable.bin</span> -std=c++1z -g -O0 -Wall &amp;&amp; ./sfinae_is_printable.bin

        IsPrintable&lt;int&gt; = true
IsPrintable&lt;std::string&gt; = true
  IsPrintable&lt;SomeClass&gt; = false
      IsPrintable&lt;Point&gt; = true
</pre>
</div>
</div>
</div>
<div id="outline-container-org2ca0569" class="outline-4">
<h4 id="org2ca0569"><span class="section-number-4">1.19.4</span> Example 4 - Print type if it is printable (C++17 if constexpr)</h4>
<div class="outline-text-4" id="text-1-19-4">
<p>
Example: Print a type whether is printable or not. If the type is not
printable notify that it cannot be printed. Note: printable here means
that the operator (&lt;&lt;) or (std::ostream&amp; &lt;&lt;) is defined for the type. 
</p>

<p>
File: 
</p>
<ul class="org-ul">
<li>File: <a href="src/sfinae-print.cpp">file:src/sfinae-print.cpp</a></li>
<li>Online Compiler: <a href="https://coliru.stacked-crooked.com/a/cb5026e9b69795cd">sfinae-print.cpp</a></li>
</ul>

<p>
Compiling: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ sfinae-print.cpp -o <span class="org-keyword">sfinae-print.bin</span> -std=c++1z -g -O0 -Wall &amp;&amp; ./sfinae-print.bin
</pre>
</div>

<p>
Headers: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
</pre>
</div>

<p>
Type trait or metafunction IsPrintable: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">IsPrintable</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span>, <span class="org-keyword">typename</span> = <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::declval<span class="org-rainbow-delimiters-depth-4">&lt;</span>X<span class="org-rainbow-delimiters-depth-4">&gt;()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">char</span>;

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">check</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">long</span>;  

        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> =
            <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span>check<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Function <b>printIfPrintableA</b>
<ul class="org-ul">
<li>Uses std::enable_if as function-return type</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Overload selected when type is printable </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-function-name">printIfPrintableA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableA] "</span>
               &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span> &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload selected when type is not printable. Or does not have the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">operator (&lt;&lt;) defined for it.</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-negation-char">!</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>                                                               
<span class="org-function-name">printIfPrintableA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableA] "</span>
               &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span> &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; <span class="org-string">"[NOT PRINTABLE]"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Function <b>printIfPrintableB</b>
<ul class="org-ul">
<li>Version B uses: Uses std::enable_if as  trailing-return type (C++11)</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printIfPrintableB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
        -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableB] "</span>
                  &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span>
                  &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printIfPrintableB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
        -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-negation-char">!</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>                                                                
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableB] "</span>
                  &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span> &lt;&lt; text
                  &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; <span class="org-string">"[NOT PRINTABLE]"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Function <b>printIfPrintableC</b>
<ul class="org-ul">
<li>Version C: Uses std::enable_if as template type parameter.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>,
         <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printIfPrintableC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableC] "</span>
               &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span>
               &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>,
         <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-negation-char">!</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printIfPrintableC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableC] "</span>
                &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span>
                &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span> &lt;&lt; <span class="org-string">"[NOT PRINTABLE]"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Function <b>printIfPrintableD</b>
<ul class="org-ul">
<li>Version D: Uses C++17 <b>if constexpr</b> for eliminating SFINAE
function overload boilerplate.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printIfPrintableD</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[printIfPrintableD] "</span>
             &lt;&lt; <span class="org-string">"Value of object of type &lt;"</span> &lt;&lt; text &lt;&lt; <span class="org-string">"&gt; = "</span>;
   <span class="org-keyword">if</span> <span class="org-keyword">constexpr</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">IsPrintable</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-constant">std</span>::cout &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-keyword">else</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[NOT PRINTABLE]"</span> &lt;&lt; <span class="org-string">"\n"</span>;                    
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li><b>Testing Classes:</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Not printable type </span>
<span class="org-keyword">struct</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">{</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Printable class (defines operator &lt;&lt;)</span>
<span class="org-keyword">struct</span> <span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">int</span> <span class="org-variable-name">x</span>;
   <span class="org-type">int</span> <span class="org-variable-name">y</span>;
   <span class="org-function-name">Point</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>: x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">friend</span> <span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-type">Point</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-constant">std</span>::ostream&amp; <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"Point{ "</span> &lt;&lt; p.x &lt;&lt; <span class="org-string">" "</span> &lt;&lt; p.y &lt;&lt; <span class="org-string">"} \n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Main Function</b> 
</p>

<ul class="org-ul">
<li>Experiment A:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n======= EXPERIMENT A ======================\n"</span>; 
printIfPrintableA<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"int"</span>, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableA<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"double"</span>, 20.4<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableA<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"SomeClass"</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableA<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Point"</span>, Point<span class="org-rainbow-delimiters-depth-2">{</span>5, 6<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======= EXPERIMENT A ======================
[printIfPrintableA] Value of object of type &lt;int&gt; = 100
[printIfPrintableA] Value of object of type &lt;double&gt; = 20.4
[printIfPrintableA] Value of object of type &lt;SomeClass&gt; = [NOT PRINTABLE]
[printIfPrintableA] Value of object of type &lt;Point&gt; = Point{ 5 6} 
</pre>
</div>


<ul class="org-ul">
<li>Experiment B:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n======= EXPERIMENT B ======================\n"</span>;
printIfPrintableB<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"int"</span>, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableB<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"double"</span>, 20.4<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableB<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"SomeClass"</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableB<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Point"</span>, Point<span class="org-rainbow-delimiters-depth-2">{</span>15, 20<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======= EXPERIMENT B ======================
[printIfPrintableB] Value of object of type &lt;int&gt; = 100
[printIfPrintableB] Value of object of type &lt;double&gt; = 20.4
[printIfPrintableB] Value of object of type &lt;SomeClass&gt; = [NOT PRINTABLE]
[printIfPrintableB] Value of object of type &lt;Point&gt; = Point{ 15 20} 
</pre>
</div>


<ul class="org-ul">
<li>Experiment C:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n======= EXPERIMENT C ======================\n"</span>;
printIfPrintableC<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"int"</span>, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableC<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"double"</span>, 20.4<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableC<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"SomeClass"</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableC<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Point"</span>, Point<span class="org-rainbow-delimiters-depth-2">{</span>15, 20<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======= EXPERIMENT C ======================
[printIfPrintableC] Value of object of type &lt;int&gt; = 100
[printIfPrintableC] Value of object of type &lt;double&gt; = 20.4
[printIfPrintableC] Value of object of type &lt;SomeClass&gt; = [NOT PRINTABLE]
[printIfPrintableC] Value of object of type &lt;Point&gt; = Point{ 15 20} 
</pre>
</div>


<ul class="org-ul">
<li>Experiment D:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n======= EXPERIMENT D (C++17) ===============\n"</span>;
printIfPrintableD<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"int"</span>, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableD<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"double"</span>, 20.4<span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableD<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"SomeClass"</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
printIfPrintableD<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Point"</span>, Point<span class="org-rainbow-delimiters-depth-2">{</span>15, 20<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;  
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======= EXPERIMENT D (C++17) ===============
[printIfPrintableD] Value of object of type &lt;int&gt; = 100
[printIfPrintableD] Value of object of type &lt;double&gt; = 20.4
[printIfPrintableD] Value of object of type &lt;SomeClass&gt; = [NOT PRINTABLE]
[printIfPrintableD] Value of object of type &lt;Point&gt; = Point{ 15 20}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1a4ef98" class="outline-3">
<h3 id="org1a4ef98"><span class="section-number-3">1.20</span> Compile-time computations with constexpr specifier</h3>
<div class="outline-text-3" id="text-1-20">
</div>
<div id="outline-container-orged40cca" class="outline-4">
<h4 id="orged40cca"><span class="section-number-4">1.20.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-20-1">
<p>
The constexpr specifier enables compile-time computations in a cleaner
and more readable way than compile-time computations with recursive
template metaprogramming.
</p>

<p>
<b>Documentation:</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a> (cppreference)</li>
<li>Relaxing constraints on constexpr functions =&gt; Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html">ISO/IEC JTC1 SC22 WG21 - N3597</a></li>
</ul>

<p>
<b>C++ Standards:</b>
</p>

<ul class="org-ul">
<li>C++11 =&gt; Introduced constexpr, however it only allows constexpr
values and recursive constexpr functions without local variables
and loops.</li>
<li>C++14 =&gt; Constexpr functions supports local variables and loops.</li>
</ul>

<p>
<b>Benefits:</b>
</p>

<ul class="org-ul">
<li>Replace compile-time computations with complicated recursive
template metaprogramming.</li>
<li>Improve performance since the computations will no longer happen at
runtime.</li>
<li>Eliminate hard-coded constants and macros.</li>
</ul>

<p>
<b>Possible use cases:</b>
</p>

<ul class="org-ul">
<li>Compute hash of string at compile-time</li>
<li>Compile-time obfuscation of strings with XOR</li>
<li>Compile-time computation of numerical constants such as Pi, Euler's
number and so on.</li>
<li>Look-up table for embedded systems</li>
<li>Save embedded systems ROM (Read-Only memory) space.</li>
</ul>

<p>
<b>Constexpr functions cannot contain:</b>
</p>

<ul class="org-ul">
<li>Calls to functions evaluated at runtime such as std::sin,
std::cos, &#x2026; Constexpr functions can only call other constexpr
functions.</li>
<li>Print statements such as std::cout &lt;&lt;&lt;; std::puts(&#x2026;)</li>
<li>goto statements</li>
<li>Exception handling, try-catch blocks</li>
<li>Lambda expressions</li>
<li>Heap-allocation (free-store allocation):  new, delete, dynamic_cast</li>
</ul>

<p>
<b>Papers</b> 
</p>

<ul class="org-ul">
<li><b>Relaxing Constraints on constexpr functions</b>
<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html</a></li>
</ul></li>

<li><b>General Constant Expressions for System Programming Languages</b>
<ul class="org-ul">
<li><a href="http://www.stroustrup.com/sac10-constexpr.pdf">http://www.stroustrup.com/sac10-constexpr.pdf</a></li>
</ul></li>

<li><b>Compile-time parsing with template metaprogramming</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/1997/ae1852b0ff66299323dfb6e5f045a27db041.pdf">https://pdfs.semanticscholar.org/1997/ae1852b0ff66299323dfb6e5f045a27db041.pdf</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1a352db" class="outline-4">
<h4 id="org1a352db"><span class="section-number-4">1.20.2</span> Basic Example - constexpr functions</h4>
<div class="outline-text-4" id="text-1-20-2">
<p>
Source: 
</p>
<ul class="org-ul">
<li>File:
<ul class="org-ul">
<li><a href="src/constexpr-function.cpp">file:src/constexpr-function.cpp</a></li>
</ul></li>
<li>Online Compiler:
<ul class="org-ul">
<li><a href="https://rextester.com/IMW7813">https://rextester.com/IMW7813</a></li>
</ul></li>
<li>Goldbot Compiler Explorer:
<ul class="org-ul">
<li><a href="https://godbolt.org/z/lMDFgG">https://godbolt.org/z/lMDFgG</a></li>
</ul></li>
</ul>

<p>
Compilation: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Compile </span>
$ clang++ constexpr-function.cpp -o <span class="org-keyword">constexpr-function.bin</span> -std=c++1z -g -O0 -Wall 
<span class="org-comment-delimiter"># </span><span class="org-comment">Run </span>
$ ./constexpr-function.bin
</pre>
</div>

<p>
Type alias: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">BigInt</span> = <span class="org-type">unsigned</span> <span class="org-type">long</span>;
</pre>
</div>

<p>
Compile-time factorial computation using recusive template
metaprogramming (old C++): 
</p>
<ul class="org-ul">
<li>Code taken from <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">wikipedia</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">====== Recursive template metaprogramming (Wikipedia) ====</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Code taken from Wikipedia:</span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">+ https://en.wikipedia.org/wiki/Template_metaprogramming</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">BigInt</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Factorial</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = N * <span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>N - 1<span class="org-rainbow-delimiters-depth-3">&gt;</span>::value <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Factorial</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 1 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
C++11 Constexpr function for compile-time factorial computation
(Version A): 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Version A =&gt; </span>
<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-function-name">factorialA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">BigInt</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> n == 1 ? 1 : n * factorialA<span class="org-rainbow-delimiters-depth-2">(</span>n - 1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C++14 Constexpr function for compile-time factorial computation
(Version B): 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Version B =&gt; Since C++14 (Not possible in C++11)</span>
<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-function-name">factorialB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">BigInt</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">BigInt</span> <span class="org-variable-name">acc</span> = 1;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 1; i &lt;= n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       acc = acc * i;
   <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C++14 Constexpr function for compile-time factorial computation
(Version C): 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Version C =&gt; Since C++14 </span>
<span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">factorialC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">BigInt</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">BigInt</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">BigInt</span> <span class="org-variable-name">acc</span> = 1;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 1; i &lt;= n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
           acc = acc * i;
   <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Main function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" ======== Old C++ ============= "</span> &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Factorial(4) = "</span> &lt;&lt; <span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>4<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Factorial(5) = "</span> &lt;&lt; <span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>5<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;

static_assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>4<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value == 24, <span class="org-string">"Error: result supposed to be equal to 24"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>5<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value == 120, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Factorial</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>6<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value == 720, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" ======== New C++ &gt;= C++11 ============= "</span> &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-variable-name">factA4</span> = factorialA<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-variable-name">factA5</span> = factorialA<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-variable-name">factB4</span> = factorialB<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-variable-name">factB5</span> = factorialB<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialA(4) = "</span> &lt;&lt; factA4 &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialA(5) = "</span> &lt;&lt; factA5 &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(4) = "</span> &lt;&lt; factB4 &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(5) = "</span> &lt;&lt; factB5 &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: factorial(6) will not is not computed at compile-time.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Instead, it is be computed at runtime, and the compiler</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">generates an ordinary function named factorialB </span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(6) = "</span> &lt;&lt; factorialB<span class="org-rainbow-delimiters-depth-1">(</span>6<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Generates compilation error when false</span>
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialA<span class="org-rainbow-delimiters-depth-2">(</span>4<span class="org-rainbow-delimiters-depth-2">)</span> == 24, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialA<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> == 120, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialB<span class="org-rainbow-delimiters-depth-2">(</span>4<span class="org-rainbow-delimiters-depth-2">)</span> == 24, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialB<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> == 120, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialC<span class="org-rainbow-delimiters-depth-2">(</span>6<span class="org-rainbow-delimiters-depth-2">)</span> == 720, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialC<span class="org-rainbow-delimiters-depth-2">(</span>7<span class="org-rainbow-delimiters-depth-2">)</span> == 7 * 720, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;    
</pre>
</div>

<p>
Program Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./constexpr-function.bin
 ======== Old C++ ============= 
<span class="org-function-name">Factorial</span>(4) = 24
<span class="org-function-name">Factorial</span>(5) = 120
 ======== New C++ &gt;= C++11 ============= 
<span class="org-function-name">factorialA</span>(4) = 24
<span class="org-function-name">factorialA</span>(5) = 120
<span class="org-function-name">factorialB</span>(4) = 24
<span class="org-function-name">factorialB</span>(5) = 120
</pre>
</div>

<p>
<b>Analysis:</b>
</p>

<ul class="org-ul">
<li>Compile-time computation:</li>
</ul>

<p>
The function-call factorialB(5) is evaluated at compile-time to 120.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">constexpr</span> <span class="org-type">BigInt</span> <span class="org-variable-name">factB5</span> = factorialB<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The following line is compiled as show in the comment:  
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">--- Highlighted line </span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(5) = "</span> &lt;&lt; factB5 &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Compiled as: </span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(5) = "</span> &lt;&lt; 120 &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>


<ul class="org-ul">
<li>The <code>static_assert</code> function is similar to the assert function,
however static_assert operates on compile-time yielding a
compilation error if the boolean argument (predicates) evaluates to
false. If the predicate argument is true, a compilation error happens:</li>
</ul>

<p>
Predicate evalutes to true =&gt; Nothing happens. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">static_assert<span class="org-rainbow-delimiters-depth-1">(</span>factorialA<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> == 120, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
By making the predicate false by changing 120 to 125, the following
compile error happens:  
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ constexpr-function.cpp -o <span class="org-keyword">constexpr-function.bin</span> -std=c++1z -g -O0 -Wall
<span class="org-function-name">constexpr-function.cpp</span>:89:2: error: static_assert failed <span class="org-string">""</span>
        static_assert(factorialA(5) == 125, <span class="org-string">""</span>);
        ^             ~~~~~~~~~~~~~~~~~~~~
1 error generated.
</pre>
</div>


<ul class="org-ul">
<li>No everything is computed at compile-time, the following code block is
computed at runtime. Constexpr function can also be computed at
runtime if needed, in this case the compiler generates an ordinary
function and its object-code.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Note: factorial(6) will not is not computed at compile-time.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Instead, it is be computed at runtime, and the compiler</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">generates an ordinary function named factorialB </span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"factorialB(6) = "</span> &lt;&lt; factorialB<span class="org-rainbow-delimiters-depth-1">(</span>6<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
According to goldbot, this call generates the following object-code
(x64 assembly):
</p>

<div class="org-src-container">
<pre class="src src-asm"><span class="org-function-name">factorialB</span>(unsigned long):
        <span class="org-keyword">push</span>    rbp
        <span class="org-keyword">mov</span>     rbp, rsp
        <span class="org-keyword">mov</span>     QWORD PTR [rbp-24], rdi
        <span class="org-keyword">mov</span>     QWORD PTR [rbp-8], 1
        <span class="org-keyword">mov</span>     QWORD PTR [rbp-16], 1
<span class="org-function-name">.L3</span>:
        <span class="org-keyword">mov</span>     rax, QWORD PTR [rbp-16]
        <span class="org-keyword">cmp</span>     rax, QWORD PTR [rbp-24]
        <span class="org-keyword">ja</span>      .L2
        <span class="org-keyword">mov</span>     rax, QWORD PTR [rbp-8]
        <span class="org-keyword">imul</span>    rax, QWORD PTR [rbp-16]
        <span class="org-keyword">mov</span>     QWORD PTR [rbp-8], rax
        <span class="org-keyword">add</span>     QWORD PTR [rbp-16], 1
        <span class="org-keyword">jmp</span>     .L3
        <span class="org-keyword">ret</span> 
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org7b88c77" class="outline-3">
<h3 id="org7b88c77"><span class="section-number-3">1.21</span> References and Bookmarks</h3>
<div class="outline-text-3" id="text-1-21">
</div>
<div id="outline-container-orgcc1972d" class="outline-4">
<h4 id="orgcc1972d"><span class="section-number-4">1.21.1</span> General</h4>
<div class="outline-text-4" id="text-1-21-1">
<p>
Templates and Iterators: 
</p>
<ul class="org-ul">
<li><a href="https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/">std::iterator is deprecated: Why, What It Was, and What to Use Instead - Fluent C++</a></li>
</ul>

<p>
Dependent Type Names: 
</p>
<ul class="org-ul">
<li><a href="http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/dependent_name.html">Dependent names - cppreference.com</a></li>
</ul>

<p>
Variadic Templates:
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/articles/EhvU7k9E/">C++11 - New features - Variadic template - C++ Articles</a></li>
<li><a href="http://kevinushey.github.io/blog/2016/01/27/introduction-to-c++-variadic-templates/">Introduction to C++ Variadic Templates  R and C++</a></li>
<li><a href="https://docs.microsoft.com/en-gb/cpp/cpp/ellipses-and-variadic-templates?view=vs-2017">Ellipses and Variadic Templates | Microsoft Docs</a></li>
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga1d8e96" class="outline-4">
<h4 id="orga1d8e96"><span class="section-number-4">1.21.2</span> Standard Library Facilities for Metaprogramming</h4>
<div class="outline-text-4" id="text-1-21-2">
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/templates">Templates - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/class_template">Class template - cppreference.com</a></li>
</ul>


<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/type_traits/">&lt;type_traits&gt;</a>  Type traits (aka metafunctions) - utilities for
querying, transforming and manipulating types at compile-time.</li>

<li><a href="https://en.cppreference.com/w/cpp/iterator">iterator library</a></li>

<li><a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">iterator tags</a> - std::input_iterator_tag, std::output_iterator_tag,
std::forward_iterator_tag</li>

<li><a href="https://en.cppreference.com/w/cpp/types/decay">std::decay</a> - Remove cv-qualifiers, turns int&amp; into int, int&amp;&amp; int
int, char* into char, int[2] into int*, and so on.</li>

<li><a href="https://en.cppreference.com/w/cpp/iterator/iterator">std::iterator</a></li>

<li><a href="https://en.cppreference.com/w/cpp/iterator/end">std::end, std::cend</a></li>

<li><a href="https://en.cppreference.com/w/cpp/iterator/iterator_traits">std::iterator_traits</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a> (C++11) - Compile-time computations.</li>

<li><a href="https://en.cppreference.com/w/cpp/types/enable_if">std::enable_if</a> - Allows to restrict a function overload,
alternative implementation of a function with different signature,
based on a type predicate. For instance, it can be used to define a
function overload which is selected only when the type predicate
<a href="https://en.cppreference.com/w/cpp/types/is_integral">std::is_integral</a> is evaluates to true (the type is any of int,
long, short and so on.). Another overload, which only applies to
float point types, can be defined by using the type predicate
<a href="https://en.cppreference.com/w/cpp/types/is_floating_point">std::is_floating_point</a>.
<ul class="org-ul">
<li>Summary: Allows to define function overloads which matches a
given type predicate metafunction (type trait).</li>
</ul></li>

<li><a href="https://en.cppreference.com/w/cpp/types/conditional">std::conditional</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/parameter_pack">parameter_pack</a> -&gt; Variadic template arguments.</li>

<li><a href="https://en.cppreference.com/w/cpp/language/sizeof...">sizeof&#x2026; operator</a> -&gt; Get size of parameter pack (arguments of
variadic template.)</li>

<li><a href="https://en.cppreference.com/w/cpp/language/fold">fold expression</a> (C++17) - Allows unpacking template variadic
paremeters in a easier way without complicated recursion
boilerplate.</li>

<li><a href="https://en.cppreference.com/w/cpp/language/if">if constexpr</a> (C++17)</li>
</ul>
</div>
</div>

<div id="outline-container-orgdc3c6fa" class="outline-4">
<h4 id="orgdc3c6fa"><span class="section-number-4">1.21.3</span> Videos</h4>
<div class="outline-text-4" id="text-1-21-3">
<ul class="org-ul">
<li>CppCon 2015: Peter Sommerlad "Variadic Templates in C++11 / C++14 -
An Introduction" - <a href="https://www.youtube.com/watch?v=R1G3P5SRXCw">https://www.youtube.com/watch?v=R1G3P5SRXCw</a></li>

<li>CppCon 2016: Micha Dominiak "Variadic expansion in examples" -
<a href="https://www.youtube.com/watch?v=Os5YLB5D2BU">https://www.youtube.com/watch?v=Os5YLB5D2BU</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>Variadic Templates are Funadic</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic">https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>The Way of the</b>
<b>Exploding Tuple</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple">https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple</a></li>
</ul>
</div>
</div>
<div id="outline-container-org656c873" class="outline-4">
<h4 id="org656c873"><span class="section-number-4">1.21.4</span> Papers and technical documents</h4>
<div class="outline-text-4" id="text-1-21-4">
<p>
Papers and technical documents about Generic Programming and Template Metaprogramming 
</p>

<ul class="org-ul">
<li>Alexander Stepanov and David R. Musser - <b>Generic Programming</b> -
<a href="http://stepanovpapers.com/genprog.pdf">http://stepanovpapers.com/genprog.pdf</a></li>

<li>Alexander Stepanov and Meng Lee. <b>The Standard Template Library</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/STL/DOC.PDF">http://stepanovpapers.com/STL/DOC.PDF</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.lrde.epita.fr/dload/papers/coots01.html">https://www.lrde.epita.fr/dload/papers/coots01.html</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html">https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html</a></li>
</ul></li>

<li>James C. Dehnert and Alexander Stepanov. <b>Fundamentals of Generic Programming</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/DeSt98.pdf">http://stepanovpapers.com/DeSt98.pdf</a></li>
</ul></li>

<li>Jeremy Gibbons. <b>Patterns in Datatype-Generic Programming</b>
<ul class="org-ul">
<li><a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf">http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf</a></li>
</ul></li>

<li>Giuseppe Lipari. <b>Design Patterns in C++ Template metaprogramming</b>
<ul class="org-ul">
<li><a href="http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf">http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf</a></li>
</ul></li>

<li>Gabriel Dos Reis and Jaakko Jarvi. <b>What is Generic Programming?</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf">https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf</a></li>
</ul></li>

<li><b>Functional Programming with C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf">https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf</a></li>
</ul></li>

<li><b>Implementing Monads for C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf">http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf</a></li>
</ul></li>

<li>Angelika Langer. <b>C++ Expression Templates - An Introduction to the</b>
<b>Principles of Expression Templates</b>
<ul class="org-ul">
<li><a href="http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm">http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm</a></li>
</ul></li>

<li><b>Advanced C++ Template Techniques: An Introduction to Meta-Programming for Scientific Computing</b>
<ul class="org-ul">
<li><a href="https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf">https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf</a></li>
</ul></li>

<li><b>Static and Metaprogramming Patterns and Static Frameworks A Catalog. An Application</b>
<ul class="org-ul">
<li><a href="https://hillside.net/plop/2006/Papers/ACM_Version/Static_and_Metaprogramming_Patterns_and_Static_Frameworks.pdf">https://hillside.net/plop/2006/Papers/ACM_Version/Static_and_Metaprogramming_Patterns_and_Static_Frameworks.pdf</a></li>
</ul></li>

<li><a href="http://people.cs.uchicago.edu/~jacobm/pubs/templates.html">What's Wrong with C++ Templates?</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-04-12 Fri 10:41</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
